<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="模板能够分离数据和逻辑，使得逻辑变得简洁清晰，同时提高复用率。  模板引擎按照功能可以划分为两种类型：  无逻辑模板引擎：此类模板引擎只进行字符串的替换，无其它逻辑； 嵌入逻辑模板引擎：此类模板引擎可以在模板中嵌入逻辑，实现流程控制&#x2F;循环等。  这两类模板引擎都比较极端。无逻辑模板引擎需要在处理器中额外添加很多逻辑用于生成替换的文本。而嵌入逻辑模板引擎则在模板中混入了大量逻辑，导致维护性">
<meta property="og:type" content="article">
<meta property="og:title" content="go template 库（模板）">
<meta property="og:url" content="http://yoursite.com/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="模板能够分离数据和逻辑，使得逻辑变得简洁清晰，同时提高复用率。  模板引擎按照功能可以划分为两种类型：  无逻辑模板引擎：此类模板引擎只进行字符串的替换，无其它逻辑； 嵌入逻辑模板引擎：此类模板引擎可以在模板中嵌入逻辑，实现流程控制&#x2F;循环等。  这两类模板引擎都比较极端。无逻辑模板引擎需要在处理器中额外添加很多逻辑用于生成替换的文本。而嵌入逻辑模板引擎则在模板中混入了大量逻辑，导致维护性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="article:published_time" content="2021-07-14T11:29:00.000Z">
<meta property="article:modified_time" content="2021-08-30T16:28:29.318Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%84%E5%9B%BE.png">


<link rel="canonical" href="http://yoursite.com/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/","path":"2021/07/14/go template库（模板）/","title":"go template 库（模板）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go template 库（模板） | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#template-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">template 使用示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">动作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">点动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">条件动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%80%EF%BC%9A"><span class="nav-number">2.2.1.</span> <span class="nav-text">形式一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%BA%8C%EF%BC%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">形式二：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%89%EF%BC%9A"><span class="nav-number">2.2.3.</span> <span class="nav-text">形式三：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.3.</span> <span class="nav-text">迭代动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%80%EF%BC%9A-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">形式一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%BA%8C%EF%BC%9A-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">形式二：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">设置动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%80%EF%BC%9A-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">形式一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%BA%8C%EF%BC%9A-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">形式二：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.5.</span> <span class="nav-text">包含动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%B8%80%EF%BC%9A-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">形式一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E4%BA%8C%EF%BC%9A-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">形式二：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">其他元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">3.3.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">预定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.2.</span> <span class="nav-text">自定义函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">模板的几种创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">第一种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">第二种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">第三种方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.</span> <span class="nav-text">嵌套模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9D%97%E5%8A%A8%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">块动作</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go template 库（模板） | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go template 库（模板）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-14 19:29:00" itemprop="dateCreated datePublished" datetime="2021-07-14T19:29:00+08:00">2021-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-08-31 00:28:29" itemprop="dateModified" datetime="2021-08-31T00:28:29+08:00">2021-08-31</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>模板能够分离数据和逻辑，使得逻辑变得简洁清晰，同时提高复用率。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="模板引擎结构图"></p>
<p>模板引擎按照功能可以划分为两种类型：</p>
<ul>
<li><strong>无逻辑模板引擎</strong>：此类模板引擎只进行字符串的替换，无其它逻辑；</li>
<li><strong>嵌入逻辑模板引擎</strong>：此类模板引擎可以在模板中嵌入逻辑，实现流程控制&#x2F;循环等。</li>
</ul>
<p>这两类模板引擎都比较极端。无逻辑模板引擎需要在处理器中额外添加很多逻辑用于生成替换的文本。而嵌入逻辑模板引擎则在模板中混入了大量逻辑，导致维护性较差。实用的模板引擎一般介于这两者之间。</p>
<span id="more"></span>

<p>在Go 语言中，<code>text/template</code> 和 <code>html/template</code> 两个库实现模板功能。</p>
<p>模板内容可以是UTF-8编码的任何内容。其中用 <code>&#123; &#123; &#125; &#125;</code> 包围的部分称为<strong>动作</strong>，<code>&#123; &#123; &#125; &#125;</code> 外的其他文本在输出时保持不变。模板需要应用到数据，模板中的动作会根据数据生成对应的内容进行替换。</p>
<p>模板解析之后可以多次执行，也可以并行执行，但是注意使用同一个 <code>Writer</code> 会导致输出交替出现。</p>
<p>这里主要记录 <code>text/template</code> 的用法。</p>
<h1 id="template-使用示例"><a href="#template-使用示例" class="headerlink" title="template 使用示例"></a>template 使用示例</h1><p>使用模板引擎一般分为 3 个步骤：</p>
<ul>
<li>定义模板（直接使用字符串字面量或文件）；</li>
<li>解析模板（使用 <code>text/template</code> 或 <code>html/template</code> 中的方法解析）；</li>
<li>传入数据生成输出。</li>
</ul>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;os&quot;
    &quot;text/template&quot;
)

type User struct &#123;
    Name string
    Age  int
&#125;

func stringLiteralTemplate() &#123;
    s := &quot;My name is &#123;&#123; .Name &#125;&#125;. I am &#123;&#123; .Age &#125;&#125; years old.\n&quot;
  // 首先调用 template.New 创建一个模板，参数为模板名
  // 然后调用 Template 类型的 Parse 方法，解析模板字符串，生成模板主体
  // 这个方法返回两个值。如果模板语法正确，则返回模板对象本身和一个 nil 值。
  // 如果有语法错误，则返回一个 error 类型的值作为第二个返回值
    t, err := template.New(&quot;test&quot;).Parse(s)
    if err != nil &#123;
        log.Fatal(&quot;Parse string literal template error:&quot;, err)
    &#125;

    u := User&#123;Name: &quot;silverming&quot;, Age: 18&#125;
    err = t.Execute(os.Stdout, u)
    if err != nil &#123;
        log.Fatal(&quot;Execute string literal template error:&quot;, err)
    &#125;
&#125;

func fileTemplate() &#123;
  // 相当于 template.New(&quot;test&quot;).ParseFiles(&quot;test&quot;)
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse file template error:&quot;, err)
    &#125;

    u := User&#123;Name: &quot;zm&quot;, Age: 18&#125;
    err = t.Execute(os.Stdout, u)
    if err != nil &#123;
        log.Fatal(&quot;Execute file template error:&quot;, err)
    &#125;
&#125;

func main() &#123;
    stringLiteralTemplate()

    fileTemplate()
&#125;
</code></pre>
<p>在可执行程序目录中新建模板文件<code>test</code>，并写入下面的内容：</p>
<pre><code>My name is &#123;&#123; .Name &#125;&#125;. I am &#123;&#123; .Age &#125;&#125; years old.
</code></pre>
<p>最后，调用模板对象的<code>Execute</code>方法，传入参数。<code>Execute</code>执行模板中的动作，将结果输出到<code>os.Stdout</code>，即<strong>标准输出</strong>。最终我们看到模板中<code>&#123; &#123; .Name &#125; &#125;</code>被<code>u</code>的<code>Name</code>字段替换，<code>&#123; &#123; .Age &#125; &#125;</code>被<code>u</code>的<code>Age</code>字段替换，标准输出中显示下面一行字符串：</p>
<pre><code>My name is silverming. I am 18 years old.
</code></pre>
<h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><p>Go 模板中的动作就是一些嵌入在模板里面的命令。动作大体上可以分为以下几种类型：</p>
<ul>
<li>点动作；</li>
<li>条件动作；</li>
<li>迭代动作；</li>
<li>设置动作；</li>
<li>包含动作。</li>
</ul>
<h2 id="点动作"><a href="#点动作" class="headerlink" title="点动作"></a>点动作</h2><p>点动作 <code>&#123; &#123; . &#125; &#125;</code> 是最重要的一个动作，代表传递给模板的数据，其他的动作和函数基本都是对这个数据进行处理，以此来达到格式化和内容展示的目的。</p>
<pre><code class="go">func main() &#123;
    s := &quot;The user is &#123;&#123; . &#125;&#125;.&quot;
    t, err := template.New(&quot;test&quot;).Parse(s)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    u := User&#123;Name: &quot;silverming&quot;, Age: 18&#125;
    err = t.Execute(os.Stdout, u)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>运行后输出结果为：</p>
<pre><code>The user is &#123;silverming 18&#125;.
</code></pre>
<p>实际上，<code>&#123; &#123; . &#125; &#125;</code> 会被替换为传给给模板的数据的字符串表示。这个字符串与以数据为参数调用 <code>fmt.Sprint</code> 函数得到的内容相同，也就是使用结构体的 <code>String</code> 方法来进行输出，如果修改了 <code>String()</code> 方法，对应的输出也就跟着改变。</p>
<h2 id="条件动作"><a href="#条件动作" class="headerlink" title="条件动作"></a>条件动作</h2><p>条件动作的形式如下：</p>
<pre><code class="go">&#123;&#123; if  pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;
</code></pre>
<p>其中 <code>pipeline</code> 表示一个值，<code>T1</code> 代表语句块，里面可以嵌套其他类型的动作。</p>
<p>条件动作的语法与编程语言中的<code>if</code>语句语法类似，有几种形式：</p>
<h3 id="形式一："><a href="#形式一：" class="headerlink" title="形式一："></a>形式一：</h3><pre><code class="go">&#123;&#123; if pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125; 
</code></pre>
<p>如果管道计算出来的值不为空，执行<code>T1</code>。否则，不生成输出。下面都表示空值：</p>
<ul>
<li><code>false</code>、0、空指针或接口；</li>
<li>长度为 0 的数组、切片、map 或字符串。</li>
</ul>
<h3 id="形式二："><a href="#形式二：" class="headerlink" title="形式二："></a>形式二：</h3><pre><code class="go">&#123;&#123; if pipeline &#125;&#125; T1 &#123;&#123; else &#125;&#125; T2 &#123;&#123; end &#125;&#125;
</code></pre>
<p>如果管道计算出来的值不为空，执行<code>T1</code>。否则，执行<code>T2</code>。</p>
<h3 id="形式三："><a href="#形式三：" class="headerlink" title="形式三："></a>形式三：</h3><pre><code class="go">&#123;&#123; if pipeline1 &#125;&#125; T1 &#123;&#123; else if pipeline2 &#125;&#125; T2 &#123;&#123; else &#125;&#125; T3 &#123;&#123; end &#125;&#125;
</code></pre>
<p>如果管道<code>pipeline1</code>计算出来的值不为空，则执行<code>T1</code>。反之如果管道<code>pipeline2</code>的值不为空，执行<code>T2</code>。如果都为空，执行<code>T3</code>。</p>
<p>使用示例：</p>
<p>test 文件内容：</p>
<pre><code class="go">Your age is: &#123;&#123; .Age &#125;&#125;
&#123;&#123; if .GreaterThan60 &#125;&#125;
Old People!
&#123;&#123; else if .GreaterThan40 &#125;&#125;
Middle Aged!
&#123;&#123; else &#125;&#125;
Young!
&#123;&#123; end &#125;&#125;
</code></pre>
<p>代码：</p>
<pre><code class="go">type AgeInfo struct &#123;
    Age           int
    GreaterThan60 bool
    GreaterThan40 bool
&#125;

func main() &#123;
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    rand.Seed(time.Now().Unix())
    age := rand.Intn(100)
    info := AgeInfo &#123;
        Age:           age,
        GreaterThan60: age &gt; 60,
        GreaterThan40: age &gt; 40,
    &#125;
    err = t.Execute(os.Stdout, info)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>运行后，通过随机生成的年龄，可能会出现如下的输出：</p>
<pre><code>Your age is: 7

Young!
</code></pre>
<p>或者：</p>
<pre><code>Your age is: 79

Old People!
</code></pre>
<p>这里会出现的问题就是有多余的空格，因为<strong>除了动作之外的任何文本都会原样保持，包括空格和换行</strong>。对于这个问题，有两种解决方式：</p>
<p>第一种方案是删除多余的空格和换行，<code>test</code> 文件修改为：</p>
<pre><code class="go">Your age is: &#123;&#123; .Age &#125;&#125;
&#123;&#123; if .GreaterThan60 &#125;&#125;Old People!&#123;&#123; else if .GreaterThan40 &#125;&#125;Middle Aged!&#123;&#123; else &#125;&#125;Young!&#123;&#123; end &#125;&#125;
</code></pre>
<p>这个方法会导致模板内容很难阅读，不够理想。为此，Go 提供了针对空白符的处理。如果一个动作以 <code>&#123; &#123;- </code>（注意有一个空格），那么该动作与它前面相邻的非空文本或动作间的空白符将会被全部删除。类似地，如果一个动作以<code> -&#125; &#125;</code> 结尾，那么该动作与它后面相邻的非空文本或动作间的空白符将会被全部删除。例如：</p>
<pre><code>&#123;&#123;23 -&#125;&#125; &lt; &#123;&#123;- 45&#125;&#125;
</code></pre>
<p>输出结果为：</p>
<pre><code>23&lt;45
</code></pre>
<p>所以，对于上面的 test 文件可以修改成下面这样：</p>
<pre><code class="go">Your age is: &#123;&#123; .Age &#125;&#125;
&#123;&#123; if .GreaterThan60 -&#125;&#125;
&quot;Old People!&quot;
&#123;&#123;- else if .GreaterThan40 -&#125;&#125;
&quot;Middle Aged!&quot;
&#123;&#123;- else -&#125;&#125;
&quot;Young!&quot;
&#123;&#123;- end &#125;&#125;
</code></pre>
<p>这样，输出的文本就不会包含多余的空格了。</p>
<h2 id="迭代动作"><a href="#迭代动作" class="headerlink" title="迭代动作"></a>迭代动作</h2><p>迭代其实与编程语言中的循环遍历类似。有两种形式：</p>
<h3 id="形式一：-1"><a href="#形式一：-1" class="headerlink" title="形式一："></a>形式一：</h3><pre><code class="go">&#123;&#123; range pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;
</code></pre>
<p>pipeline 的值类型必须是数组、切片、map、channel。如果值的长度为 0，那么无输出。否则，**<code>.</code> 被设置为当前遍历到的元素，然后执行<code>T1</code>，即在<code>T1</code>中<code>.</code>表示遍历的当前元素，而非传给模板的参数<strong>。如果值是 map 类型，且键是可比较的基本类型，</strong>元素将会以键的顺序访问**。</p>
<h3 id="形式二：-1"><a href="#形式二：-1" class="headerlink" title="形式二："></a>形式二：</h3><pre><code class="go">&#123;&#123; range pipeline &#125;&#125; T1 &#123;&#123; else &#125;&#125; T2 &#123;&#123; end &#125;&#125;
</code></pre>
<p>与前一种形式基本一样，如果值的长度为 0，那么执行<code>T2</code>。</p>
<p>使用例子如下，假设有以下模板文件：</p>
<pre><code class="go">Apple Products:
&#123;&#123; range . &#125;&#125;
&#123;&#123; .Name &#125;&#125;: ￥&#123;&#123; .Price &#125;&#125;
&#123;&#123; else &#125;&#125;
No Products!!!
&#123;&#123; end &#125;&#125;
</code></pre>
<p>执行代码如下：</p>
<pre><code class="go">type Item struct &#123;
    Name	string
    Price	int
&#125;

func main() &#123;
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    items := []Item &#123;
        &#123; &quot;iPhone&quot;, 5499 &#125;,
        &#123; &quot;iPad&quot;, 6331 &#125;,
        &#123; &quot;iWatch&quot;, 1499 &#125;,
        &#123; &quot;MacBook&quot;, 8250 &#125;,
    &#125;

    err = t.Execute(os.Stdout, items)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>会得到如下的输出：</p>
<pre><code>Apple Products:

iPhone: ￥5499

iPad: ￥6331

iWatch: ￥1499

MacBook: ￥8250
</code></pre>
<p>在 <code>range</code> 语句循环体内，<code>.</code> 被设置为当前遍历的元素，可以直接使用 <code>&#123; &#123; .Name &#125; &#125;</code> 或 <code>&#123; &#123; .Price &#125; &#125;</code> 访问产品名称和价格。在程序中，将 <code>nil</code> 传给 <code>Execute</code> 方法会得到下面的输出：</p>
<pre><code>Apple Products:

No Products!!!
</code></pre>
<h2 id="设置动作"><a href="#设置动作" class="headerlink" title="设置动作"></a>设置动作</h2><p>设置动作使用 <code>with</code> 关键字重定义 <code>.</code>。在 <code>with</code> 语句内，<code>.</code> 会被定义为指定的值。一般用在结构嵌套很深时，能起到简化代码的作用。</p>
<h3 id="形式一：-2"><a href="#形式一：-2" class="headerlink" title="形式一："></a>形式一：</h3><pre><code class="go">&#123;&#123; with pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;
</code></pre>
<p>如果管道值不为空，则将 <code>.</code> 设置为 <code>pipeline</code> 的值，然后执行 <code>T1</code>。否则，不生成输出。</p>
<h3 id="形式二：-2"><a href="#形式二：-2" class="headerlink" title="形式二："></a>形式二：</h3><pre><code class="go">&#123;&#123; with pipeline &#125;&#125; T1 &#123;&#123; else &#125;&#125; T2 &#123;&#123; end &#125;&#125;
</code></pre>
<p>与前一种形式的不同之处在于当管道值为空时，不改变 <code>.</code> 执行 <code>T2</code>。</p>
<p>使用例子如下：</p>
<p>模板文件内容：</p>
<pre><code class="go">Pet Info:
Name: &#123;&#123; .Name &#125;&#125;
Age: &#123;&#123; .Age &#125;&#125;
Owner:
&#123;&#123; with .Owner &#125;&#125;
  Name: &#123;&#123; .Name &#125;&#125;
  Age: &#123;&#123; .Age &#125;&#125;
&#123;&#123; end &#125;&#125;
</code></pre>
<p>代码如下：</p>
<pre><code class="go">type User struct &#123;
    Name string
    Age  int
&#125;

type Pet struct &#123;
    Name  string
    Age   int
    Owner User
&#125;

func main() &#123;
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    p := Pet &#123;
        Name:  &quot;Orange&quot;,
        Age:   2,
        Owner: User &#123;
            Name: &quot;zm&quot;,
            Age:  18,
        &#125;,
    &#125;

    err = t.Execute(os.Stdout, p)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>执行代码后输出如下：</p>
<pre><code class="go">Pet Info:
Name: Orange
Age: 2
Owner:

  Name: zm
  Age: 18
</code></pre>
<p>可见，在 <code>with</code> 语句内，<code>.</code> 被替换成了 <code>Owner</code> 字段的值。</p>
<h2 id="包含动作"><a href="#包含动作" class="headerlink" title="包含动作"></a>包含动作</h2><p>包含动作可以在一个模板中嵌入另一个模板，方便模板的复用。</p>
<h3 id="形式一：-3"><a href="#形式一：-3" class="headerlink" title="形式一："></a>形式一：</h3><pre><code class="go">&#123;&#123; template "name" &#125;&#125;
</code></pre>
<h3 id="形式二：-3"><a href="#形式二：-3" class="headerlink" title="形式二："></a>形式二：</h3><pre><code class="go">&#123;&#123; template "name" pipeline &#125;&#125;
</code></pre>
<p>其中 <code>name</code> 表示嵌入的模板名称。第一种形式，将使用 <code>nil</code> 作为传入内嵌模板的参数。第二种形式，管道<code>pipeline</code>的值将会作为参数传给内嵌的模板。</p>
<p>使用例子如下：</p>
<p>模板文件：</p>
<p><strong>test1</strong>:</p>
<pre><code class="go">This is in test1.
&#123;&#123; template "test2" &#125;&#125;

&#123;&#123; template "test2" . &#125;&#125;
</code></pre>
<p><strong>test2</strong>：</p>
<pre><code class="go">This is in test2.
Get: &#123;&#123; . &#125;&#125;.
</code></pre>
<p>代码如下：</p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;os&quot;
    &quot;text/template&quot;
)

func main() &#123;
    t, err := template.ParseFiles(&quot;test1&quot;, &quot;test2&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    err = t.Execute(os.Stdout, &quot;test data&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>运行后程序输出如下：</p>
<pre><code>This is in test1.
This is in test2.
Get: &lt;no value&gt;.

This is in test2.
Get: test data.
</code></pre>
<p>前一个嵌入模板，没有传递参数。后一个传入<code>.</code>，即传给<code>test1</code>模板的参数。</p>
<h1 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释只有一种语法：</p>
<pre><code class="go">&#123;&#123; /* 注释 */ &#125;&#125;
</code></pre>
<p>注释的内容不会呈现在输出中，它就像代码注释一样，是为了让模板更易读。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>一个参数就是模板中的一个值。它的取值有多种：</p>
<ul>
<li>布尔值、字符串、字符、整数、浮点数、虚数和复数等<strong>字面量</strong>；</li>
<li>结构中的一个字段或 map 中的一个键。<strong>结构的字段名必须是导出的，即大写字母开头，map 的键名则不必</strong>；</li>
<li>一个函数或方法。必须只返回一个值，或者只返回一个值和一个错误。如果返回了非空的错误，则<code>Execute</code>方法执行终止，返回该错误给调用者；</li>
</ul>
<p>上面几种形式可以结合使用：</p>
<pre><code class="go">&#123;&#123; .Field1.Key1.Method1.Field2.Key2.Method2 &#125;
```

在前面的例子中也已经用过很多次参数了。下面举一个例子：

模板文件内容如下：

```go
My full name is &#123;&#123; .FullName &#125;&#125;.
</code></pre>
<p>代码如下：</p>
<pre><code class="go">type User struct &#123;
    FirstName 	string
    LastName	string
&#125;

func (u User) FullName() string &#123;
    return u.FirstName + &quot; &quot; + u.LastName
&#125;

func main() &#123;
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    err = t.Execute(os.Stdout, User&#123;FirstName: &quot;silver&quot;, LastName: &quot;ming&quot;&#125;)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>运行后输出如下：</p>
<pre><code>My full name is silver ming.
</code></pre>
<p>关于参数的几个要点：</p>
<ul>
<li>参数可以是任何类型；</li>
<li>如果参数为指针，实现会根据需要取其基础类型；</li>
<li>如果参数计算得到一个函数类型，它不会自动调用。例如 <code>&#123; &#123; .Method1 &#125; &#125;</code>，如果 <code>Method1</code> 方法返回一个函数，那么返回值函数不会调用。如果要调用它，使用内置的 <code>call</code> 函数。</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道也就是前面看到的 <code>pipeline</code>，管道的语法与 Linux 中的管道类似，即<strong>命令</strong>的链式序列：</p>
<pre><code class="go">&#123;&#123; p1 | p2 | p3 &#125;&#125;
</code></pre>
<p>每个单独的命令（即<code>p1/p2/p3...</code>）可以是下面三种类型：</p>
<ul>
<li>参数，见上面；</li>
<li>可能带有参数的方法调用；</li>
<li>可能带有参数的函数调用。</li>
</ul>
<p><strong>在一个链式管道中，每个命令的结果会作为下一个命令的最后一个参数。最后一个命令的结果作为整个管道的值。</strong></p>
<p>管道必须只返回一个值，或者只返回一个值和一个错误。如果返回了非空的错误，那么<code>Execute</code>方法执行终止，并将该错误返回给调用者。</p>
<p>在迭代程序的基础上稍作修改：</p>
<p>模板文件如下：</p>
<pre><code class="go">Product: &#123;&#123; .Name &#125;&#125;
Price: ￥&#123;&#123; .Price &#125;&#125;
Num: &#123;&#123; .Num &#125;&#125;
Total: ￥&#123;&#123; .Total | printf "%.2f" &#125;&#125;
</code></pre>
<p>先调用 <code>Item.Total</code> 方法计算商品总价，然后使用 <code>printf</code> 格式化，保留两位小数。</p>
<pre><code class="go">type Item struct &#123;
    Name  string
    Price float64
    Num   int
&#125;

func (item Item) Total() float64 &#123;
    return item.Price * float64(item.Num)
&#125;

func main() &#123;
    t, err := template.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    item := Item &#123;&quot;iPhone&quot;, 5499.99, 2 &#125;

    err = t.Execute(os.Stdout, item)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>最终输出：</p>
<pre><code>Product: iPhone
Price: ￥5499.99
Num: 2
Total: ￥10999.98
</code></pre>
<p><code>printf</code> 是 Go 模板内置的函数，类似的函数在源码中有以下这些：</p>
<pre><code class="go">func builtins() FuncMap &#123;
    return FuncMap&#123;
        &quot;and&quot;:      and,
        &quot;call&quot;:     call,
        &quot;html&quot;:     HTMLEscaper,
        &quot;index&quot;:    index,
        &quot;slice&quot;:    slice,
        &quot;js&quot;:       JSEscaper,
        &quot;len&quot;:      length,
        &quot;not&quot;:      not,
        &quot;or&quot;:       or,
        &quot;print&quot;:    fmt.Sprint,
        &quot;printf&quot;:   fmt.Sprintf,
        &quot;println&quot;:  fmt.Sprintln,
        &quot;urlquery&quot;: URLQueryEscaper,

        // Comparisons
        &quot;eq&quot;: eq, // ==
        &quot;ge&quot;: ge, // &gt;=
        &quot;gt&quot;: gt, // &gt;
        &quot;le&quot;: le, // &lt;=
        &quot;lt&quot;: lt, // &lt;
        &quot;ne&quot;: ne, // !=
    &#125;
&#125;
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在动作中，可以用管道的值定义一个变量。</p>
<pre><code>$variable := pipeline
</code></pre>
<p><code>$variable</code> 为变量名，声明变量的动作不生成输出。</p>
<p>类似地，变量也可以重新赋值：</p>
<pre><code>$variable = pipeline
</code></pre>
<p>在<code>range</code>动作中可以定义两个变量：</p>
<pre><code>range $index, $element := range pipeline
</code></pre>
<p>这样就可以在循环中通过<code>$index</code>和<code>$element</code>访问索引和元素了。</p>
<p>变量的作用域持续到定义它的控制结构的<code>&#123; &#123; end &#125; &#125;</code>动作。如果没有这样的控制结构，则持续到模板结束。模板调用不继承变量。</p>
<p>执行开始时，<code>$</code> 被设置为传入的数据参数，即<code>.</code>的值。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 模板提供了大量的预定义函数，如果有特殊需求也可以实现自定义函数。模板执行时，遇到函数调用，先从模板自定义函数表中查找，而后查找全局函数表。</p>
<h3 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h3><p>预定义函数分为以下几类：</p>
<ul>
<li>逻辑运算，<code>and/or/not</code>；</li>
<li>调用操作，<code>call</code>；</li>
<li>格式化操作，<code>print/printf/println</code>，与用参数直接调用<code>fmt.Sprint/Sprintf/Sprintln</code>得到的内容相同；</li>
<li>比较运算，<code>eq/ne/lt/le/gt/ge</code>。</li>
</ul>
<p>在上面条件动作的示例代码中，我们在代码中计算出大小关系再传入模板，这样比较繁琐，可以直接使用比较运算简化。</p>
<p>有两点需要注意：</p>
<ul>
<li>由于是函数调用，所有的参数都会被求值，没有<strong>短路求值</strong>；</li>
<li>比较运算只作用于基本类型，且没有 Go 语法那么严格，例如可以比较有符号和无符号整数。</li>
</ul>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>默认情况下，模板中无自定义函数，可以使用模板的<code>Funcs</code>方法添加。下面实现一个格式化日期的自定义函数：</p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;os&quot;
    &quot;text/template&quot;
    &quot;time&quot;
)

func formatDate(t time.Time) string &#123;
    return t.Format(&quot;2016-01-02&quot;)
&#125;

func main() &#123;
    funcMap := template.FuncMap &#123;
        &quot;fdate&quot;: formatDate,
    &#125;
    t := template.New(&quot;test&quot;).Funcs(funcMap)
    t, err := t.ParseFiles(&quot;test&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse errr:&quot;, err)
    &#125;

    err = t.Execute(os.Stdout, time.Now())
    if err != nil &#123;
        log.Fatal(&quot;Exeute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>模板文件<code>test</code>：</p>
<pre><code class="go">Today is &#123;&#123; . | fdate &#125;&#125;.
</code></pre>
<p>模板的 <code>Func</code> 方法接受一个 <code>template.FuncMap</code> 类型变量，键为函数名，值为实际定义的函数。 可以一次设置多个自定义函数。自定义函数要求只返回一个值，或者返回一个值和一个错误。 设置之后就可以在模板中使用 <code>fdate</code> 了，输出：</p>
<pre><code>Today is 7016-01-07.
</code></pre>
<p>这里不能使用<code>template.ParseFiles</code>，因为在解析模板文件的时候 <code>fdate</code> 未定义会导致解析失败。<strong>必须先创建模板，调用 <code>Funcs</code> 设置自定义函数，然后再解析模板。</strong></p>
<h1 id="模板的几种创建方式"><a href="#模板的几种创建方式" class="headerlink" title="模板的几种创建方式"></a>模板的几种创建方式</h1><p>模板创建的方式主要有两种：</p>
<ul>
<li>先调用 <code>template.New</code> 创建模板，然后使用 <code>Parse/ParseFiles</code> 解析模板内容；</li>
<li>直接使用 <code>template.ParseFiles</code> 创建并解析模板文件。</li>
</ul>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>第一种方式，调用 <code>template.New</code> 创建模板时需要传入一个模板名字，后续调用 <code>ParseFiles</code> 可以传入一个或多个文件，<strong>这些文件中必须有一个基础名（即去掉路径部分）与模板名相同</strong>。如果没有文件名与模板名相同，则 <code>Execute</code> 调用失败，返回错误。例如：</p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;os&quot;
    &quot;text/template&quot;
)

func main() &#123;
    t := template.New(&quot;test&quot;)
    t, err := t.ParseFiles(&quot;test1&quot;)

    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    err = t.Execute(os.Stdout, nil)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<p>上面的代码执行会出现以下的错误：</p>
<pre><code class="go">Execute error:template: test: &quot;test&quot; is an incomplete or empty template
</code></pre>
<p>之所以会出现这种情况，跟模板的结构定义有关：</p>
<pre><code class="go">// src/text/template.go
type common struct &#123;
    tmpl   map[string]*Template // Map from name to defined templates.
    option option
    muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
    parseFuncs FuncMap
    execFuncs  map[string]reflect.Value
&#125;

type Template struct &#123;
    name string
    *parse.Tree
    *common
    leftDelim  string
    rightDelim string
&#125;
</code></pre>
<p>模板结构 <code>Template</code> 中有一个字段 <code>common</code>，<code>common</code> 中又有一个字段<code>tmpl</code>保存名字到模板的映射。其实，最外层的<code>Template</code>结构是<strong>主模板</strong>，我们调用<code>Execute</code>方法时执行的就是主模板。 <strong>执行<code>ParseFiles</code>方法时，每个文件都会生成一个模板。只有文件基础名与模板名相同时，该文件的内容才会解析到主模板中。这也是上面的程序执行失败的原因——主模板为空。</strong> 其它文件解析生成<strong>关联模板</strong>，存储在字段<code>tmpl</code>中。关联模板可以是在主模板中通过 <code>&#123; &#123; define &#125; &#125;</code> 动作定义，或者在非主模板文件中定义。关联模板也可以执行，但是需要使用<code>ExecuteTemplate</code>方法，显式传入模板名：</p>
<pre><code class="go">func main()
    t := template.New(&quot;test&quot;)
    t, err := t.ParseFiles(&quot;test1&quot;)
    
    if err != nil &#123;
        log.Fatal(&quot;in associatedTemplate Parse error:&quot;, err)
    &#125;
    
    err = t.ExecuteTemplate(os.Stdout, &quot;test1&quot;, nil)
    if err != nil &#123;
        log.Fatal(&quot;in associatedTemplate Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>第二种方式将创建和解析两步合并在一起了。<code>template.ParseFiles</code>方法将传入的第一个文件名作为模板名称，其余的文件（如果有的话）解析后存放在<code>tmpl</code>中：</p>
<pre><code class="go">t, err := template.ParseFiles(&quot;file1&quot;, &quot;file2&quot;, &quot;file3&quot;)
</code></pre>
<p>其实就等价于：</p>
<pre><code class="go">t := template.New(&quot;file1&quot;)
t, err := t.ParseFiles(&quot;file1&quot;, &quot;file2&quot;, &quot;file3&quot;)
</code></pre>
<p>少了不一致的可能性，所以调用 <code>Execute</code> 方法时不会出现上面的错误。</p>
<h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><p>还有一种创建方式，使用 <code>ParseGlob</code> 函数。<code>ParseGlob</code> 会对匹配给定模式的所有文件进行语法分析。</p>
<pre><code class="go">func main() &#123;
    t, err := template.ParseGlob(&quot;tmpl*.glob&quot;)
    if err != nil &#123;
        log.Fatal(&quot;in globTemplate parse error:&quot;, err)
    &#125;

    err = t.Execute(os.Stdout, nil)
    if err != nil &#123;
        log.Fatal(err)
    &#125;

    for i := 1; i &lt;= 3; i++ &#123;
        err = t.ExecuteTemplate(os.Stdout, fmt.Sprintf(&quot;tmpl%d.glob&quot;, i), nil)
        if err != nil &#123;
            log.Fatal(err)
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>ParseGlob</code> 返回的模板以匹配的第一个文件基础名作为名称。<code>ParseGlob</code> 解析时会对同一个目录下的文件进行排序，所以第一个文件总是固定的。</p>
<p>这里创建三个模板文件，<code>tmpl1.glob</code>：</p>
<pre><code>In glob template file1.
</code></pre>
<p>&#96;&#96;tmpl2.glob&#96;:</p>
<pre><code>In glob template file2.
</code></pre>
<p><code>tmpl3.glob</code>:</p>
<pre><code>In glob template file3.
</code></pre>
<p>最终输出为：</p>
<pre><code>In glob template file1.
In glob template file1.
In glob template file2.
In glob template file3.
</code></pre>
<p>注意，<strong>如果多个不同路径下的文件名相同，那么后解析的会覆盖之前的。</strong></p>
<h1 id="嵌套模板"><a href="#嵌套模板" class="headerlink" title="嵌套模板"></a>嵌套模板</h1><p>在一个模板文件中还可以通过 <code>&#123; &#123; define &#125; &#125;</code> 动作定义其它的模板，这些模板就是<strong>嵌套模板</strong>。模板定义必须在模板内容的最顶层，像 Go 程序中的全局变量一样。</p>
<p>嵌套模板一般用于<strong>布局（layout）</strong>。很多文本的结构其实非常固定，例如邮件有标题和正文，网页有首部、正文和尾部等。 我们可以为这些固定结构的每部分定义一个模板。</p>
<p>定义模板文件 <code>layout.tmpl</code>：</p>
<pre><code class="go">&#123;&#123; define "layout" &#125;&#125;
This is body.
&#123;&#123; template "content" . &#125;&#125;
&#123;&#123; end &#125;&#125;

&#123;&#123; define "content" &#125;&#125;
This is &#123;&#123; . &#125;&#125; content.
&#123;&#123; end &#125;&#125;
</code></pre>
<p>上面定义了两个模板<code>layout</code>和<code>content</code>，<code>layout</code>中使用了<code>content</code>。执行这种方式定义的模板必须使用<code>ExecuteTemplate</code>方法：</p>
<pre><code class="go">func main() &#123;
    t, err := template.ParseFiles(&quot;layout.tmpl&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Parse error:&quot;, err)
    &#125;

    err = t.ExecuteTemplate(os.Stdout, &quot;layout&quot;, &quot;amazing&quot;)
    if err != nil &#123;
        log.Fatal(&quot;Execute error:&quot;, err)
    &#125;
&#125;
</code></pre>
<h1 id="块动作"><a href="#块动作" class="headerlink" title="块动作"></a>块动作</h1><p>块动作其实就是定义一个默认模板，语法如下：</p>
<pre><code class="go">&#123;&#123; block "name" arg &#125;&#125;
T1
&#123;&#123; end &#125;&#125;
</code></pre>
<p>其实它就等价于定义一个模板，然后立即使用它：</p>
<pre><code class="go">&#123;&#123; define "name" &#125;&#125;
T1
&#123;&#123; end &#125;&#125;

&#123;&#123; template "name" arg &#125;&#125;
</code></pre>
<p>如果后面定义了模板 <code>content</code>，那么使用后面的定义，否则使用默认模板。</p>
<p>例如上面的示例中，我们将模板修改如下：</p>
<pre><code class="go">&#123;&#123; define "layout" &#125;&#125;
This is body.
&#123;&#123; block "content" . &#125;&#125;
This is default content.
&#123;&#123; end &#125;&#125;
&#123;&#123; end &#125;&#125;
</code></pre>
<p>去掉后面的<code>content</code>模板定义，执行<code>layout</code>时，<code>content</code>部分会显示默认值。</p>
<p><strong>参考文档</strong>：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://darjun.github.io/2019/12/31/goweb/template1/#&gid=1&pid=1">Go Web 编程之 模板（一）</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/29/gomock%20%E4%BD%BF%E7%94%A8/" rel="prev" title="gomock 使用">
                  <i class="fa fa-chevron-left"></i> gomock 使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/25/Go%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="next" title="Go 如何进行单元测试">
                  Go 如何进行单元测试 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">37:40</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
