<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Go 中的单元测试和基准测试的使用</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Go 中的单元测试和基准测试的使用</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-test-工具"><span class="toc-text">go test 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-test-的参数"><span class="toc-text">go test 的参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单元测试函数"><span class="toc-text">单元测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单元测试函数的格式"><span class="toc-text">单元测试函数的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单元测试函数的使用示例"><span class="toc-text">单元测试函数的使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试组"><span class="toc-text">测试组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自测试-t-Run"><span class="toc-text">自测试 t.Run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试覆盖率-go-test-cover"><span class="toc-text">测试覆盖率 go test -cover</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基准测试函数"><span class="toc-text">基准测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基准测试示例"><span class="toc-text">基准测试示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能比较函数"><span class="toc-text">性能比较函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重置时间-ResetTimer"><span class="toc-text">重置时间 ResetTimer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行测试-RunParallel"><span class="toc-text">并行测试 RunParallel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结合-pprof-性能监控"><span class="toc-text">结合 pprof 性能监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setup-与-TearDown"><span class="toc-text">Setup 与 TearDown</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TestMain"><span class="toc-text">TestMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子测试的-Setup-与-Teardown"><span class="toc-text">子测试的 Setup 与 Teardown</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#示例函数-Example"><span class="toc-text">示例函数 Example</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#示例函数的格式"><span class="toc-text">示例函数的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例函数示例"><span class="toc-text">示例函数示例</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/go"><i class="tag post-item-tag">go</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Go 中的单元测试和基准测试的使用</h1><time class="has-text-grey" datetime="2021-03-16T09:16:10.000Z">2021-03-16</time><article class="mt-2 post-content"><h1 id="go-test-工具"><a href="#go-test-工具" class="headerlink" title="go test 工具"></a>go test 工具</h1><p><code>go test</code> 命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以 <code>_test.go</code> 为后缀名的源代码文件都是 <code>go test</code> 测试的一部分，不会被 <code>go build</code> 编译到最终的可执行文件中。</p>
<p>在 <code>*_test.go</code> 文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数：</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">格式</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>测试函数</strong></td>
<td align="left">函数名前缀为Test</td>
<td align="left">测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td align="left"><strong>基准函数</strong></td>
<td align="left">函数名前缀为Benchmark</td>
<td align="left">测试函数的性能</td>
</tr>
<tr>
<td align="left"><strong>示例函数</strong></td>
<td align="left">函数名前缀为Example</td>
<td align="left">为文档提供示例文档</td>
</tr>
</tbody></table>
<p><code>go test</code> 命令会遍历所有的 <code>*_test.go</code> 文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<p>Golang 单元测试对文件名和方法名，参数都有很严格的要求。</p>
<ol>
<li>文件名必须以 <code>xx_test.go</code> 命名</li>
<li>方法必须是 <code>Test</code> 开头</li>
<li>方法参数必须 <code>t *testing.T</code></li>
<li>使用 <code>go test</code> 执行单元测试</li>
</ol>
<h2 id="go-test-的参数"><a href="#go-test-的参数" class="headerlink" title="go test 的参数"></a>go test 的参数</h2><p>go test 是 go 语言自带的测试工具，其中包含的是两类，单元测试和性能测试</p>
<p>通过 <code>go help test</code> 可以看到 go test 的使用说明：</p>
<p>格式形如： </p>
<pre><code class="shell">go test [-c] [-i] [build flags] [packages] [flags for test binary]</code></pre>
<p>参数解读：</p>
<ul>
<li><p>-c : 编译 go test 成为可执行的二进制文件，但是不运行测试。</p>
</li>
<li><p>-i : 安装测试包依赖的 package，但是不运行测试。</p>
</li>
<li><p>关于 build flags，调用 go help build，这些是编译运行过程中需要使用到的参数，一般设置为空</p>
</li>
<li><p>关于 packages，调用 go help packages，这些是关于包的管理，一般设置为空</p>
</li>
<li><p>关于 flags for test binary，调用 go help flags for test binary，这些是 go test 过程中经常使用到的参数</p>
</li>
</ul>
<p>常用示例如下：</p>
<ul>
<li>-test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</li>
<li>-test.run pattern: 只跑哪些单元测试用例</li>
<li>-test.bench patten: 只跑那些性能测试用例</li>
<li>-test.benchmem : 是否在性能测试的时候输出内存情况</li>
<li>-test.benchtime t : 性能测试运行的时间，默认是1s</li>
<li>-test.cpuprofile cpu.out : 是否输出cpu性能分析文件</li>
<li>-test.memprofile mem.out : 是否输出内存性能分析文件</li>
<li>-test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件</li>
<li>-test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是 profile 中一个 sample 代表的内存大小。默认是设置为 512 * 1024 的。如果将它设置为 1，则每分配一个内存块就会在 profile 中有个打点，那么生成的 profile 的 sample 就会非常多。如果设置为0，那就是不做打点了。可以通过设置 <code>memprofilerate=1</code> 和 <code>GOGC=off</code> 来关闭内存回收，并且对每个内存块的分配进行观察。</li>
<li>-test.blockprofilerate n: 基本同上，控制的是 goroutine 阻塞时候打点的纳秒数。默认不设置就相当于 <code>-test.blockprofilerate=1</code>，每一纳秒都打点记录一下</li>
<li>-test.parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS。</li>
<li>-test.timeout t : 如果测试用例运行时间超过t，则抛出 panic</li>
<li>-test.cpu 1,2,4 : 程序运行在哪些 CPU 上面，使用二进制的1所在位代表，和 nginx 的 nginx_worker_cpu_affinity 是一个道理</li>
<li>-test.short : 将那些运行时间较长的测试用例运行时间缩短</li>
</ul>
<h1 id="单元测试函数"><a href="#单元测试函数" class="headerlink" title="单元测试函数"></a>单元测试函数</h1><h2 id="单元测试函数的格式"><a href="#单元测试函数的格式" class="headerlink" title="单元测试函数的格式"></a>单元测试函数的格式</h2><p>测试函数必须导入 testing 包，基本格式如下：</p>
<pre><code class="go">func TestName(t *testing.T) {
    //...    
}</code></pre>
<p>测试函数的名字必须以 Test 开头，可选的后缀名必须是以大写字母开头，例如：</p>
<pre><code class="go">func TestAdd(t *testing.T){ ... }
func TestSum(t *testing.T){ ... }
func TestLog(t *testing.T){ ... }</code></pre>
<p>其中，参数 t 是用于报告测试失败和附加的日志信息的，<code>testing.T</code> 拥有的方法如下：</p>
<pre><code class="go">Cleanup(func())
Error(args ...interface{})
Errorf(format string, args ...interface{})
Fail()
FailNow()
Failed() bool
Fatal(args ...interface{})
Fatalf(format string, args ...interface{})
Helper()
Log(args ...interface{})
Logf(format string, args ...interface{})
Name() string
Skip(args ...interface{})
SkipNow()
Skipf(format string, args ...interface{})
Skipped() bool
TempDir() string</code></pre>
<p>其中，</p>
<ul>
<li>Fail，Error：该测试失败，该测试继续，其他测试继续执行</li>
<li>FailNow，Fatal：该测试失败，该测试终止，其他测试继续执行</li>
</ul>
<h2 id="单元测试函数的使用示例"><a href="#单元测试函数的使用示例" class="headerlink" title="单元测试函数的使用示例"></a>单元测试函数的使用示例</h2><p>在 split 包中定义一个 Split 函数，实现如下：</p>
<pre><code class="go">package split

import &quot;strings&quot;

func Split(s, sep string) (result []string) {
    i := strings.Index(s, sep)

    for i &gt; -1 {
        result = append(result, s[:i])
        s = s[i+1:]
        i = strings.Index(s, sep)
    }
    result = append(result, s)
    return
}</code></pre>
<p>在新建一个文件命名为 <code>split_test</code>，内容如下：</p>
<pre><code class="go">package split

import (
    &quot;reflect&quot;
    &quot;testing&quot;
)

func TestSplit(t *testing.T) {
    got := Split(&quot;a:b:c&quot;, &quot;:&quot;)      // 程序输出的结果
    want := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} // 期望的结果
    // slice 不能直接比较，借助反射包中的方法进行比价
    if !reflect.DeepEqual(want, got) {
        t.Errorf(&quot;excepted:%v, got %v&quot;, want, got)
    }
}</code></pre>
<p>在 split 目录下运行 go test 命令：</p>
<pre><code class="shell">split » go test
PASS
ok      algorithm/split 0.005s</code></pre>
<p>再写一个多个字符切割字符串的测试用例：</p>
<pre><code class="go">func TestMoreSplit(t *testing.T) {
    got := Split(&quot;abcd&quot;,&quot;bc&quot;) // 按照当前 split 的实现，这里 got 应该是[a,cd]
    want := []string{&quot;a&quot;,&quot;d&quot;}
    if !reflect.DeepEqual(want, got) {
        t.Errorf(&quot;excepted:%v, got %v&quot;, want, got)
    }
}</code></pre>
<p>再次运行 go test，结果如下：</p>
<pre><code>--- FAIL: TestMoreSplit (0.00s)
    split_test.go:21: excepted:[a d], got [a cd]
FAIL
exit status 1
FAIL    algorithm/split 0.005s</code></pre><p>可以看到测试不通过，这里可以通过添加 <code>-v</code> 参数，查看测试函数的名称和运行时间：</p>
<pre><code>// go test -v

=== RUN   TestSplit
--- PASS: TestSplit (0.00s)
=== RUN   TestMoreSplit
    split_test.go:21: excepted:[a d], got [a cd]
--- FAIL: TestMoreSplit (0.00s)
FAIL
exit status 1
FAIL    algorithm/split 0.005s</code></pre><p>这样就可以看出哪个函数通过而哪个函数没有通过。</p>
<p>还可以在 go test 命中后添加 -run 参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被 go test 命令执行。</p>
<pre><code>~ » go test -v -run=&quot;More&quot;
=== RUN   TestMoreSplit
    split_test.go:21: excepted:[a d], got [a cd]
--- FAIL: TestMoreSplit (0.00s)
FAIL
exit status 1
FAIL    algorithm/split 0.006s</code></pre><p>对于上面代码的 bug 进行修复：</p>
<pre><code class="go">package split

import &quot;strings&quot;

func Split(s, sep string) (result []string) {
    i := strings.Index(s, sep)

    for i &gt; -1 {
        result = append(result, s[:i])
        s = s[i+len(sep):] // 这里使用 len(sep) 获取 sep 的长度
        i = strings.Index(s, sep)
    }
    result = append(result, s)
    return
}</code></pre>
<p>然后重新进行测试，需要注意，<strong>修改了代码之后不要仅仅执行那些失败的测试函数，还应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题</strong>。</p>
<pre><code class="go">=== RUN   TestSplit
--- PASS: TestSplit (0.00s)
=== RUN   TestMoreSplit
--- PASS: TestMoreSplit (0.00s)
PASS
ok      algorithm/split 0.005s</code></pre>
<h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a>测试组</h2><p>接下来在测试一下 split 函数对于中文字符串的支持，这个时候一种方式是再编写一个 TestChineseSplit 测试函数，更好的方式是使用如下的方法来添加更多的测试用例：</p>
<pre><code class="go">package split

import (
    &quot;reflect&quot;
    &quot;testing&quot;
)

func TestSplit(t *testing.T) {
    // 定义一个测试用例类型
    type test struct {
        input string
        sep   string
        want  []string
    }
    // 定义一个存储测试用例的切片
    tests := []test{
        {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
        {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},
        {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
        {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},
    }
    // 遍历切片，逐一执行测试用例
    for _, tc := range tests {
        got := Split(tc.input, tc.sep)
        if !reflect.DeepEqual(got, tc.want) {
            // 使用 %#v 格式化的方式
            t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)
        }
    }
}</code></pre>
<h2 id="自测试-t-Run"><a href="#自测试-t-Run" class="headerlink" title="自测试 t.Run"></a>自测试 t.Run</h2><p>对于上面的测试，如果测试用例比较多的时候，是没办法一眼看出来具体是哪个测试用例失败了。可以通过如下的解决方法：</p>
<pre><code class="go">package split

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;testing&quot;
)

func TestSplit(t *testing.T) {
    // 定义一个测试用例类型
    type test struct {
        input string
        sep   string
        want  []string
    }
    // 通过 map 存储测试用例
    tests := map[string]test{
        &quot;simple&quot;:      {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
        &quot;wrong sep&quot;:   {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},
        &quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
        &quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},
    }
    // 遍历切片，逐一执行测试用例
    for name, tc := range tests {
        got := Split(tc.input, tc.sep)
        if !reflect.DeepEqual(got, tc.want) {
            // 使用 %#v 格式化的方式
            t.Errorf(&quot;name:%s excepted:%#v, got:%#v&quot;, name, tc.want, got)
        }
    }
}</code></pre>
<p>另外，go1.7+ 中新增了子测试，可以按照如下方式使用 t.Run 执行子测试：</p>
<pre><code class="go">package split

import (
    &quot;reflect&quot;
    &quot;testing&quot;
)

func TestSplit(t *testing.T) {
    // 定义一个测试用例类型
    type test struct {
        input string
        sep   string
        want  []string
    }
    // 通过 map 存储测试用例
    tests := map[string]test{
        &quot;simple&quot;:      {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
        &quot;wrong sep&quot;:   {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},
        &quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
        &quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}},
    }
    // 遍历切片，逐一执行测试用例
    for name, tc := range tests {
        t.Run(name, func(t *testing.T) {
            // 使用 t.Run() 执行子测试
            got := Split(tc.input, tc.sep)
            if !reflect.DeepEqual(got, tc.want) {
                // 使用 %#v 格式化的方式
                t.Errorf(&quot;name:%s excepted:%#v, got:%#v&quot;, name, tc.want, got)
            }
        })
    }
}</code></pre>
<p>运行 go test -v 命令就可以看到清晰的输出内容了：</p>
<pre><code>=== RUN   TestSplit
=== RUN   TestSplit/simple
=== RUN   TestSplit/wrong_sep
=== RUN   TestSplit/more_sep
=== RUN   TestSplit/leading_sep
--- PASS: TestSplit (0.00s)
    --- PASS: TestSplit/simple (0.00s)
    --- PASS: TestSplit/wrong_sep (0.00s)
    --- PASS: TestSplit/more_sep (0.00s)
    --- PASS: TestSplit/leading_sep (0.00s)
PASS
ok      algorithm/split 0.005s</code></pre><p>可以通过 <code>-run=RegExp</code> 来指定运行的测试用例，还可以通过 / 来指定要运行的子测试用例，<strong>例如：<code>go test -v -run=Split/simple</code> 只会运行 simple 对应的子测试用例</strong>。</p>
<h2 id="测试覆盖率-go-test-cover"><a href="#测试覆盖率-go-test-cover" class="headerlink" title="测试覆盖率 go test -cover"></a>测试覆盖率 go test -cover</h2><p><strong>测试覆盖率是代码被测试套件覆盖的百分比。</strong>通常使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>
<p>GO 提供内置功能来检查代码覆盖率。可以使用 <code>go test -cover</code> 来查看测试覆盖率。例如:</p>
<pre><code>$ go test -cover 

PASS
coverage: 100.0% of statements
ok      algorithm/split 0.005s</code></pre><p>可以看到测试用例的代码覆盖率是 100%。</p>
<p>Go 还提供了额外的 <code>-coverprofile</code> 参数，用来将覆盖率相关的记录信息输出到一个文件：</p>
<pre><code>go test -cover -coverprofile=c.out

PASS
coverage: 100.0% of statements
ok      algorithm/split 0.005s</code></pre><p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的 c.out 文件中，然后执行 <code>go tool cover -html=c.out</code>，使用 cover 工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个 HTML 报告:</p>
<p><img src="https://qiniu.xiaoming.net.cn/go-cover%20%E6%8A%A5%E5%91%8A.jpg" alt="go cover 报告"></p>
<h1 id="基准测试函数"><a href="#基准测试函数" class="headerlink" title="基准测试函数"></a>基准测试函数</h1><p>基准测试就是在一定的工作负载下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<pre><code class="go">func BenchmarkName(b *testing.B) {
    // 与性能测试无关的代码

    b.ResetTimer()
    for i:=0;i&lt;b.N;i++ {
        // 测试代码
    }
    b.StopTimer()

    // 与性能测试无关的代码
}</code></pre>
<p>基准测试以 Benchmark 为前缀，需要一个 <code>*testing.B</code> 类型的参数b，<strong>基准测试必须要执行 b.N 次，这样的测试才有对照性</strong>，b.N 的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B 拥有的方法如下：</p>
<pre><code class="Go">func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})
func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool
func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})
func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})
func (c *B) Name() string
func (b *B) ReportAllocs()
func (b *B) ResetTimer()
func (b *B) Run(name string, f func(b *B)) bool
func (b *B) RunParallel(body func(*PB))
func (b *B) SetBytes(n int64)
func (b *B) SetParallelism(p int)
func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
func (b *B) StartTimer()
func (b *B) StopTimer()</code></pre>
<h2 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h2><p>为 split 包中的 Split 函数编写基准测试如下：</p>
<pre><code class="go">func BenchmarkSplit(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        Split(&quot;枯藤老树昏鸦&quot;,&quot;老&quot;)
    }
}</code></pre>
<p>基准测试并不会默认执行，需要增加 <code>-bench</code> 参数，通过执行 <code>go test -bench=Split</code> 命令执行基准测试，输出结果如下：</p>
<pre><code>$ go test -bench=Split

goos: darwin
goarch: amd64
pkg: algorithm/split
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkSplit-4         9540991               121.5 ns/op
PASS
ok      algorithm/split 1.294s</code></pre><ul>
<li>其中 BenchmarkSplit-4 表示对 Split 函数进行基准测试，数字 4 表示 GOMAXPROCS 的值，这个对于并发基准测试很重要。</li>
<li>9540991 和 121.5 ns/op 表示每次调用 Split 函数耗时 121.5ns，这个结果是 9540991 次调用的平均值。</li>
</ul>
<p>还可以添加 <code>-benchmem</code> 参数，来获得内存分配的统计数据：</p>
<pre><code>$ go test -bench=Split -benchmem

goos: darwin
goarch: amd64
pkg: algorithm/split
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkSplit-4         9606978               121.7 ns/op            48 B/op          2 allocs/op
PASS
ok      algorithm/split 1.303s</code></pre><p>其中，<strong>48 B/op表示每次操作内存分配了 48 字节，2 allocs/op则表示每次操作进行了 2 次内存分配</strong>。</p>
<p>对 Split 函数进行优化：</p>
<pre><code class="go">func Split(s, sep string) (result []string) {
    // 提前使用 make 为 result 分配一个容量足够大的切片
    result = make([]string,0,strings.Count(s,sep) +1)
    i := strings.Index(s, sep)

    for i &gt; -1 {
        result = append(result, s[:i])
        s = s[i+len(sep):] // 这里使用 len(sep) 获取 sep 的长度
        i = strings.Index(s, sep)
    }
    result = append(result, s)
    return
}</code></pre>
<p>再次运行测试：</p>
<pre><code>$ go test -bench=Split -benchmem

goos: darwin
goarch: amd64
pkg: algorithm/split
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkSplit-4        10998399                95.64 ns/op           32 B/op          1 allocs/op
PASS
ok      algorithm/split 1.170s</code></pre><p>可以看到每次分配的内存将为 32 字节，而且只进行了 1 次内存分配。</p>
<h2 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h2><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是：</p>
<ol>
<li>发生在两个不同操作之间的相对耗时，比如同一个函数处理 1000 个元素的耗时与处理 1 万甚至 100 万个元素的耗时的差别是多少？</li>
<li>再或者对于同一个任务究竟使用哪种算法性能最佳？通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</li>
</ol>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的 Benchmark 函数传入不同的值来调用。举个例子如下：</p>
<pre><code class="go">func benchmark(b *testing.B, size int){/* ... */}
func Benchmark10(b *testing.B){ benchmark(b, 10) }
func Benchmark100(b *testing.B){ benchmark(b, 100) }
func Benchmark1000(b *testing.B){ benchmark(b, 1000) }</code></pre>
<p>例如编写了一个计算斐波那契数列的函数如下：</p>
<pre><code class="go">package fib

func Fib(n int) int {
    if n &lt; 2 {
        return n
    }
    return Fib(n-1) + Fib(n-2)
}</code></pre>
<p>性能测试函数如下：</p>
<pre><code class="go">package fib

import &quot;testing&quot;

func benchmarkFib(b *testing.B,n int) {
    for i := 0; i &lt; b.N; i++ {
        Fib(n)
    }
}

func BenchmarkFib1(b *testing.B) {benchmarkFib(b,1)}
func BenchmarkFib2(b *testing.B) {benchmarkFib(b,2)}
func BenchmarkFib3(b *testing.B) {benchmarkFib(b,3)}
func BenchmarkFib10(b *testing.B) {benchmarkFib(b,10)}
func BenchmarkFib20(b *testing.B) {benchmarkFib(b,20)}
func BenchmarkFib40(b *testing.B) {benchmarkFib(b,40)}</code></pre>
<p>运行基准测试：</p>
<pre><code>$ go test -bench=.

goos: darwin
goarch: amd64
pkg: algorithm/fib
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkFib1-4         654152845                1.772 ns/op
BenchmarkFib2-4         227844997                5.229 ns/op
BenchmarkFib3-4         142425820                8.411 ns/op
BenchmarkFib10-4         3659920               323.4 ns/op
BenchmarkFib20-4           29044             41357 ns/op
BenchmarkFib40-4               2         609840838 ns/op
PASS
ok      algorithm/fib   10.091s</code></pre><p>这里需要注意的是，默认情况下，<strong>每个基准测试至少运行1秒</strong>。如果在 Benchmark 函数返回时没有到 1 秒，则 b.N 的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的 BenchmarkFib40 只运行了两次，每次运行的平均值只有不到一秒。像这种情况下应该可以使用 -benchtime 标志增加最小基准时间，以产生更准确的结果。例如：</p>
<pre><code>$ go test -bench=Fib40 -benchtime=20s

goos: darwin
goarch: amd64
pkg: algorithm/fib
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkFib40-4              38         614229184 ns/op
PASS
ok      algorithm/fib   23.965s</code></pre><p>这一次 BenchmarkFib40 运行了 38 次。</p>
<p><strong>使用性能比较函数做测试的时候，一个容易犯的错误就是把 b.N 作为输入的大小</strong>，例如：</p>
<pre><code class="go">// 错误示范1
func BenchmarkFibWrong(b *testing.B) {
    for n := 0; n &lt; b.N; n++ {
        Fib(n)
    }
}

// 错误示范2
func BenchmarkFibWrong2(b *testing.B) {
    Fib(b.N)
}</code></pre>
<h2 id="重置时间-ResetTimer"><a href="#重置时间-ResetTimer" class="headerlink" title="重置时间 ResetTimer()"></a>重置时间 ResetTimer()</h2><p><code>b.ResetTimer()</code> 之前的处理不会被放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作：</p>
<pre><code class="go">func BenchmarkSplit(b *testing.B) {
    time.Sleep(5 * time.Second) // 假设需要做一些耗时的无关操作
    b.ResetTimer()              // 重置计时器
    for i := 0; i &lt; b.N; i++ {
        Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)
    }
}</code></pre>
<h2 id="并行测试-RunParallel"><a href="#并行测试-RunParallel" class="headerlink" title="并行测试 RunParallel"></a>并行测试 RunParallel</h2><pre><code class="go">func (b *B) RunParallel(body func(*PB))</code></pre>
<p>该函数会以并行的方式执行给定的基准测试：</p>
<ul>
<li>RunParallel 会创建出多个 goroutine，并将 b.N 分配给这些 goroutine 执行， 其中 goroutine 数量的默认值为 GOMAXPROCS</li>
<li>用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在 RunParallel 之前调用 SetParallelism 。</li>
<li>RunParallel 通常会与 -cpu 标志一同使用。</li>
</ul>
<pre><code class="go">package split

import &quot;testing&quot;

func BenchmarkSplitParallel(b *testing.B) {
    //b.SetParallelism(1) // 设置使用的 cpu 数量
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            Split(&quot;枯藤老树昏鸦&quot;, &quot;老&quot;)
        }
    })
}</code></pre>
<p>执行测试后：</p>
<pre><code>$ go test -bench=.

goos: darwin
goarch: amd64
pkg: algorithm/split
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkSplitParallel-4        21511131                52.12 ns/op
PASS
ok      algorithm/split 1.185s</code></pre><h2 id="结合-pprof-性能监控"><a href="#结合-pprof-性能监控" class="headerlink" title="结合 pprof 性能监控"></a>结合 pprof 性能监控</h2><pre><code class="go">package fib

import &quot;testing&quot;

func BenchmarkFib10(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        Fib(10)
    }
}</code></pre>
<p>执行命令：</p>
<pre><code>go test -bench=. -benchmem -cpuprofile profile.out
// 还可以同时查看内存
go test -bench=. -benchmem -memprofile memprofile.out -cpuprofile profile.out</code></pre><p>这会在当前目录下生成 <code>memprofile.out</code> 和 <code>profile.out</code> 文件，接下来可以用输出的文件使用 pprof：</p>
<pre><code>go tool pprof profile.out 

Type: cpu
Time: Mar 17, 2021 at 8:22pm (CST)
Duration: 1.65s, Total samples = 1.32s (80.06%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top
Showing nodes accounting for 1320ms, 100% of 1320ms total
      flat  flat%   sum%        cum   cum%
    1300ms 98.48% 98.48%     1320ms   100%  algorithm/fib.Fib
      20ms  1.52%   100%       20ms  1.52%  runtime.newstack
         0     0%   100%     1320ms   100%  algorithm/fib.BenchmarkFib10
         0     0%   100%     1320ms   100%  testing.(*B).launch
         0     0%   100%     1320ms   100%  testing.(*B).runN
(pprof) </code></pre><p>这个是使用 cpu 文件， 也可以使用内存文件</p>
<p>然后也可以用 list 命令检查函数需要的时间:</p>
<pre><code>(pprof) list Fib
Total: 1.32s
ROUTINE ======================== algorithm/fib.BenchmarkFib10 in /Users/silverming/go-project/algorithm/fib/fib_test.go
         0      1.32s (flat, cum)   100% of Total
         .          .      2:
         .          .      3:import &quot;testing&quot;
         .          .      4:
         .          .      5:func BenchmarkFib10(b *testing.B) {
         .          .      6:   for i := 0; i &lt; b.N; i++ {
         .      1.32s      7:           Fib(10)
         .          .      8:   }
         .          .      9:}
ROUTINE ======================== algorithm/fib.Fib in /Users/silverming/go-project/algorithm/fib/fib.go
     1.30s      1.91s (flat, cum) 144.70% of Total
         .          .      1:package fib
         .          .      2:
     260ms      280ms      3:func Fib(n int) int {
     150ms      150ms      4:   if n &lt; 2 {
     170ms      170ms      5:           return n
         .          .      6:   }
     720ms      1.31s      7:   return Fib(n-1) + Fib(n-2)
         .          .      8:}</code></pre><p>还可以通过 web 命令生成图像（没有测试成功）。。。</p>
<h2 id="Setup-与-TearDown"><a href="#Setup-与-TearDown" class="headerlink" title="Setup 与 TearDown"></a>Setup 与 TearDown</h2><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h3 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a>TestMain</h3><p>通过在 <code>*_test.go</code> 文件中定义 TestMain 函数，可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p>
<p>如果测试文件包含函数 <code>func TestMain(m *testing.M)</code> ，<strong>那么生成的测试会先调用 TestMain(m)，然后再运行具体测试</strong>。</p>
<p>TestMain 运行在主 goroutine 中, 可以在调用 m.Run 前后做任何设置（setup）和拆卸（teardown）。</p>
<p><strong>退出测试的时候应该使用 m.Run 的返回值作为参数调用 os.Exit</strong>。</p>
<p>一个使用  TestMain 来设置 Setup 和 TearDown 的示例如下：</p>
<pre><code class="go">func TestMain(m *testing.M) {
    fmt.Println(&quot;write setup code here...&quot;) // 测试之前的做一些设置
    // 如果 TestMain 使用了 flags，这里应该加上flag.Parse()
    retCode := m.Run()                         // 执行测试
    fmt.Println(&quot;write teardown code here...&quot;) // 测试之后做一些拆卸工作
    os.Exit(retCode)                           // 退出测试
}</code></pre>
<p>需要注意的是：<strong>在调用TestMain时， flag.Parse 并没有被调用。</strong>所以如果 TestMain 依赖于 command-line 标志 (包括 testing 包的标记)，则应该显示的调用 flag.Parse。</p>
<h3 id="子测试的-Setup-与-Teardown"><a href="#子测试的-Setup-与-Teardown" class="headerlink" title="子测试的 Setup 与 Teardown"></a>子测试的 Setup 与 Teardown</h3><p>有时候可能需要为每个测试集设置 Setup 与 Teardown，也有可能需要为每个子测试设置 Setup 与 Teardown。</p>
<p>下面定义两个函数工具函数如下：</p>
<pre><code class="go">// 测试集的 Setup 和 Teardown
func setupTestCase(t *testing.T) func(t *testing.T) {
    t.Log(&quot;如有需要哦在此执行：测试之前的 setup&quot;)
    return func(t *testing.T) {
        t.Log(&quot;如有需要在此执行：测试之后的 teardown&quot;)
    }
}

// 子测试的 Setup 和 Teardown
func setupSubTest(t *testing.T) func(t *testing.T) {
    t.Log(&quot;如有需要在此执行：子测试之前的 setup&quot;)
    return func(t *testing.T) {
        t.Log(&quot;如有需要在此执行：子测试之后的 teardown&quot;)
    }
}</code></pre>
<p>使用方式如下：</p>
<pre><code class="go">func TestSplit(t *testing.T) {
    type test struct { // 定义test结构体
        input string
        sep   string
        want  []string
    }
    tests := map[string]test{ // 测试用例使用map存储
        &quot;simple&quot;:      {input: &quot;a:b:c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
        &quot;wrong sep&quot;:   {input: &quot;a:b:c&quot;, sep: &quot;,&quot;, want: []string{&quot;a:b:c&quot;}},
        &quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
        &quot;leading sep&quot;: {input: &quot;枯藤老树昏鸦&quot;, sep: &quot;老&quot;, want: []string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}},
    }
    teardownTestCase := setupTestCase(t) // 测试之前执行 setup 操作
    defer teardownTestCase(t)            // 测试之后执行 teardown 操作

    for name, tc := range tests {
        t.Run(name, func(t *testing.T) { // 使用 t.Run() 执行子测试
            teardownSubTest := setupSubTest(t) // 子测试之前执行 setup 操作
            defer teardownSubTest(t)           // 测试之后执行 teardown 操作
            got := Split(tc.input, tc.sep)
            if !reflect.DeepEqual(got, tc.want) {
                t.Errorf(&quot;excepted:%#v, got:%#v&quot;, tc.want, got)
            }
        })
    }
}</code></pre>
<p>测试结果如下：</p>
<pre><code>$ go test -v                                                                                                    silverming@ZIMINGXING-MB1
=== RUN   TestSplit
    split_test.go:10: 如有需要哦在此执行：测试之前的 setup
=== RUN   TestSplit/more_sep
    split_test.go:18: 如有需要在此执行：子测试之前的 setup
    split_test.go:20: 如有需要在此执行：子测试之后的 teardown
=== RUN   TestSplit/leading_sep
    split_test.go:18: 如有需要在此执行：子测试之前的 setup
    split_test.go:46: excepted:[]string{&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;}, got:[]string{&quot;枯藤&quot;, &quot;树昏鸦&quot;}
    split_test.go:20: 如有需要在此执行：子测试之后的 teardown
=== RUN   TestSplit/simple
    split_test.go:18: 如有需要在此执行：子测试之前的 setup
    split_test.go:20: 如有需要在此执行：子测试之后的 teardown
=== RUN   TestSplit/wrong_sep
    split_test.go:18: 如有需要在此执行：子测试之前的 setup
    split_test.go:20: 如有需要在此执行：子测试之后的 teardown
=== CONT  TestSplit
    split_test.go:12: 如有需要在此执行：测试之后的 teardown
--- FAIL: TestSplit (0.00s)
    --- PASS: TestSplit/more_sep (0.00s)
    --- FAIL: TestSplit/leading_sep (0.00s)
    --- PASS: TestSplit/simple (0.00s)
    --- PASS: TestSplit/wrong_sep (0.00s)
FAIL
exit status 1
FAIL    algorithm/split 0.005s</code></pre><h1 id="示例函数-Example"><a href="#示例函数-Example" class="headerlink" title="示例函数 Example"></a>示例函数 Example</h1><h2 id="示例函数的格式"><a href="#示例函数的格式" class="headerlink" title="示例函数的格式"></a>示例函数的格式</h2><p>被 go test 特殊对待的第三种函数就是示例函数，它们的函数名以 Example 为前缀。它们既没有参数也没有返回值。标准格式如下：</p>
<pre><code class="go">func ExampleName() {
    //...
}</code></pre>
<h2 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a>示例函数示例</h2><p>为 Split 函数编写一个示例函数如下：</p>
<pre><code class="go">package split_test

import (
    &quot;algorithm/split&quot;
    &quot;fmt&quot;
)

func ExampleSplit() {
    fmt.Println(split.Split(&quot;a:b:c&quot;,&quot;:&quot;))
    fmt.Println(split.Split(&quot;枯藤老树昏鸦&quot;,&quot;老&quot;))
    // Output
    // [a b c]
    // [枯藤 树昏鸦]
}</code></pre>
<p>这个时候函数就会生成相应的文档：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3%E7%A4%BA%E4%BE%8B.png" alt="示例函数文档示例"></p>
<p>为代码编写示例代码有如下三个用处：</p>
<ol>
<li><p>示例函数能够作为文档直接使用，例如基于 web 的 godoc 中能把示例函数与对应的函数或包相关联。</p>
</li>
<li><p>示例函数只要包含了 <code>// Output:</code> 也是可以通过 go test 运行的可执行测试。</p>
<pre><code> split $ go test -run Example
 PASS
 ok      github.com/pprof/studygo/code_demo/test_demo/split       0.006s</code></pre></li>
</ol>
<ol start="3">
<li>示例函数提供了可以直接运行的示例代码，可以直接在 golang.org 的 godoc 文档服务器上使用 Go Playground 运行示例代码。</li>
</ol>
<p><strong>参考文章：</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/fly910905/article/details/105905491" target="_blank" rel="noopener">Go基础：如何做单元测试和基准测试</a></p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/03/23/go%E4%B8%AD%E7%9A%84time%E5%8C%85/" title="go 中 time 包的使用"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: go 中 time 包的使用</span></a><a class="button is-default" href="/2021/03/16/go%E4%B8%ADContext%E5%8C%85/" title="Go 中 Context 包"><span class="has-text-weight-semibold">下一页: Go 中 Context 包</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>