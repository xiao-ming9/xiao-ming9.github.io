<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="业务背景我们有一款产品跟海外某个国家的客户有业务合作，因此，我们在这个国家的服务器上单独部署了一整套的服务（大概有八九个微服务），这些服务的宿主机大概都集中在三、四台宿主机上。这些服务日复一日，年复一年的并肩作战着，直到有一天…… 初见端倪前阵子，我们在一个服务进行扩容、重启的时候，总是概率性的出现如下错误导致的 panic：  Google 的结果是说由于 Linux 分配的客户端连接端口用尽，">
<meta property="og:type" content="article">
<meta property="og:title" content="一次内存泄漏的排查">
<meta property="og:url" content="http://yoursite.com/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="业务背景我们有一款产品跟海外某个国家的客户有业务合作，因此，我们在这个国家的服务器上单独部署了一整套的服务（大概有八九个微服务），这些服务的宿主机大概都集中在三、四台宿主机上。这些服务日复一日，年复一年的并肩作战着，直到有一天…… 初见端倪前阵子，我们在一个服务进行扩容、重启的时候，总是概率性的出现如下错误导致的 panic：  Google 的结果是说由于 Linux 分配的客户端连接端口用尽，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E7%AB%AF%E5%8F%A3%E7%94%A8%E5%B0%BDpanic.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%85%B6%E4%BB%96%E6%9C%BA%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT1.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT2.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT3.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-ESTABLISHED.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-ip%E7%AB%AF%E5%8F%A3%E6%8E%92%E6%9F%A5.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-pprof%20%E6%8E%92%E6%9F%A5.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BB%A3%E7%A0%81.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BB%A3%E7%A0%812.jpg">
<meta property="article:published_time" content="2022-04-07T10:19:15.000Z">
<meta property="article:modified_time" content="2022-07-03T14:13:34.665Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta property="article:tag" content="内存泄漏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/%E7%AB%AF%E5%8F%A3%E7%94%A8%E5%B0%BDpanic.jpg">


<link rel="canonical" href="http://yoursite.com/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/","path":"2022/04/07/一次内存泄漏的排查/","title":"一次内存泄漏的排查"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>一次内存泄漏的排查 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">业务背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E7%AB%AF%E5%80%AA"><span class="nav-number">2.</span> <span class="nav-text">初见端倪</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%90%E9%9C%B2%E5%A4%B4%E8%A7%92"><span class="nav-number">3.</span> <span class="nav-text">渐露头角</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%B7%E8%A7%92%E5%90%B9%E5%93%8D"><span class="nav-number">4.</span> <span class="nav-text">号角吹响</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BA%E5%B8%88%E6%9C%AA%E6%8D%B7"><span class="nav-number">5.</span> <span class="nav-text">出师未捷</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83"><span class="nav-number">6.</span> <span class="nav-text">渐入佳境</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E5%85%B6%E7%84%B6%EF%BC%8C%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6"><span class="nav-number">7.</span> <span class="nav-text">知其然，知其所以然</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%AE%9E%E8%B7%B5%E7%9B%B8%E7%BB%93%E5%90%88"><span class="nav-number">8.</span> <span class="nav-text">理论实践相结合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%85%B3%E9%97%AD"><span class="nav-number">8.1.</span> <span class="nav-text">正常读取和关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%85%B3%E9%97%AD"><span class="nav-number">8.2.</span> <span class="nav-text">只读取不关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E5%85%B3%E9%97%AD%E4%B8%8D%E8%AF%BB%E5%8F%96"><span class="nav-number">8.3.</span> <span class="nav-text">只关闭不读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A2%E4%B8%8D%E5%85%B3%E9%97%AD%E4%B9%9F%E4%B8%8D%E8%AF%BB%E5%8F%96"><span class="nav-number">8.4.</span> <span class="nav-text">既不关闭也不读取</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-number">9.</span> <span class="nav-text">后记</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="一次内存泄漏的排查 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一次内存泄漏的排查
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 18:19:15" itemprop="dateCreated datePublished" datetime="2022-04-07T18:19:15+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-03 22:13:34" itemprop="dateModified" datetime="2022-07-03T22:13:34+08:00">2022-07-03</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>我们有一款产品跟海外某个国家的客户有业务合作，因此，我们在这个国家的服务器上单独部署了一整套的服务（大概有八九个微服务），这些服务的宿主机大概都集中在三、四台宿主机上。这些服务日复一日，年复一年的并肩作战着，直到有一天……</p>
<h1 id="初见端倪"><a href="#初见端倪" class="headerlink" title="初见端倪"></a>初见端倪</h1><p>前阵子，我们在一个服务进行扩容、重启的时候，总是概率性的出现如下错误导致的 panic：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AB%AF%E5%8F%A3%E7%94%A8%E5%B0%BDpanic.jpg" alt="端口用尽panic"></p>
<p>Google 的结果是说由于 Linux 分配的客户端连接端口用尽，无法建立 socket 连接导致的。</p>
<p>这时候还有点懵逼，单纯以为是容器的宿主机有问题，于是，我重新在另外一台机器进行了节点扩容，这次很幸运，服务启动成功了，于是乎以为问题已经顺利解决，可以美美的下班了。</p>
<span id="more"></span>

<h1 id="渐露头角"><a href="#渐露头角" class="headerlink" title="渐露头角"></a>渐露头角</h1><p>过了一周，我们发现线上的另一个服务在疯狂报错，上去查看日志，发现：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%85%B6%E4%BB%96%E6%9C%BA%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD.jpg" alt="内存泄漏排查-其他机器端口耗尽"></p>
<p>同样的错误又出现了，而且这次是在另外一个服务上，这时候开始觉得哪里不对劲了，另一个服务怎么也出现这种错误？难道又是宿主机有问题？接着仔细一看，诶，这个机器 ip 怎么看着有点眼熟，这时候脑子里有了一个不好的想法……</p>
<p>于是，我把剩下的几个服务都上去看了一遍日志，果不其然，基本上每个服务都有这种错误存在。</p>
<p>难道线上流量有这么大？</p>
<p>到这里，感觉有必要弄清楚，到底端口号都哪去了，怎么就都被占了呢，不然再下去可能整套微服务都要挂了（人可能也要没了）。</p>
<p>于是，一次线上问题的排查战开始展开。。。</p>
<h1 id="号角吹响"><a href="#号角吹响" class="headerlink" title="号角吹响"></a>号角吹响</h1><p>作为一个还没见过的错误，第一反应很自然就是谷歌，搜索结果显示，很多人都是因为请求完成后连接不是立即释放，而是处于 <code>TIME_WAIT</code> 状态导致的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT1.jpg" alt="内存泄漏排查-TIME_WAIT1"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT2.jpg" alt="内存泄漏排查-TIME_WAIT2"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-TIME_WAIT3.jpg" alt="内存泄漏排查-TIME_WAIT2"></p>
<p>解决的办法也很简单，只需要对 Linux 的相关参数进行优化，缩短 <code>TIME_WAIT</code> 的时间，增加可提供的端口范围即可：</p>
<pre><code> // 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭
net.ipv4.tcp_tw_reuse=1 
//修改系默认的 TIMEOUT 时间，默认为60s
net.ipv4.tcp_fin_timeout=15
// 表示用于向外连接的端口范围。设置为 1024 到 65535
net.ipv4.ip_local_port_range=1024 65535
</code></pre>
<p>看起来似乎这个问题很容易解决嘛，看来今天又可以美美的下班了。</p>
<h1 id="出师未捷"><a href="#出师未捷" class="headerlink" title="出师未捷"></a>出师未捷</h1><p>在上手开始操作之前，我打算先看看现在的 <code>TIME_WAIT</code> 数量到底有多少，于是，Google 一条显示当前连接状态的命令（真的记不住。。。），熟练的按下 <code>command+C</code>，<code>command+V</code>：</p>
<pre><code class="shell">netstat -an | awk &#39;/^tcp/ &#123;++y[$NF]&#125; END &#123;for(w in y) print w, y[w]&#125;&#39;

LISTEN 54
ESTABLISHED 142640
SYN_SENT 2
TIME_WAIT 216
</code></pre>
<p>。。。</p>
<p>。。。</p>
<p>。。。</p>
<blockquote>
<p>一般来说，处于网络连接中的状态主要有以下几个：</p>
<ul>
<li><code>CLOSED</code>：无连接是活动的或正在进行</li>
<li><code>LISTEN</code>：服务器在等待进入呼叫</li>
<li><code>SYN_RECV</code>：一个连接请求已经到达，等待确认</li>
<li><code>SYN_SENT</code>：应用已经开始，打开一个连接</li>
<li><code>ESTABLISHED</code>：正常数据传输状态</li>
<li><code>FIN_WAIT1</code>：应用说它已经完成</li>
<li><code>FIN_WAIT2</code>：另一边已同意释放</li>
<li><code>ITMED_WAIT</code>：等待所有分组死掉</li>
<li><code>CLOSING</code>：两边同时尝试关闭</li>
<li><code>TIME_WAIT</code>：表示处理完毕，等待超时结束的请求数。</li>
<li><code>LAST_ACK</code>：等待所有分组死掉</li>
</ul>
</blockquote>
<p>当看到打印出来的结果是，我整个人是有点懵的，这怎么跟书上说的好像不太一样啊，说好的是 <code>TIME_WAIT</code> 数量太多了呢？另外，<code>ESTABLISHED</code> 的数量未免也太多了，为什么机器上建立起了这么多的连接？</p>
<p>为了进一步分析问题，我又到其他的容器节点上查看网络连接情况，基本上每台机器的 <code>ESTABLISHED</code> 数量都高达十几万。</p>
<p>于是乎，Google 搜索框的内容变成了：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-ESTABLISHED.jpg" alt="内存泄漏排查-ESTABLISHED"></p>
<p>这时，组里的大佬提点了一句，一直这样查也查不出什么，不如先看看这些连接是从哪里来的。</p>
<p>确实，马克思主义教导我们，脱离实践的理论都是空洞的理论，一切还得从实际出发，那不如先来看看这些连接都是从哪里来的。</p>
<h1 id="渐入佳境"><a href="#渐入佳境" class="headerlink" title="渐入佳境"></a>渐入佳境</h1><p>于是我在容器上，用 <code>netstat</code> 命令统计了本机发起的链接，过滤出处于 <code>ESTABLISHED</code> 链接状态的连接，看看大部分是来自于本机哪个端口：</p>
<pre><code class="shell">netstat -na | grep ESTABLISHED | awk &#39;&#123;print $4&#125;&#39; | sort | uniq -c|sort -n
</code></pre>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-ip%E7%AB%AF%E5%8F%A3%E6%8E%92%E6%9F%A5.jpg" alt="内存泄漏排查-ip端口排查"></p>
<p>结果很让我意外，某一个 ipport 的连接居然高达 10w+，更让我意外的是，这个地址，竟然是我们部署的某一个微服务！</p>
<p>到这里，问题的根源就呼之欲出了。。。</p>
<p>是它！就是它！内存泄漏！！！而且很有可能就是 http 请求导致的内存泄漏。</p>
<p>为了进一步验证是不是由于 http 的内存泄漏所导致的问题，决定用 pprof 神器进行进一步的分析：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-pprof%20%E6%8E%92%E6%9F%A5.jpg" alt="内存泄漏排查-pprof 排查"></p>
<p>果然，从打印的 goroutine 信息来看，无疑是发生了 http 的内存泄漏，那很可能就是代码里对于发送 http 请求后的 body 没有进行处理（读取 body 内容或者 close）导致的，定位我们自身的业务代码，果然找到了其中一段内容：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BB%A3%E7%A0%81.jpg" alt="内存泄漏排查-内存泄漏代码"></p>
<p>而在其调用的下游 http 服务中，存在返回 404 的场景：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BB%A3%E7%A0%812.jpg" alt="内存泄漏排查-内存泄漏代码2"></p>
<p>所以，当下游服务返回 404 时，上游服务直接进行了 return，<strong>既没有把 rsp body 的内容读取出来，也没有执行下面的  <code>Close</code> 操作</strong>，这就导致了连接即没有办法进行复用，也无法进行回收的尴尬处境，导致连接一直无法释放，造成内存泄漏。</p>
<p>而在我们的业务中，下游服务返回 404 在某些场景下是比较常见的，这就导致了大量的 goroutine 泄漏，出现了上面的问题。</p>
<p>于是，赶紧一顿输出，赶在节前把 bug 解决掉，美美下班回家过节。</p>
<h1 id="知其然，知其所以然"><a href="#知其然，知其所以然" class="headerlink" title="知其然，知其所以然"></a>知其然，知其所以然</h1><p>书接上文提到的，在进行 http 请求后，如果没有<strong>把 rsp body 的内容读取出来，或者执行 body 的 <code>Close</code> 操作</strong>，就会导致连接无法被复用，也无法进行回收，那这里是为什么呢？</p>
<p>欲知此事如何，请听下文源码分析。(<strong>内容相对枯燥，谨慎入内。。。</strong>)</p>
<p>以 <code>http.Get</code> 方法为例：</p>
<pre><code class="go">es, err := client.Do(req)
func (c *Client) Do(req *Request) (*Response, error) &#123;
    return c.do(req)
&#125;

func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;
     //...
     if resp, didTimeout, err = c.send(req, deadline); err != nil &#123;
       //...
&#125;
     //...
&#125;

func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeoutfunc() bool, err error) &#123;
     //...
     // 这里关注下 c.transport 和 send 方法
     resp, didTimeout, err = send(req, c.transport(), deadline)
     //...
&#125;

// 可以看到，http 的请求采用 DefaultTransport 进行连接管理
func (c *Client) transport() RoundTripper &#123;
    if c.Transport != nil &#123;
        return c.Transport
    &#125;
    return DefaultTransport
&#125;

func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) &#123;
     //...
     resp, err = rt.RoundTrip(req)
     //...
&#125;

// 这里开始进入 RoundTrip 逻辑
// src/net/http/roundtrip.go
func (t *Transport) RoundTrip(req *Request) (*Response, error) &#123;
    return t.roundTrip(req)
&#125;

func (t *Transport) roundTrip(req *Request) (*Response, error) &#123;
     //...
     // 这里会获取一个空闲链接，该链接有可能是连接池里的，也有可能是新创建出来的
     pconn, err := t.getConn(treq, cm)
     //...
&#125;

// 这个函数是重点，返回一个长连接
func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) &#123;
     //...
     // 这里尝试从空闲连接中获取一个连接
     if delivered := t.queueForIdleConn(w); delivered &#123;
       //...
           return w.pc,nil
    &#125;
     //...
     // 如果上面没有获取到连接，在这个函数里创建连接
    t.queueForDial(w)
     //...
&#125;

// 使用空闲连接
func (t *Transport) queueForIdleConn(w *wantConn) (delivered bool) &#123;
     //...
     if list, ok := t.idleConn[w.key]; ok &#123;
       //...
    &#125;
     //...
&#125;

// 创建连接
func (t *Transport) queueForDial(w *wantConn) &#123;
     //...
     // 如果没有限制最大连接数，则直接创建新的连接
     if t.MaxConnsPerHost &lt;= 0 &#123;
        go t.dialConnFor(w)
    return
    &#125;
     //...
     // 如果有最大连接数限制就判断是否已经超过了最大连接，没超过直接创建
     if n := t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost &#123;
        if t.connsPerHost == nil &#123;
            t.connsPerHost = make(map[connectMethodKey]int)
        &#125;
        t.connsPerHost[w.key] = n + 1
        go t.dialConnFor(w)
        return
    &#125;
     //...
     // 超过了放到等待队列里
     q := t.connsPerHostWait[w.key]
     //...
&#125;

// 创建新的连接都会走到这个方法
func (t *Transport) dialConnFor(w *wantConn) &#123;
     //...
     // 在这里创建连接
     pc, err := t.dialConn(w.ctx, w.cm)
     //...
&#125;

func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) &#123;
     //...
     conn, err := t.dial(ctx, &quot;tcp&quot;, cm.addr())
     //...
     // 创建两个协程，一个读一个写
     go pconn.readLoop()
    go pconn.writeLoop()
     //...
&#125;
</code></pre>
<p>首先，<code>Get</code> 方法一路会走到 <code>Transport</code> 的 <code>getConn</code> 方法里(前面还有很长的流程，这里就忽略了），这个方法会<strong>优先尝试从没有释放的空闲连接中获取一个连接</strong>，如果没有则执行连接创建。</p>
<pre><code class="go">/ 这个函数是重点，返回一个长连接
func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) &#123;
     //...
     // 这里尝试从空闲连接中获取一个连接
     if delivered := t.queueForIdleConn(w); delivered &#123;
       //...
           return w.pc,nil
    &#125;
     //...
     // 如果上面没有获取到连接，在这个函数里创建连接
    t.queueForDial(w)
     //...
&#125;
</code></pre>
<p>创建新连接的方法是 <code>dialConn</code>，这个方法也很长，但是这里的重点在方法结尾处的两行：</p>
<pre><code class="go">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) &#123;
    // ...
    go pconn.readLoop()
    go pconn.writeLoop()
    return pconn, nil
&#125;
</code></pre>
<p>可以看到，一旦创建一个新连接，就会启动一个读 goroutine 和一个写 goroutine。这两个 goroutine 内部都是一个 for 循环，只有在满足特定的条件下，才会退出循环。</p>
<p>那么，这两个 goroutine 在什么时候释放呢？</p>
<p>先看看 <code>writeLoop</code>:</p>
<pre><code class="go">func (pc *persistConn) writeLoop() &#123;
    defer close(pc.writeLoopDone)
    for &#123;
        select &#123;
        case wr := &lt;-pc.writech:
            startBytesWritten := pc.nwrite
            err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))
            // ...
            if err != nil &#123;
                pc.close(err)
                return
            &#125;
        case &lt;-pc.closech:
            return
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>writeLoop</code> 退出循环的场景，一个是执行 request 的写入失败，另外一个就是当前连接被关闭。</p>
<p><code>readLoop</code> 的代码则相对复杂一些：</p>
<pre><code class="go">func (pc *persistConn) readLoop() &#123;
    //...
    alive := true
    for alive &#123;
        //...
        if resp.Close || rc.req.Close || resp.StatusCode &lt;= 199 || bodyWritable &#123;
            // Don&#39;t do keep-alive on error if either party requested a close
            // or we get an unexpected informational (1xx) response.
            // StatusCode 100 is already handled above.
            alive = false
        &#125;
        //...
        if !hasBody || bodyWritable &#123;
            replaced := pc.t.replaceReqCanceler(rc.cancelKey, nil)

            // Put the idle conn back into the pool before we send the response
            // so if they process it quickly and make another request, they&#39;ll
            // get this same conn. But we use the unbuffered channel &#39;rc&#39;
            // to guarantee that persistConn.roundTrip got out of its select
            // potentially waiting for this persistConn to close.

            // 这里判断如果请求的 body 没有内容并且 response 的 body 可写，会直接把连接放回空闲连接池
            // 在上面的注释中表示，golang 会避免一个连接在短时间内刚被放回连接池又被取出来使用，导致两次拿到同一个连接
            alive = alive &amp;&amp;
                !pc.sawEOF &amp;&amp;
                pc.wroteRequest() &amp;&amp;
                replaced &amp;&amp; tryPutIdleConn(trace)
            //...
        &#125;
        //...
        // Before looping back to the top of this function and peeking on
        // the bufio.Reader, wait for the caller goroutine to finish
        // reading the response body. (or for cancellation or death)
        select &#123;
        case bodyEOF := &lt;-waitForBodyRead:
            replaced := pc.t.replaceReqCanceler(rc.cancelKey, nil) // before pc might return to idle pool
            alive = alive &amp;&amp;
                bodyEOF &amp;&amp;
                !pc.sawEOF &amp;&amp;
                pc.wroteRequest() &amp;&amp;
                replaced &amp;&amp; tryPutIdleConn(trace)
            if bodyEOF &#123;
                eofc &lt;- struct&#123;&#125;&#123;&#125;
            &#125;
        case &lt;-rc.req.Cancel:
            alive = false
            pc.t.CancelRequest(rc.req)
        case &lt;-rc.req.Context().Done():
            alive = false
            pc.t.cancelRequest(rc.cancelKey, rc.req.Context().Err())
        case &lt;-pc.closech:
            alive = false
        &#125;
        //...
    &#125;
&#125;
</code></pre>
<p><code>readLoop</code> 函数同样也是一个 <code>for</code> 循环，而退出循环的条件是 <code>alive</code> 的值是 <code>false</code> ，那么 <code>alive</code> 什么时候会是 <code>false</code> 呢？</p>
<p>从上面的代码中可以看到，只有在以下几种场景中，存在 <code>alive</code> 是 <code>false</code> ，使得 goroutine 退出的可能：</p>
<ul>
<li>request 或者 respone 任何一方请求关闭连接，或者收到 1xx 的状态码。</li>
<li><code>body</code> 被读取完毕或者 <code>body</code> 被关闭。</li>
<li><code>request</code> 主动 <code>cancel</code>。</li>
<li><code>request</code> 的 <code>context Done</code> 状态为 <code>true</code>。</li>
<li>当前连接被关闭。</li>
</ul>
<p>这里来分析一下第二种场景（<code>body</code> 被读取完毕或者 <code>body</code> 被关闭），其对应的代码段为：</p>
<pre><code class="go">case bodyEOF := &lt;-waitForBodyRead:
    alive = alive &amp;&amp;
                bodyEOF &amp;&amp;
                !pc.sawEOF &amp;&amp;
                pc.wroteRequest() &amp;&amp;
                replaced &amp;&amp; tryPutIdleConn(trace)
</code></pre>
<p>这里 <code>alive</code> 是否为 <code>true</code> 便取决于 <code>bodyEOF</code> 的值，<code>bodyEOF</code> 来源于一个通道 <code>waitForBodyRead</code>，这个通道的值则来自：</p>
<pre><code class="go">waitForBodyRead := make(chan bool, 2)
    body := &amp;bodyEOFSignal&#123;
        body: resp.Body,
        earlyCloseFn: func() error &#123;
            waitForBodyRead &lt;- false
            &lt;-eofc // will be closed by deferred call at the end of the function
            return nil

        &#125;,
        fn: func(err error) error &#123;
            isEOF := err == io.EOF
            waitForBodyRead &lt;- isEOF
            if isEOF &#123;
                &lt;-eofc // see comment above eofc declaration
            &#125; else if err != nil &#123;
                if cerr := pc.canceled(); cerr != nil &#123;
                    return cerr
                &#125;
            &#125;
            return err
        &#125;,
    &#125;
</code></pre>
<p>在上面的代码中，如果执行了 <code>earlyCloseFn</code>，那么 <code>waitForBodyRead</code> 就会输入 false，<code>alive</code> 也就会是 <code>false</code>，此时会退出 <code>readLoop</code> 这个循环。</p>
<p>如果执行了 <code>fn</code>，其中包括正常情况下 <code>body</code> 读完数据抛出 <code>io.EOF</code> 时的 <code>case</code>，此时 <code>waitForBodyRead</code> 通道输入时 <code>true</code>，<code>alive</code> 也会是 <code>true</code>, 它会接着往下执行 <code>tryPutIdleConn(trace)</code>,将 <code>pconn</code> 连接放回到空闲队列中等待新的请求，也就是该连接会被复用。</p>
<p>那接下来就是看看 <code>earlyCloseFn</code> 和 <code>fn</code> 这两个方法分别是在什么场景下执行了。</p>
<p>还记得我们上面说的两种场景吗？再帮大家回忆一下，要使连接能够被回收复用，有两个方式是可以做到的：</p>
<ol>
<li>把 rsp body 的内容全部读取出来；</li>
<li>执行 body 的 <code>Close</code> 操作。</li>
</ol>
<p>首先来看看读取 rsp body 的场景：</p>
<pre><code class="go">body, err := ioutil.ReadAll(rsp.Body)

func ReadAll(r io.Reader) ([]byte, error) &#123;
    return io.ReadAll(r)
&#125;

func ReadAll(r Reader) ([]byte, error) &#123;
    //...
    n, err := r.Read(b[len(b):cap(b)])
       //...
&#125;

func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;
    //...
    n, err = es.body.Read(p)
    if err != nil &#123;
        es.mu.Lock()
        defer es.mu.Unlock()
        if es.rerr == nil &#123;
            es.rerr = err
        &#125;
        // 这里会有一个 io.EOF 的报错，因为 ReadAll 读取完了全部的数据
        err = es.condfn(err)
    &#125;
    return
&#125;

func (es *bodyEOFSignal) condfn(err error) error &#123;
    if es.fn == nil &#123;
        return err
    &#125;
    // 这里就执行了 fn
    err = es.fn(err)
    es.fn = nil
    return err
&#125;
</code></pre>
<p>可以看到，在最后读取完毕之后，会执行 <code>fn</code> ，而这里的入参 <code>err</code> 因为已经读取完了所有内容，所以是一个 <code>io.EOF</code>，所以此时 <code>waitForBodyRead</code> 输入 true，<code>alive</code> 继续会 true，此时 <code>readLoop</code> 继续存在，并不会退出，此时会执行 <code>tryPutIdleConn(trace)</code> 把连接放回池子里复用。</p>
<p>再看看 Close 的场景：</p>
<pre><code class="go">func (es *bodyEOFSignal) Close() error &#123;
    es.mu.Lock()
    defer es.mu.Unlock()
    if es.closed &#123;
        return nil
    &#125;
    es.closed = true
    if es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF &#123;
        return es.earlyCloseFn()
    &#125;
    err := es.body.Close()
    return es.condfn(err)
&#125;
</code></pre>
<p>可以看到，如果在读取到了非 <code>io.EOF</code> 错误时（<strong>也就是 rsp.Body 的内容没有被读取完毕的场景下</strong>）会执行会执行 <code>earlyCloseFn</code>，此时 <code>waitForBodyRead</code> 会输入 <code>false</code>，那么 <code>alive</code> 就会是 <code>false</code> 从而使得 <code>readLoop</code> 退出。</p>
<p>而如果 body 内容已经被读取完毕，则同样调用 <code>fn</code> ，此时连接不会退出，但是可以在下次有需要新连接时被复用。</p>
<p>到了这里，再回顾一下上面 <code>raedLoop</code> 退出的几个条件：</p>
<pre><code class="go">case bodyEOF := &lt;-waitForBodyRead:
            replaced := pc.t.replaceReqCanceler(rc.cancelKey, nil) // before pc might return to idle pool
            alive = alive &amp;&amp;
                bodyEOF &amp;&amp;
                !pc.sawEOF &amp;&amp;
                pc.wroteRequest() &amp;&amp;
                replaced &amp;&amp; tryPutIdleConn(trace)
            if bodyEOF &#123;
                eofc &lt;- struct&#123;&#125;&#123;&#125;
            &#125;
        case &lt;-rc.req.Cancel:
            alive = false
            pc.t.CancelRequest(rc.req)
        case &lt;-rc.req.Context().Done():
            alive = false
            pc.t.cancelRequest(rc.cancelKey, rc.req.Context().Err())
        case &lt;-pc.closech:
            alive = false
        &#125;
</code></pre>
<ul>
<li>request 或者 respone 任何一方请求关闭连接，或者收到 1xx 的状态码。</li>
<li><code>body</code> 被读取完毕或者 <code>body</code> 被关闭。</li>
<li><code>request</code> 主动 <code>cancel</code>。</li>
<li><code>request</code> 的 <code>context Done</code> 状态为 <code>true</code>。</li>
<li>当前连接被关闭。</li>
</ul>
<p>所以，经过上面花里胡哨的分析，可以知道，如果一个请求拿到响应后，既没有读取 body 的所有内容，也没有对 body 执行 <code>Close</code> 操作，将导致两个 <code>goroutine</code> 一直没法被回收，造成内存泄漏。</p>
<p>而如果读取了 body 的所有内容或者把 body close 掉，则可以使连接得以释放复用。</p>
<p>当然，这两种场景导致的结果也不相同。对于只读取 body 的场景，连接并不会被释放掉，而是作为空闲链接等待下一次的复用。而对于关闭 body 的场景，则分为两种情况，当 body 内容被读取完毕时，连接能够进行复用；而当 body 内容没有被读取完毕时，连接会被释放掉，下一次请求会重新建立连接。</p>
<h1 id="理论实践相结合"><a href="#理论实践相结合" class="headerlink" title="理论实践相结合"></a>理论实践相结合</h1><p>前面逼逼赖赖说了那么多，但是事实到底是不是如此呢？</p>
<p>都说实践是检验真理的唯一标准，那么下面我们就来验证一下上面的观点。</p>
<h2 id="正常读取和关闭"><a href="#正常读取和关闭" class="headerlink" title="正常读取和关闭"></a>正常读取和关闭</h2><pre><code class="go">func main() &#123;
    num := 10
    for index := 0; index &lt; num; index++ &#123;
        rsp, err := http.Get(&quot;https://www.baidu.com&quot;)
        if err != nil &#123;
            continue
        &#125;
        io.Copy(ioutil.Discard, rsp.Body)
        rsp.Body.Close()
    &#125;
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 90) // 一段时间连接空闲，自动关闭，默认值是 90s
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code>此时goroutine个数= 3
此时goroutine个数= 1
</code></pre>
<h2 id="只读取不关闭"><a href="#只读取不关闭" class="headerlink" title="只读取不关闭"></a>只读取不关闭</h2><pre><code class="go">func main() &#123;
    num := 10
    for index := 0; index &lt; num; index++ &#123;
        rsp, err := http.Get(&quot;https://www.baidu.com&quot;)
        if err != nil &#123;
            continue
        &#125;
        io.Copy(ioutil.Discard, rsp.Body)
        //rsp.Body.Close()
    &#125;
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 10) // 一段时间连接空闲，看看连接是否释放
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 90) // 一段时间连接空闲，自动关闭，默认值是 90s
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code>此时goroutine个数= 3
此时goroutine个数= 3
此时goroutine个数= 1
</code></pre>
<h2 id="只关闭不读取"><a href="#只关闭不读取" class="headerlink" title="只关闭不读取"></a>只关闭不读取</h2><pre><code class="go">func main() &#123;
    num := 10
    for index := 0; index &lt; num; index++ &#123;
        rsp, err := http.Get(&quot;https://www.baidu.com&quot;)
        if err != nil &#123;
            continue
        &#125;
        //io.Copy(ioutil.Discard, rsp.Body)
        rsp.Body.Close()
    &#125;
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 10) // 一段时间连接空闲，看看连接是否关闭
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 90) // 一段时间连接空闲，自动关闭，默认值是 90s
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code>此时goroutine个数= 3
此时goroutine个数= 1
此时goroutine个数= 1
</code></pre>
<h2 id="既不关闭也不读取"><a href="#既不关闭也不读取" class="headerlink" title="既不关闭也不读取"></a>既不关闭也不读取</h2><pre><code class="go">func main() &#123;
    num := 10
    for index := 0; index &lt; num; index++ &#123;
        _, err := http.Get(&quot;https://www.baidu.com&quot;)
        if err != nil &#123;
            continue
        &#125;
        //io.Copy(ioutil.Discard, rsp.Body)
        //rsp.Body.Close()
    &#125;
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 10) // 一段时间连接空闲，看看连接是否关闭
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
    time.Sleep(time.Second * 90) // 一段时间连接空闲，自动关闭，默认值是 90s
    fmt.Printf(&quot;此时goroutine个数= %d\n&quot;, runtime.NumGoroutine())
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code>此时goroutine个数= 21
此时goroutine个数= 21
此时goroutine个数= 21
</code></pre>
<p>可以看到，在最后一种场景下，会造成 goroutine 的泄漏。</p>
<p>综上，我们日常在写代码的过程中，对于需要执行 HTTP 请求的场景，一定记得 <code>resp.Body.Close</code>，这也是一个良好的代码习惯：</p>
<pre><code class="go">res, err := http.Get(url)
if err != nil &#123;
    log.Printf(&quot;Error: %s\n&quot;, err)
    return
&#125;
defer res.Body.Close()
</code></pre>
<p>多提一些题外话，在网上查看的时候，发现有很多博客上认为应该采用下面的写法：</p>
<pre><code class="go">res, err := http.Get(url)
defer func() &#123;
   if res != nil &amp;&amp; res.Body != nil &#123;
      res.Body.Close()
   &#125;
&#125;()
if err != nil &#123;
    log.Printf(&quot;Error: %s\n&quot;, err)
    return
&#125;
</code></pre>
<p>上面的代码为什么不是在 <code>err != nil</code> 的场景下才执行 <code>Close</code> 呢？原因是在于存在一种特殊的场景：当请求得到一个重定向的错误时，此时返回的 body 内容并非空的。</p>
<p>初看上面的代码总感觉很奇怪，而且感觉这似乎不属于 Golang 的风格，于是去搜刮了一下 Golang 的官方仓库，发现之前确实存在这种问题，但是在后续的版本其实已经做了处理。</p>
<p>现有的版本下，如果出现重定向的错误，其返回的 body 虽然不为空，但是其实已经对其进行了 <code>Close</code> 操作，这一步主要在上面的 <code>do</code> 方法中执行：</p>
<pre><code class="go">func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;
      //...
  
            // Sentinel error to let users select the
            // previous response, without closing its
            // body. See Issue 10069.
            if err == ErrUseLastResponse &#123;
                return resp, nil
            &#125;

            // Close the previous response&#39;s body. But
            // read at least some of the body so if it&#39;s
            // small the underlying TCP connection will be
            // re-used. No need to check for errors: if it
            // fails, the Transport won&#39;t reuse it anyway.
            const maxBodySlurpSize = 2 &lt;&lt; 10
            if resp.ContentLength == -1 || resp.ContentLength &lt;= maxBodySlurpSize &#123;
                io.CopyN(io.Discard, resp.Body, maxBodySlurpSize)
            &#125;
            resp.Body.Close()

            if err != nil &#123;
                // Special case for Go 1 compatibility: return both the response
                // and an error if the CheckRedirect function failed.
                // See https://golang.org/issue/3795
                // The resp.Body has already been closed.
                ue := uerr(err)
                ue.(*url.Error).URL = loc
                return resp, ue
            &#125;
      // ...
&#125;
</code></pre>
<p>有兴趣的可以看看下面的两个 Issue 和 commit 记录：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/3795">net&#x2F;http has broken compatibility on redirection handler #3795</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/10069">net&#x2F;http: redirection response has closed body #10069</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/aecfcd827edb4a7ab6248668f7329a330e1f0e4a">net&#x2F;http: clean up the Client redirect code, document Body.Close rule…</a></li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过这次内存泄漏的排查，也学到不少新技能，从发现问题，到问题分析，定位问题，再到源码了解，一步一步走过来，积累了很多知识，也很感谢组里大佬们的帮助，让自己从中学到了很多实用的经验。</p>
<p>以上分析内容如果有不正确的地方，欢迎各位大佬们批评指正！下次线上问题，再会！（希望没有下次了～）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5NDY2MDk4Mw==&mid=2247486370&idx=1&sn=8b8bbd7ef43849ad71b72f7fddbb12b7&source=41#wechat_redirect">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7Fl5MuCl-G6wIQQiAqLAKA">i&#x2F;o timeout ， 希望你不要踩到这个net&#x2F;http包的坑</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94">go语言设计与实现</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" rel="tag"># 内存泄漏</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Golang%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="prev" title="Golang 常见问题">
                  <i class="fa fa-chevron-left"></i> Golang 常见问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/07/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" rel="next" title="Go 内存对齐">
                  Go 内存对齐 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:50</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
