<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Wechat:934933088">
<meta property="og:type" content="website">
<meta property="og:title" content="Silverming">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="Wechat:934933088">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/04/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/04/Kafka/" class="post-title-link" itemprop="url">Kafka 知识汇总</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 00:21:23" itemprop="dateCreated datePublished" datetime="2022-07-04T00:21:23+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-05 00:21:30" itemprop="dateModified" datetime="2022-07-05T00:21:30+08:00">2022-07-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>59 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Kafka 被定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。Kafka 在现代的系统中主要承担三大角色：</p>
<ul>
<li>消息系统：Kafka 和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。</li>
<li>存储系统：Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于Kafka 的消息持久化功能和多副本机制，我们可以把Kafka作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。</li>
<li>流式处理平台：Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个典型的 Kafka 体系架构包括若干 Producer、若干 Broker、若干 Consumer，以及一个 ZooKeeper 集群。其中 ZooKeeper 是 Kafka 用来负责集群元数据的管理、控制器的选举等操作的。Producer 将消息发送到 Broker，Broker 负责将收到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="kafka基本概念"></p>
<ul>
<li><p>Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</p>
</li>
<li><p>Consumer：消费者，也就是接收消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理。</p>
</li>
<li><p>Broker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的 Kafka 服务节点或 Kafka 服务实例。大多数情况下也可以将 Broker 看作一台 Kafka 服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个 Broker 组成了一个 Kafka 集群。一般而言，习惯使用首字母小写的 broker 来表示服务代理节点。</p>
</li>
</ul>
<p>在 Kafka 中还有两个特别重要的概念—主题（Topic）与分区（Partition）。Kafka 中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到 Kafka 集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。</p>
<p>主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，<strong>Kafka 保证的是分区有序而不是主题有序</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5.png" alt="kafka 消息写入"></p>
<p>每一条消息被发送到broker之前，会根据分区规则选择存储到哪个具体的分区。如果分区规则设定得合理，所有的消息都可以均匀地分配到不同的分区中。<strong>如果一个主题只对应一个文件，那么这个文件所在的机器 I/O 将会成为这个主题的性能瓶颈，而分区解决了这个问题</strong>。在创建主题的时候可以通过指定的参数来设置分区的个数，当然也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。</p>
<p>Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中 leader 副本负责处理读写请求，follower 副本只负责与 leader 副本的消息同步。<strong>副本处于不同的 broker 中，当 leader 副本出现故障时，从 follower 副本中重新选举新的 leader 副本对外提供服务</strong>。Kafka 通过多副本机制实现了故障的自动转移，当 Kafka 集群中某个 broker 失效时仍然能保证服务可用。</p>
<p>如下图所示，Kafka 集群中有 4 个 broker，某个主题中有 3 个分区，且副本因子（即副本个数）也为 3，如此每个分区便有 1 个 leader 副本和 2 个 follower 副本。生产者和消费者只与 leader 副本进行交互，而 follower 副本只负责消息的同步，很多时候 follower 副本中的消息相对 leader 副本而言会有一定的滞后。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6.png" alt="kafka多副本机制"></p>
<p>Kafka 消费端也具备一定的容灾能力。<strong>Consumer 使用拉（Pull）模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失</strong>。</p>
<h2 id="ISR-机制"><a href="#ISR-机制" class="headerlink" title="ISR 机制"></a>ISR 机制</h2><p>分区中的所有副本统称为 AR（Assigned Replicas）。所有与 leader 副本保持一定程度同步的副本（包括 leader 副本在内）组成 ISR（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。消息会先发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，同步期间内 follower 副本相对于 leader 副本而言会有一定程度的滞后。前面所说的“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。与 leader 副本同步滞后过多的副本（不包括leader副本）组成 OSR（Out-of-Sync Replicas），由此可见，AR=ISR+OSR。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR 集合为空。</p>
<p>leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当 follower 副本落后太多或失效时，leader 副本会把它从 ISR 集合中剔除。如果 OSR 集合中有 follower 副本“追上”了leader副本，那么 leader 副本会把它从 OSR 集合转移至 ISR 集合。<strong>默认情况下，当 leader 副本发生故障时，只有在 ISR 集合中的副本才有资格被选举为新的 leader，而在 OSR 集合中的副本则没有任何机会</strong>（不过这个原则也可以通过修改相应的参数配置来改变）。ISR 与 HW 和 LEO 也有紧密的关系。HW 是 High Watermark 的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），<strong>消费者只能拉取到这个 offset 之前的消息</strong>。</p>
<p>如下图所示，它代表一个日志文件，这个日志文件中有 9 条消息，第一条消息的 offset（LogStartOffset）为 0，最后一条消息的 offset 为 8，offset 为 9 的消息用虚线框表示，代表下一条待写入的消息。日志文件的 HW 为 6，表示消费者只能拉取到 offset 在 0 至 5 之间的消息，而 offset 为 6 的消息对消费者而言是不可见的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="日志文件格式"></p>
<p>LEO 是 Log End Offset 的缩写，它<strong>标识当前日志文件中下一条待写入消息的 offset</strong>，图中 offset 为 9 的位置即为当前日志文件的 LEO，LEO 的大小相当于当前日志分区中最后一条消息的 offset 值加1。分区 ISR 集合中的每个副本都会维护自身的 LEO，而 <strong>ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息</strong>。</p>
<p>如下图所示，假设某个分区的 ISR 集合中有 3 个副本，即一个 leader 副本和 2 个 follower 副本，此时分区的 LEO 和 HW 都为 3：</p>
<p><img src="https://qiniu.xiaoming.net.cn/ISR%E6%9C%BA%E5%88%B6-1.png" alt="ISR机制-1"></p>
<p>消息 3 和消息 4 从生产者发出之后会被先存入 leader 副本：</p>
<p><img src="https://qiniu.xiaoming.net.cn/ISR%E6%9C%BA%E5%88%B6-2.png" alt="ISR机制-2"></p>
<p>在消息写入 leader 副本之后，follower 副本会发送拉取请求来拉取消息 3 和消息 4 以进行消息同步。</p>
<p>在同步过程中，不同的 follower 副本的同步效率也不尽相同。如下图所示，在某一时刻 follower1 完全跟上了 leader 副本而 follower2 只同步了消息 3，如此 leader 副本的 LEO 为5，follower1 的 LEO 为5，follower2 的 LEO 为 4，那么当前分区的 HW 取最小值4，此时消费者可以消费到offset为0至3之间的消息。</p>
<p><img src="https://qiniu.xiaoming.net.cn/ISR%E6%9C%BA%E5%88%B6-3.png" alt="ISR机制-3"></p>
<p>写入消息（情形4）如下所示，所有的副本都成功写入了消息3和消息4，整个分区的HW和LEO都变为5，因此消费者可以消费到offset为4的消息了。</p>
<p><img src="https://qiniu.xiaoming.net.cn/ISR%E6%9C%BA%E5%88%B6-4.png" alt="ISR机制-4"></p>
<p>Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower 副本异步地从 leader 副本中复制数据，数据只要被 leader 副本写入就被认为已经成功提交。在这种情况下，如果 follower 副本都还没有复制完而落后于 leader 副本，突然 leader 副本宕机，则会造成数据丢失。Kafka 使用的这种ISR的方式则有效地权衡了数据可靠性和性能之间的关系。</p>
<h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><p>这里列举几个常用的参数，具体其他的所有参数信息可以在 Kafka 官网查看。</p>
<h3 id="zookeeper-connect"><a href="#zookeeper-connect" class="headerlink" title="zookeeper.connect"></a>zookeeper.connect</h3><p>该参数指明 broker 要连接的 ZooKeeper 集群的服务地址（包含端口号），没有默认值，且此参数为必填项。可以配置为 <code>localhost：2181</code>，如果 ZooKeeper 集群中有多个节点，则可以用逗号将每个节点隔开，类似于 <code>localhost1：2181</code>，<code>localhost2：2181</code>，<code>localhost3：2181</code> 这种格式。</p>
<p>最佳的实践方式是再加一个 chroot 路径，这样既可以明确指明该 chroot 路径下的节点是为 Kafka 所用的，也可以实现多个 Kafka 集群复用一套 ZooKeeper 集群，这样可以节省更多的硬件资源。包含 chroot 路径的配置类似于 <code>localhost1：2181</code>，<code>localhost2：2181</code>，<code>localhost3：2181/kafka</code>这种，如果不指定 chroot，那么默认使用 ZooKeeper 的根路径。</p>
<h3 id="listeners"><a href="#listeners" class="headerlink" title="listeners"></a>listeners</h3><p>该参数指明 broker 监听客户端连接的地址列表，即为客户端要连接 broker 的入口地址列表，配置格式为 <code>protocol1：//hostname1：port1</code>，<code>protocol2：//hostname2：port2</code>，其中 protocol 代表协议类型，Kafka 当前支持的协议类型有 PLAINTEXT、SSL、SASL_SSL 等，如果未开启安全认证，则使用简单的 PLAINTEXT 即可。hostname 代表主机名，port代表服务端口，此参数的默认值为 null。比如此参数配置为 PLAINTEXT：//198.162.0.2：9092，如果有多个地址，则中间以逗号隔开。如果不指定主机名，则表示绑定默认网卡，注意有可能会绑定到 127.0.0.1，这样无法对外提供服务，所以主机名最好不要为空；如果主机名是0.0.0.0，则表示绑定所有的网卡。与此参数关联的还有 advertised.listeners，作用和 listeners 类似，默认值也为 null。不过 advertised.listeners 主要用于 IaaS（Infrastructure as a Service）环境，比如公有云上的机器通常配备有多块网卡，即包含私网网卡和公网网卡，对于这种情况而言，可以设置 <code>advertised.listeners</code> 参数绑定公网IP供外部客户端使用，而配置 listeners 参数来绑定私网 IP 地址供 broker 间通信使用。</p>
<h3 id="broker-id"><a href="#broker-id" class="headerlink" title="broker.id"></a>broker.id</h3><p>该参数用来指定 Kafka 集群中 broker 的唯一标识，默认值为 -1。如果没有设置，那么 Kafka 会自动生成一个。这个参数还和 <code>meta.properties</code> 文件及服务端参数 <code>broker.id.generation.enable</code> 和 <code>reserved.broker.max.id</code> 有关。</p>
<h3 id="log-dir-和-log-dirs"><a href="#log-dir-和-log-dirs" class="headerlink" title="log.dir 和 log.dirs"></a>log.dir 和 log.dirs</h3><p>Kafka 把所有的消息都保存在磁盘上，而这两个参数用来配置 Kafka 日志文件存放的根目录。一般情况下，<code>log.dir</code> 用来配置单个根目录，而 <code>log.dirs</code> 用来配置多个根目录（以逗号分隔），但是 Kafka 并没有对此做强制性限制，也就是说，<code>log.dir</code> 和<code>log.dirs</code> 都可以用来配置单个或多个根目录。<code>log.dirs</code> 的优先级比 <code>log.dir</code> 高，但是如果没有配置 <code>log.dirs</code>，则会以 <code>log.dir</code> 配置为准。默认情况下只配置了 <code>log.dir</code> 参数，其默认值为 <code>/tmp/kafka-logs</code>。</p>
<h3 id="message-max-bytes"><a href="#message-max-bytes" class="headerlink" title="message.max.bytes"></a>message.max.bytes</h3><p>该参数用来指定 broker 所能接收消息的最大值，默认值为 1000012（B），约等于 976.6 KB。如果 Producer 发送的消息大于这个参数所设置的值，那么（Producer）就会报出 <code>RecordTooLargeException</code> 的异常。如果需要修改这个参数，那么还要考虑 <code>max.request.size</code> （客户端参数）、<code>max.message.bytes</code>（topic端参数）等参数的影响。为了避免修改此参数而引起级联的影响，建议在修改此参数之前考虑分拆消息的可行性。</p>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p>生产者的客户端使用不同语言不一样，这里就不写了，主要看看生产者客户端的内部实现原理。</p>
<p>消息在真正发往 Kafka 之前，有可能需要经历拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）等一系列的作用，最后才执行发送操作。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://qiniu.xiaoming.net.cn/%E7%94%9F%E4%BA%A7%E8%80%85%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="生产者整体架构"></p>
<p>整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和 Sender 线程（发送线程）。在主线程中由 KafkaProducer 创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到<strong>消息累加器（RecordAccumulator，也称为消息收集器）</strong>中。Sender 线程负责从 RecordAccumulator 中获取消息并将其发送到 Kafka 中。</p>
<p>RecordAccumulator 主要用来缓存消息以便 Sender 线程可以批量发送，进而减少网络传输的资源消耗以提升性能。RecordAccumulator 缓存的大小可以通过生产者客户端参数 <code>buffer.memory</code> 配置，默认值为 33554432B，即 32MB。如果生产者发送消息的速度超过发送到服务器的速度，则会导致生产者空间不足，这个时候 KafkaProducer 的 send（） 方法调用要么被阻塞，要么抛出异常，这个取决于参数 <code>max.block.ms</code> 的配置，此参数的默认值为 60000，即 60 秒。</p>
<p>主线程中发送过来的消息都会被追加到 RecordAccumulator 的某个双端队列（Deque）中，在 RecordAccumulator 的内部为每个分区都维护了一个双端队列，队列中的内容就是 ProducerBatch，即 <code>Deque＜ProducerBatch＞</code>。消息写入缓存时，追加到双端队列的尾部；</p>
<p>Sender 读取消息时，从双端队列的头部读取。注意 ProducerBatch 不是 ProducerRecord，<strong>ProducerBatch 中可以包含一至多个 ProducerRecord</strong>。通俗地说，ProducerRecord 是生产者中创建的消息，而 ProducerBatch 是指一个消息批次，ProducerRecord 会被包含在 ProducerBatch 中，这样可以使字节的使用更加紧凑。与此同时，将较小的 ProducerRecord 拼凑成一个较大的 ProducerBatch，也可以减少网络请求的次数以提升整体的吞吐量。如果生产者客户端需要向很多分区发送消息，则可以将 <code>buffer.memory</code> 参数适当调大以增加整体的吞吐量。</p>
<p>消息在网络上都是以字节（Byte）的形式传输的，在发送之前需要创建一块内存区域来保存对应的消息。在 Kafka 生产者客户端中，通过 <code>java.io.ByteBuffer</code> 实现消息内存的创建和释放。不过频繁的创建和释放是比较耗费资源的，在 RecordAccumulator 的内部还有一个 BufferPool，它主要用来实现 ByteBuffer 的复用，以实现缓存的高效利用。不过 BufferPool 只针对特定大小的 ByteBuffer 进行管理，而其他大小的 ByteBuffer 不会缓存进 BufferPool 中，这个特定的大小由 <code>batch.size</code> 参数来指定，默认值为16384B，即16KB。可以适当地调大 <code>batch.size</code> 参数以便多缓存一些消息。</p>
<p>ProducerBatch 的大小和 <code>batch.size</code> 参数也有着密切的关系。当一条消息（ProducerRecord）流入 RecordAccumulator 时，会先寻找与消息分区所对应的双端队列（如果没有则新建），再从这个双端队列的尾部获取一个 ProducerBatch（如果没有则新建），查看 ProducerBatch 中是否还可以写入这个 ProducerRecord，如果可以则写入，如果不可以则需要创建一个新的 ProducerBatch。</p>
<p>在新建 ProducerBatch 时评估这条消息的大小是否超过 <code>batch.size</code> 参数的大小，如果不超过，那么就以 <code>batch.size</code> 参数的大小来创建 ProducerBatch，这样在使用完这段内存区域之后，可以通过 BufferPool 的管理来进行复用；如果超过，那么就以评估的大小来创建 ProducerBatch，这段内存区域不会被复用。</p>
<p>Sender 从 RecordAccumulator 中获取缓存的消息之后，会进一步将原本 <code>＜分区，Deque＜ProducerBatch＞＞</code> 的保存形式转变成 <code>＜Node，List＜ProducerBatch＞</code> 的形式，其中 Node 表示 Kafka 集群的 broker 节点。对于网络连接来说，生产者客户端是与具体的 broker 节点建立的连接，也就是向具体的 broker 节点发送消息，而并不关心消息属于哪一个分区；而对于 KafkaProducer 的应用逻辑而言，只关注向哪个分区中发送哪些消息，所以在这里需要做一个应用逻辑层面到网络I/O层面的转换。</p>
<p>在转换成 <code>＜Node，List＜ProducerBatch＞＞</code> 的形式之后，Sender 还会进一步封装成 <code>＜Node，Request＞</code> 的形式，这样就可以将 Request 请求发往各个 Node 了，这里的 Request 是指 Kafka 的各种协议请求，对于消息发送而言就是指具体的 ProduceRequest。</p>
<p>请求在从 Sender 线程发往 Kafka 之前还会保存到 InFlightRequests 中，InFlightRequests 保存对象的具体形式为 <code>Map＜NodeId，Deque＜Request＞＞</code>，它的主要作用是<strong>缓存了已经发出去但还没有收到响应的请求</strong>（NodeId 是一个String 类型，表示节点的 id 编号）。与此同时，InFlightRequests 还提供了许多管理类的方法，并且通过配置参数还可以限制每个连接（也就是客户端与 Node 之间的连接）最多缓存的请求数。这个配置参数为 <code>max.in.fight.requests.per.connection</code>，默认值为 5，即每个连接最多只能缓存 5个未响应的请求，超过该数值之后就不能再向这个连接发送更多的请求了，除非有缓存的请求收到了响应（Response）。通过比较 <code>Deque＜Request＞</code> 的 size 与这个参数的大小来判断对应的 Node 中是否已经堆积了很多未响应的消息，如果真是如此，那么说明这个 Node 节点负载较大或网络连接有问题，再继续向其发送请求会增大请求超时的可能。</p>
<h2 id="元数据更新"><a href="#元数据更新" class="headerlink" title="元数据更新"></a>元数据更新</h2><p>上面提及的 <code>InFlightRequests</code> 还可以获得 <code>leastLoadedNode</code>，即所有 Node 中负载最小的那一个。这里的负载最小是通过每个 <code>Node</code> 在 <code>InFlightRequests</code> 中还未确认的请求决定的，未确认的请求越多则认为负载越大。</p>
<p>对于下图的 InFlightRequests 来说，图中展示了三个节点 Node0、Node1 和 Node2，很明显 Node1 的负载最小。也就是说，Node1 为当前的 leastLoadedNode。选择 leastLoadedNode 发送请求可以使它能够尽快发出，避免因网络拥塞等异常而影响整体的进度。<strong>leastLoadedNode 的概念可以用于多个应用场合，比如元数据请求、消费者组播协议的交互</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%85%83%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png" alt="kafka元数据更新"></p>
<p>Producer 客户端在创建一条消息时，只知道主题的名称，对于其他一些必要的信息却一无所知。KafkaProducer 要将此消息追加到指定主题的某个分区所对应的 leader 副本之前，首先需要知道主题的分区数量，然后经过计算得出（或者直接指定）目标分区，之后 KafkaProducer 需要知道目标分区的 leader 副本所在的 broker 节点的地址、端口等信息才能建立连接，最终才能将消息发送到 Kafka，在这一过程中所需要的信息都属于<strong>元数据信息</strong>。</p>
<p>而实际上在使用时，只需要配置部分的 broker 节点的地址即可，不需要配置所有 broker 节点的地址，因为客户端可以自己发现其他 broker 节点的地址，这一过程也属于元数据相关的更新操作。与此同时，分区数量及 leader 副本的分布都会动态地变化，客户端也需要动态地捕捉这些变化。</p>
<p>元数据是指 Kafka 集群的元数据，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的 leader 副本分配在哪个节点上，follower 副本分配在哪些节点上，哪些副本在 AR、ISR 等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。</p>
<p>当客户端中没有需要使用的元数据信息时，比如没有指定的主题信息，或者超过 <code>metadata.max.age.ms</code> 时间没有更新元数据都会引起元数据的更新操作。客户端参数 <code>metadata.max.age.ms</code> 的默认值为300000，即 5 分钟。元数据的更新操作是在客户端内部进行的，对客户端的外部使用者不可见。当需要更新元数据时，会先挑选出 <code>leastLoadedNode</code>，然后向这个 Node 发送 MetadataRequest 请求来获取具体的元数据信息。这个更新操作是由 Sender 线程发起的，在创建完 MetadataRequest 之后同样会存入 InFlightRequests，之后的步骤就和发送消息时的类似。元数据虽然由 Sender 线程负责更新，但是主线程也需要读取这些信息，这里的数据同步通过 synchronized 和 final 关键字来保障。</p>
<h2 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a>相关参数</h2><h3 id="必填参数"><a href="#必填参数" class="headerlink" title="必填参数"></a>必填参数</h3><p>在 Kafka 生产者客户端中，有 3 个参数是必填的：</p>
<ul>
<li><code>bootstrap.servers</code>：该参数用来指定生产者客户端连接 Kafka 集群所需的 broker 地址清单，具体的内容格式为<code>host1：port1</code>，<code>host2：port2</code>，可以设置一个或多个地址，中间以逗号隔开，此参数的默认值为“”。<strong>注意这里并非需要所有的 broker 地址，因为生产者会从给定的broker里查找到其他broker的信息</strong>。不过建议至少要设置两个以上的 broker 地址信息，当其中任意一个宕机时，生产者仍然可以连接到 Kafka 集群上。</li>
<li><code>key.serializer</code> 和 <code>value.serializer</code>：broker 端接收的消息必须以字节数组（<code>byte[]</code>）的形式存在。在发往 broker 之前需要将消息中对应的 key 和 value 做相应的序列化操作来转换成字节数组。<code>key.serializer</code> 和 <code>value.serializer</code> 这两个参数分别用来指定 key 和 value 序列化操作的序列化器，这两个参数无默认值。</li>
</ul>
<p>接下来再说几个非必填，但比较重要的参数。</p>
<h3 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h3><p>这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。acks 是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。acks 参数有3种类型的值（都是字符串类型）。</p>
<ul>
<li>acks=1。默认值即为1。生产者发送消息之后，只要分区的 leader 副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息无法写入 leader 副本，比如在 leader 副本崩溃、重新选举新的 leader 副本的过程中，那么生产者就会收到一个错误的响应，为了避免消息丢失，生产者可以选择重发消息。<strong>如果消息写入 leader 副本并返回成功响应给生产者，且在被其他 follower 副本拉取之前 leader 副本崩溃，那么此时消息还是会丢失，因为新选举的 leader 副本中并没有这条对应的消息</strong>。acks 设置为1，是消息可靠性和吞吐量之间的折中方案。</li>
<li>acks=-1 或 acks=all。生产者在消息发送之后，需要等待 ISR 中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。在其他配置环境相同的情况下，acks 设置为-1（all）可以达到最强的可靠性。但这并不意味着消息就一定可靠，因为 ISR 中可能只有 leader 副本，这样就退化成了 acks=1 的情况。要获得更高的消息可靠性需要配合 <code>min.insync.replicas</code> 等参数的联动。</li>
</ul>
<h3 id="max-request-size"><a href="#max-request-size" class="headerlink" title="max.request.size"></a>max.request.size</h3><p>这个参数用来限制生产者客户端能发送的消息的最大值，默认值为 1048576B，即 1 MB。一般情况下，这个默认值就可以满足大多数的应用场景了。并不建议盲目地增大这个参数的配置值，尤其是在对 Kafka 整体脉络没有足够把控的时候。因为这个参数还涉及一些其他参数的联动，比如 broker 端的 <code>message.max.bytes</code> 参数，如果配置错误可能会引起一些不必要的异常。比如将 broker 端的 <code>message.max.bytes</code> 参数配置为10，而 <code>max.request.size</code>参数配置为20，那么当发送一条大小为 15B 的消息时，生产者客户端就会报出异常。</p>
<h3 id="retries-和-retry-backoff-ms"><a href="#retries-和-retry-backoff-ms" class="headerlink" title="retries 和 retry.backoff.ms"></a>retries 和 retry.backoff.ms</h3><p><code>retries</code> 参数用来配置生产者重试的次数，默认值为 0，即在发生异常的时候不进行任何重试动作。消息在从生产者发出到成功写入服务器之前可能发生一些临时性的异常，比如网络抖动、leader 副本的选举等，这种异常往往是可以自行恢复的，生产者可以通过配置 retries 大于 0 的值，以此通过内部重试来恢复而不是一味地将异常抛给生产者的应用程序。如果重试达到设定的次数，那么生产者就会放弃重试并返回异常。不过<strong>并不是所有的异常都是可以通过重试来解决的，比如消息太大，超过 <code>max.request.size</code> 参数配置的值时，这种方式就不可行了</strong>。重试还和另一个参数 <code>retry.backoff.ms</code> 有关，这个参数的默认值为 100，它用来设定两次重试之间的时间间隔，避免无效的频繁重试。在配置 <code>retries</code> 和 <code>retry.backoff.ms</code> 之前，最好先估算一下可能的异常恢复时间，这样可以设定总的重试时间大于这个异常恢复时间，以此来避免生产者过早地放弃重试。</p>
<p>Kafka 可以保证同一个分区中的消息是有序的。如果生产者按照一定的顺序发送消息，那么这些消息也会顺序地写入分区，进而消费者也可以按照同样的顺序消费它们。对于某些应用来说，顺序性非常重要，比如 MySQL 的 binlog 传输，如果出现错误就会造成非常严重的后果。如果将 acks 参数配置为非零值，并且 <code>max.in.fight.requests.per.connection</code> 参数配置为大于 1 的值，那么就会出现错序的现象：<strong>如果第一批次消息写入失败，而第二批次消息写入成功，那么生产者会重试发送第一批次的消息，此时如果第一批次的消息写入成功，那么这两个批次的消息就出现了错序。</strong>一般而言，在需要保证消息顺序的场合建议把参数 <code>max.in.fight.requests.per.connection</code> 配置为1，而不是把 acks 配置为 0，不过这样也会影响整体的吞吐。</p>
<h3 id="compression-type"><a href="#compression-type" class="headerlink" title="compression.type"></a>compression.type</h3><p>这个参数用来指定消息的压缩方式，默认值为“none”，即默认情况下，消息不会被压缩。该参数还可以配置为“gzip”“snappy”和“lz4”。对消息进行压缩可以极大地减少网络传输量、降低网络I/O，从而提高整体的性能。消息压缩是一种使用时间换空间的优化方式，如果对时延有一定的要求，则不推荐对消息进行压缩。</p>
<h3 id="connections-max-idle-ms"><a href="#connections-max-idle-ms" class="headerlink" title="connections.max.idle.ms"></a>connections.max.idle.ms</h3><p>这个参数用来指定在多久之后关闭限制的连接，默认值是540000（ms），即9分钟。</p>
<h3 id="linger-ms"><a href="#linger-ms" class="headerlink" title="linger.ms"></a>linger.ms</h3><p>这个参数用来指定生产者发送 ProducerBatch 之前等待更多消息（ProducerRecord）加入ProducerBatch 的时间，默认值为 0。生产者客户端会在 ProducerBatch 被填满或等待时间超过 <code>linger.ms</code> 值时发送出去。增大这个参数的值会增加消息的延迟，但是同时能提升一定的吞吐量。这个 <code>linger.ms</code> 参数与 TCP 协议中的 Nagle 算法有异曲同工之妙。</p>
<h3 id="receive-buffer-bytes"><a href="#receive-buffer-bytes" class="headerlink" title="receive.buffer.bytes"></a>receive.buffer.bytes</h3><p>这个参数用来设置 Socket 接收消息缓冲区（SO_RECBUF）的大小，默认值为32768（B），即32KB。如果设置为-1，则使用操作系统的默认值。如果 Producer 与 Kafka 处于不同的机房，则可以适地调大这个参数值。</p>
<h3 id="send-buffer-bytes"><a href="#send-buffer-bytes" class="headerlink" title="send.buffer.bytes"></a>send.buffer.bytes</h3><p>这个参数用来设置 Socket 发送消息缓冲区（SO_SNDBUF）的大小，默认值为131072（B），即128KB。与 <code>receive.buffer.bytes</code> 参数一样，如果设置为-1，则使用操作系统的默认值。</p>
<h3 id="request-timeout-ms"><a href="#request-timeout-ms" class="headerlink" title="request.timeout.ms"></a>request.timeout.ms</h3><p>这个参数用来配置 Producer 等待请求响应的最长时间，默认值为30000（ms）。请求超时之后可以选择进行重试。注意这个参数需要比 broker 端参数 <code>replica.lag.time.max.ms</code> 的值要大，这样可以减少因客户端重试而引起的消息重复的概率。</p>
<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费者与消费组"><a href="#消费者与消费组" class="headerlink" title="消费者与消费组"></a>消费者与消费组</h2><p>消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。</p>
<p>如下图所示，某个主题中共有4个分区（Partition）：P0、P1、P2、P3。有两个消费组 A 和 B 都订阅了这个主题，消费组 A 中有 4 个消费者（C0、C1、C2和C3），消费组 B 中有2个消费者（C4 和 C5）。按照 Kafka 默认的规则，最后的分配结果是消费组 A 中的每一个消费者分配到 1 个分区，消费组 B 中的每一个消费者分配到 2 个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，<strong>每一个分区只能被一个消费组中的一个消费者所消费</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-1.png" alt="消费者与消费者组-1"></p>
<p>再看一下消费组内的消费者个数变化时所对应的分区分配的演变。假设目前某消费组内只有一个消费者 C0，订阅了一个主题，这个主题包含 7 个分区：P0、P1、P2、P3、P4、P5、P6。也就是说，这个消费者 C0 订阅了 7 个分区，具体分配情形下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-2.png" alt="消费者与消费者组-2"></p>
<p>此时消费组内又加入了一个新的消费者 C1，按照既定的逻辑，需要将原来消费者 C0 的部分分区分配给消费者 C1 消费，如图所示。消费者 C0 和 C1 各自负责消费所分配到的分区，彼此之间并无逻辑上的干扰：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-3.png" alt="消费者与消费者组-3"></p>
<p>紧接着消费组内又加入了一个新的消费者 C2，消费者 C0、C1 和 C2 按照下图中的方式各自负责消费所分配到的分区：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-4.png" alt="消费者与消费者组-4"></p>
<p>消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，可以增加（或减少）消费者的个数来提高（或降低）整体的消费能力。对于分区数固定的情况，一味地增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。参考下图，一共有8个消费者，7个分区，那么最后的消费者 C7 由于分配不到任何分区而无法消费任何消息：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-5.png" alt="消费者与消费者组-5"></p>
<p>以上分配逻辑都是基于默认的分区分配策略进行分析的，可以通过消费者客户端参数 <code>partition.assignment.strategy</code> 来设置消费者与订阅主题之间的分区分配策略。</p>
<p>对于消息中间件而言，一般有两种消息投递模式：点对点（P2P，Point-to-Point）模式和发布/订阅（Pub/Sub）模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（Topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。<strong>Kafka 同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合</strong>：</p>
<ul>
<li><p>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</p>
</li>
<li><p>如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。</p>
</li>
</ul>
<p>消费组是一个逻辑上的概念，它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，这个可以通过消费者客户端参数 <code>group.id</code> 来配置，默认值为空字符串。</p>
<p>消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个线程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一台机器上，也可以部署在不同的机器上。</p>
<p>一个正常的消费逻辑需要具备以下几个步骤：</p>
<ul>
<li>（1）配置消费者客户端参数及创建相应的消费者实例。</li>
<li>（2）订阅主题。</li>
<li>（3）拉取消息并消费。</li>
<li>（4）提交消费位移。</li>
<li>（5）关闭消费者实例。</li>
</ul>
<h2 id="消费者客户端相关参数"><a href="#消费者客户端相关参数" class="headerlink" title="消费者客户端相关参数"></a>消费者客户端相关参数</h2><ul>
<li><p><code>bootstrap.servers</code>：该参数的释义和生产者客户端 KafkaProducer 中的相同，用来指定连接 Kafka 集群所需的 broker 地址清单，具体内容形式为 <code>host1：port1</code>，<code>host2：post</code>，可以设置一个或多个地址，中间用逗号隔开，此参数的默认值为“”。注意这里并非需要设置集群中全部的 broker 地址，<strong>消费者会从现有的配置中查找到全部的Kafka集群成员</strong>。这里设置两个以上的 broker 地址信息，当其中任意一个宕机时，消费者仍然可以连接到 Kafka 集群上。</p>
</li>
<li><p><code>group.id</code>：消费者隶属的消费组的名称，默认值为“”。如果设置为空，则会报出异常：<code>Exception in thread &quot;main&quot;org.apache.kafka.common.errors.InvalidGroupIdException：The configuredgroupId is invalid</code>。一般而言，这个参数需要设置成具有一定的业务意义的名称。</p>
</li>
<li><p><code>key.deserializer</code> 和 <code>value.deserializer</code>：与生产者客户端 KafkaProducer 中的 <code>key.serializer</code> 和 <code>value.serializer</code> 参数对应。消费者从 broker 端获取的消息格式都是字节数组（byte[]）类型，所以需要执行相应的反序列化操作才能还原成原有的对象格式。这两个参数分别用来指定消息中 key 和 value 所需反序列化操作的反序列化器，这两个参数无默认值。</p>
</li>
<li><p><code>client.id</code>：这个参数用来设定 KafkaConsumer 对应的客户端 id，默认值也为“”。如果客户端不设置，则 KafkaConsumer 会自动生成一个非空字符串，内容形式如“consumer-1”“consumer-2”，即字符串“consumer-”与数字的拼接。</p>
</li>
</ul>
<h2 id="订阅主题和分区"><a href="#订阅主题和分区" class="headerlink" title="订阅主题和分区"></a>订阅主题和分区</h2><p>通过使用 <code>subscribe（）</code> 方法可以订阅了一个主题，对于这个方法而言，既可以以集合的形式订阅多个主题，也可以以正则表达式的形式订阅特定模式的主题。</p>
<p>如果消费者采用的是正则表达式的方式（subscribe（Pattern））订阅，在之后的过程中，如果有人又创建了新的主题，并且主题的名字与正则表达式相匹配，那么这个消费者就可以消费到新添加的主题中的消息。如果应用程序需要消费多个主题，并且可以处理不同的类型，那么这种订阅方式就很有效。<strong>在 Kafka 和其他系统之间进行数据复制时，这种正则表达式的方式就显得很常见</strong>。</p>
<p>消费者不仅可以通过 <code>subscribe（）</code>方法订阅主题，还可以直接订阅某些主题的特定分区，在 KafkaConsumer 中还提供了一个 <code>assign（）</code> 方法来实现这些功能。</p>
<p>这个方法只接受一个参数 <code>partitions</code>，用来指定需要订阅的分区集合。</p>
<p>如果事先并不知道主题中有多少个分区，还可以通过 <code>partitionsFor（）</code> 方法来查询指定主题的元数据信息。</p>
<p>元数据信息中的属性 <code>topic</code> 表示主题名称，<code>partition</code> 代表分区编号，<code>leader</code> 代表分区的 <code>leader</code> 副本所在的位置，<code>replicas</code> 代表分区的AR集合，<code>inSyncReplicas</code> 代表分区的 ISR 集合，<code>offineReplicas</code> 代表分区的 <code>OSR</code> 集合。通过<code>partitionFor（）</code>方法的协助，可以通过 <code>assign（）</code>方法来实现订阅主题（全部分区）的功能。</p>
<p>如果需要取消订阅，可以通过 <code>subscribe（Collection）</code>方式实现的订阅，也可以取消通过 <code>subscribe（Pattern）</code> 方式实现的订阅，还可以取消通过 <code>assign（Collection）</code> 方式实现的订阅。</p>
<p>如果将 <code>subscribe（Collection）</code> 或 <code>assign（Collection）</code> 中的集合参数设置为空集合，那么作用等同于 <code>unsubscribe（）</code> 方法。</p>
<p>如果没有订阅任何主题或分区，那么再继续执行消费程序的时候会报异常。</p>
<p>集合订阅的方式 <code>subscribe（Collection）</code>、正则表达式订阅的方式 <code>subscribe（Pattern）</code> 和指定分区的订阅方式 <code>assign（Collection）</code> 分表代表了三种不同的订阅状态：<code>AUTO_TOPICS</code>、<code>AUTO_PATTERN</code> 和 <code>USER_ASSIGNED</code>（如果没有订阅，那么订阅状态为 <code>NONE</code>）。然而这三种状态是互斥的，在一个消费者中只能使用其中的一种，否则会报出异常。</p>
<p>通过 <code>subscribe（）</code> 方法订阅主题具有消费者自动再均衡的功能，在多个消费者的情况下可以根据分区分配策略来自动分配各个消费者与分区的关系。当消费组内的消费者增加或减少时，分区分配关系会自动调整，以实现消费负载均衡及故障自动转移。而通过 <code>assign（）</code> 方法订阅分区时，是不具备消费者自动均衡的功能的。</p>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p><strong>Kafka 中的消费是基于拉模式的</strong>。消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。</p>
<p>Kafka 中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用 <code>poll（）</code> 方法，而 <code>poll（）</code> 方法返回的是所订阅的主题（分区）上的一组消息。</p>
<p>对于 <code>poll（）</code> 方法而言，如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空；如果订阅的所有分区中都没有可供消费的消息，那么 <code>poll（）</code> 方法返回为空的消息集合。</p>
<p><code>poll（）</code> 方法里还有一个超时时间参数timeout，用来控制poll（）方法的阻塞时间，在消费者的缓冲区里没有可用数据时会发生阻塞。<code>timeout</code> 的设置取决于应用程序对响应速度的要求，比如需要在多长时间内将控制权移交给执行轮询的应用线程。可以直接将 <code>timeout</code> 设置为 0，这样 <code>poll（）</code> 方法会立刻返回，而不管是否已经拉取到了消息。<strong>如果应用线程唯一的工作就是从Kafka中拉取并消费消息，则可以将这个参数设置为最大值 <code>Long.MAX_VALUE</code></strong>。</p>
<p>消费者消费到的每条消息的类型为 <code>ConsumerRecord</code>,它具有以下字段信息：</p>
<ul>
<li><code>topic</code> 和 <code>partition</code> 这两个字段分别代表消息所属主题的名称和所在分区的编号。</li>
<li><code>offset</code> 表示消息在所属分区的偏移量。</li>
<li><code>timestamp</code> 表示时间戳，与此对应的 <code>timestampType</code> 表示时间戳的类型。<code>timestampType</code> 有两种类型： <code>CreateTime</code> 和 <code>LogAppendTime</code>，分别代表消息创建的时间戳和消息追加到日志的时间戳。</li>
<li><code>headers</code> 表示消息的头部内容。</li>
<li><code>key</code> 和 <code>value</code> 分别表示消息的键和消息的值，一般业务应用要读取的就是 value。</li>
<li><code>checksum</code> 是 CRC32 的校验值。</li>
</ul>
<p><code>poll（）</code> 方法的返回值类型是 <code>ConsumerRecords</code>，它用来表示一次拉取操作所获得的消息集，内部包含了若干 <code>ConsumerRecord</code>。</p>
<p><code>ConsumerRecords</code> 类提供了一个 <code>records（TopicPartition）</code> 方法来获取消息集中指定分区的消息。</p>
<p>到目前为止，可以简单地认为 <code>poll（）</code> 方法只是拉取一下消息而已，但就其内部逻辑而言并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容。</p>
<h2 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h2><p>对于 Kafka 中的分区而言，它的每条消息都有唯一的 offset，用来表示消息在分区中对应的位置。对于消费者而言，它也有一个 offset 的概念，消费者使用 offset 来表示消费到分区中某个消息所在的位置。</p>
<p>在每次调用 <code>poll（）</code> 方法时，它返回的是还没有被消费过的消息集（当然这个前提是消息已经存储在Kafka 中了，并且暂不考虑异常情况的发生），要做到这一点，就需要记录上一次消费时的消费位移。并且这个消费位移必须做持久化保存，而不是单单保存在内存中，否则消费者重启之后就无法知晓之前的消费位移。再考虑一种情况，当有新的消费者加入时，那么必然会有再均衡的动作，对于同一分区而言，它可能在再均衡动作之后分配给新的消费者，如果不持久化保存消费位移，那么这个新的消费者也无法知晓之前的消费位移。</p>
<p>在旧消费者客户端中，消费位移是存储在 ZooKeeper 中的。而在新消费者客户端中，消费位移存储在 Kafka 内部的主题 <code>__consumer_offsets</code> 中。这里把将消费位移存储起来（持久化）的动作称为“提交”，消费者在消费完消息之后需要执行消费位移的提交。</p>
<p>如下图的消费位移，x 表示某一次拉取操作中此分区消息的最大偏移量，假设当前消费者已经消费了 x 位置的消息，那么就可以说消费者的<strong>消费位移为 x</strong>，图中也用了 <code>lastConsumedOffset</code> 这个单词来标识它。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4-1.png" alt="kafka 位移提交-1"></p>
<p>不过需要非常明确的是，<strong>当前消费者需要提交的消费位移并不是 x，而是 x+1</strong>，对应于图中的 <code>position</code>，它表示下一条需要拉取的消息的位置。在消费者中还有一个 <code>committed offset</code> 的概念，它表示已经提交过的消费位移。</p>
<p>KafkaConsumer 类提供了 <code>position（TopicPartition）</code>和 <code>committed（TopicPartition）</code> 两个方法来分别获取上面所说的 <code>position</code> 和 <code>committed offset</code> 的值。</p>
<p>对于位移提交的具体时机的把握也很有讲究，有可能会造成重复消费和消息丢失的现象。如下图所示，当前一次 <code>poll（）</code> 操作所拉取的消息集为 <code>[x+2，x+7]</code>，<code>x+2</code> 代表上一次提交的消费位移，说明已经完成了 <code>x+1</code> 及之前的所有消息的消费，<code>x+5</code> 表示当前正在处理的位置。<strong>如果拉取到消息之后就进行了位移提交</strong>，即提交了 <code>x+8</code>，那么当前消费 <code>x+5</code> 的时候遇到了异常，在故障恢复之后，重新拉取的消息是从 <code>x+8</code> 开始的。也就是说，<code>x+5</code> 至 <code>x+7</code> 之间的消息并未能被消费，如此便发生了消息丢失的现象。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4-2.png" alt="kafka 位移提交-2"></p>
<p>再考虑另外一种情形，<strong>位移提交的动作是在消费完所有拉取到的消息之后才执行的</strong>，那么当消费 <code>x+5</code> 的时候遇到了异常，在故障恢复之后，重新拉取的消息是从 <code>x+2</code> 开始的。也就是说，<code>x+2</code> 至 <code>x+4</code> 之间的消息又重新消费了一遍，故而又发生了重复消费的现象。</p>
<p>而实际情况还会有比这两种更加复杂的情形，比如第一次的位移提交的位置为 <code>x+8</code>，而下一次的位移提交的位置为 <code>x+4</code>。</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>在 Kafka 中默认的消费位移的提交方式是自动提交，这个由消费者客户端参数 <code>enable.auto.commit</code> 配置，默认值为 true。当然这个默认的自动提交不是每消费一条消息就提交一次，而是定期提交，这个定期的周期时间由客户端参数 <code>auto.commit.interval.ms</code> 配置，默认值为5秒，此参数生效的前提是 <code>enable.auto.commit</code> 参数为true。</p>
<p><strong>在默认的方式下，消费者每隔 5 秒会将拉取到的每个分区中最大的消息位移进行提交。自动位移提交的动作是在poll（）方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移</strong>。</p>
<p>在 Kafka 消费的编程逻辑中位移提交是一大难点，自动提交消费位移的方式非常简便，它免去了复杂的位移提交逻辑，让编码更简洁。但随之而来的是重复消费和消息丢失的问题。假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动提交消费位移之前，消费者崩溃了，那么又得从上一次位移提交的地方重新开始消费，这样便发生了重复消费的现象（对于再均衡的情况同样适用）。<strong>可以通过减小位移提交的时间间隔来减小重复消息的窗口大小，但这样并不能避免重复消费的发送，而且也会使位移提交更加频繁</strong>。</p>
<p>按照一般思维逻辑而言，自动提交是延时提交，重复消费可以理解，那么消息丢失又是在什么情形下会发生的呢？看一下下图中的情形。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4.png" alt="kafka 自动提交"></p>
<p>拉取线程A不断地拉取消息并存入本地缓存，另一个处理线程 B 从缓存中读取消息并进行相应的逻辑处理。假设目前进行到了第 y+1 次拉取，以及第 m 次位移提交的时候，也就是 x+6 之前的位移已经确认提交了，处理线程 B 却还正在消费 x+3 的消息。此时如果处理线程 B 发生了异常，待其恢复之后会从第 m 此位移提交处，也就是 x+6 的位置开始拉取消息，那么 x+3 至 x+6 之间的消息就没有得到相应的处理，这样便发生消息丢失的现象。</p>
<p>自动位移提交的方式在正常情况下不会发生消息丢失或重复消费的现象，但是在编程的世界里异常无可避免，与此同时，自动位移提交也无法做到精确的位移管理。在 Kafka 中还提供了手动位移提交的方式，这样可以使得开发人员对消费位移的管理控制更加灵活。很多时候并不是说拉取到消息就算消费完成，而是需要将消息写入数据库、写入本地缓存，或者是更加复杂的业务处理。在这些场景下，所有的业务处理完成才能认为消息被成功消费，手动的提交方式可以让开发人员根据程序的逻辑在合适的地方进行位移提交。开启手动提交功能的前提是消费者客户端参数 <code>enable.auto.commit</code> 配置为false。</p>
<h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p>手动提交可以细分为同步提交和异步提交，对应于 KafkaConsumer 中的 <code>commitSync（）</code> 和 <code>commitAsync（）</code> 两种类型的方法。</p>
<h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><p><code>commitSync（）</code> 方法会根据 <code>poll（）</code> 方法拉取的最新位移来进行提交（注意提交的值对应于前面图中 position 的位置），只要没有发生不可恢复的错误（Unrecoverable Error），它就会阻塞消费者线程直至位移提交完成。</p>
<p>对于采用 <code>commitSync（）</code> 的无参方法而言，它提交消费位移的频率和拉取批次消息、处理批次消息的频率是一样的，如果想寻求更细粒度的、更精准的提交，那么就需要使用 <code>commitSync（）</code> 的另一个含参方法，该方法提供了一个 <code>offsets</code> 参数，用来提交指定分区的位移。无参的 <code>commitSync（）</code> 方法只能提交当前批次对应的 position 值。如果需要提交一个中间值，比如业务每消费一条消息就提交一次位移，那么就可以使用这种方式。</p>
<h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>与 <code>commitSync（）</code> 方法相反，异步提交的方式（<code>commitAsync（）</code>）在执行的时候消费者线程不会被阻塞，可能在提交消费位移的结果还未返回之前就开始了新一次的拉取操作。异步提交可以使消费者的性能得到一定的增强。</p>
<p><code>commitAsync</code> 提供了一个可选的 <code>callback</code> 参数，用来提供一个异步提交的回调方法，当位移提交完成后会回调 <code>OffsetCommitCallback</code> 中的 <code>onComplete（）</code> 方法。</p>
<p><code>commitAsync（）</code>提交的时候同样会有失败的情况发生，那么应该怎么处理呢？有可能想到的是重试，问题的关键也就在这里了。如果某一次异步提交的消费位移为 x，但是提交失败了，然后下一次又异步提交了消费位移为 x+y，这次成功了。如果这里引入了重试机制，前一次的异步提交的消费位移在重试的时候提交成功了，那么此时的消费位移又变为了 x。如果此时发生异常（或者再均衡），那么恢复之后的消费者（或者新的消费者）就会从 x 处开始消费消息，这样就发生了重复消费的问题。</p>
<p>为此可以设置一个递增的序号来维护异步提交的顺序，每次位移提交之后就增加序号相对应的值。在遇到位移提交失败需要重试的时候，可以检查所提交的位移和序号的值的大小，如果前者小于后者，则说明有更大的位移已经提交了，不需要再进行本次重试；如果两者相同，则说明可以进行重试提交。除非程序编码错误，否则不会出现前者大于后者的情况。</p>
<p>如果位移提交失败的情况经常发生，那么说明系统肯定出现了故障，在一般情况下，位移提交失败的情况很少发生，不重试也没有关系，后面的提交也会有成功的。重试会增加代码逻辑的复杂度，不重试会增加重复消费的概率。如果消费者异常退出，那么这个重复消费的问题就很难避免，因为这种情况下无法及时提交消费位移；<strong>如果消费者正常退出或发生再均衡的情况，那么可以在退出或再均衡执行之前使用同步提交的方式做最后的把关</strong>。</p>
<h2 id="控制和关闭消费"><a href="#控制和关闭消费" class="headerlink" title="控制和关闭消费"></a>控制和关闭消费</h2><p>KafkaConsumer 提供了对消费速度进行控制的方法，在有些应用场景下可能需要暂停某些分区的消费而先消费其他分区，当达到一定条件时再恢复这些分区的消费。KafkaConsumer 中使用 <code>pause（）</code>和 <code>resume（）</code> 方法来分别实现暂停某些分区在拉取操作时返回数据给客户端和恢复某些分区向客户端返回数据的操作。另外，还提供了一个无参的 <code>paused（）</code> 方法来返回被暂停的分区集合。</p>
<h2 id="指定位移消费"><a href="#指定位移消费" class="headerlink" title="指定位移消费"></a>指定位移消费</h2><p>一个新的消费组建立的时候，它根本没有可以查找的消费位移。或者消费组内的一个新消费者订阅了一个新的主题，它也没有可以查找的消费位移。当 <code>__consumer_offsets</code> 主题中有关这个消费组的位移信息过期而被删除后，它也没有可以查找的消费位移。</p>
<p>在 Kafka 中每当消费者查找不到所记录的消费位移时，就会根据消费者客户端参数 <code>auto.offset.reset</code> 的配置来决定从何处开始进行消费，这个参数的默认值为“latest”，表示从分区末尾开始消费消息。参考下图，按照默认的配置，消费者会从 9 开始进行消费（9 是下一条要写入消息的位置），更加确切地说是从 9 开始拉取消息。如果将 <code>auto.offset.reset</code> 参数配置为 “earliest”，那么消费者会从起始处，也就是 0 开始消费。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4.png" alt="kafka 指定位移提交"></p>
<p>除了查找不到消费位移，位移越界也会触发 <code>auto.offset.reset</code> 参数的执行。</p>
<p><code>auto.offset.reset</code> 参数还有一个可配置的值—“none”，配置为此值就意味着出现查到不到消费位移的时候，既不从最新的消息位置处开始消费，也不从最早的消息位置处开始消费，此时会报出异常。</p>
<p>到目前为止，可以知道消息的拉取是根据 <code>poll（）</code> 方法中的逻辑来处理的，这个 <code>poll（）</code> 方法中的逻辑对于普通的开发人员而言是一个黑盒，无法精确地掌控其消费的起始位置。提供的 <code>auto.offset.reset</code> 参数也只能在找不到消费位移或位移越界的情况下粗粒度地从开头或末尾开始消费。有些时候，需要一种更细粒度的掌控，可以从特定的位移处开始拉取消息，而 KafkaConsumer 中的 <code>seek（）</code> 方法正好提供了这个功能，让我们得以追前消费或回溯消费。</p>
<p><code>seek（）</code> 方法中的参数 <code>partition</code> 表示分区，而 <code>offset</code> 参数用来指定从分区的哪个位置开始消费。<code>seek（）</code> 方法只能重置消费者分配到的分区的消费位置，而<strong>分区的分配是在 <code>poll（）</code> 方法的调用过程中实现的</strong>。也就是说，<strong>在执行 <code>seek（）</code> 方法之前需要先执行一次 <code>poll（）</code> 方法，等到分配到分区之后才可以重置消费位置</strong>。在调用 <code>poll()</code> 方法后，可以通过 KafkaConsumer 的 <code>assignment（）</code> 方法来判定是否分配到了相应的分区。</p>
<p>如果对未分配到的分区执行 <code>seek（）</code> 方法，那么会报出异常。</p>
<p>KafkaConsumer 中还提供了 <code>seekToBeginning（）</code> 方法和 <code>seekToEnd（）</code> 方法来实现从分区的开头或末尾开始消费。</p>
<p>有时候我们并不知道特定的消费位置，却知道一个相关的时间点，比如想要消费昨天 8 点之后的消息，这个需求更符合正常的思维逻辑。此时无法直接使用 <code>seek（）</code> 方法来追溯到相应的位置。KafkaConsumer 同样考虑到了这种情况，它提供了一个 <code>offsetsForTimes（）</code> 方法，通过 timestamp 来查询与此对应的分区位置。</p>
<p>前面提到了 Kafka 中的消费位移是存储在一个内部主题中的，而 <code>seek（）</code> 方法可以突破这一限制：消费位移可以保存在任意的存储介质中，例如数据库、文件系统等。以数据库为例，将消费位移保存在其中的一个表中，在下次消费的时候可以读取存储在数据表中的消费位移并通过 <code>seek（）</code> 方法指向这个具体的位置。</p>
<p><code>seek（）</code> 方法提供了从特定位置读取消息的能力，可以通过这个方法来向前跳过若干消息，也可以通过这个方法来向后回溯若干消息，这样为消息的消费提供了很大的灵活性。<code>seek（）</code> 方法也为提供了将消费位移保存在外部存储介质中的能力，还可以配合再均衡监听器来提供更加精准的消费能力。</p>
<h2 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h2><p>再均衡是指分区的所属权从一个消费者转移到另一消费者的行为，它为消费组具备高可用性和伸缩性提供保障，可以既方便又安全地删除消费组内的消费者或往消费组内添加消费者。不过在再均衡发生期间，消费组内的消费者是无法读取消息的。也就是说，<strong>在再均衡发生期间的这一小段时间内，消费组会变得不可用</strong>。另外，当一个分区被重新分配给另一个消费者时，消费者当前的状态也会丢失。比如消费者消费完某个分区中的一部分消息时还没有来得及提交消费位移就发生了再均衡操作，之后这个分区又被分配给了消费组内的另一个消费者，原来被消费完的那部分消息又被重新消费一遍，也就是发生了重复消费。一般情况下，应尽量避免不必要的再均衡的发生。</p>
<p>在消费者订阅的时候，提供了再均衡监听器，用来设定发生再均衡动作前后的一些准备或收尾的动作。<code>onPartitionsRevoked</code> 这个方法会在再均衡开始之前和消费者停止读取消息之后被调用，可以通过这个回调方法来处理消费位移的提交，以此来避免一些不必要的重复消费现象的发生。<code>onPartitionsAssigned</code> 这个方法会在重新分配分区之后和消费者开始读取消费之前被调用。</p>
<h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><p>KafkaProducer 是线程安全的，然而 KafkaConsumer 却是非线程安全的。KafkaConsumer 中定义了一个 <code>acquire（)</code> 方法，用来检测当前是否只有一个线程在操作，若有其他线程正在操作则会抛出异常。</p>
<p>KafkaConsumer 中的每个公用方法在执行所要执行的动作之前都会调用这个 <code>acquire（）</code> 方法，只有 <code>wakeup（）</code> 方法是个例外。</p>
<p><code>acquire（）</code> 方法和通常所说的锁（synchronized、Lock等）不同，它不会造成阻塞等待，可以将其看作一个轻量级锁，它仅通过线程操作计数标记的方式来检测线程是否发生了并发操作，以此保证只有一个线程在操作。<code>acquire（）</code>方法和<code>release（）</code> 方法成对出现，表示相应的加锁和解锁操作。</p>
<p><code>cquire（）</code> 方法和 <code>release（）</code> 方法都是私有方法，因此在实际应用中不需要显式地调用，但了解其内部的机理之后可以促使正确、有效地编写相应的程序逻辑。</p>
<p>KafkaConsumer 非线程安全并不意味着在消费消息的时候只能以单线程的方式执行。如果生产者发送消息的速度大于消费者处理消息的速度，那么就会有越来越多的消息得不到及时的消费，造成了一定的延迟。除此之外，由于 Kafka 中消息保留机制的作用，有些消息有可能在被消费之前就被清理了，从而造成消息的丢失。</p>
<p>可以通过多线程的方式来实现消息消费，多线程的目的就是为了提高整体的消费能力。</p>
<p>多线程的实现方式有多种，</p>
<ul>
<li>第一种也是最常见的方式：线程封闭，即为每个线程实例化一个 KafkaConsumer 对象。</li>
</ul>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-1.png" alt="kafka消费者多线程实现-1"></p>
<p>一个线程对应一个 KafkaConsumer 实例，可以称之为消费线程。一个消费线程可以消费一个或多个分区中的消息，所有的消费线程都隶属于同一个消费组。这种实现方式的并发度受限于分区的实际个数，当消费线程的个数大于分区数时，就有部分消费线程一直处于空闲的状态。</p>
<ul>
<li>多线程消费同一分区</li>
</ul>
<p>与此对应的第二种方式是多个消费线程同时消费同一个分区，这个通过 <code>assign（）</code>、<code>seek（）</code> 等方法实现，这样可以打破原有的消费线程的个数不能超过分区数的限制，进一步提高了消费的能力。不过这种实现方式对于位移提交和顺序控制的处理就会变得非常复杂，实际应用中使用得极少，也并不推荐。一般而言，分区是消费线程的最小划分单位。</p>
<p>上面所说的第一种这种多线程的实现方式和开启多个消费进程的方式没有本质上的区别，它的优点是每个线程可以按顺序消费各个分区中的消息。缺点也很明显，每个消费线程都要维护一个独立的 TCP 连接，如果分区数和 <code>consumerThreadNum</code> 的值都很大，那么会造成不小的系统开销。</p>
<ul>
<li>将处理消息模块改成多线程的实现方式</li>
</ul>
<p>当每次拉去到消息后，如果这里对消息的处理非常迅速，那么 <code>poll（）</code> 拉取的频次也会更高，进而整体消费的性能也会提升；相反，如果对消息的处理缓慢，比如进行一个事务性操作，或者等待一个RPC的同步响应，那么 <code>poll（）</code> 拉取的频次也会随之下降，进而造成整体消费性能的下降。一般而言，<code>poll（）</code> 拉取消息的速度是相当快的，而整体消费的瓶颈也正是在处理消息这一块，如果通过一定的方式来改进这一部分，那么就能带动整体消费性能的提升。因此有了第三种实现方式。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-2.png" alt="kafka消费者多线程实现-2"></p>
<p>第三种实现方式相比第一种实现方式而言，除了横向扩展的能力，还可以减少TCP连接对系统资源的消耗，不过缺点就是对于消息的顺序处理就比较困难了，在具体实现的时候还需要考虑位移提交的情况。对于第一种实现方式而言，如果要做具体的位移提交，直接实现即可。而对于第三种实现方式，这里引入一个共享变量 <code>offsets</code> 来参与提交。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-3.png" alt="kafka消费者多线程实现-3"></p>
<p>每一个处理消息的 RecordHandler 类在处理完消息之后都将对应的消费位移保存到共享变量 <code>offsets</code> 中，KafkaConsumerThread 在每一次 <code>poll（）</code> 方法之后都读取 <code>offsets</code> 中的内容并对其进行位移提交。注意在实现的过程中对 <code>offsets</code> 读写需要加锁处理，防止出现并发问题。</p>
<p>但是在写入 <code>offsets</code> 的时候需要注意位移覆盖的问题。对于同一个分区中的消息，假设一个处理线程RecordHandler1 正在处理 <code>offset</code> 为 0～99 的消息，而另一个处理线程 RecordHandler2 已经处理完了 <code>offset</code> 为100～199 的消息并进行了位移提交，此时如果 RecordHandler1 发生异常，则之后的消费只能从 200 开始而无法再次消费 0～99 的消息，从而造成了消息丢失的现象。对此就要引入更加复杂的处理机制，这里提供一种解决思路，参考下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-4.png" alt="kafka消费者多线程实现-4"></p>
<p>总体结构上是基于滑动窗口实现的。对于第三种实现方式而言，它所呈现的结构是通过消费者拉取分批次的消息，然后提交给多线程进行处理，而这里的滑动窗口式的实现方式是将拉取到的消息暂存起来，多个消费线程可以拉取暂存的消息，这个用于暂存消息的缓存大小即为滑动窗口的大小，总体上而言没有太多的变化，不同的是对于消费位移的把控。每一个方格代表一个批次的消息，一个滑动窗口包含若干方格，<code>startOffset</code> 标注的是当前滑动窗口的起始位置，<code>endOffset</code> 标注的是末尾位置。每当 <code>startOffset</code> 指向的方格中的消息被消费完成，就可以提交这部分的位移，与此同时，窗口向前滑动一格，删除原来 <code>startOffset</code> 所指方格中对应的消息，并且拉取新的消息进入窗口。滑动窗口的大小固定，所对应的用来暂存消息的缓存大小也就固定了，这部分内存开销可控。方格大小和滑动窗口的大小同时决定了消费线程的并发数：一个方格对应一个消费线程，对于窗口大小固定的情况，方格越小并行度越高；对于方格大小固定的情况，窗口越大并行度越高。不过，若窗口设置得过大，不仅会增大内存的开销，而且在发生异常（比如Crash）的情况下也会引起大量的重复消费，同时还考虑线程切换的开销，建议根据实际情况设置一个合理的值，不管是对于方格还是窗口而言，过大或过小都不合适。</p>
<p>如果一个方格内的消息无法被标记为消费完成，那么就会造成 <code>startOffset</code> 的悬停。为了使窗口能够继续向前滑动，那么就需要设定一个阈值，当 <code>startOffset</code> 悬停一定的时间后就对这部分消息进行本地重试消费，如果重试失败就转入重试队列，如果还不奏效就转入死信队列。真实应用中无法消费的情况极少，一般是由业务代码的处理逻辑引起的，比如消息中的内容格式与业务处理的内容格式不符，无法对这条消息进行决断，这种情况可以通过优化代码逻辑或采取丢弃策略来避免。如果需要消息高度可靠，也可以将无法进行业务逻辑的消息（这类消息可以称为死信）存入磁盘、数据库或 Kafka，然后继续消费下一条消息以保证整体消费进度合理推进，之后可以通过一个额外的处理任务来分析死信进而找出异常的原因。</p>
<h2 id="其他相关参数"><a href="#其他相关参数" class="headerlink" title="其他相关参数"></a>其他相关参数</h2><p>除了上面提到的客户端相关参数，还有一些可选的用于性能调优和故障排除的参数。</p>
<h3 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a>fetch.min.bytes</h3><p>该参数用来配置 Consumer 在一次拉取请求（调用 poll（）方法）中能从 Kafka 中拉取的最小数据量，默认值为 1（B）。Kafka 在收到 Consumer 的拉取请求时，如果返回给 Consumer 的数据量小于这个参数所配置的值，那么它就需要进行等待，直到数据量满足这个参数的配置大小。可以适当调大这个参数的值以提高一定的吞吐量，不过也会造成额外的延迟（latency），对于延迟敏感的应用可能就不可取了。</p>
<h3 id="fetch-max-bytes"><a href="#fetch-max-bytes" class="headerlink" title="fetch.max.bytes"></a>fetch.max.bytes</h3><p>该参数与 <code>fetch.max.bytes</code> 参数对应，它用来配置 Consumer 在一次拉取请求中从 Kafka 中拉取的最大数据量，默认值为 52428800（B），也就是 50 MB。</p>
<p>如果这个参数设置的值比任何一条写入 Kafka 中的消息要小，那么会不会造成无法消费呢？比如一条消息的大小为10B，而这个参数的值是1（B），既然此参数设定的值是一次拉取请求中所能拉取的最大数据量，那么显然 1B＜10B，所以无法拉取。这个观点是错误的，该参数设定的不是绝对的最大值，如果在<strong>第一个非空分区中拉取的第一条消息大于该值，那么该消息将仍然返回，以确保消费者继续工作</strong>。也就是说，上面问题的答案是可以正常消费。与此相关的，Kafka 中所能接收的最大消息的大小通过服务端参数 <code>message.max.bytes</code>（对应于主题端参数 <code>max.message.bytes</code>）来设置。</p>
<h3 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a>fetch.max.wait.ms</h3><p>这个参数也和 <code>fetch.min.bytes</code> 参数有关，如果 Kafka 仅仅参考 <code>fetch.min.bytes</code> 参数的要求，那么有可能会一直阻塞等待而无法发送响应给 Consumer，显然这是不合理的。<code>fetch.max.wait.ms</code> 参数用于指定 Kafka 的等待时间，默认值为500（ms）。如果 Kafka 中没有足够多的消息而满足不了 <code>fetch.min.bytes</code> 参数的要求，那么最终会等待 500ms。这个参数的设定和 Consumer 与 Kafka 之间的延迟也有关系，如果业务应用对延迟敏感，那么可以适当调小这个参数。</p>
<h3 id="max-partition-fetch-bytes"><a href="#max-partition-fetch-bytes" class="headerlink" title="max.partition.fetch.bytes"></a>max.partition.fetch.bytes</h3><p>这个参数用来配置从每个分区里返回给 Consumer 的最大数据量，默认值为 1048576（B），即 1 MB。这个参数与 <code>fetch.max.bytes</code> 参数相似，只不过 <code>max.partition.fetch.bytes</code> 用来限制一次拉取中每个分区的消息大小，而 <code>fetch.max.bytes</code> 用来限制一次拉取中整体消息的大小。同样，如果这个参数设定的值比消息的大小要小，那么也不会造成无法消费，Kafka 为了保持消费逻辑的正常运转不会对此做强硬的限制。</p>
<h3 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h3><p>这个参数用来配置 Consumer 在一次拉取请求中拉取的最大消息数，默认值为 500（条）。如果消息的大小都比较小，则可以适当调大这个参数值来提升一定的消费速度。</p>
<h3 id="connections-max-idle-ms-1"><a href="#connections-max-idle-ms-1" class="headerlink" title="connections.max.idle.ms"></a>connections.max.idle.ms</h3><p>这个参数用来指定在多久之后关闭限制的连接，默认值是 540000（ms），即 9 分钟。</p>
<h3 id="exclude-internal-topics"><a href="#exclude-internal-topics" class="headerlink" title="exclude.internal.topics"></a>exclude.internal.topics</h3><p>Kafka中有两个内部的主题：<code>__consumer_offsets</code> 和 <code>__transaction_state</code>。<code>exclude.internal.topics</code> 用来指定 Kafka 中的内部主题是否可以向消费者公开，默认值为 true。如果设置为 true，那么只能使用 subscribe（Collection）的方式而不能使用 subscribe（Pattern）的方式来订阅内部主题，设置为 false 则没有这个限制。</p>
<h3 id="receive-buffer-bytes-1"><a href="#receive-buffer-bytes-1" class="headerlink" title="receive.buffer.bytes"></a>receive.buffer.bytes</h3><p>这个参数用来设置 Socket 接收消息缓冲区（<code>SO_RECBUF</code>）的大小，默认值为 65536（B），即 64 KB。如果设置为 -1，则使用操作系统的默认值。如果 Consumer 与 Kafka 处于不同的机房，则可以适当调大这个参数值。</p>
<h3 id="send-buffer-bytes-1"><a href="#send-buffer-bytes-1" class="headerlink" title="send.buffer.bytes"></a>send.buffer.bytes</h3><p>这个参数用来设置 Socket 发送消息缓冲区（<code>SO_SNDBUF</code>）的大小，默认值为 131072（B），即 128 KB。与<code>receive.buffer.bytes</code> 参数一样，如果设置为 -1，则使用操作系统的默认值。</p>
<h3 id="request-timeout-ms-1"><a href="#request-timeout-ms-1" class="headerlink" title="request.timeout.ms"></a>request.timeout.ms</h3><p>这个参数用来配置 Consumer 等待请求响应的最长时间，默认值为 30000（ms）。</p>
<h3 id="metadata-max-age-ms"><a href="#metadata-max-age-ms" class="headerlink" title="metadata.max.age.ms"></a>metadata.max.age.ms</h3><p>这个参数用来配置元数据的过期时间，默认值为300000（ms），即 5 分钟。如果元数据在此参数所限定的时间范围内没有进行更新，则会被强制更新，即使没有任何分区变化或有新的 broker 加入。</p>
<h3 id="isolation-level"><a href="#isolation-level" class="headerlink" title="isolation.level"></a>isolation.level</h3><p>这个参数用来配置消费者的事务隔离级别。字符串类型，有效值为“read_uncommitted”和“read_committed”，表示消费者所消费到的位置，如果设置为“read_committed”，那么消费者就会忽略事务未提交的消息，即只能消费到 LSO（LastStableOffset）的位置，默认情况下为“read_uncommitted”，即可以消费到 HW（High Watermark）处的位置。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>主题和分区是Kafka 的两个核心概念，主题作为消息的归类，可以再细分为一个或多个分区，分区也可以看作对消息的二次归类。分区的划分不仅为 Kafka 提供了可伸缩性、水平扩展的功能，还通过多副本机制来为 Kafka 提供数据冗余以提高数据可靠性。从 Kafka 的底层实现来说，主题和分区都是逻辑上的概念，分区可以有一至多个副本，<strong>每个副本对应一个日志文件，每个日志文件对应一至多个日志分段（LogSegment），每个日志分段还可以细分为索引文件、日志存储文件和快照文件等</strong>。</p>
<p>如果 broker 端配置参数 <code>auto.create.topics.enable</code> 设置为true（默认值就是true），那么当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为 <code>num.partitions</code> （默认值为1）、副本因子为 <code>default.replication.factor</code>（默认值为1）的主题。除此之外，当一个消费者开始从未知主题中读取消息时，或者当任意一个客户端向未知主题发送元数据请求时，都会按照配置参数 <code>num.partitions</code> 和 <code>default.replication.factor</code> 的值来创建一个相应的主题。很多时候，这种自动创建主题的行为都是非预期的。除非有特殊应用需求，否则不建议将 <code>auto.create.topics.enable</code> 参数设置为 true，这个参数会增加主题的管理与维护的难度。</p>
<p>更加推荐也更加通用的方式是通过 kafka-topics.sh 脚本来创建主题。</p>
<p>在执行完脚本之后，Kafka会在 log.dir 或 log.dirs 参数所配置的目录下创建相应的主题分区，默认情况下这个目录为 <code>/tmp/kafka-logs/</code>。</p>
<p>主题、分区、副本和 Log（日志）的关系如下图所示，主题和分区都是提供给上层用户的抽象，而在副本层面或更加确切地说是 Log 层面才有实际物理上的存在。同一个分区中的多个副本必须分布在不同的 broker 中，这样才能提供有效的数据冗余。对于示例中的分区数为4、副本因子为2、broker数为3的情况下，按照2、3、3的分区副本个数分配给各个 broker 是最优的选择。再比如在分区数为 3、副本因子为 3，并且 broker 数同样为3的情况下，分配 3、3、3 的分区副本个数给各个 broker 是最优的选择，也就是每个 broker 中都拥有所有分区的一个副本。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E5%88%86%E5%8C%BA-1.png" alt="kafka 分区-1"></p>
<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><h3 id="优先副本的选举"><a href="#优先副本的选举" class="headerlink" title="优先副本的选举"></a>优先副本的选举</h3><p>分区使用多副本机制来提升可靠性，但只有 leader 副本对外提供读写服务，而 follower 副本只负责在内部进行消息的同步。如果一个分区的 leader 副本不可用，那么就意味着整个分区变得不可用，此时就需要 Kafka 从剩余的 follower 副本中挑选一个新的 leader 副本来继续对外提供服务。</p>
<p>虽然不够严谨，但从某种程度上说，broker 节点中 leader 副本个数的多少决定了这个节点负载的高低。在创建主题的时候，该主题的分区及副本会尽可能均匀地分布到 Kafka 集群的各个 broker 节点上，对应的 leader 副本的分配也比较均匀。</p>
<p>在创建主题的时候，该主题的分区及副本会尽可能均匀地分布到 Kafka 集群的各个broker节点上，对应的 leader 副本的分配也比较均匀。比如使用 kafka-topics.sh 脚本创建一个分区数为 3、副本因子为 3 的主题 topic-partitions，创建之后的分布信息如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E5%88%86%E5%8C%BA-2.png" alt="kafka 分区-2"></p>
<p>可以看到 leader 副本均匀分布在 brokerId 为 0、1、2 的 broker 节点之中。针对同一个分区而言，同一个 broker 节点中不可能出现它的多个副本，即 Kafka 集群的一个 broker 中最多只能有它的一个副本，可以将 leader 副本所在的 broker 节点叫作分区的 leader 节点，而 follower 副本所在的 broker 节点叫作分区的 follower 节点。随着时间的更替，Kafka 集群的 broker 节点不可避免地会遇到宕机或崩溃的问题，当分区的 leader 节点发生故障时，其中一个 follower 节点就会成为新的 leader 节点，这样就会导致集群的负载不均衡，从而影响整体的健壮性和稳定性。当原来的 leader 节点恢复之后重新加入集群时，它只能成为一个新的 follower 节点而不再对外提供服务。比如将 brokerId 为 2 的节点重启，那么主题 topic-partitions 新的分布信息如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%88%86%E5%8C%BA-3.png" alt="kafka分区-3"></p>
<p>可以看到原本分区 1 的 leader 节点为 2，现在变成了 0，如此一来原本均衡的负载变成了失衡：节点 0 的负载最高，而节点1的负载最低。为了能够有效地治理负载失衡的情况，Kafka 引入了优先副本（preferredreplica）的概念。所谓的优先副本是指在 AR 集合列表中的第一个副本。比如上面主题 topic-partitions 中分区 0 的AR集合列表（Replicas）为[1，2，0]，那么分区 0 的优先副本即为 1。</p>
<p>理想情况下，优先副本就是该分区的 leader 副本，所以也可以称之为preferred leader。Kafka 要确保所有主题的优先副本在 Kafka 集群中均匀分布，这样就保证了所有分区的 leader 均衡分布。如果 leader 分布过于集中，就会造成集群负载不均衡。所谓的优先副本的选举是指通过一定的方式促使优先副本选举为 leader 副本，以此来促进集群的负载均衡，这一行为也可以称为“分区平衡”。</p>
<p>需要注意的是，分区平衡并不意味着 Kafka 集群的负载均衡，因为还要考虑集群中的分区分配是否均衡。更进一步，每个分区的 leader 副本的负载也是各不相同的，有些 leader 副本的负载很高，比如需要承载 TPS 为 30000 的负荷，而有些 leader 副本只需承载个位数的负荷。也就是说，就算集群中的分区分配均衡、leader 分配均衡，也并不能确保整个集群的负载就是均衡的，还需要其他一些硬性的指标来做进一步的衡量。</p>
<p>在 Kafka 中可以提供分区自动平衡的功能，与此对应的 broker 端参数是 <code>auto.leader.rebalance.enable</code>，此参数的默认值为 true，即默认情况下此功能是开启的。如果开启分区自动平衡的功能，则 Kafka 的控制器会启动一个定时任务，这个定时任务会轮询所有的 broker 节点，计算每个 broker 节点的分区不平衡率（broker 中的不平衡率=非优先副本的 leader 个数/分区总数）是否超过 <code>leader.imbalance.per.broker.percentage</code> 参数配置的比值，默认值为 10%，如果超过设定的比值则会自动执行优先副本的选举动作以求分区平衡。执行周期由参数 <code>leader.imbalance.check.interval.seconds</code> 控制，默认值为 300 秒，即 5 分钟。</p>
<p>不过在生产环境中不建议将 <code>auto.leader.rebalance.enable</code> 设置为默认的true，因为这可能引起负面的性能问题，也有可能引起客户端一定时间的阻塞。因为执行的时间无法自主掌控，如果在关键时期（比如电商大促波峰期）执行关键任务的关卡上执行优先副本的自动选举操作，势必会有业务阻塞、频繁超时之类的风险。前面也分析过，分区及副本的均衡也不能完全确保集群整体的均衡，并且集群中一定程度上的不均衡也是可以忍受的，为防止出现关键时期“掉链子”的行为，建议还是将掌控权把控在自己的手中，可以针对此类相关的埋点指标设置相应的告警，在合适的时机执行合适的操作，而这个“合适的操作”就是指手动执行分区平衡。</p>
<h4 id="手动执行分区平衡"><a href="#手动执行分区平衡" class="headerlink" title="手动执行分区平衡"></a>手动执行分区平衡</h4><p>Kafka中 <code>kafka-perferred-replica-election.sh</code> 脚本提供了对分区 leader 副本进行重新平衡的功能。优先副本的选举过程是一个安全的过程，Kafka 客户端可以自动感知分区 leader 副本的变更。脚本中还提供了 <code>path-to-json-file</code> 参数来小批量地对部分分区执行优先副本的选举操作。通过 <code>path-to-json-file</code> 参数来指定一个 JSON 文件，这个 JSON 文件里保存需要执行优先副本选举的分区清单。</p>
<p>在实际生产环境中，一般使用 <code>path-to-json-file</code> 参数来分批、手动地执行优先副本的选举操作。尤其是在应对大规模的 Kafka 集群时，理应杜绝采用非 <code>path-to-json-file</code> 参数的选举操作方式。同时，优先副本的选举操作也要注意避开业务高峰期，以免带来性能方面的负面影响。</p>
<h1 id="日志存储"><a href="#日志存储" class="headerlink" title="日志存储"></a>日志存储</h1><h2 id="文件目录布局"><a href="#文件目录布局" class="headerlink" title="文件目录布局"></a>文件目录布局</h2><p>Kafka 中的消息是以主题为基本单位进行归类的，各个主题在逻辑上相互独立。每个主题又可以分为一个或多个分区，分区的数量可以在主题创建的时候指定，也可以在之后修改。每条消息在发送的时候会根据分区规则被追加到指定的分区中，分区中的每条消息都会被分配一个唯一的序列号，也就是通常所说的偏移量(offset)。</p>
<p>如果分区规则设置得合理，那么所有的消息可以均匀地分布到不同的分区中，这样就可以实现水平扩展。不考虑多副本的情况，一个分区对应一个日志(Log)。为了防止 Log 过大， Kafka 又引入了<strong>日志分段(LogSegment)</strong>的概念，将 Log 切分为多个 LogSegment，相当于一个巨型文件被平均分配为多个相对较小的文件，这样也便于消息的维护和清理。事实上， Log 和 LogSegnient 也不是纯粹物理意义上的概念， Log 在物理上只以文件夹的形式存储， 而每个 LogSegment 对应于磁盘上的一个日志文件和两个索引文件，以及可能的其他文件（比如以 <code>. txnindex</code> 为后缀的事务索引文件）。下图描绘了主题、分区与副本之间，Log 和 LogSegment 的关系。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="kafka日志存储结构"></p>
<p>向 Log 中追加消息时是顺序写入的，只有最后一个 LogSegment 才能执行写入操作， 在此之前所有的 LogSegment 都不能写入数据。为了方便描述， 将最后一个 LogSegment 称为 <code>activeSegment</code>，即表示当前活跃的日志分段。随着消息的不断写入，当 activeSegment 满足一定的条件时，就需要创建新的 activeSegment，之后追加的消息将写入新的 activeSegment。 为了便于消息的检索， 每个 LogSegment 中的日志文件 （以 <code>.log</code> 为文件后缀）都有对应的两个索引文件：偏移量索引文件（以 <code>.index</code> 为文件后缀）和时间戳索引文件（以 <code>. timeindex</code> 为文件后缀）。每个 LogSegment 都有一个基准偏移量 baseOffset，用来表示当前 LogSegment 中第一条消息的offset。 偏移量是一个 64 位的长整数， 日志文件和两个索引文件都是根据基准偏移量(baseOffset)命名的，名称固定为 20 位数字，没有达到的位数则用0填充。 比如第一个 LogSegment 的基准偏移量为 0, 对应的日志文件为 00000000000000000000.log。</p>
<p>注意每个 LogSegment 中不只包含 <code>.log</code>,<code>.index</code>,<code>.timeindex</code> 这 3 种文件，还可能包含 <code>.deleted</code>,<code>.cleaned</code>,<code>.swap</code> 等临时文件，以及可能的 <code>.snapshot</code>,<code>.txnindex</code>,<code>leader-epoch-checkpoint</code> 等文件。</p>
<h2 id="日志格式的演变"><a href="#日志格式的演变" class="headerlink" title="日志格式的演变"></a>日志格式的演变</h2><p>Kafka 的消息格式经历了 3 个版本：v0 版本，v1 版本和 v2 版本。</p>
<h3 id="V0-版本"><a href="#V0-版本" class="headerlink" title="V0 版本"></a>V0 版本</h3><p>Kafka 消息格式的第一个版本通常称为 v0 版本， 在 Kafka 0.10.0 之前都采用的这个消息格式。这里只讨论消息未压缩的情形。 </p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20v0%E7%89%88%E6%9C%AC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png" alt="kafka v0版本日志格式"></p>
<p>如上图所示，左边的 RECORD 部分就是 v0 版本的消息格式， 大多数人会把图中左边的整体（即包括 offset 和 message size 字段）都看作消息，因为每个 RECORD(v0 和 v1 版）必定对应一个 offset 和 message size。每条消息都有一个 offset 用来标志它在分区中的偏移量， 这个 offset 是逻辑值， 而非实际物理偏移值， message size 表示消息的大小，这两者在一起被称为日志头部(LOG_OVERHEAD)，固定为 12B。与消息对应的还有消息集的概念，消息集中包含一条或多条消息，消息集不仅是存储于磁盘及在网络上传输(Produce &amp; Fetch)的基本形式，而且是 Kafka 中压缩的基本单元（上图右边）。</p>
<p>消息格式中的各个字段解释如下：</p>
<ul>
<li><p>crc32 (4B) : crc32 校验值，校验范围为 magic 至 value 之间。</p>
</li>
<li><p>magic (1B) : 消息格式版本号，此版本的 magic 值为 0。</p>
</li>
<li><p>attributes(1B) ：消息的属性，总共占 1 个字节，低 3 位表示压缩类型：0 表示 NONE，1 表示 GZIP，2 表示 SNAPPY，3 表示 LZ4（LZ4自Kafka 0.9.x引入）， 其余位保留。</p>
</li>
<li><p>key length(4B) ：表示消息的 key 的长度。 如果为-1, 则表示没有设置 key, 即 key= null。</p>
</li>
<li><p>key: 可选， 如果没有 key 则无此字段。</p>
</li>
<li><p>value length (4B) : 实际消息体的长度。 如果为-1, 则表示消息为空。</p>
</li>
<li><p>value: 消息体。可以为空，比如墓碑（tombstone）消息 。 </p>
</li>
</ul>
<p>v0 版本中一个消息的最小长度(RECORD_OVERHEAD_ V0)为 <code>crc32 + magic + attributes + key length + value length = 4B + 1B + 1B + 4B + 4B =14B</code>。 也就是说， v0 版本中一条消息的最小长度度为14B, 如果小于这个值， 那么这就是一条破损的消息而不被接收。</p>
<h3 id="V1-版本"><a href="#V1-版本" class="headerlink" title="V1 版本"></a>V1 版本</h3><p>v1 版本比 v0 版本多了一个 timestamp 字段，表示消息的时间戳信息：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20v1%E7%89%88%E6%9C%AC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png" alt="kafka v1版本日志格式"></p>
<p>v1 版本的 magic 字段的值为1。 v1 版本的 attributes 字段中的低 3 位和 v0 版本的一样，还是表示压缩类型。而第4位(bit)也被利用了起来：0 表示 timestamp 类型为 CreateTime，而 1 表示 timestamp 类型为 LogAppendTime，其他位保留。 timestamp 类型由 broker 端参数 <code>log.message.timestamp.type</code> 来配置， 默认值为 CreateTime，即采用生产者创建消息时的时间戳。如果在创建 ProducerRecord 时没有显式指定消息的时间戳，那么 KafkaProducer 也会在发送这条消息前自动添加上。</p>
<p>v1 版本的消息的最小长度（RECORD_OVERHEAD_V1）要比 v0 版本的大 8 个字节，即 22B。如果像 v0 版本一样发送一条 key = “key”、value= “value” 的消息，那么此条消息在 v1 版本中会占用42B。</p>
<h4 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h4><p>常见的压缩算法是数据量越大压缩效果越好，一条消息通常不会太大，这就导致压缩效果并不是太好。而 Kafka 实现的压缩方式是将多条消息一起进行压缩，这样可以保证较好的压缩效果。</p>
<p>在一般情况下，生产者发送的压缩数据在 broker 中也是保待压缩状态进行存储的，消费者从服务端获取的也是压缩的消息，消费者在处理消息之前才会解压消息，这样保待了端到端的压缩。</p>
<p>Kafka 日志中使用哪种压缩方式是通过参数 <code>compression.type</code> 来配置的，默认值为 “producer”，表示保留生产者使用的压缩方式。这个参数还可以配置为”gzip” “snappy” “lz4”, 分别对应 GZIP、 SNAPPY、 LZ4 这 3 种压缩算法。如果参数 <code>compression.type</code> 配置为 “uncompressed” , 则表示不压缩。</p>
<p>以上都是针对消息未压缩的情况， 而当消息压缩时是将整个消息集进行压缩作为内层消息 (inner message) , 内层消息整体作为外层 (wrapper message) 的 value, 其结构如下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20v1%E7%89%88%E6%9C%AC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F-%E6%B6%88%E6%81%AF%E5%8E%8B%E7%BC%A9-1.png" alt="kafka v1版本日志格式-消息压缩-1"></p>
<p>其实每个从生产者发出的消息集中的消息 offset 都是从 0 开始的，这个 offset 不能直接存储在日志文件中，对 offset 的转换是在服务端进行的，客户端不需要做这个工作。 </p>
<p>外层消息保存了内层消息中最后一条消息的绝对位移(absolute offset) , 绝对位移是相对于整个分区而言的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20v1%E7%89%88%E6%9C%AC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F-%E6%B6%88%E6%81%AF%E5%8E%8B%E7%BC%A9-2.png" alt="kafka v1版本日志格式-消息压缩-2"></p>
<p>对于未压缩的情形， 图右内层消息中最后一条的 offset 理应是 1030, 但被压缩之后就变成了 5, 而这个 1030 被赋予给了外层的 offset 。当消费者消费这个消息集的时候，首先解压缩整个消息集，然后找到内层消息中最后一条消息的 inner offset，再找到内层消息中最后一条消息前面的消息的 absolute offset。</p>
<h3 id="V2-版本"><a href="#V2-版本" class="headerlink" title="V2 版本"></a>V2 版本</h3><p>v2 版本中消息集称为Record Batch，而不是先前的Message Set，其内部也包含了一条或多条消息，消息的格式如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20v2%E7%89%88%E6%9C%AC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png" alt="kafka v2版本日志格式"></p>
<p>在消息压缩的情形下，Record Batch Header部分（从 first offset 到 records count 字段）是不被压缩的，而被压缩的是 records 字段中的所有内容。生产者客户端中的 ProducerBatch 对应这里的 RecordBatch，而 ProducerRecord 对应这里的Record。</p>
<p>观察消息格式 Record 的关键字段，可以看到内部字段大量采用了 Varints，这样 Kafka 可以根据具体的值来确定需要几个字节来保存。v2 版本的消息格式去掉了 crc 字段，另外增加了 length（消息总长度）、timestamp delta（时间戳增量）、offset delta（位移增量）和 headers 信息，并且 attributes 字段被弃用了。</p>
<ul>
<li><p>length：消息总长度。</p>
</li>
<li><p>attributes：弃用，但还是在消息格式中占据1B的大小，以备未来的格式扩展。</p>
</li>
<li><p>timestamp delta：时间戳增量。通常一个timestamp需要占用8个字节，如果像这里一样保存与 RecordBatch 的起始时间戳的差值，则可以进一步节省占用的字节数。</p>
</li>
<li><p>offset delta：位移增量。保存与 RecordBatch 起始位移的差值，可以节省占用的字节数。</p>
</li>
<li><p>headers：这个字段用来支持应用级别的扩展，而不需要像 v0 和 v1 版本一样不得不将一些应用级别的属性值嵌入消息体。</p>
</li>
<li><p>first offset：表示当前 RecordBatch 的起始位移。</p>
</li>
<li><p>length：计算从 partition leader epoch 字段开始到末尾的长度。</p>
</li>
<li><p>partition leader epoch：分区 leader 纪元，可以看作分区 leader 的版本号或更新次数。</p>
</li>
<li><p>magic：消息格式的版本号，对 v2 版本而言，magic 等于2。</p>
</li>
<li><p>attributes：消息属性，注意这里占用了两个字节。低3位表示压缩格式，可以参考 v0 和 v1；第4位表示时间戳类型；第5位表示此 RecordBatch 是否处于事务中，0 表示非事务，1 表示事务。第 6 位表示是否是控制消息（ControlBatch），0表示非控制消息，而1表示是控制消息，控制消息用来支持事务功能。</p>
</li>
<li><p>last offset delta：RecordBatch 中最后一个 Record 的 offset 与 first offset 的差值。主要被 broker 用来确保 RecordBatch中Record 组装的正确性。</p>
</li>
<li><p>first timestamp：RecordBatch 中第一条 Record 的时间戳。</p>
</li>
</ul>
<h4 id="变长字段"><a href="#变长字段" class="headerlink" title="变长字段"></a>变长字段</h4><p>Kafka 从 0.11.0 版本开始所使用的消息格式版本为v2，这个版本的消息相比v0和v1的版本而言改动很大，同时还参考了Protocol Buffer而引入了变长整型（Varints）和ZigZag编码。</p>
<p>Varints是使用一个或多个字节来序列化整数的一种方法。数值越小，其占用的字节数就越少。Varints中的每个字节都有一个位于最高位的msb位（most significantbit），除最后一个字节外，其余msb位都设置为1，最后一个字节的msb位为0。这个msb位表示其后的字节是否和当前字节一起来表示同一个整数。除msb位外，剩余的7位用于存储数据本身，这种表示类型又称为Base 128。通常而言，一个字节8位可以表示256个值，所以称为Base 256，而这里只能用7位表示，2的7次方即128。Varints中采用的是小端字节序，即最小的字节放在最前面。举个例子，比如数字1，它只占一个字节，所以msb位为0：</p>
<pre><code>0000 0001</code></pre><p>再举一个复杂点的例子，比如数字300：</p>
<pre><code>1010 1100 0000 0010</code></pre><p>怎么知道这是300呢? 首先将每个字节的 msb 去掉, 这个仅仅是告诉我们是否已经读到数字的结尾(可以看到, 第一个字节被设置了,因为在 varint 中不止一个字节):</p>
<pre><code>// 去掉最高位的 1 bit
1010 1100 0000 0010
→ 010 1100  000 0010</code></pre><p>把两个 7bit 的组翻转过来， 然后可以将他们连接起来，去掉前面的0就得到最后的值:</p>
<pre><code>000 0010  010 1100
→  000 0010 ++ 010 1100
→  100101100
→  256 + 32 + 8 + 4 = 300</code></pre><p>Varints 可以用来表示 int32、int64、uint32、uint64、sint32、sint64、bool、enum 等类型。在实际使用过程中，如果当前字段可以表示为负数，那么对int32/int64和sint32/sint64而言，它们在进行编码时存在较大的区别。比如使用int64表示一个负数，那么哪怕是-1，其编码后的长度始终为10个字节（可以通过下面的代码来测试长度），就如同对待一个很大的无符号长整型数一样。为了使编码更加高效，<strong>Varints使用了ZigZag的编码方式</strong>。</p>
<p>ZigZag编码以一种锯齿形（zig-zags）的方式来回穿梭正负整数，将带符号整数映射为无符号整数，这样可以使绝对值较小的负数仍然享有较小的Varints编码值，比如-1编码为1，1编码为2，-2编码为3。</p>
<table>
<thead>
<tr>
<th>原始有符号整型</th>
<th>编码结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483648</td>
<td>4294967295</td>
</tr>
</tbody></table>
<p>换句话说, 对于 sint32, 每个值 n 被编码为:</p>
<pre><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></pre><p>或者 64 位版本:</p>
<pre><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</code></pre><p>注意第二个移动 <code>(n &gt;&gt; 31)</code> 部分，是一个算数位移运算。 因此，移动的结果要么是0(如果n是正数) 要么是1(如果n是负数)。</p>
<p>以-1为例， 其二进制表现形式为 1111 1111 1111 1111 11111111 1111 1111 (补码）。</p>
<pre><code> (n&lt;&lt;1) = 1111 1111 1111 1111 1111 1111 1111 1110 
 (n&gt;&gt;31) = 1111 1111 1111 1111 1111 1111 1111 1111 
 (n &lt;&lt; 1) ^ (n &gt;&gt;31) = 1</code></pre><p>最终-1的Varints编码为0000 0001，这样原本用4个字节表示的-1现在可以用1个字节来表示了。</p>
<p>1 就显得非常简单了，其二进制表现形式为0000 0000 0000 00000000 0000 0000 0001。</p>
<pre><code>(n&lt;&lt;1) = 0000 0000 0000 0000 0000 0000 0000 0010
(n&gt;&gt;31) = 0000 0000 0000 0000 0000 0000 0000 0000
(n &lt;&lt; 1) A (n&gt;&gt;31) = 2 </code></pre><p>最终1的Varints编码为0000 0010，也只占用1个字节。前面说过Varints中的一个字节中只有7位是有效数值位，即只能表示128个数值，转变成绝对值之后其实质上只能表示64个数值。比如对消息体长度而言，其值肯定是大于等于0的正整数，那么一个字节长度的Varints最大只能表示64。65的二进制数表示为：0100 0001</p>
<p>经过ZigZag处理后为： <code>1000 0010 ^ 0000 0000 = 1000 0010</code></p>
<p>每个字节的低7位是有效数值位， 所以1000 0010进一步转变为： 000 0001 000 0010 </p>
<p>而Varints使用小端字节序， 所以需要翻转一下位置： 000 0010 000 0001 </p>
<p>设置非最后一个字节的msb 位为1, 最后一个字节的msb 位为0, 最终有： 1000 0010 0000 0001 </p>
<p>所以最终65表示为1000 0010 0000 0001, 而64却表示为0100 0000。</p>
<p>回顾Kafka v0和v1版本的消息格式，如果消息本身没有key，那么key length字段为-1，int类型的需要4个字节来保存，而如果采用Varints来编码则只需要1个字节。根据Varints的规则可以推导出0～63之间的数字占1个字节，64～8191之间的数字占2个字节，8192～1048575之间的数字占3个字节。而Kafka broker端配置 <code>message.max.bytes</code> 的默认大小为1000012 （Varints编码占3个字节），如果消息格式中与长度有关的字段采用Varints的编码，那么绝大多数情况下都会节省空间，而v2版本的消息格式也正是这样做的。不过需要注意的是，Varints 并非一直会节省空间，一个 int32 最长会占用5 个字节（大于默认的4个字节），一个int64最长会占用10个字节（大于默认的8个字节）。</p>
<h2 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h2><p>每个日志分段文件对应了两个索引文件，主要用来提高查找消息的效率。<strong>偏移量索引文件</strong>用来建立消息偏移量（offset）到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置；<strong>时间戳索引文件</strong>则根据指定的时间戳（timestamp）来查找对应的偏移量信息。Kafka 中的索引文件以稀疏索引（sparse index）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项。每当写入一定量（由 broker 端参数 <code>log.index.interval.bytes</code> 指定，默认值为4096，即4KB）的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项，增大或减小 <code>log.index.interval.bytes</code>的值，对应地可以增加或缩小索引项的密度。</p>
<p>稀疏索引通过 MappedByteBuffer 将索引文件映射到内存中，以加快索引的查询速度。偏移量索引文件中的偏移量是单调递增的，查询指定偏移量时，使用二分查找法来快速定位偏移量的位置，如果指定的偏移量不在索引文件中，则会返回小于指定偏移量的最大偏移量。时间戳索引文件中的时间戳也保持严格的单调递增，查询指定时间戳时，也根据二分查找法来查找不大于该时间戳的最大偏移量，至于要找到对应的物理文件位置还需要根据偏移量索引文件来进行再次定位。稀疏索引的方式是在磁盘空间、内存空间、查找时间等多方面之间的一个折中。</p>
<p>当日志分段文件达到一定的条件时需要进行切分，那么其对应的索引文件也需要进行切分。对非当前活跃的日志分段而言，其对应的索引文件内容已经固定而不需要再写入索引项，所以会被设定为只读。而对当前活跃的日志分段（activeSegment）而言，索引文件还会追加更多的索引项，所以被设定为可读写。在索引文件切分的时候，Kafka 会关闭当前正在写入的索引文件并置为只读模式，同时以可读写的模式创建新的索引文件，索引文件的大小由broker端参数 <code>log.index.size.max.bytes</code> 配置。Kafka 在创建索引文件的时候会为其预分配 <code>log.index.size.max.bytes</code> 大小的空间，注意这一点与日志分段文件不同，只有当索引文件进行切分的时候，Kafka 才会把该索引文件裁剪到实际的数据大小。也就是说，与当前活跃的日志分段对应的索引文件的大小固定为 <code>log.index.size.max.bytes</code>，而其余日志分段对应的索引文件的大小为实际的占用空间。</p>
<h3 id="偏移量索引"><a href="#偏移量索引" class="headerlink" title="偏移量索引"></a>偏移量索引</h3><p>偏移量索引每个索引项占用8个字节，分为两个部分。</p>
<ul>
<li>relativeOffset：相对偏移量，表示消息相对于baseOffset 的偏移量，占用4个字节，当前索引文件的文件名即为baseOffset的值。</li>
<li>position：物理地址，也就是消息在日志分段文件中对应的物理位置，占用4个字节。</li>
</ul>
<p>偏移量索引的查找过程如下：</p>
<p>假设现在只有 00000000000000000000.index和 00000000000000000000.log：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%A5%E5%BF%97%E5%81%8F%E7%A7%BB%E9%87%8F%E7%B4%A2%E5%BC%95-1.png" alt="kafka日志偏移量索引-1"></p>
<p>如果要查找偏移量为 23 的消息，首先通过二分法在偏移量索引文件中找到不大于23的最大索引项，即[22，656]，然后从日志分段文件中的物理位置656开始顺序查找偏移量为23的消息。</p>
<p><strong>当日志分段文件不止一份的时候，则需要先定位具体的日志分段文件</strong>：</p>
<p>如下图，假设要查找偏移量为268的消息，那么应该怎么办呢？首先肯定是定位到 baseOffset 为 251 的日志分段，然后计算相对偏移量relativeOffset=268-251=17，之后再在该日志分段对应的索引文件中找到不大于17的索引项，最后根据索引项中的position定位到具体的日志分段文件位置开始查找目标消息。</p>
<p>那么又是如何查找baseOffset 为251的日志分段的呢？这里并不是顺序查找，而是用了跳跃表的结构。Kafka 的每个日志对象中使用了 ConcurrentSkipListMap 来保存各个日志分段，每个日志分段的 baseOffset 作为 key，这样可以根据指定偏移量来快速定位到消息所在的日志分段。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%A5%E5%BF%97%E5%81%8F%E7%A7%BB%E9%87%8F%E7%B4%A2%E5%BC%95-2.png" alt="kafka日志偏移量索引-2"></p>
<h3 id="时间戳索引"><a href="#时间戳索引" class="headerlink" title="时间戳索引"></a>时间戳索引</h3><p>时间戳索引项的格式如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E6%88%B3%E7%B4%A2%E5%BC%95.png" alt="kafka日志时间戳索引"></p>
<p>每个索引项占用12个字节，分为两个部分：</p>
<ul>
<li><p>timestamp：当前日志分段最大的时间戳。</p>
</li>
<li><p>relativeOffset：时间戳所对应的消息的相对偏移量。</p>
</li>
</ul>
<p>时间戳索引文件中包含若干时间戳索引项，每个追加的时间戳索引项中的 timestamp 必须大于之前追加的索引项的 timestamp，否则不予追加。如果 broker 端参数 <code>log.message.timestamp.type</code> 设置为 LogAppendTime，那么消息的时间戳必定能够保持单调递增；相反，如果是 CreateTime 类型则无法保证。</p>
<p>生产者可以使用类似 ProducerRecord（String topic，Integer partition，Longtimestamp，K key，V value）的方法来指定时间戳的值。即使生产者客户端采用自动插入的时间戳也无法保证时间戳能够单调递增，如果两个不同时钟的生产者同时往一个分区中插入消息，那么也会造成当前分区的时间戳乱序。</p>
<p>与偏移量索引文件相似，时间戳索引文件大小必须是索引项大小（12B）的整数倍，如果不满足条件也会进行裁剪。同样假设 broker 端参数 <code>log.index.size.max.bytes</code> 配置为67，那么对应于时间戳索引文件，Kafka 在内部会将其转换为60。每当写入一定量的消息时，就会在偏移量索引文件和时间戳索引文件中分别增加一个偏移量索引项和时间戳索引项。两个文件增加索引项的操作是同时进行的，但并不意味着偏移量索引中的 relativeOffset 和时间戳索引项中的 relativeOffset 是同一个值。</p>
<p>假设现在有以下日志分段文件：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E6%88%B3%E7%B4%A2%E5%BC%95-2.png" alt="kafka日志时间戳索引-2"></p>
<p>如果要查找指定时间戳targetTimeStamp=1526384718288开始的消息，首先是找到不小于指定时间戳的日志分段。这里就无法使用跳跃表来快速定位到相应的日志分段了，需要分以下几个步骤来完成。</p>
<ol>
<li>将targetTimeStamp和每个日志分段中的最大时间戳largestTimeStamp逐一对比，直到找到不小于 targetTimeStamp 的 largestTimeStamp 所对应的日志分段。日志分段中的largestTimeStamp的计算是先查询该日志分段所对应的时间戳索引文件，找到最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则取该日志分段的最近修改时间。</li>
<li>找到相应的日志分段之后，在时间戳索引文件中使用二分查找算法查找到不大于targetTimeStamp的最大索引项，即[1526384718283，28]，如此便找到了一个相对偏移量28。</li>
<li>在偏移量索引文件中使用二分算法查找到不大于28的最大索引项，即[26，838]。</li>
<li>从步骤1中找到日志分段文件中的838的物理位置开始查找不小于targetTimeStamp的消息。</li>
</ol>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>Kafka 依赖于文件系统（更底层地来说就是磁盘）来存储和缓存消息。对于各个存储介质的速度，大体同下图所示，层级越高代表速度越快：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8.png" alt="各种存储介质"></p>
<p>而实际上，磁盘的速度快慢完全取决于我们如何使用它。有关测试结果表明，一个由6块7200r/min的RAID-5阵列组成的磁盘簇的<strong>线性（顺序）写入速度可以达到600MB/s，而随机写入速度只有100KB/s</strong>，两者性能相差6000倍。操作系统可以针对线性读写做深层次的优化，比如预读（read-ahead，提前将一个比较大的磁盘块读入内存）和后写（write-behind，将很多小的逻辑写操作合并起来组成一个大的物理写操作）技术。<strong>顺序写盘的速度不仅比随机写盘的速度快，而且也比随机写内存的速度快</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%A3%81%E7%9B%98%3A%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E9%80%9F%E5%BA%A6.png" alt="磁盘/内存写入速度"></p>
<p>Kafka 在设计时采用了文件追加的方式来写入消息，即只能在日志文件的尾部追加新的消息，并且也不允许修改已写入的消息，这种方式属于典型的顺序写盘的操作，所以就算 Kafka使用磁盘作为存储介质，它所能承载的吞吐量也不容小觑。这是让Kafka在性能上具备足够竞争力的一大因素，<strong>除此顺序写盘之外，kafka 还利用了操作系统的页缓存、零拷贝，进一步提高了性能</strong>。</p>
<h3 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h3><p>页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘 I/O 的操作。具体来说，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。为了弥补性能上的差异，现代操作系统越来越“激进地”将内存作为磁盘缓存，甚至会非常乐意将所有可用的内存用作磁盘缓存，这样当内存回收时也几乎没有性能损失，所有对于磁盘的读写也将经由统一的缓存。</p>
<p>当一个进程准备读取磁盘上的文件内容时，操作系统会先查看待读取的数据所在的页（page）是否在页缓存（pagecache）中，如果存在（命中）则直接返回数据，从而避免了对物理磁盘的 I/O 操作；如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据页存入页缓存，之后再将数据返回给进程。同样，如果一个进程需要将数据写入磁盘，那么操作系统也会检测数据对应的页是否在页缓存中，如果不存在，则会先在页缓存中添加相应的页，最后将数据写入对应的页。被修改过后的页也就变成了脏页，操作系统会在合适的时间把脏页中的数据写入磁盘，以保持数据的一致性。</p>
<p>对一个进程而言，它会在进程内部缓存处理所需的数据，然而这些数据有可能还缓存在操作系统的页缓存中，因此同一份数据有可能被缓存了两次。并且，除非使用Direct I/O的方式，否则页缓存很难被禁止。此外，使用 Java 开发的程序会有两个问题：</p>
<ol>
<li><p>对象的内存开销非常大，通常会是真实数据大小的几倍甚至更多，空间使用率低下；</p>
</li>
<li><p>Java的垃圾回收会随着堆内数据的增多而变得越来越慢。</p>
</li>
</ol>
<p>基于这些因素，<strong>使用文件系统并依赖于页缓存的做法明显要优于维护一个进程内缓存或其他结构，至少可以省去了一份进程内部的缓存消耗，同时还可以通过结构紧凑的字节码来替代使用对象的方式以节省更多的空间</strong>。如此，可以在 32GB 的机器上使用28GB至30GB的内存而不用担心GC所带来的性能问题。</p>
<p>此外，即使Kafka服务重启，页缓存还是会保持有效，然而进程内的缓存却需要重建。这样也极大地简化了代码逻辑，因为维护页缓存和文件之间的一致性交由操作系统来负责，这样会比进程内维护更加安全有效。</p>
<p>Kafka 中大量使用了页缓存，这是 Kafka 实现高吞吐的重要因素之一。虽然消息都是先被写入页缓存，然后由操作系统负责具体的刷盘任务的，但在 Kafka 中同样提供了同步刷盘及间断性强制刷盘（fsync）的功能，这些功能可以通过<code>log.flush.interval.messages</code>、<code>log.flush.interval.ms</code> 等参数来控制。</p>
<p>同步刷盘可以提高消息的可靠性，防止由于机器掉电等异常造成处于页缓存而没有及时写入磁盘的消息丢失。不过并不建议这么做，刷盘任务就应交由操作系统去调配，消息的可靠性应该由多副本机制来保障，而不是由同步刷盘这种严重影响性能的行为来保障。</p>
<p>Linux 系统会使用磁盘的一部分作为swap分区，这样可以进行进程的调度：把当前非活跃的进程调入 swap 分区，以此把内存空出来让给活跃的进程。对大量使用系统页缓存的 Kafka而言，应当尽量避免这种内存的交换，否则会对它各方面的性能产生很大的负面影响。可以通过修改 <code>vm.swappiness</code> 参数（Linux系统参数）来进行调节。<code>vm.swappiness</code> 参数的上限为 100，它表示积极地使用 swap 分区，并把内存上的数据及时地搬运到 swap 分区中；<code>vm.swappiness</code> 参数的下限为0，表示在任何情况下都不要发生交换，这样一来，当内存耗尽时会根据一定的规则突然中止某些进程。建议将这个参数的值设置为 1，这样保留了 swap 的机制而又最大限度地限制了它对 Kafka 性能的影响。</p>
<h3 id="磁盘-IO-流程"><a href="#磁盘-IO-流程" class="headerlink" title="磁盘 IO 流程"></a>磁盘 IO 流程</h3><p>从编程角度而言，一般磁盘I/O的场景有以下四种：</p>
<ol>
<li><p>用户调用标准C库进行I/O操作，数据流为：应用程序buffer→C库标准IObuffer→文件系统页缓存→通过具体文件系统到磁盘。</p>
</li>
<li><p>用户调用文件 I/O，数据流为：应用程序 buffer→文件系统页缓存→通过具体文件系统到磁盘。</p>
</li>
<li><p>用户打开文件时使用O_DIRECT，绕过页缓存直接读写磁盘。</p>
</li>
<li><p>用户使用类似dd工具，并使用direct参数，绕过系统cache与文件系统直接写磁盘。</p>
</li>
</ol>
<p>发起I/O请求的步骤可以表述为如下的内容（以最长链路为例）。</p>
<ul>
<li>写操作：用户调用fwrite把数据写入C库标准IObuffer后就返回，即写操作通常是异步操作；数据写入C库标准IObuffer后，不会立即刷新到磁盘，会将多次小数据量相邻写操作先缓存起来合并，最终调用write函数一次性写入（或者将大块数据分解多次write 调用）页缓存；数据到达页缓存后也不会立即刷新到磁盘，内核有pdflush 线程在不停地检测脏页，判断是否要写回到磁盘，如果是则发起磁盘I/O请求。</li>
<li>读操作：用户调用fread到C库标准IObuffer中读取数据，如果成功则返回，否则继续；到页缓存中读取数据，如果成功则返回，否则继续；发起 I/O 请求，读取数据后缓存buffer和C库标准IObuffer并返回。可以看出，读操作是同步请求。</li>
<li>I/O请求处理：通用块层根据I/O请求构造一个或多个bio结构并提交给调度层；调度器将 bio 结构进行排序和合并组织成队列且确保读写操作尽可能理想：将一个或多个进程的读操作合并到一起读，将一个或多个进程的写操作合并到一起写，尽可能变随机为顺序（因为随机读写比顺序读写要慢），读必须优先满足，而写也不能等太久。</li>
</ul>
<p>磁盘IO流程如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%A3%81%E7%9B%98IO%E6%B5%81%E7%A8%8B.png" alt="磁盘IO流程"></p>
<p>针对不同的应用场景，I/O调度策略也会影响I/O的读写性能，目前Linux系统中的I/O调度策略有4种，分别为 <code>NOOP</code>、<code>CFQ</code>、<code>DEADLINE</code> 和 <code>ANTICIPATORY</code>，默认为 CFQ。</p>
<h4 id="NOOP"><a href="#NOOP" class="headerlink" title="NOOP"></a>NOOP</h4><p>NOOP 算法的全写为 No Operation。该算法实现了最简单的FIFO队列，所有I/O请求大致按照先来后到的顺序进行操作。之所以说“大致”，原因是NOOP在FIFO的基础上还做了相邻I/O请求的合并，并不是完全按照先进先出的规则满足I/O请求。</p>
<p>假设有如下的I/O请求序列：</p>
<pre><code>100,500,101,10,56,1000</code></pre><p>NOOP将会按照如下顺序满足I/O请求：</p>
<pre><code>100(101),500,10,56,1000</code></pre><h4 id="CFQ"><a href="#CFQ" class="headerlink" title="CFQ"></a>CFQ</h4><p>CFQ 算法的全写为Completely Fair Queuing。该算法的特点是按照I/O请求的地址进行排序，而不是按照先来后到的顺序进行响应。假设有如下的I/O请求序列：</p>
<pre><code>100,500,101,10,56,1000</code></pre><p>CFQ将会按照如下顺序满足：</p>
<pre><code>100,101,500,1000,10,56</code></pre><p>CFQ是默认的磁盘调度算法，对于通用服务器来说是最好的选择。它试图均匀地分布对/IO带宽的访问。CFQ为每个进程单独创建一个队列来管理该进程所产生的请求，也就是说，每个进程一个队列，各队列之间的调度使用时间片进行调度，以此来保证每个进程都能被很好地分配到I/O带宽。I/O调度器每次执行一个进程的4次请求。在传统的SAS盘上，磁盘寻道花去了绝大多数的I/O响应时间。CFQ的出发点是对I/O地址进行排序，以尽量少的磁盘旋转次数来满足尽可能多的I/O请求。在CFQ算法下，SAS盘的吞吐量大大提高了。相比于NOOP的缺点是，先来的I/O请求并不一定能被满足，可能会出现“饿死”的情况。</p>
<h4 id="DEADLINE"><a href="#DEADLINE" class="headerlink" title="DEADLINE"></a>DEADLINE</h4><p>DEADLINE在CFQ的基础上，解决了I/O请求“饿死”的极端情况。除了CFQ本身具有的I/O排序队列，DEADLINE额外分别为读I/O和写I/O提供了FIFO队列。读FIFO队列的最大等待时间为500ms，写FIFO队列的最大等待时间为5s。FIFO队列内的I/O请求优先级要比CFQ队列中的高，而读FIFO队列的优先级又比写FIFO队列的优先级高。优先级可以表示如下：</p>
<pre><code>FIFO(Read) &gt; FIFO(Write) &gt; CFQ</code></pre><h4 id="ANTICIPATORY"><a href="#ANTICIPATORY" class="headerlink" title="ANTICIPATORY"></a>ANTICIPATORY</h4><p>CFQ和DEADLINE考虑的焦点在于满足零散I/O请求上。对于连续的I/O请求，比如顺序读，并没有做优化。为了满足随机I/O和顺序I/O混合的场景，Linux还支持ANTICIPATORY调度算法。</p>
<p>ANTICIPATORY在DEADLINE的基础上，为每个读I/O都设置了6ms的等待时间窗口。如果在6ms内OS收到了相邻位置的读I/O请求，就可以立即满足。ANTICIPATORY算法通过增加等待时间来获得更高的性能，假设一个块设备只有一个物理查找磁头（例如一个单独的SATA硬盘），将多个随机的小写入流合并成一个大写入流（相当于将随机读写变顺序读写），通过这个原理来使用读取/写入的延时换取最大的读取/写入吞吐量。适用于大多数环境，特别是读取/写入较多的环境。</p>
<p>不同的磁盘调度算法（以及相应的I/O优化手段）对Kafka 这类依赖磁盘运转的应用的影响很大，建议根据不同的业务需求来测试并选择合适的磁盘调度算法。</p>
<p>从文件系统层面分析，Kafka 操作的都是普通文件，并没有依赖于特定的文件系统，但是依然推荐使用EXT4或XFS。尤其是对XFS而言，它通常有更好的性能，这种性能的提升主要影响的是Kafka的写入性能。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>除了消息顺序追加、页缓存等技术，Kafka还使用零拷贝（Zero-Copy）技术来进一步提升性能。所谓的零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。对 Linux操作系统而言，零拷贝技术依赖于底层的 sendfile（）方法实现。<strong>对应于 Java 语言，FileChannal.transferTo（）方法的底层实现就是sendfile（）方法。</strong></p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p><strong>Kafka中存在大量的延时操作，比如延时生产、延时拉取和延时删除等。Kafka并没有使用JDK自带的Timer或DelayQueue来实现延时的功能，而是基于时间轮的概念自定义实现了一个用于延时功能的定时器（SystemTimer）。</strong></p>
<p>JDK中Timer和DelayQueue的插入和删除操作的平均时间复杂度为 <code>O（nlogn）</code>并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为<code>O（1）</code>。</p>
<p>Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务（TimerTask）。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95-1.png" alt="kafka时间轮算法-1"></p>
<p>时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickMs）。时间轮的时间格个数是固定的，可用wheelSize来表示，那么整个时间轮的总体时间跨度（interval）可以通过公式 tickMs×wheelSize计算得出。时间轮还有一个表盘指针（currentTime），用来表示时间轮当前所处的时间，currentTime是tickMs的整数倍。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList中的所有任务。</p>
<p>若时间轮的tickMs为1ms且wheelSize等于20，那么可以计算得出总体时间跨度interval为20ms。初始情况下表盘指针currentTime指向时间格0，<strong>此时有一个定时为2ms的任务插进来会存放到时间格为2的TimerTaskList中</strong>。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2对应的TimeTaskList中的任务进行相应的到期操作。此时若又有一个定时为 8ms 的任务插进来，则会存放到时间格 10 中，currentTime再过8ms后会指向时间格10。如果插入8ms任务的同时，还有一个定时为19ms的任务插进来，新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入原本已经到期的时间格1。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。</p>
<p>如果此时有一个定时为350ms的任务该如何处理？直接扩充wheelSize的大小？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且也会拉低效率。<strong>Kafka 为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。</strong></p>
<p>如下图，第一层的时间轮tickMs=1ms、wheelSize=20、interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95-2.png" alt="kafka时间轮算法-2"></p>
<p>对于350ms的定时任务，显然第一层时间轮不能满足条件，所以就升级到第二层时间轮中，最终被插入第二层时间轮中时间格17所对应的TimerTaskList。如果此时又有一个定时为450ms的任务，那么显然第二层时间轮也无法满足条件，所以又升级到第三层时间轮中，最终被插入第三层时间轮中时间格1的TimerTaskList。注意到在到期时间为[400ms，800ms）区间内的多个任务（比如446ms、455ms和473ms的定时任务）都会被放入第三层时间轮的时间格1，时间格1对应的TimerTaskList的超时时间为400ms。随着时间的流逝，当此TimerTaskList到期之时，原本定时为450ms的任务还剩下50ms的时间，还不能执行这个任务的到期操作。</p>
<p><strong>这里就有一个时间轮降级的操作，会将这个剩余时间为50ms 的定时任务重新提交到层级时间轮中，此时第一层时间轮的总体时间跨度不够，而第二层足够，所以该任务被放到第二层时间轮到期时间为[40ms，60ms）的时间格中</strong>。再经历40ms之后，此时这个任务又被“察觉”，不过还剩余10ms，还是不能立即执行到期操作。所以还要再有一次时间轮的降级，此任务被添加到第一层时间轮到期时间为[10ms，11ms）的时间格中，之后再经历 10ms 后，此任务真正到期，最终执行相应的到期操作。</p>
<p>设计源于生活。常见的钟表就是一种具有三层结构的时间轮，第一层时间轮tickMs=1ms、wheelSize=60、interval=1min，此为秒钟；第二层 tickMs=1min、wheelSize=60、interval=1hour，此为分钟；第三层tickMs=1hour、wheelSize=12、interval=12hours，此为时钟。</p>
<p>在 Kafka 中，第一层时间轮的参数同上面的案例一样：tickMs=1ms、wheelSize=20、interval=20ms，各个层级的wheelSize也固定为20，所以各个层级的tickMs和interval也可以相应地推算出来。</p>
<p>Kafka在具体实现时间轮TimingWheel时还有一些小细节：</p>
<ul>
<li>TimingWheel 在创建的时候以当前系统时间为第一层时间轮的起始时间（startMs），这里的当前系统时间并没有简单地调用 System.currentTimeMillis（），而是调用了Time.SYSTEM.hiResClockMs，这是因为 currentTimeMillis（）方法的时间精度依赖于操作系统的具体实现，有些操作系统下并不能达到毫秒级的精度，而Time.SYSTEM.hiResClockMs实质上采用了System.nanoTime（）/1_000_000来将精度调整到毫秒。</li>
<li>TimingWheel中的每个双向环形链表TimerTaskList都会有一个哨兵节点（sentinel），引入哨兵节点可以简化边界条件。哨兵节点也称为哑元节点（dummy node），它是一个附加的链表节点，该节点作为第一个节点，它的值域中并不存储任何东西，只是为了操作的方便而引入的。如果一个链表有哨兵节点，那么线性表的第一个元素应该是链表的第二个节点。</li>
<li>除了第一层时间轮，其余高层时间轮的起始时间（startMs）都设置为创建此层时间轮时前面第一轮的currentTime。每一层的currentTime都必须是tickMs的整数倍，如果不满足则会将currentTime修剪为tickMs的整数倍，以此与时间轮中的时间格的到期时间范围对应起来。修剪方法为：currentTime=startMs-（startMs%tickMs）。currentTime会随着时间推移而推进，但不会改变为tickMs的整数倍的既定事实。若某一时刻的时间为timeMs，那么此时时间轮的currentTime=timeMs-（timeMs%tickMs），时间每推进一次，每个层级的时间轮的currentTime都会依据此公式执行推进。</li>
<li>Kafka 中的定时器只需持有 TimingWheel 的第一层时间轮的引用，并不会直接持有其他高层的时间轮，但每一层时间轮都会有一个引用（overflowWheel）指向更高一层的应用，以此层级调用可以实现定时器间接持有各个层级时间轮的引用。</li>
</ul>
<p>Kafka中的定时器借了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都加入DelayQueue，“每个用到的TimerTaskList”特指非哨兵节点的定时任务项TimerTaskEntry对应的TimerTaskList。DelayQueue会根据TimerTaskList对应的超时时间expiration来排序，最短expiration的TimerTaskList会被排在DelayQueue的队头。Kafka中会有一个线程来获取DelayQueue 中到期的任务列表，有意思的是这个线程所对应的名称叫作“ExpiredOperationReaper”，可以直译为“过期操作收割机”。当“收割机”线程获取 DelayQueue中超时的任务列表 TimerTaskList之后，既可以根据 TimerTaskList 的 expiration来推进时间轮的时间，也可以就获取的TimerTaskList执行相应的操作，对里面的TimerTaskEntry该执行过期操作的就执行过期操作，该降级时间轮的就降级时间轮。</p>
<p>前面说过，DelayQueue不适合Kafka这种高性能要求的定时任务，为何这里还要引入DelayQueue呢？<strong>注意对定时任务项TimerTaskEntry的插入和删除操作而言，TimingWheel时间复杂度为O（1），性能高出DelayQueue很多，如果直接将TimerTaskEntry插入DelayQueue，那么性能显然难以支撑。</strong>就算根据一定的规则将若干TimerTaskEntry划分到TimerTaskList这个组中，然后将TimerTaskList插入DelayQueue，如果在TimerTaskList中又要多添加一个TimerTaskEntry时该如何处理呢？对DelayQueue而言，这类操作显然变得力不从心。</p>
<p>但是，Kafka 中的 TimingWheel 专门用来执行插入和删除TimerTaskEntry的操作，而 DelayQueue 专门负责时间推进的任务。试想一下，DelayQueue 中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O（1）的时间复杂度（获取之后DelayQueue内部才会再次切换出新的队头）。如果采用每秒定时推进，那么获取第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取第二个超时任务时又需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓“知人善用”，<strong>用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，两者相辅相成</strong>。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="消息传输保障"><a href="#消息传输保障" class="headerlink" title="消息传输保障"></a>消息传输保障</h2><p>一般而言，消息中间件的消息传输保障有3个层级，分别如下：</p>
<ul>
<li><p>at most once：至多一次。消息可能会丢失，但绝对不会重复传输。</p>
</li>
<li><p>at least once：最少一次。消息绝不会丢失，但可能会重复传输。</p>
</li>
<li><p>exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次。</p>
</li>
</ul>
<p>Kafka 的消息传输保障机制非常直观。当生产者向 Kafka 发送消息时，一旦消息被成功提交到日志文件，由于多副本机制的存在，这条消息就不会丢失。如果生产者发送消息到 Kafka之后，遇到了网络问题而造成通信中断，那么生产者就无法判断该消息是否已经提交。虽然Kafka无法确定网络故障期间发生了什么，但生产者可以进行多次重试来确保消息已经写入 Kafka，这个重试的过程中有可能会造成消息的重复写入，所以<strong>对生产者来说， Kafka 提供的消息传输保障为 at least once</strong>。</p>
<p>对消费者而言，消费者处理消息和提交消费位移的顺序在很大程度上决定了消费者提供哪一种消息传输保障。如果消费者在拉取完消息之后，应用逻辑先处理消息后提交消费位移，那么在消息处理之后且在位移提交之前消费者宕机了，待它重新上线之后，会从上一次位移提交的位置拉取，这样就出现了重复消费，因为有部分消息已经处理过了只是还没来得及提交消费位移，此时就对应at least once。如果消费者在拉完消息之后，应用逻辑先提交消费位移后进行消息处理，那么在位移提交之后且在消息处理完成之前消费者宕机了，待它重新上线之后，会从已经提交的位移处开始重新消费，但之前尚有部分消息未进行消费，如此就会发生消息丢失，此时就对应at most once。</p>
<p>Kafka 从 0.11.0.0 版本开始引入了幂等和事务这两个特性，以此来实现 EOS（exactly once semantics，精确一次处理语义）。</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>所谓的幂等，简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。</p>
<p>生产者在进行重试的时候有可能会重复写入消息，而使用 Kafka 的幂等性功能之后就可以避免这种情况。开启幂等性功能的方式很简单，只需要显式地将生产者客户端参数 <code>enable.idempotence</code> 设置为 true 即可（这个参数的默认值为false)。</p>
<p>不过如果要确保幂等性功能正常，还需要确保生产者客户端的 <code>retries</code>、<code>acks</code>、<code>max.in.flight.requests.per.connection</code> 这几个参数不被配置错。实际上在使用幂等性功能的时候，用户完全可以不用配置（也不建议配置）这几个参数。</p>
<ul>
<li><p>如果用户显式地指定了 retries 参数，那么这个参数的值必须大于 0，否则会报出ConfigException;</p>
</li>
<li><p>如果用户没有显式地指定 retries 参数，那么 KafkaProducer 会将它置为Integer.MAX_VALUE。同时还需要保证 <code>max.in.flight.requests.per.connection</code> 参数的值不能大于5（这个参数的值默认为5），否则也会报出ConfigException;</p>
</li>
<li><p>如果用户还显式地指定了 acks 参数，那么还需要保证这个参数的值为-1（all），如果不为-1（这个参数的值默认为1），那么也会报出ConfigException。如果用户没有显式地指定这个参数，那么KafkaProducer会将它置为-1。</p>
</li>
</ul>
<p>开启幂等性功能之后，生产者就可以如同未开启幂等时一样发送消息了。为了实现生产者的幂等性，Kafka为此引入了producer id（以下简称PID）和序列号（sequence number）这两个概念，分别对应 v2 版的日志格式中RecordBatch的producer id和first seqence这两个字段。每个新的生产者实例在初始化的时候都会被分配一个PID，这个PID对用户而言是完全透明的。对于每个PID，消息发送到的每一个分区都有对应的序列号，这些序列号从0开始单调递增。<strong>生产者每发送一条消息就会将<code>＜PID，分区＞</code>对应的序列号的值加1</strong>。</p>
<p>broker端会在内存中为每一对<code>＜PID，分区＞</code>维护一个序列号。对于收到的每一条消息，只有当它的序列号的值（SN_new）比broker端中维护的对应的序列号的值（SN_old）大1（即SN_new=SN_old+1）时，broker才会接收它。如果<code>SN_new＜SN_old+1</code>，那么说明消息被重复写入，broker可以直接将其丢弃。如果<code>SN_new＞SN_old+1</code>，那么说明中间有数据尚未写入，出现了乱序，暗示可能有消息丢失，对应的生产者会抛出OutOfOrderSequenceException，这个异常是一个严重的异常，后续的诸如 send（）、beginTransaction（）、commitTransaction（）等方法的调用都会抛出IllegalStateException的异常。</p>
<p>引入序列号来实现幂等也只是针对每一对<code>＜PID，分区＞</code>而言的，也就是说，Kafka的幂等只能保证单个生产者会话（session）中单分区的幂等。但是，发送了两条相同的消息，不过这仅仅是指消息内容相同，但对Kafka 而言是两条不同的消息，因为会为这两条消息分配不同的序列号。Kafka 并不会保证消息内容的幂等。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>幂等性并不能跨多个分区运作，而事务可以弥补这个缺陷。事务可以保证对多个分区写入操作的原子性。操作的原子性是指多个操作要么全部成功，要么全部失败，不存在部分成功、部分失败的可能。</p>
<p>对流式应用（Stream Processing Applications）而言，一个典型的应用模式为“consume-transform-produce”。在这种模式下消费和生产并存：应用程序从某个主题中消费消息，然后经过一系列转换后写入另一个主题，消费者可能在提交消费位移的过程中出现问题而导致重复消费，也有可能生产者重复生产消息。</p>
<p>Kafka中的事务可以使应用程序将消费消息、生产消息、提交消费位移当作原子操作来处理，同时成功或失败，即使该生产或消费会跨多个分区。</p>
<p>为了实现事务，应用程序必须提供唯一的 transactionalId，这个 transactionalId通过客户端参数transactional.id来显式设置。事务要求生产者开启幂等特性，因此通过将transactional.id参数设置为非空从而开启事务特性的同时需要将 <code>enable.idempotence</code> 设置为 true （如果未显式设置，则KafkaProducer默认会将它的值设置为true），如果用户显式地将<code>menable.idempotence</code>设置为false，则会报出ConfigException。</p>
<p>transactionalId与PID一一对应，两者之间所不同的是transactionalId由用户显式设置，而PID是由Kafka内部分配的。另外，为了保证新的生产者启动后，具有相同transactionalId的旧生产者能够立即失效，每个生产者通过transactionalId获取PID的同时，还会获取一个单调递增的producer epoch。如果使用同一个transactionalId开启两个生产者，那么前一个开启的生产者会报出错误。</p>
<p>producer epoch 对应 v2 版的日志格式中RecordBatch的producer epoch字段。从生产者的角度分析，通过事务，Kafka 可以保证跨生产者会话的消息幂等发送，以及跨生产者会话的事务恢复。前者表示具有相同 transactionalId 的新生产者实例被创建且工作的时候，旧的且拥有相同transactionalId的生产者实例将不再工作。后者指当某个生产者实例宕机后，新的生产者实例可以保证任何未完成的旧事务要么被提交（Commit），要么被中止（Abort），如此可以使新的生产者实例从一个正常的状态开始工作。</p>
<p>而从消费者的角度分析，事务能保证的语义相对偏弱。出于以下原因，Kafka 并不能保证已提交的事务中的所有消息都能够被消费：</p>
<ul>
<li>对采用日志压缩策略的主题而言，事务中的某些消息有可能被清理（相同key的消息，后写入的消息会覆盖前面写入的消息）。</li>
<li>事务中消息可能分布在同一个分区的多个日志分段（LogSegment）中，当老的日志分段被删除时，对应的消息可能会丢失。</li>
<li>消费者可以通过seek（）方法访问任意offset的消息，从而可能遗漏事务中的部分消息。</li>
<li>消费者在消费时可能没有分配到事务内的所有分区，如此它也就不能读取事务中的所有消息。</li>
</ul>
<p>在消费端有一个参数isolation.level，与事务有着莫大的关联，这个参数的默认值为“read_uncommitted”，意思是说消费端应用可以看到（消费到）未提交的事务，当然对于已提交的事务也是可见的。这个参数还可以设置为“read_committed”，表示消费端应用不可以看到尚未提交的事务内的消息。举个例子，如果生产者开启事务并向某个分区值发送3条消息msg1、msg2和msg3，在执行commitTransaction（）或abortTransaction（）方法前，设置为“read_committed”的消费端应用是消费不到这些消息的，不过在KafkaConsumer内部会缓存这些消息，直到生产者执行 commitTransaction（）方法之后它才能将这些消息推送给消费端应用。反之，如果生产者执行了 abortTransaction（）方法，那么 KafkaConsumer 会将这些缓存的消息丢弃而不推送给消费端应用。</p>
<p>日志文件中除了普通的消息，还有一种消息专门用来标志一个事务的结束，它就是控制消息（ControlBatch）。控制消息一共有两种类型：COMMIT和ABORT，分别用来表征事务已经成功提交或已经被成功中止。KafkaConsumer 可以通过这个控制消息来判断对应的事务是被提交了还是被中止了，然后结合参数isolation.level配置的隔离级别来决定是否将相应的消息返回给消费端应用，如下图所示:</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E4%BA%8B%E5%8A%A1.png" alt="kafka事务"></p>
<p>为了实现事务的功能，Kafka还引入了事务协调器（TransactionCoordinator）来负责处理事务，这一点可以类比一下组协调器（GroupCoordinator）。每一个生产者都会被指派一个特定的TransactionCoordinator，所有的事务逻辑包括分派PID 等都是由 TransactionCoordinator 来负责实施的。TransactionCoordinator会将事务状态持久化到内部主题__transaction_state 中。</p>
<h1 id="可靠性实现"><a href="#可靠性实现" class="headerlink" title="可靠性实现"></a>可靠性实现</h1><h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><p>Kafka从0.8版本开始为分区引入了多副本机制，通过增加副本数量来提升数据容灾能力。同时，Kafka通过多副本机制实现故障自动转移，在Kafka集群中某个broker节点失效的情况下仍然保证服务可用。</p>
<p>这里简要地提一下相关的概念：</p>
<ul>
<li><p>副本是相对于分区而言的，即副本是特定分区的副本。</p>
</li>
<li><p>一个分区中包含一个或多个副本，其中一个为leader副本，其余为follower副本，各个副本位于不同的broker节点中。只有leader副本对外提供服务，follower副本只负责数据同步。</p>
</li>
<li><p>分区中的所有副本统称为 AR，而 ISR 是指与leader 副本保持同步状态的副本集合，当然leader副本本身也是这个集合中的一员。</p>
</li>
<li><p>LEO标识每个分区中最后一条消息的下一个位置，分区的每个副本都有自己的LEO，ISR中最小的LEO即为HW，俗称高水位，消费者只能拉取到HW之前的消息。</p>
</li>
</ul>
<p>从生产者发出的一条消息首先会被写入分区的leader副本，不过<strong>还需要等待ISR集合中的所有 follower 副本都同步完之后才能被认为已经提交，之后才会更新分区的 HW，进而消费者可以消费到这条消息</strong>。</p>
<h3 id="失效副本"><a href="#失效副本" class="headerlink" title="失效副本"></a>失效副本</h3><p>正常情况下，分区的所有副本都处于ISR集合中，但是难免会有异常情况发生，从而某些副本被剥离出ISR集合中。在ISR集合之外，也就是处于同步失效或功能失效（比如副本处于非存活状态）的副本统称为失效副本，失效副本对应的分区也就称为同步失效分区，即under-replicated分区。</p>
<p>失效副本不仅是指处于功能失效状态的副本，处于同步失效状态的副本也可以看作失效副本。怎么判定一个分区是否有副本处于同步失效的状态呢？Kafka从0.9.x版本开始就通过唯一的broker端参数 <code>replica.lag.time.max.ms</code>（默认10000）来抉择，当ISR集合中的一个follower副本滞后leader副本的时间超过此参数指定的值时则判定为同步失败，需要将此follower副本剔除出ISR集合，具体参考下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-1.png" alt="kafka多副本机制-1"></p>
<p>当follower副本将leader副本LEO（LogEndOffset）之前的日志全部同步时，则认为该 follower 副本已经追赶上leader 副本，此时更新该副本的 lastCaughtUpTimeMs 标识。</p>
<p>Kafka 的副本管理器会启动一个副本过期检测的定时任务，而这个定时任务会定时检查当前时间与副本的 lastCaughtUpTimeMs 差值是否大于参数 replica.lag.time.max.ms 指定的值。</p>
<p><strong>不要错误地认为 follower 副本只要拉取 leader副本的数据就会更新lastCaughtUpTimeMs</strong>。当 leader 副本中消息的流入速度大于follower副本中拉取的速度时，就算 follower 副本一直不断地拉取 leader 副本的消息也不能与leader副本同步。如果还将此follower副本置于ISR集合中，那么当leader副本下线而选取此follower副本为新的leader副本时就会造成消息的严重丢失。</p>
<p>Kafka源码注释中说明了一般有两种情况会导致副本失效：</p>
<ul>
<li><p>follower副本进程卡住，在一段时间内根本没有向leader副本发起同步请求，比如频繁的Full GC。</p>
</li>
<li><p>follower副本进程同步过慢，在一段时间内都无法追赶上leader副本，比如I/O开销过大。</p>
</li>
</ul>
<p>在这里再补充一点，如果通过工具增加了副本因子，那么新增加的副本在赶上leader副本之前也都是处于失效状态的。如果一个follower副本由于某些原因（比如宕机）而下线，之后又上线，在追赶上leader副本之前也处于失效状态。</p>
<h3 id="ISR-伸缩"><a href="#ISR-伸缩" class="headerlink" title="ISR 伸缩"></a>ISR 伸缩</h3><h4 id="ISR-缩减"><a href="#ISR-缩减" class="headerlink" title="ISR 缩减"></a>ISR 缩减</h4><p>Kafka 在启动的时候会开启两个与 ISR 相关的定时任务，名称分别为“isr-expiration”和“isr-change-propagation”。</p>
<p>isr-expiration 任务会周期性地检测每个分区是否需要缩减其ISR集合。这个周期和replica.lag.time.max.ms参数有关，大小是这个参数值的一半，默认值为5000ms。当检测到ISR集合中有失效副本时，就会收缩ISR集合。如果某个分区的ISR集合发生变更，则会将变更后的数据记录到 ZooKeeper 对应的 <code>/brokers/topics/＜topic＞/partition/＜parititon＞/state</code> 节点中。节点中的数据示例如下：</p>
<pre><code>{&quot;controller_epoch&quot;:26,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:2,&quot;isr&quot;:[0,1]}</code></pre><p>其中controller_epoch表示当前Kafka控制器的epoch，leader表示当前分区的leader副本所在的broker的id编号，version表示版本号（当前版本固定为1），leader_epoch表示当前分区的leader纪元，isr表示变更后的ISR列表。</p>
<p>除此之外，当 ISR 集合发生变更时还会将变更后的记录缓存到 isrChangeSet 中，isr-change-propagation 任务会周期性（固定值为 2500ms）地检查 isrChangeSet，如果发现 isrChangeSet 中有ISR集合的变更记录，那么它会在ZooKeeper的 <code>/isr_change_notification</code> 路径下创建一个以 <code>isr_change_</code> 开头的持久顺序节点（比如<code>/isr_change_notification/isr_change_0000000000</code>），并将isrChangeSet中的信息保存到这个节点中。</p>
<p>Kafka控制器为<code>/isr_change_notification</code>添加了一个Watcher，当这个节点中有子节点发生变化时会触发Watcher的动作，以此通知控制器更新相关元数据信息并向它管理的broker节点发送更新元数据的请求，最后删除<code>/isr_change_notification</code>路径下已经处理过的节点。</p>
<p>频繁地触发Watcher会影响Kafka控制器、ZooKeeper甚至其他broker节点的性能。为了避免这种情况，Kafka添加了限定条件，当检测到分区的ISR集合发生变化时，还需要检查以下两个条件：</p>
<ol>
<li>上一次ISR集合发生变化距离现在已经超过5s</li>
<li>上一次写入ZooKeeper的时间距离现在已经超过60s</li>
</ol>
<p>满足以上两个条件之一才可以将ISR集合的变化写入目标节点。</p>
<h4 id="ISR-扩充"><a href="#ISR-扩充" class="headerlink" title="ISR 扩充"></a>ISR 扩充</h4><p>随着follower副本不断与leader副本进行消息同步，follower副本的LEO也会逐渐后移，并最终追赶上leader副本，此时该follower副本就有资格进入ISR集合。</p>
<p>追赶上leader副本的判定准则是此副本的LEO是否不小于leader副本的HW，注意这里并不是和leader副本的LEO相比。ISR扩充之后同样会更新ZooKeeper中的<code>/brokers/topics/＜topic＞/partition/＜parititon＞/state</code>节点和isrChangeSet，之后的步骤就和ISR收缩时的相同。当ISR集合发生增减时，或者ISR集合中任一副本的LEO发生变化时，都可能会影响整个分区的HW。</p>
<p>如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-2.png" alt="kafka多副本机制-2"></p>
<p>leader副本的LEO为9，follower1副本的LEO为7，而follower2副本的LEO为6，如果判定这3个副本都处于ISR集合中，那么这个分区的HW为6；如果follower2已经被判定为失效副本被剥离出ISR集合，那么此时分区的HW为leader副本和follower1副本中LEO的最小值，即为7。</p>
<h3 id="LEO-和-HW"><a href="#LEO-和-HW" class="headerlink" title="LEO 和 HW"></a>LEO 和 HW</h3><p>对于副本而言，还有两个概念：本地副本（Local Replica）和远程副本（RemoteReplica），本地副本是指对应的Log分配在当前的broker节点上，远程副本是指对应的Log分配在其他的broker节点上。在Kafka中，同一个分区的信息会存在多个broker节点上，并被其上的副本管理器所管理，这样在逻辑层面每个broker节点上的分区就有了多个副本，但是只有本地副本才有对应的日志。</p>
<p>如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-3.png" alt="kafka多副本机制-3"></p>
<p>某个分区有3个副本分别位于broker0、broker1和broker2节点中，其中带阴影的方框表示本地副本。假设broker0上的副本1为当前分区的leader副本，那么副本2和副本3就是follower副本，整个消息追加的过程可以概括如下：</p>
<ol>
<li>生产者客户端发送消息至leader副本（副本1）中</li>
<li>消息被追加到leader副本的本地日志，并且会更新日志的偏移量。</li>
<li>follower副本（副本2和副本3）向leader副本请求同步数据。</li>
<li>leader副本所在的服务器读取本地日志，并更新对应拉取的follower副本的信息。</li>
<li>leader副本所在的服务器将拉取结果返回给follower副本。</li>
<li>follower副本收到leader副本返回的拉取结果，将消息追加到本地日志中，并更新日志的偏移量信息。</li>
</ol>
<p>再来分析在这个过程中各个副本LEO和HW的变化情况。</p>
<p>假设生产者一直在往leader副本（带阴影的方框）中写入消息，某一时刻，leader副本的LEO增加至5，并且所有副本的HW还都为0。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-4.png" alt="kafka多副本机制-4"></p>
<p>之后follower副本（不带阴影的方框）向leader副本拉取消息，在拉取的请求中会带有自身的LEO信息，这个LEO信息对应的是FetchRequest请求中的fetch_offset。leader副本返回给follower副本相应的消息，并且还带有自身的HW信息，如下图所示，这个HW信息对应的是FetchResponse中的high_watermark。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-5.png" alt="kafka多副本机制-5"></p>
<p>此时两个follower副本各自拉取到了消息，并更新各自的LEO为3和4。</p>
<p>与此同时，follower副本还会更新自己的HW，更新HW的算法是比较当前LEO和leader副本中传送过来的HW的值，取较小值作为自己的HW值。当前两个follower副本的HW都等于0（min（0，0）=0）。接下来follower副本再次请求拉取leader副本中的消息，如下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-6.png" alt="kafka多副本机制-6"></p>
<p>此时leader副本收到来自follower副本的FetchRequest请求，其中带有LEO的相关信息，选取其中的最小值作为新的HW，即min（15，3，4）=3。然后连同消息和HW一起返回FetchResponse给follower副本，如下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-7.png" alt="kafka多副本机制-7"></p>
<p>注意leader副本的HW是一个很重要的东西，因为它直接影响了分区数据对消费者的可见性。</p>
<p>两个follower副本在收到新的消息之后更新LEO并且更新自己的HW为3（min（LEO，3）=3）。</p>
<p>在一个分区中，leader副本所在的节点会记录所有副本的LEO，而follower副本所在的节点只会记录自身的LEO，而不会记录其他副本的LEO。对HW而言，各个副本所在的节点都只记录它自身的HW。leader副本中带有其他 follower 副本的 LEO，那么它们是什么时候更新的呢？leader 副本收到 follower副本的FetchRequest请求之后，它首先会从自己的日志文件中读取数据，然后在返回给follower副本数据前先更新follower副本的LEO。</p>
<h3 id="Leader-Epoch"><a href="#Leader-Epoch" class="headerlink" title="Leader Epoch"></a>Leader Epoch</h3><p>在正常情况下的leader副本与follower副本之间的同步过程，如果leader副本发生切换，那么同步过程又该如何处理呢？在0.11.0.0版本之前，Kafka使用的是基于HW的同步机制，但这样有可能出现数据丢失或leader副本和follower副本数据不一致的问题。</p>
<p>首先来看一下数据丢失的问题，如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-1.png" alt="kafka leadr epoch-1"></p>
<p>Replica B是当前的leader副本（用L标记），Replica A是follower副本。在某一时刻，B中有2条消息m1和m2，A从B中同步了这两条消息，此时A和B的LEO都为2，同时HW都为1；之后A再向B中发送请求以拉取消息，FetchRequest请求中带上了A的LEO信息，B在收到请求之后更新了自己的HW为2；B中虽然没有更多的消息，但还是在延时一段时间之后返回FetchResponse，并在其中包含了HW信息；最后A根据FetchResponse中的HW信息更新自己的HW为2。</p>
<p><strong>可以看到整个过程中两者之间的HW同步有一个间隙，在A写入消息m2之后（LEO更新为2）需要再一轮的FetchRequest/FetchResponse才能更新自身的HW为2。如果在这个时候A宕机了，那么在A重启之后会根据之前HW位置（这个值会存入本地的复制点文件replication-offset-checkpoint）进行日志截断，这样便会将m2这条消息删除，此时A只剩下m1这一条消息，之后A再向B发送FetchRequest请求拉取消息。</strong></p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-2.png" alt="kafka leadr epoch-2"></p>
<p>此时若 B 再宕机，那么 A 就会被选举为新的leader。B 恢复之后会成为follower，由于follower副本HW不能比leader副本的HW高，所以还会做一次日志截断，以此将HW调整为1。这样一来m2这条消息就丢失了（就算B不能恢复，这条消息也同样丢失）。（两个轮流挂，有点离谱。。。。）</p>
<p>对于这种情况，也有一些解决方法，比如等待所有follower副本都更新完自身的HW之后再更新leader副本的HW，这样会增加多一轮的FetchRequest/FetchResponse延迟，自然不够妥当。还有一种方法就是follower副本恢复之后，在收到leader副本的FetchResponse前不要截断follower副本（follower副本恢复之后会做两件事情：截断自身和向leader发送FetchRequest请求），不过这样也避免不了数据不一致的问题。</p>
<p>如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-3.png" alt="kafka leadr epoch-3"></p>
<p>当前leader副本为A，follower副本为B，A中有2条消息m1和m2，并且HW和LEO都为2，B中有1条消息m1，并且HW和LEO都为1（此时还没收到 leader 的 hw 更新返回）。假设A和B同时“挂掉”，然后B第一个恢复过来并成为leader，如图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-4.png" alt="kafka leadr epoch-4"></p>
<p>之后B写入消息m3，并将LEO和HW更新至2（假设所有场景中的min.insync.replicas参数配置为1）。此时A也恢复过来了，根据前面数据丢失场景中的介绍可知它会被赋予follower的角色，并且需要根据HW截断日志及发送FetchRequest至B，不过此时A的HW正好也为2，那么就可以不做任何调整了，如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-5.png" alt="kafka leadr epoch-5"></p>
<p>如此一来A中保留了m2而B中没有，B中新增了m3而A也同步不到，这样A和B就出现了数据不一致的情形。</p>
<p>为了解决上述两种问题，Kafka从0.11.0.0开始引入了leader epoch的概念，在需要截断数据的时候使用leader epoch作为参考依据而不是原本的HW。leader epoch代表leader的纪元信息（epoch），初始值为0。每当leader变更一次，leaderepoch的值就会加1，相当于为leader增设了一个版本号。与此同时，每个副本中还会增设一个矢量<code>＜LeaderEpoch=＞StartOffset＞</code>，其中StartOffset表示当前LeaderEpoch下写入的第一条消息的偏移量。每个副本的Log下都有一个leader-epoch-checkpoint文件，在发生leader epoch变更时，会将对应的矢量对追加到这个文件中，v2版本的消息格式时就提到了消息集中的<code>partition leader epoch</code>字段，而这个字段正对应这里讲述的leader epoch。</p>
<p>再来看一下引入 leader epoch 之后如何应付前面所说的数据丢失和数据不一致的场景。首先讲述应对数据丢失的问题，如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-6.png" alt="kafka leadr epoch-6"></p>
<p>同样 A 发生重启，之后 A 不是先忙着截断日志而是先发送OffsetsForLeaderEpochRequest请求给 B（OffsetsForLeaderEpochRequest 请求体结构如下图所示，其中包含 A 当前的LeaderEpoch值）</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-7.png" alt="kafka leadr epoch-7"></p>
<p>B作为目前的leader在收到请求之后会返回当前的LEO（LogEndOffset，注意图中LE0和LEO的不同），与请求对应的响应为OffsetsForLeaderEpochResponse，对应的响应体结构可以参考图下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-8.png" alt="kafka leadr epoch-8"></p>
<p>如果A中的LeaderEpoch（假设为LE_A）和B中的不相同，那么B此时会查找LeaderEpoch为 LE_A+1 对应的 StartOffset 并返回给 A，也就是 LE_A 对应的LEO，所以可以将OffsetsForLeaderEpochRequest的请求看作用来查找follower副本当前LeaderEpoch的LEO。A在收到2之后发现和目前的LEO相同，也就不需要截断日志了。之后跟前面一样，B发生了宕机，A成为新的leader，那么对应的LE=0也变成了LE=1，对应的消息m2此时就得到了保留，这是原本所不能保留的。之后不管B有没有恢复，后续的消息都可以以LE1为LeaderEpoch陆续追加到A中。</p>
<p>再来看一下leader epoch如何应对数据不一致的场景。如下图所示，当前A为leader，B为follower，A中有2条消息m1和m2，而B中有1条消息m1。假设A和B同时“挂掉”，然后B第一个恢复过来并成为新的leader。</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-9.png" alt="kafka leadr epoch-9"></p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20leadr%20epoch-10.png" alt="kafka leadr epoch-10"></p>
<p>之后B写入消息m3，并将LEO和HW更新至2。注意此时的LeaderEpoch已经从LE0增至LE1了。</p>
<p>紧接着A也恢复过来成为follower并向B发送OffsetsForLeaderEpochRequest请求，此时A的LeaderEpoch为LE0。B根据LE0查询到对应的offset为1并返回给A，A就截断日志并删除了消息m2。之后A发送FetchRequest至B请求来同步数据，最终A和B中都有两条消息m1和m3，HW和LEO都为2，并且LeaderEpoch都为LE1，如此便解决了数据不一致的问题。</p>
<h3 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离"></a>为什么不支持读写分离</h3><p>在Kafka中，生产者写入消息、消费者读取消息的操作都是与leader副本进行交互的，从而实现的是一种主写主读的生产消费模型。数据库、Redis等都具备主写主读的功能，与此同时还支持主写从读的功能，主写从读也就是读写分离，为了与主写主读对应，这里就以主写从读来称呼。Kafka并不支持主写从读，这是为什么呢？</p>
<p>从代码层面上来说，虽然增加了代码复杂度，但在Kafka中这种功能完全可以支持。</p>
<p>对于这个问题，可以从“收益点”这个角度来做具体分析。主写从读可以让从节点去分担主节点的负载压力，预防主节点负载过重而从节点却空闲的情况发生。但是主写从读也有2个很明显的缺点：</p>
<ol>
<li>数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中A数据的值都为X，之后将主节点中A的值修改为Y，那么在这个变更通知到从节点之前，应用读取从节点中的A数据的值并不为最新的Y，由此便产生了数据不一致的问题。</li>
<li>延时问题。类似Redis这种组件，数据从写入主节点到同步至从节点中的过程需要经历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在Kafka中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</li>
</ol>
<p>现实情况下，很多应用既可以忍受一定程度上的延时，也可以忍受一段时间内的数据不一致的情况，那么对于这种情况，Kafka是否有必要支持主写从读的功能呢？主读从写可以均摊一定的负载却不能做到完全的负载均衡，比如对于数据写压力很大而读压力很小的情况，从节点只能分摊很少的负载压力，而绝大多数压力还是在主节点上。而在Kafka中却可以达到很大程度上的负载均衡，而且这种均衡是在主写主读的架构上实现的。看一下Kafka的生产消费模型，如图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/kafka%20%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" alt="kafka 生产消费模型"></p>
<p>在Kafka集群中有3个分区，每个分区有3个副本，正好均匀地分布在3个broker上，灰色阴影的代表leader副本，非灰色阴影的代表follower副本，虚线表示follower副本从leader副本上拉取消息。当生产者写入消息的时候都写入leader副本，对于上图中的情形，每个broker都有消息从生产者流入；当消费者读取消息的时候也是从leader副本中读取的，对于图中情形，每个broker都有消息流出到消费者。很明显地可以看出，每个broker上的读写负载都是一样的，这就说明Kafka可以通过主写主读实现主写从读实现不了的负载均衡。上图展示是一种理想的部署情况，有以下几种情况（包含但不仅限于）会造成一定程度上的负载不均衡：</p>
<ol>
<li>broker端的分区分配不均。当创建主题的时候可能会出现某些broker分配到的分区数多而其他broker分配到的分区数少，那么自然而然地分配到的leader副本也就不均。</li>
<li>生产者写入消息不均。生产者可能只对某些broker中的leader副本进行大量的写入操作，而对其他broker中的leader副本不闻不问。</li>
<li>消费者消费消息不均。消费者可能只对某些broker中的leader副本进行大量的拉取操作，而对其他broker中的leader副本不闻不问。</li>
<li>leader副本的切换不均。在实际应用中可能会由于broker宕机而造成主从副本的切换，或者分区副本的重分配等，这些动作都有可能造成各个broker中leader副本的分配不均。</li>
</ol>
<p>对此，可以做一些防范措施。针对第一种情况，在主题创建的时候尽可能使分区分配得均衡，好在Kafka 中相应的分配算法也是在极力地追求这一目标，如果是开发人员自定义的分配，则需要注意这方面的内容。对于第二和第三种情况，主写从读也无法解决。对于第四种情况，Kafka 提供了优先副本的选举来达到 leader副本的均衡，与此同时，也可以配合相应的监控、告警和运维平台来实现均衡的优化。</p>
<p>在实际应用中，配合监控、告警、运维相结合的生态平台，在绝大多数情况下Kafka都能做到很大程度上的负载均衡。总的来说，Kafka 只支持主写主读有几个优点：可以简化代码的实现逻辑，减少出错的可能；将负载粒度细化均摊，与主写从读相比，不仅负载效能更好，而且对用户可控；没有延时的影响；在副本稳定的情况下，不会出现数据不一致的情况。为此，Kafka 又何必再去实现对它而言毫无收益的主写从读的功能呢？这一切都得益于 Kafka 优秀的架构设计，从某种意义上来说，主写从读是由于设计上的缺陷而形成的权宜之计。</p>
<h2 id="日志同步机制"><a href="#日志同步机制" class="headerlink" title="日志同步机制"></a>日志同步机制</h2><p>在分布式系统中，日志同步机制既要保证数据的一致性，也要保证数据的顺序性。虽然有许多方式可以实现这些功能，但最简单高效的方式还是从集群中选出一个leader来负责处理数据写入的顺序性。只要leader还处于存活状态，那么follower只需按照leader中的写入顺序来进行同步即可。</p>
<p>通常情况下，只要leader不宕机我们就不需要关心follower的同步问题。不过当leader宕机时，我们就要从follower中选举出一个新的leader。follower的同步状态可能落后leader很多，甚至还可能处于宕机状态，所以必须确保选择具有最新日志消息的follower作为新的leader。日志同步机制的一个基本原则就是：如果告知客户端已经成功提交了某条消息，那么即使 leader宕机，也要保证新选举出来的leader中能够包含这条消息。这里就有一个需要权衡（tradeoff）的地方，如果leader在消息被提交前需要等待更多的follower确认，那么在它宕机之后就可以有更多的follower替代它，不过这也会造成性能的下降。</p>
<p>对于这种权衡，一种常见的做法是“少数服从多数”，它可以用来负责提交决策和选举决策。虽然Kafka不采用这种方式，但可以拿来探讨和理解权衡的艺术。在这种方式下，如果我们有2f+1个副本，那么在提交之前必须保证有f+1个副本同步完消息。同时为了保证能正确选举出新的leader，至少要保证有f+1个副本节点完成日志同步并从同步完成的副本中选举出新的leader节点。并且在不超过f个副本节点失败的情况下，新的leader需要保证不会丢失已经提交过的全部消息。这样在任意组合的 f+1 个副本中，理论上可以确保至少有一个副本能够包含已提交的全部消息，这个副本的日志拥有最全的消息，因此会有资格被选举为新的 leader来对外提供服务。</p>
<p>“少数服从多数”的方式有一个很大的优势，系统的延迟取决于最快的几个节点，比如副本数为3，那么延迟就取决于最快的那个follower而不是最慢的那个（除了leader，只需要另一个follower确认即可）。不过它也有一些劣势，为了保证leader选举的正常进行，它所能容忍的失败follower数比较少，如果要容忍1个follower失败，那么至少要有3个副本，如果要容忍2个follower失败，必须要有5个副本。也就是说，在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降。这也就是“少数服从多数”的这种Quorum模型常被用作共享集群配置（比如ZooKeeper），而很少用于主流的数据存储中的原因。</p>
<p>与“少数服从多数”相关的一致性协议有很多，比如Zab、Raft和ViewstampedReplication等。而Kafka使用的更像是微软的PacificA算法。</p>
<p>在Kafka中动态维护着一个ISR集合，处于ISR集合内的节点保持与leader相同的高水位（HW），只有位列其中的副本（unclean.leader.election.enable配置为false）才有资格被选为新的 leader。写入消息时只有等到所有 ISR 集合中的副本都确认收到之后才能被认为已经提交。位于 ISR 中的任何副本节点都有资格成为leader，选举过程简单、开销低，这也是Kafka选用此模型的重要因素。Kafka中包含大量的分区，leader副本的均衡保障了整体负载的均衡，所以这一因素也极大地影响Kafka的性能指标。</p>
<p>在采用ISR模型和（f+1）个副本数的配置下，一个Kafka分区能够容忍最大f个节点失败，相比于“少数服从多数”的方式所需的节点数大幅减少。实际上，为了能够容忍f个节点失败，“少数服从多数”的方式和ISR的方式都需要相同数量副本的确认信息才能提交消息。比如，为了容忍1个节点失败，“少数服从多数”需要3个副本和1个follower的确认信息，采用ISR的方式需要2个副本和1个follower的确认信息。在需要相同确认信息数的情况下，采用ISR的方式所需要的副本总数变少，复制带来的集群开销也就更低，“少数服从多数”的优势在于它可以绕开最慢副本的确认信息，降低提交的延迟，而对Kafka而言，这种能力可以交由客户端自己去选择。</p>
<p>另外，一般的同步策略依赖于稳定的存储系统来做数据恢复，也就是说，在数据恢复时日志文件不可丢失且不能有数据上的冲突。不过它们忽视了两个问题：首先，磁盘故障是会经常发生的，在持久化数据的过程中并不能完全保证数据的完整性；其次，即使不存在硬件级别的故障，我们也不希望在每次写入数据时执行同步刷盘（fsync）的动作来保证数据的完整性，这样会极大地影响性能。而 Kafka 不需要宕机节点必须从本地数据日志中进行恢复，Kafka 的同步方式允许宕机副本重新加入ISR集合，但在进入ISR之前必须保证自己能够重新同步完leader中的所有数据。</p>
<p><strong>参考文档</strong>：</p>
<blockquote>
<p>《深入理解 Kafka：核心设计与实践原理》——朱忠华</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/07/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">Go 内存对齐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-07 18:24:33 / 修改时间：18:47:56" itemprop="dateCreated datePublished" datetime="2022-04-07T18:24:33+08:00">2022-04-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算-go-结构体占用的空间"><a href="#计算-go-结构体占用的空间" class="headerlink" title="计算 go 结构体占用的空间"></a>计算 go 结构体占用的空间</h1><p>在 go 中，可以使用 <code>unsafe.Sizeof</code> 计算出一个数据类型实例所占用的字节数。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type Args struct {
    num1 int
    num2 int
}

type Flag struct {
    num1 int16
    num2 int32
}

func main() {
    fmt.Println(unsafe.Sizeof(Args{}))
    fmt.Println(unsafe.Sizeof(Flag{}))
}</code></pre>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/07/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/" class="post-title-link" itemprop="url">一次内存泄漏的排查</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 18:19:15" itemprop="dateCreated datePublished" datetime="2022-04-07T18:19:15+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-03 22:13:34" itemprop="dateModified" datetime="2022-07-03T22:13:34+08:00">2022-07-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>我们有一款产品跟海外某个国家的客户有业务合作，因此，我们在这个国家的服务器上单独部署了一整套的服务（大概有八九个微服务），这些服务的宿主机大概都集中在三、四台宿主机上。这些服务日复一日，年复一年的并肩作战着，直到有一天……</p>
<h1 id="初见端倪"><a href="#初见端倪" class="headerlink" title="初见端倪"></a>初见端倪</h1><p>前阵子，我们在一个服务进行扩容、重启的时候，总是概率性的出现如下错误导致的 panic：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AB%AF%E5%8F%A3%E7%94%A8%E5%B0%BDpanic.jpg" alt="端口用尽panic"></p>
<p>Google 的结果是说由于 Linux 分配的客户端连接端口用尽，无法建立 socket 连接导致的。</p>
<p>这时候还有点懵逼，单纯以为是容器的宿主机有问题，于是，我重新在另外一台机器进行了节点扩容，这次很幸运，服务启动成功了，于是乎以为问题已经顺利解决，可以美美的下班了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/07/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Golang%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Golang%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Golang 常见问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-07 20:55:07 / 修改时间：21:40:23" itemprop="dateCreated datePublished" datetime="2021-11-07T20:55:07+08:00">2021-11-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-结构体是否可以比较，为什么？"><a href="#Go-结构体是否可以比较，为什么？" class="headerlink" title="Go 结构体是否可以比较，为什么？"></a>Go 结构体是否可以比较，为什么？</h1><p>Go 的结构体是否可以比较，需要视具体情况而定，在某些情况下是可以比较的，而某些情况下比较会不符合预期，甚至直接报错。</p>
<p>先来看看几个例子：</p>
<h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><pre><code class="go">type Value struct {
    Name   string
    Gender string
}

func main() {
    v1 := Value{Name: &quot;煎鱼&quot;, Gender: &quot;男&quot;}
    v2 := Value{Name: &quot;煎鱼&quot;, Gender: &quot;男&quot;}
    if v1 == v2 {
        fmt.Println(&quot;脑子进煎鱼了&quot;)
        return
    }

    fmt.Println(&quot;脑子没进煎鱼&quot;)
}</code></pre>
<p>声明了两个变量，分别是 v1 和 v2。其都是 <code>Value</code> 结构体的实例化，是同一个结构体的两个实例。</p>
<p>输出结果：</p>
<pre><code>脑子进煎鱼了</code></pre><p>在这里，结构体是可比较的。</p>
<h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>接下来继续改造上面的例子，在原本的结构体中增加了指针类型的引用。</p>
<p>第二个例子如下：</p>
<pre><code class="go">type Value struct {
    Name   string
    Gender *string
}

func main() {
    v1 := Value{Name: &quot;煎鱼&quot;, Gender: new(string)}
    v2 := Value{Name: &quot;煎鱼&quot;, Gender: new(string)}
    if v1 == v2 {
        fmt.Println(&quot;脑子进煎鱼了&quot;)
        return
    }

    fmt.Println(&quot;脑子没进煎鱼&quot;)
}</code></pre>
<p>这段程序输出的结果是：脑子没进煎鱼。</p>
<h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p>再尝试 string 数组类型：</p>
<pre><code class="go">type Value struct {
    Name   string
    GoodAt []string
}

func main() {
    v1 := Value{Name: &quot;煎鱼&quot;, GoodAt: []string{&quot;炸&quot;, &quot;煎&quot;, &quot;蒸&quot;}}
    v2 := Value{Name: &quot;煎鱼&quot;, GoodAt: []string{&quot;炸&quot;, &quot;煎&quot;, &quot;蒸&quot;}}
    if v1 == v2 {
        fmt.Println(&quot;脑子进煎鱼了&quot;)
        return
    }

    fmt.Println(&quot;脑子没进煎鱼&quot;)
}
</code></pre>
<p>这里程序会直接报错：</p>
<pre><code># command-line-arguments
./main.go:15:8: invalid operation: v1 == v2 (struct containing []string cannot be compared)</code></pre><h2 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h2><p>那不同结构体，相同的值内容呢，能否进行比较？</p>
<pre><code class="go">type Value1 struct {
    Name string
}

type Value2 struct {
    Name string
}
func main() {
    v1 := Value1{Name: &quot;煎鱼&quot;}
    v2 := Value2{Name: &quot;煎鱼&quot;}
    if v1 == v2 {
        fmt.Println(&quot;脑子进煎鱼了&quot;)
        return
    }

    fmt.Println(&quot;脑子没进煎鱼&quot;)
}</code></pre>
<p>显然，这种情况是会直接报错：</p>
<pre><code># command-line-arguments
./main.go:18:8: invalid operation: v1 == v2 (mismatched types Value1 and Value2)</code></pre><p>那是不是就完全没法比较了呢？并不，可以借助强制转换来实现：</p>
<pre><code class="go">if v1 == Value1(v2) {
  fmt.Println(&quot;脑子进煎鱼了&quot;)
  return
 }</code></pre>
<p>这样程序就会正常运行，且输出 “脑子进煎鱼了”。当然，若是不可比较类型，依然是不行的。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么 Go 结构体有的比较就是正常，有的就不行，甚至还直接报错了。难道是有什么 “潜规则” 吗？</p>
<p>在 Go 语言中，Go 结构体有时候并不能直接比较，<strong>当其基本类型包含：slice、map、function 时，是不能比较的</strong>。若强行比较，就会导致出现例子中的直接报错的情况。</p>
<p>而指针引用，其虽然都是 <code>new(string)</code>，从表象来看是一个东西，但其具体返回的地址是不一样的。</p>
<p>因此若要比较，则需改为：</p>
<pre><code class="go">func main() {
    gender := new(string)
    v1 := Value{Name: &quot;煎鱼&quot;, Gender: gender}
    v2 := Value{Name: &quot;煎鱼&quot;, Gender: gender}
    ...
}</code></pre>
<p>这样就可以保证两者的比较。如果被迫无奈，被要求一定要用结构体比较怎么办？</p>
<p>这时候可以使用反射方法 <code>reflect.DeepEqual</code>，如下：</p>
<pre><code class="go">func main() {
    v1 := Value{Name: &quot;煎鱼&quot;, GoodAt: []string{&quot;炸&quot;, &quot;煎&quot;, &quot;蒸&quot;}}
    v2 := Value{Name: &quot;煎鱼&quot;, GoodAt: []string{&quot;炸&quot;, &quot;煎&quot;, &quot;蒸&quot;}}
    if reflect.DeepEqual(v1, v2) {
        fmt.Println(&quot;脑子进煎鱼了&quot;)
        return
    }

    fmt.Println(&quot;脑子没进煎鱼&quot;)
}</code></pre>
<h2 id="例子五"><a href="#例子五" class="headerlink" title="例子五"></a>例子五</h2><p>再看一种特殊的例子：</p>
<pre><code class="go">type People struct {}

func main() {
 a := &amp;People{}
 b := &amp;People{}
 fmt.Println(a == b)
}</code></pre>
<p>这里的输出结果是： false。</p>
<p>再稍加改造一下：</p>
<pre><code class="go">type People struct {}

func main() {
 a := &amp;People{}
 b := &amp;People{}
 fmt.Printf(&quot;%p\n&quot;, a)
 fmt.Printf(&quot;%p\n&quot;, b)
 fmt.Println(a == b)
}</code></pre>
<p>输出结果是：true。</p>
<p>综合以上，总结的一个例子：</p>
<pre><code class="go">func main() {
 a := new(struct{})
 b := new(struct{})
 println(a, b, a == b)

 c := new(struct{})
 d := new(struct{})
 fmt.Println(c, d)
 println(c, d, c == d)
}</code></pre>
<p>输出的结果如下：</p>
<pre><code class="go">// a, b; a == b
0xc00005cf57 0xc00005cf57 false

// c, d
&amp;{} &amp;{}
// c, d, c == d
0x118c370 0x118c370 true</code></pre>
<p>第一段代码的结果是 false，第二段的结果是 true，且可以看到内存地址指向的完全一样，也就是排除了输出后变量内存指向改变导致的原因。</p>
<p>进一步来看，似乎是 <code>fmt.Print</code> 方法导致的，但一个标准库里的输出方法，会导致这种奇怪的问题？</p>
<p>这里其实跟内存的逃逸有关，对例子进行逃逸分析：</p>
<pre><code class="go">// 源代码结构
$ cat -n main.go
     5 func main() {
     6  a := new(struct{})
     7  b := new(struct{})
     8  println(a, b, a == b)
     9 
    10  c := new(struct{})
    11  d := new(struct{})
    12  fmt.Println(c, d)
    13  println(c, d, c == d)
    14 }

// 进行逃逸分析
$ go run -gcflags=&quot;-m -l&quot; main.go
# command-line-arguments
./main.go:6:10: a does not escape
./main.go:7:10: b does not escape
./main.go:10:10: c escapes to heap
./main.go:11:10: d escapes to heap
./main.go:12:13: ... argument does not escape</code></pre>
<p>通过分析可得知变量 a, b 均是分配在栈中，而变量 c, d 分配在堆中。</p>
<p>其关键原因是因为调用了 <code>fmt.Println</code> 方法，<strong>该方法内部是涉及到大量的反射相关方法的调用，会造成逃逸行为</strong>，也就是分配到堆上。</p>
<h3 id="关注第一个细节，就是-“为什么逃逸后，两个空-struct-会是相等的？"><a href="#关注第一个细节，就是-“为什么逃逸后，两个空-struct-会是相等的？" class="headerlink" title="关注第一个细节，就是 “为什么逃逸后，两个空 struct 会是相等的？"></a>关注第一个细节，就是 “为什么逃逸后，两个空 struct 会是相等的？</h3><p>这里主要与 Go runtime 的一个优化细节有关，如下：</p>
<pre><code class="go">// runtime/malloc.go
var zerobase uintptr</code></pre>
<p>变量 <code>zerobase</code> 是所有 0 字节分配的基础地址。更进一步来讲，就是空（0字节）的在进行了逃逸分析后，往堆分配的都会指向 <code>zerobase</code> 这一个地址。</p>
<p>所以空 struct 在逃逸后本质上指向了 <code>zerobase</code>，其两者比较就是相等的，返回了 true。</p>
<h3 id="为什么没逃逸不相等"><a href="#为什么没逃逸不相等" class="headerlink" title="为什么没逃逸不相等"></a>为什么没逃逸不相等</h3><p>关注第二个细节，就是 “为什么没逃逸前，两个空 struct 比较不相等？”。</p>
<p>这里其实是 Golang 团队有意而为之：</p>
<pre><code>This is an intentional language choice to give implementations flexibility in how they handle pointers to zero-sized objects. If every pointer to a zero-sized object were required to be different, then each allocation of a zero-sized object would have to allocate at least one byte. If every pointer to a zero-sized object were required to be the same, it would be different to handle taking the address of a zero-sized field within a larger struct.

Pointers to distinct zero-size variables may or may not be equal.</code></pre><p>因此 Go 团队这番操作，与 Go map 的随机性如出一辙，避免大家对这类逻辑的直接依赖，是值得思考的。</p>
<p>而在没逃逸的场景下，两个空 struct 的比较动作，你以为是真的在比较。实际上已经在代码优化阶段被直接优化掉，转为了 false。</p>
<p>因此，虽然在代码上看上去是 <code>==</code> 在做比较，实际上结果是 <code>a == b</code> 时就直接转为了 false，比都不需要比了。</p>
<p>既然我们知道了他是在代码优化阶段被优化的，那么相对的，知道了原理的我们也可以借助在 go 编译运行时的 gcflags 指令，让他不优化。</p>
<p>在运行前面的例子时，执行 <code>-gcflags=&quot;-N -l&quot;</code> 指令：</p>
<pre><code>$ go run -gcflags=&quot;-N -l&quot; main.go 
0xc000092f06 0xc000092f06 true
&amp;{} &amp;{}
0x118c370 0x118c370 true</code></pre><p>这时候，两个比较的结果都是 true 了。</p>
<p><strong>参考文档</strong>：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/HScH6nm3xf4POXVk774jUA" target="_blank" rel="noopener">手撕 Go 面试官：Go 结构体是否可以比较，为什么？</a></p>
<p><a href="https://mp.weixin.qq.com/s/QnMOwYUANdydbiM8yGznHA" target="_blank" rel="noopener">用 Go struct 不能犯的一个低级错误！</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/16/%E4%BD%BF%E7%94%A8channel%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/16/%E4%BD%BF%E7%94%A8channel%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">使用 channel 导致的死锁和内存泄漏问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-16 12:20:25 / 修改时间：12:20:42" itemprop="dateCreated datePublished" datetime="2021-10-16T12:20:25+08:00">2021-10-16</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用-channel-导致的死锁和内存泄漏问题"><a href="#使用-channel-导致的死锁和内存泄漏问题" class="headerlink" title="使用 channel 导致的死锁和内存泄漏问题"></a>使用 channel 导致的死锁和内存泄漏问题</h1><h2 id="死锁出现的条件"><a href="#死锁出现的条件" class="headerlink" title="死锁出现的条件"></a>死锁出现的条件</h2><p>死锁有三个必要条件他们分别是<strong>循环等待、资源共享、非抢占式</strong>，在 go 并发中出现通道死锁只有两种情况：</p>
<ol>
<li>数据要发送，但是没有人接收；</li>
<li>数据要接收，但是没有人发送；</li>
</ol>
<h2 id="发送单个值的死锁"><a href="#发送单个值的死锁" class="headerlink" title="发送单个值的死锁"></a>发送单个值的死锁</h2><p>在下面这种情况下，就会出现死锁的情况：</p>
<pre><code class="go">a := make(chan int)
a &lt;- 1   //将数据写入channel
z := &lt;-a //从channel中读取数据</code></pre>
<p>原因在于：</p>
<ul>
<li>有且只有一个协程时，无缓冲的通道</li>
<li>先发送会阻塞在发送，先接收会阻塞在接收处。</li>
<li>发送操作在接收者准备好之前是阻塞的，接收操作在发送之前是阻塞的。</li>
</ul>
<p>解决办法就是<strong>改为缓冲通道</strong>，或者<strong>使用协程配对</strong>。</p>
<h3 id="协程配对，先发送还是先接收无所谓只要配对就好"><a href="#协程配对，先发送还是先接收无所谓只要配对就好" class="headerlink" title="协程配对，先发送还是先接收无所谓只要配对就好"></a>协程配对，先发送还是先接收无所谓只要配对就好</h3><pre><code class="go">chanInt := make(chan int)
go func() {
    chanInt &lt;- 1
}()

res := &lt;-chanInt</code></pre>
<h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><pre><code class="go">chanInt := make(chan int,1)
chanInt &lt;- 2
res := &lt;-chanInt</code></pre>
<ul>
<li>缓冲通道内部的消息数量用 <code>len()</code> 函数可以测试出来</li>
<li>缓冲通道的容量可以用 <code>cap()</code> 测试出来</li>
<li>在满足 <code>cap&gt;len</code> 时候，因为没有满，发送不会阻塞</li>
<li>在 <code>len&gt;0</code> 时，因为不为空，所以接收不会阻塞</li>
</ul>
<p>使用缓冲通道可以让生产者和消费者减少阻塞的可能性，对异步操作更友好，不用等待对方准备，但是容量不应设置过大，不然会占用较多内存。</p>
<h2 id="多个值发送产生的死锁"><a href="#多个值发送产生的死锁" class="headerlink" title="多个值发送产生的死锁"></a>多个值发送产生的死锁</h2><p>配对可以让死锁消失，但如果发送多个值，这时候由于无法配对了，又会产生死锁：</p>
<pre><code class="go">func multipleDeathLock() {
 chanInt := make(chan int)
 defer close(chanInt)
 go func() {
  res := &lt;-chanInt
  fmt.Println(res)
 }()
 chanInt &lt;- 1
 chanInt &lt;- 1
}</code></pre>
<h3 id="循环接收值解决死锁"><a href="#循环接收值解决死锁" class="headerlink" title="循环接收值解决死锁"></a>循环接收值解决死锁</h3><p>循环来不断接收值，接受一个处理一个，可以解决上述的死锁问题，如下：</p>
<pre><code class="go">func multipleLoop() {
 chanInt := make(chan int)
 defer close(chanInt)
 go func() {
  for {
   //不使用ok会goroutine泄漏
   //res := &lt;-chanInt
   res,ok := &lt;-chanInt
   if !ok {
                 break
            }
   fmt.Println(res)
  }
 }()
 chanInt &lt;- 1
 chanInt &lt;- 1
}</code></pre>
<ul>
<li>给通道的接收加上二个值，<code>ok</code> 代表通道是否正常，如果是关闭则为<code>false</code>值</li>
<li>如果不使用 ok 判断，会输出 <code>1 1 0 0 0</code> 这样的数列，因为关闭是需要时间的，而循环接收关闭的通道拿到的是 <code>0</code>，另外还会导致<code>goroutine</code>泄漏（后面讲到）</li>
</ul>
<h3 id="先接收还是先发送"><a href="#先接收还是先发送" class="headerlink" title="先接收还是先发送"></a>先接收还是先发送</h3><p>在上面的例子中，使用的是先开一个协程来接收，再进行发送的过程。如果反过来，在协程中进行发送：</p>
<pre><code class="go">func multipleDeathLock2() {
 chanInt := make(chan int)
 defer close(chanInt)
 go func() {
  chanInt &lt;- 1
  chanInt &lt;- 2
 }()
 for {
  res, ok := &lt;-chanInt
  if !ok {
   break
  }
  fmt.Println(res)
 }
}</code></pre>
<p>此时运行程序会导致死锁：</p>
<pre><code class="go">1
2
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.multipleDeathLock2()</code></pre>
<ul>
<li>出现上面的结果是因为 <code>for</code> 循环一直在获取通道中的值，但是在读取完 <code>1 2</code> 后，通道中没有新的值传入，而且此时不会执行  <code>defer close(chanInt)</code>，这样接收者就阻塞了。</li>
<li>为什么先接收再发送可以，因为<strong>发送提前结束后会触发函数的 <code>defer</code> 自动关闭通道</strong></li>
<li>所以<strong>应该总是先接收后发送，并由发送端来关闭</strong></li>
</ul>
<h2 id="goroutine-泄漏"><a href="#goroutine-泄漏" class="headerlink" title="goroutine 泄漏"></a>goroutine 泄漏</h2><p><code>goroutine</code> 终止的场景有三个：</p>
<ul>
<li>当一个 <code>goroutine</code> 完成了它的工作</li>
<li>由于发生了没有处理的错误</li>
<li>有其他的协程告诉它终止</li>
</ul>
<p>当三个条件都没有满足时，<code>goroutine</code> 就会一直运行下去。</p>
<pre><code class="go">func goroutineLeak() {
 chanInt := make(chan int)
 defer close(chanInt)
 go func() {
  for {
   res := &lt;-chanInt
   //res,ok := &lt;-chanInt
   //if !ok {
            //     break
            //}
   fmt.Println(res)
  }
 }()
 chanInt &lt;- 1
 chanInt &lt;- 1
}</code></pre>
<p>上面程序运行后，后面会一直打印 0 ：</p>
<pre><code>1
1
0
0
0
...</code></pre><ul>
<li>上面的 <code>goroutineLeak()</code> 函数结束后触发 <code>defer close(chanInt)</code> 关闭了通道</li>
<li>但是匿名函数中 <code>goroutine</code> 并没有关闭，而是一直在循环取值，并且取到的是关闭后的通道值（这里是 <code>int</code> 的默认值 0）</li>
<li><code>goroutine</code> 会永远运行下去，如果以后再次使用又会出现新的泄漏！导致内存、<code>cpu</code>占用越来越多。</li>
</ul>
<p>假如不关闭且外部没有写入值，那接收处就会永远阻塞在那里，连输出都不会有：</p>
<pre><code class="go">func goroutineLeakNoClosed() {
 chanInt := make(chan int)
 go func() {
  for {
   res := &lt;-chanInt
   fmt.Println(res)
  }
 }()
}</code></pre>
<ul>
<li>无任何输出的阻塞</li>
<li>换成写入也是一样的</li>
<li>如果是有缓冲的通道，换成已满的通道写没有读；或者换成向空的通道读没有写也是同样的情况</li>
<li>除了阻塞，<code>goroutine</code>进入死循环也是泄露的原因</li>
</ul>
<p>要发现死锁，可以通过 pprof 工具。</p>
<p><strong>参考文章</strong>：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/fxJeMfHFNZRhC2JP3SP1XQ" target="_blank" rel="noopener">面试高频：Go语言死锁与goroutine泄露问题谈论</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/29/go%20http%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/go%20http%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">go http 库 Connection reset by peer 解决</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-29 16:48:10" itemprop="dateCreated datePublished" datetime="2021-08-29T16:48:10+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 19:04:15" itemprop="dateModified" datetime="2022-04-07T19:04:15+08:00">2022-04-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Connection-reset-by-peer"><a href="#Connection-reset-by-peer" class="headerlink" title="Connection reset by peer"></a>Connection reset by peer</h1><p>最近使用go 中 http 包的默认服务端发起 get 请求，个别请求出现了：<code>Connection reset by peer</code> 的错误。大致的报错长这个样子：</p>
<pre><code>read tcp xx.xxx.xxx.xxx:xx-&gt;xx.xxx.xxx.xxx:xx: read: connection reset by peer</code></pre><p>在网上查找了一些资料，这里归结使用 http 包的注意事项以及上述错误出现的原因。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/29/go%20http%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Go%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Go%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go 如何进行单元测试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-25 20:11:50" itemprop="dateCreated datePublished" datetime="2021-07-25T20:11:50+08:00">2021-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-29 16:23:35" itemprop="dateModified" datetime="2021-08-29T16:23:35+08:00">2021-08-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前了解了 gomock 的一些基本使用技巧，但是对于单元测试这一 part 一直都是云里雾里，借着最近正好工作上要求写单测，学习一下 go 语言如何进行单元测试。</p>
<h1 id="单元测试的含义"><a href="#单元测试的含义" class="headerlink" title="单元测试的含义"></a>单元测试的含义</h1><p>单元测试通常来讲是对代码中的某一个功能单元进行测试，这里的单元可能是一个函数，也可能对应实际业务需求的某一小块功能。通过单元测试，可以检测我们的代码在某一单元功能里存在的问题，减少 bug 的产生。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/25/Go%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/" class="post-title-link" itemprop="url">go template 库（模板）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-14 19:29:00" itemprop="dateCreated datePublished" datetime="2021-07-14T19:29:00+08:00">2021-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-31 00:28:29" itemprop="dateModified" datetime="2021-08-31T00:28:29+08:00">2021-08-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>模板能够分离数据和逻辑，使得逻辑变得简洁清晰，同时提高复用率。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="模板引擎结构图"></p>
<p>模板引擎按照功能可以划分为两种类型：</p>
<ul>
<li><strong>无逻辑模板引擎</strong>：此类模板引擎只进行字符串的替换，无其它逻辑；</li>
<li><strong>嵌入逻辑模板引擎</strong>：此类模板引擎可以在模板中嵌入逻辑，实现流程控制/循环等。</li>
</ul>
<p>这两类模板引擎都比较极端。无逻辑模板引擎需要在处理器中额外添加很多逻辑用于生成替换的文本。而嵌入逻辑模板引擎则在模板中混入了大量逻辑，导致维护性较差。实用的模板引擎一般介于这两者之间。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/14/go%20template%E5%BA%93%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/29/gomock%20%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/29/gomock%20%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">gomock 使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 09:41:52" itemprop="dateCreated datePublished" datetime="2021-06-29T09:41:52+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-03 10:24:44" itemprop="dateModified" datetime="2021-07-03T10:24:44+08:00">2021-07-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>gomock 是 Go 官方的模拟框架，可以与 go 的 test 很好的集成。在实际项目中，当需要进行单元测试时，往往会有很多的依赖项，有些依赖可能还没有办法直接进行创建，例如数据库连接，文件 I/O 等。此时通过使用 go mock 可以模拟依赖项，简化测试。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/29/gomock%20%E4%BD%BF%E7%94%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/21/go%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/21/go%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">go 常用关键字的原理及设计</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-21 09:55:34" itemprop="dateCreated datePublished" datetime="2021-06-21T09:55:34+08:00">2021-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-16 12:16:54" itemprop="dateModified" datetime="2021-10-16T12:16:54+08:00">2021-10-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="for-和-range"><a href="#for-和-range" class="headerlink" title="for 和 range"></a>for 和 range</h1><p>循环是几乎所有编程语言都具有的控制结构，也是编程语言中常用的控制结构，Go 语言除了使用经典的三段式循环之外，还引入了另一个关键字 <code>range</code> 用于快速遍历数组、哈希表以及 Channel 等元素。</p>
<p>这里主要记录 Go 语言中的两种不同循环，也就是经典的 for 循环和 for…range 循环，分析这两种循环在运行时的结构以及它们的实现原理。</p>
<p>for 循环和 for…range 循环的形式分别如下：</p>
<pre><code class="go">func main() {
    // for 循环
    for i := 0; i &lt; 10; i++ {
        println(i)
    }

    // for range 循环
    arr := []int{1, 2, 3}
    for i, _ := range arr {
        println(i)
    }
}</code></pre>
<p>在汇编语言中，无论是经典的 for  循环还是 for-range 循环都会使用 <code>JMP</code> 等命令跳回循环体的开始位置复用代码，所以<strong>使用 for…range 语法的控制结构最终应该也会被 Go 语言的编译器转换成普通的 for 循环</strong>。</p>
<p>接下来将逐个分析每一种循环的场景。</p>
<h2 id="for-经典循环"><a href="#for-经典循环" class="headerlink" title="for 经典循环"></a>for 经典循环</h2><p>Go 语言中的for 经典循环在编译器看来就是一个 <code>OFOR</code> 类型的节点，这个节点具有以下的结构：</p>
<pre><code class="go">for Ninit; Left; Right {
    NBody
}</code></pre>
<p>其中包括初始化循环的 <code>Ninit</code>、循环的中止条件 <code>Left</code>、循环体结束时执行的 <code>Right</code> 表达式以及循环体 <code>NBody</code>。</p>
<p>一个常见的 for 循环代码会被 <code>stmt</code> 方法转换成以下的控制结构，其中包含了 4 个不同的块，这些不同的代码块之间会通过边去连接，与我们理解的 for 循环控制结构其实没有太多的差别。</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%E7%BB%8F%E5%85%B8%E5%BE%AA%E7%8E%AF.webp" alt="go经典循环"></p>
<h2 id="for-range-范围循环"><a href="#for-range-范围循环" class="headerlink" title="for-range 范围循环"></a>for-range 范围循环</h2><p>范围循环在 go 中更为常见，它会使用 <code>for</code> 和 <code>range</code> 两个关键字，<strong>编译器会在编译期间将带有 <code>range</code> 的循环变成普通的经典循环，也就是将 <code>ORANGE</code> 类型的节点转换成 <code>OFOR</code> 类型</strong>。所有的 <code>range</code> 都会被 <code>walkrange</code> 函数转换成只包含基本表达式的语句，不包含任何复杂的结构。</p>
<p>下面分别分析每一种结构下的循环场景。</p>
<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>对于数组和切片来说，for-range 循环有三种不同的遍历方式，这三种不同的遍历方式会在 <code>walkrange</code> 函数中被转换成不同的控制逻辑，这三种不同的逻辑分别对应着代码中的不同条件。</p>
<h4 id="清空数组和切片"><a href="#清空数组和切片" class="headerlink" title="清空数组和切片"></a>清空数组和切片</h4><p>当想要清空数组或者哈希表等结构时，通常会使用遍历清除的方式：</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    for i, _ := range arr {
        arr[i] = 0
    }
}</code></pre>
<p>依次遍历切片和哈希是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以<strong>最快的方法是直接清空这片内存中的内容</strong>。<strong>在 go 的编译器中，针对这种情况，编译器会直接使用 <code>memclrNoHeapPointers</code> 直接清空切片中的数据</strong>。</p>
<p>在 <code>walkrange</code> 最开始的逻辑就是数组和切片的清空逻辑：</p>
<pre><code class="go">func walkrange(n *Node) *Node {
    switch t.Etype {
    case TARRAY, TSLICE:
        if arrayClear(n, v1, v2, a) {
            return n
        }</code></pre>
<p><code>arrayClear</code> 是一个非常有趣的优化，当在 Go 语言中遍历去删除所有的元素时，其实会在这个函数中被优化成如下的代码：</p>
<pre><code class="go">// 原代码
for i := range a {
    a[i] = zero
}

// 优化后
if len(a) != 0 {
    hp = &amp;a[0]
    hn = len(a)*sizeof(elem(a))
    memclrNoHeapPointers(hp, hn)
    i = len(a) - 1
}</code></pre>
<p>相比于依次清除数组或者切片中的数据，Go 语言会直接使用 <code>memclrNoHeapPointers</code> 或者 <code>memclrHashPointers</code> 函数直接清除目标数组对应内存空间中的数据并在执行完成后更新用于遍历数组的索引，保证上下文不会出现问题，这也印证了我们在概述一节中观察到的现象。</p>
<h4 id="for-range-a-遍历数组和切片"><a href="#for-range-a-遍历数组和切片" class="headerlink" title="for range a {} 遍历数组和切片"></a><code>for range a {}</code> 遍历数组和切片</h4><p>在处理了上面清空这种特殊的情况之后，继续回到 <code>ORANGE</code> 节点的处理过程了，在这里首先会设置 for 循环的 <code>Left</code> 和 <code>Right</code> 字段，也就是终止的条件和循环体每次执行结束后运行的代码：</p>
<pre><code class="go">        ha := a

        hv1 := temp(types.Types[TINT])
        hn := temp(types.Types[TINT])

        init = append(init, nod(OAS, hv1, nil))
        init = append(init, nod(OAS, hn, nod(OLEN, ha, nil)))

        n.Left = nod(OLT, hv1, hn)
        n.Right = nod(OAS, hv1, nod(OADD, hv1, nodintconst(1)))

        if v1 == nil {
            break
        }</code></pre>
<p>如果循环是 <code>for range a {}</code>，那么就满足了上述代码中的条件 <code>v1 == nil</code>，即循环不关心数组的索引和数据，在这种情况下只是单纯的遍历，并不关心索引和数据的情况，那么它会被转换成如下所示的代码：</p>
<pre><code class="go">ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
for ; hv1 &lt; hn; hv1++ {
    // ...
}</code></pre>
<p>这其实是最简单的 <code>range</code> 结构在编译期间被转换后的形式，由于原代码其实并不需要数组中任何元素的信息，只需要使用数组或者切片的数量执行对应次数的循环。</p>
<h4 id="for-i-range-a-遍历数组和切片"><a href="#for-i-range-a-遍历数组和切片" class="headerlink" title="for i := range a {} 遍历数组和切片"></a><code>for i := range a {}</code> 遍历数组和切片</h4><p>如果我们只需要使用遍历数组时的索引就会执行如下的代码：</p>
<pre><code class="go">        if v2 == nil {
            body = []*Node{nod(OAS, v1, hv1)}
            break
        }</code></pre>
<p>它会将类似 <code>for i := range a {}</code> 的结构转换成如下所示的逻辑，与第一种循环相比，这种循环额外地在循环体中添加了 <code>v1 := hv1</code> 用于传递遍历数组时的索引：</p>
<pre><code class="go">ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
for ; hv1 &lt; hn; hv1++ {
    v1 := hv1
    // ...
}</code></pre>
<h4 id="for-i-elem-range-a-遍历数组和切片"><a href="#for-i-elem-range-a-遍历数组和切片" class="headerlink" title="for i, elem := range a {} 遍历数组和切片"></a><code>for i, elem := range a {}</code> 遍历数组和切片</h4><p>这种场景下需要同时获取索引和值，也是最常用的一种场景，处理这种情况在 <code>walkrange</code> 中使用如下代码：</p>
<pre><code class="go">    tmp := nod(OINDEX, ha, hv1)
        tmp.SetBounded(true)
        a := nod(OAS2, nil, nil)
        a.List.Set2(v1, v2)
        a.Rlist.Set2(hv1, tmp)
        body = []*Node{a}
    }
    n.Ninit.Append(init...)
    n.Nbody.Prepend(body...)

    return n
}</code></pre>
<p>这段代码处理的就是类似 <code>for i, elem := range a {}</code> 的逻辑，它不止会在循环体中插入更新索引的表达式，还会插入赋值的操作让循环体内部的代码能够访问数组中的元素：</p>
<pre><code class="go">ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
v2 := nil
for ; hv1 &lt; hn; hv1++ {
    tmp := ha[hv1]
    v1, v2 = hv1, tmp
    ...
}</code></pre>
<p>对于所有的 range 循环，<strong>Go 语言都会在编译期将原切片或者数组赋值给一个新变量 <code>ha</code>，在赋值的过程中就发生了拷贝</strong>，而我们又通过 <code>len</code> 关键字预先获取了切片的长度，所以此时遍历的切片其实已经不是原有的切片变量了。</p>
<p>下面的这个例子中，在每次循环中都往数组中加入的变量，以此试图构建一个永不停止的循环，然而<strong>实际上该循环只会循环三次</strong>，原因就是编译期间传入循环的是 arr 的一个拷贝，并不是当前实时的 arr，所以在循环中追加新的元素也不会改变循环执行的次数。</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    for _, v := range arr {
        arr = append(arr, v)
    }
    fmt.Println(arr)
}

$ go run main.go
1 2 3 1 2 3</code></pre>
<p>遇到这种同时遍历索引和元素的 <code>range</code> 循环时，从上面的代码中可以看到，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代中都被重新赋值，在赋值时也发生了拷贝</strong>。</p>
<p>在下面的代码中，在一个循环中将 range 返回的变量值的地址赋值给另外一个新数组，当打印这个新数组中变量地址的值的时候，实际上这个新数组中的值都是老数组的最后一个值。</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    newArr := []*int{}
    for _, v := range arr {
        newArr = append(newArr, &amp;v)
    }
    for _, v := range newArr {
        fmt.Println(*v)
    }
}

$ go run main.go
3 3 3</code></pre>
<p>在这种场景下，<strong>正确的做法应该是使用 <code>&amp;arr[i]</code> 替代 <code>&amp;v</code></strong>。</p>
<p>所以如果想要访问数组中元素所在的地址，不应该直接获取 <code>range</code> 返回的 <code>v2</code> 变量的地址 <code>&amp;v2</code>，想要解决这个问题应该使用 <code>&amp;a[index]</code> 这种方式获取数组中元素对应的地址。</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    newArr := []*int{}
    for i, _ := range arr {
        newArr = append(newArr, &amp;arr[i])
    }
    for _, v := range newArr {
        fmt.Println(*v)
    }
}</code></pre>
<p>在遇到这种问题时，应该使用如上所示的代码来获取数组中元素的地址，而不应该使用编译器生成的、会被复用的临时变量。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 的遍历详细在这里：<a href="https://xiaoming.net.cn/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/#%E9%81%8D%E5%8E%86-map" target="_blank" rel="noopener">map 遍历</a></p>
<p>总的来说，哈希表的遍历会随机选择开始的位置，然后依次遍历桶中的元素，桶中元素如果被遍历完，就会遍历当前桶对应的溢出桶，溢出桶都遍历结束之后才会遍历哈希中的下一个桶，直到所有的桶都被遍历完成。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串的遍历与数组和哈希表非常相似，只是在遍历的过程中会获取字符串中索引对应的字节，然后将字节转换成 <code>rune</code>，我们在遍历字符串时拿到的值都是 <code>rune</code> 类型的变量，其实类似 <code>for i, r := range s {}</code> 的结构都会被转换成如下的形式：</p>
<pre><code class="go">ha := s
for hv1 := 0; hv1 &lt; len(ha); {
    hv1t := hv1
    hv2 := rune(ha[hv1])
    if hv2 &lt; utf8.RuneSelf {
        hv1++
    } else {
        hv2, hv1 = decoderune(h1, hv1)
    }
    v1, v2 = hv1t, hv2
}</code></pre>
<p>这段代码的框架与上面提到的数组和哈希其实非常相似，只是细节有一些不同。<strong>字符串其实就是一个只读的字节数组切片</strong>，所以使用下标访问字符串中的元素时其实得到的就是字节，但是这段代码会将当前的字节转换成 <code>rune</code> 类型，如果当前的 <code>rune</code> 是 ASCII 的，那么只会占用一个字节长度，这时只需要将索引加一，但是如果当前的 <code>rune</code> 占用了多个字节就会使用 <code>decoderune</code> 进行解码，具体的过程就不详细介绍了。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>在 <code>range</code> 循环中使用 Channel 其实也是比较常见的做法，一个形如 <code>for v := range ch {}</code> 的表达式会最终被转换成如下的格式：</p>
<pre><code class="go">ha := a
hv1, hb := &lt;-ha
for ; hb != false; hv1, hb = &lt;-ha {
    v1 := hv1
    hv1 = nil
    // ...
}</code></pre>
<p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <code>runtime.chanrecv2</code> 并阻塞当前的协程，当 <code>runtime.chanrecv2</code> 返回时会根据布尔值 <code>hb</code> 判断当前的值是否存在：</p>
<ul>
<li>如果不存在当前值，意味着当前的管道已经被关闭；</li>
<li>如果存在当前值，会为 <code>v1</code> 赋值并清除 <code>hv1</code> 变量中的数据，然后重新陷入阻塞等待新数据；</li>
</ul>
<h2 id="常见现象总结"><a href="#常见现象总结" class="headerlink" title="常见现象总结"></a>常见现象总结</h2><h3 id="永不停止的循环"><a href="#永不停止的循环" class="headerlink" title="永不停止的循环"></a>永不停止的循环</h3><p>下面的代码中，在每次循环中都往数组中加入的变量，以此试图构建一个永不停止的循环，然而<strong>实际上该循环只会循环三次</strong>。</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    for _, v := range arr {
        arr = append(arr, v)
    }
    fmt.Println(arr)
}

$ go run main.go
1 2 3 1 2 3</code></pre>
<h3 id="循环中的指针赋值"><a href="#循环中的指针赋值" class="headerlink" title="循环中的指针赋值"></a>循环中的指针赋值</h3><p>在下面的代码中，在一个循环中将 range 返回的变量值的地址赋值给另外一个新数组，当打印这个新数组中变量地址的值的时候，实际上这个新数组中的值都是老数组的最后一个值。</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    newArr := []*int{}
    for _, v := range arr {
        newArr = append(newArr, &amp;v)
    }
    for _, v := range newArr {
        fmt.Println(*v)
    }
}

$ go run main.go
3 3 3</code></pre>
<p>在这种场景下，<strong>正确的做法应该是使用 <code>&amp;arr[i]</code> 替代 <code>&amp;v</code></strong>。</p>
<h3 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h3><p>当想要清空数组或者哈希表等结构时，通常会使用遍历清除的方式：</p>
<pre><code class="go">func main() {
    arr := []int{1, 2, 3}
    for i, _ := range arr {
        arr[i] = 0
    }
}</code></pre>
<p>依次遍历切片和哈希是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以<strong>最快的方法是直接清空这片内存中的内容</strong>。<strong>在 go 的编译器中，针对这种情况，编译器会直接使用 <code>memclrNoHeapPointers</code> 直接清空切片中的数据</strong>。</p>
<h3 id="随机遍历"><a href="#随机遍历" class="headerlink" title="随机遍历"></a>随机遍历</h3><p>当遍历 map 结构时，每次遍历出来的结果的顺序都是不确定的，这是 Go 故意设计的，为了提高这种不确定性，go 甚至还做了一些工作，以此告诉所有使用 Go 语言的开发者不要依赖于哈希遍历的稳定。</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>defer 主要用来做一些收尾的工作，例如关闭文件描述符、关闭数据库连接以及释放资源等。</p>
<p>在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在 defer 定义时就把值传递给 defer，并被 cache 起来；<strong>作为闭包引用的话，则会在 defer 函数真正调用时根据整个上下文确定当前的值</strong>。</p>
<p>defer 后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。</p>
<h2 id="defer-的相关使用问题"><a href="#defer-的相关使用问题" class="headerlink" title="defer 的相关使用问题"></a>defer 的相关使用问题</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><pre><code class="go">func deferFuncParameter() {
    var aInt = 1

    defer fmt.Println(aInt)

    aInt = 2
    return
}</code></pre>
<blockquote>
<p>输出 1。延迟函数 <code>fmt.Println(aInt)</code> 的参数在 defer 语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数。</p>
</blockquote>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><pre><code class="go">package main

import &quot;fmt&quot;

func printArray(array *[3]int) {
    for i := range array {
        fmt.Println(array[i])
    }
}

func deferFuncParameter() {
    var aArray = [3]int{1, 2, 3}

    defer printArray(&amp;aArray)

    aArray[0] = 10
    return
}

func main() {
    deferFuncParameter()
}</code></pre>
<blockquote>
<p>输出10、2、3三个值。延迟函数printArray()的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。</p>
</blockquote>
<h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><pre><code class="go">func deferFuncReturn() (result int) {
    i := 1

    defer func() {
       result++
    }()

    return i
}</code></pre>
<blockquote>
<p>函数输出 2。函数的 return 语句并不是原子的，实际执行分为设置返回值–&gt;ret，defer 语句实际执行在返回前，即拥有 defer 的函数返回过程是：设置返回值–&gt;执行defer–&gt;ret。所以 return 语句先把 result 设置为i的值，即1，defer语句中又把result递增1，所以最终返回2。</p>
</blockquote>
<h3 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h3><pre><code class="go">func f() (r int) {
  defer func(r int) {
        r = r + 5
  }(r)
  return 1
}</code></pre>
<blockquote>
<p>根据上述 return 规则拆解，所以得到的结果是 1</p>
</blockquote>
<pre><code class="go">func f() (r int) {
      t := 5
      // 1. 赋值指令
      r = t
      // 2. defer 被插入到赋值与返回之间执行，这里 r 是传值
      func (r int) {
            r = r + 5
    }(r)
      // 3. 空的 return
      return
}</code></pre>
<h2 id="defer使用时的注意事项"><a href="#defer使用时的注意事项" class="headerlink" title="defer使用时的注意事项"></a>defer使用时的注意事项</h2><h3 id="defer-的执行时机"><a href="#defer-的执行时机" class="headerlink" title="defer 的执行时机"></a>defer 的执行时机</h3><pre><code class="go">func main() {
    {
        defer fmt.Println(&quot;defer runs&quot;)
        fmt.Println(&quot;block ends&quot;)
    }

    fmt.Println(&quot;main ends&quot;)
}

$ go run main.go
block ends
main ends
defer runs</code></pre>
<p><code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p>
<h3 id="预计算参数：defer-语句的参数在它出现时就已经确定下来"><a href="#预计算参数：defer-语句的参数在它出现时就已经确定下来" class="headerlink" title="预计算参数：defer 语句的参数在它出现时就已经确定下来"></a>预计算参数：defer 语句的参数在它出现时就已经确定下来</h3><pre><code class="go">func main() {
    startedAt := time.Now()
    defer fmt.Println(time.Since(startedAt))

    time.Sleep(time.Second)
}

$ go run main.go
0s</code></pre>
<p>当调用 <code>defer</code> 关键字时，它会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p>
<p>想要解决这个问题，只需要向 <code>defer</code> 关键字传入匿名函数：</p>
<pre><code class="go">func main() {
    startedAt := time.Now()
    defer func() { fmt.Println(time.Since(startedAt)) }()

    time.Sleep(time.Second)
}

$ go run main.go
1s</code></pre>
<p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前调用并打印出符合预期的结果。</p>
<p>注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer 后面的语句对变量的修改可能会影响延迟函数。</p>
<h3 id="延迟函数执行按后进先出的顺序执行"><a href="#延迟函数执行按后进先出的顺序执行" class="headerlink" title="延迟函数执行按后进先出的顺序执行"></a>延迟函数执行按后进先出的顺序执行</h3><p>定义 defer 类似于入栈操作，执行 defer 类似于出栈操作。</p>
<p>设计 defer 的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请 A 资源，再跟据 A 资源申请 B 资源，跟据 B 资源申请 C 资源，即申请顺序是: A–&gt;B–&gt;C，释放时往往又要反向进行。这就是把 deffer 设计成 FIFO 的原因。</p>
<p>每申请到一个用完需要释放的资源时，立即定义一个 defer 来释放资源是个很好的习惯。</p>
<h3 id="defer-可能操作主函数的具名返回值"><a href="#defer-可能操作主函数的具名返回值" class="headerlink" title="defer 可能操作主函数的具名返回值"></a>defer 可能操作主函数的具名返回值</h3><p>定义 defer 的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer 所作用的函数可能会影响到返回值。</p>
<p>若要理解延迟函数是如何影响主函数返回值的，需要明白函数是如何返回的。</p>
<h4 id="函数的返回过程"><a href="#函数的返回过程" class="headerlink" title="函数的返回过程"></a>函数的返回过程</h4><p>关键字 <code>return</code> 不是一个原子操作，实际上 <code>return</code> 只代理汇编指令 <code>ret</code>，即将跳转程序执行。比如语句<code>return i</code>，实际上分两步进行：</p>
<ol>
<li>将 i 值存入栈中作为返回值</li>
<li>然后执行跳转</li>
</ol>
<p>而 defer 的执行时机正是跳转前，所以说 defer 执行时还是有机会操作返回值的。例如下面这个例子：</p>
<pre><code class="go">func deferFuncReturn() (result int) {
    i := 1

    defer func() {
       result++
    }()

    return i
}</code></pre>
<p>该函数的 return 语句可以拆分成下面两行：</p>
<pre><code class="go">result = i
return</code></pre>
<p>而延迟函数的执行正是在return之前，即加入defer后的执行过程如下：</p>
<pre><code class="go">result = i
result++
return</code></pre>
<p>所以上面函数实际返回 i++ 值。</p>
<p>关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把 return 语句拆开都可以很好的理解。下面还有几个例子。</p>
<h4 id="主函数拥有匿名返回值，返回字面值"><a href="#主函数拥有匿名返回值，返回字面值" class="headerlink" title="主函数拥有匿名返回值，返回字面值"></a>主函数拥有匿名返回值，返回字面值</h4><p>一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回”1”、”2”、”Hello”这样的值，这种情况下 defer 语句是无法操作返回值的。</p>
<p>一个返回字面值的函数，如下所示：</p>
<pre><code class="go">func foo() int {
    var i int

    defer func() {
        i++
    }()

    return 1
}</code></pre>
<p>上面的 return 语句，直接把 1 写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。</p>
<h4 id="主函数拥有匿名返回值，返回变量"><a href="#主函数拥有匿名返回值，返回变量" class="headerlink" title="主函数拥有匿名返回值，返回变量"></a>主函数拥有匿名返回值，返回变量</h4><p>一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下 defer 语句可以引用到返回值，但不会改变返回值。</p>
<p>一个返回本地变量的函数，如下所示：</p>
<pre><code class="go">func foo() int {
    var i int

    defer func() {
        i++
    }()

    return i
}</code></pre>
<p>上面的函数，返回一个局部变量，同时 defer 函数也会操作这个局部变量。对于匿名返回值来说，<strong>可以假定仍然有一个变量存储返回值</strong>，假定返回值变量为 “anony”，上面的返回语句可以拆分成以下过程：</p>
<pre><code class="go">anony = i
i++
return</code></pre>
<p>由于 i 是整型，会将值拷贝给 anony，所以 defer 语句中修改i值，对函数返回值不造成影响。</p>
<h4 id="主函数拥有具名返回值"><a href="#主函数拥有具名返回值" class="headerlink" title="主函数拥有具名返回值"></a>主函数拥有具名返回值</h4><p>主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果 defer 语句操作该返回值，可能会改变返回结果。</p>
<p>一个影响函返回值的例子：</p>
<pre><code class="go">func foo() (ret int) {
    defer func() {
        ret++
    }()
    return 0
}</code></pre>
<p>上面的函数拆解出来，如下所示：</p>
<pre><code class="go">ret = 0
ret++
return</code></pre>
<p>函数真正返回前，在 defer 中对返回值做了+1操作，所以函数最终返回 1。</p>
<h2 id="defer-数据结构"><a href="#defer-数据结构" class="headerlink" title="defer 数据结构"></a>defer 数据结构</h2><p><code>defer</code> 在 Go 语言源代码中的数据结构如下：</p>
<pre><code class="go">type _defer struct {
    siz       int32    // 参数和结果的内存大小
    started   bool    
    openDefer bool    // 当前 defer 是否经过开放编码的优化
    sp        uintptr    // 函数栈指针
    pc        uintptr // 调用方的程序计数器
    fn        *funcval // defer 关键字中传入的参数，也就是 defer 后面的函数地址
    _panic    *_panic    // 触发延迟调用的结构体，可能为空
    link      *_defer
}</code></pre>
<p><code>_defer</code> 结构体是延迟调用链表上的一个节点，所有的结构体都会通过 <code>link</code> 字段串联成链表。</p>
<p>下图展示了一个 goroutine 定义多个 defer 的场景：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%80%E4%B8%AA%20goroutine%20%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%20defer.jpg" alt="一个 goroutine 定义多个 defer"></p>
<p>新声明的 defer 总是添加到链表头部，函数返回前执行 defer 则是从链表首部依次取出执行。一个 goroutine 可能连续调用多个函数，defer 添加过程跟上述流程一致，进入函数时添加 defer，离开函数时取出 defer，所以即便调用多个函数，也总是能保证 defer 是按 FIFO 方式执行的。</p>
<h2 id="defer-执行机制"><a href="#defer-执行机制" class="headerlink" title="defer 执行机制"></a>defer 执行机制</h2><p><code>defer</code> 会根据条件的不同，使用三种不同的机制处理该关键字：</p>
<pre><code class="go">func (s *state) stmt(n *Node) {
    ...
    switch n.Op {
    case ODEFER:
        if s.hasOpenDefers {
            s.openDeferRecord(n.Left) // 开放编码
        } else {
            d := callDefer // 堆分配
            if n.Esc == EscNever {
                d = callDeferStack // 栈分配
            }
            s.callResult(n.Left, d)
        }
    }
}</code></pre>
<p>堆上分配 <code>_defer</code> 结构体是默认的兜底方案，当使用这种方式时，<code>defer</code> 在编译器看来也是函数调用。</p>
<p>当 <code>defer</code> 关键字在函数体中最多执行一次的时候，会将 <code>_defer</code> 结构体分配到栈上，以此节约内存分配带来的开销。</p>
<p>开放编码的方式时在 1.14 引入的使用代码内联优化 <code>defer</code> 关键的额外开销。开放编码作为一种优化 <code>defer</code> 关键字的方法，它不是在所有的场景下都会开启的，开放编码只会在满足以下的条件时启用：</p>
<ol>
<li>函数的 <code>defer</code> 数 量少于或者等于 8 个；</li>
<li>函数的 <code>defer</code> 关键字不能在循环中执行；</li>
<li>函数的 <code>return</code> 语句与 <code>defer</code> 语句的乘积小于或者等于 15 个；</li>
</ol>
<h1 id="make-和-new"><a href="#make-和-new" class="headerlink" title="make 和 new"></a>make 和 new</h1><p><code>make</code> 的作用是初始化内置的数据结构，也就是切片、哈希表和 Channel</p>
<p>在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：</p>
<pre><code class="go">slice := make([]int, 0, 100)
hash := make(map[int]bool, 10)
ch := make(chan int, 5)</code></pre>
<ol>
<li><code>slice</code> 是一个包含 <code>data</code>、<code>cap</code> 和 <code>len</code> 的结构体 <code>reflect.SliceHeader</code></li>
<li><code>hash</code> 是一个指向 <code>runtime.hmap</code> 结构体的指针；</li>
<li><code>ch</code> 是一个指向 <code>runtime.hchan</code> 结构体的指针；</li>
</ol>
<p><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</p>
<pre><code class="go">i := new(int)

var v int
i := &amp;v</code></pre>
<p>上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。</p>
<h2 id="make-实现"><a href="#make-实现" class="headerlink" title="make 实现"></a>make 实现</h2><p>make 的实现在<a href="https://xiaoming.net.cn/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">go 常用基本类型源码设计分析</a>中已经分析过了，具体总结如下：在编译期间的类型检查阶段，Go 语言会将代表 <code>make</code> 关键字的 <code>OMAKE</code> 节点根据参数类型的不同转换成了 <code>OMAKESLICE</code>、<code>OMAKEMAP</code> 和 <code>OMAKECHAN</code> 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。</p>
<h2 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h2><p>编译器会在中间代码生成阶段通过以下两个函数处理该关键字：</p>
<ol>
<li><p><code>cmd/compile/internal/gc.callnew</code> 会将关键字转换成 <code>ONEWOBJ</code> 类型的节点；</p>
</li>
<li><p><code>cmd/compile/internal/gc.state.expr</code> 会根据申请空间的大小分两种情况处理：</p>
<ul>
<li><p>如果申请的空间为 0，就会返回一个表示空指针的 <code>zerobase</code> 变量；</p>
</li>
<li><p>在遇到其他情况时会将关键字转换成 <code>runtime.newobject</code> 函数：</p>
<pre><code class="go">func callnew(t *types.Type) *Node {
  ...
  n := nod(ONEWOBJ, typename(t), nil)
  ...
  return n
}

func (s *state) expr(n *Node) *ssa.Value {
  switch n.Op {
  case ONEWOBJ:
      if n.Type.Elem().Size() == 0 {
          return s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)
      }
      typ := s.expr(n.Left)
      vv := s.rtcall(newobject, true, []*types.Type{n.Type}, typ)
      return vv[0]
  }
}</code></pre>
</li>
</ul>
</li>
</ol>
<p>需要注意的是，无论是直接使用 <code>new</code>，还是使用 <code>var</code> 初始化变量，它们在编译器看来都是 <code>ONEW</code> 和 <code>ODCL</code> 节点。如果变量会逃逸到堆上，这些节点在这一阶段都会被 <code>cmd/compile/internal/gc.walkstmt</code> 转换成通过 <code>runtime.newobject</code> 函数并在堆上申请内存。不过这也不是绝对的，如果通过 <code>var</code> 或者 <code>new</code> 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上。</p>
<pre><code class="go">func walkstmt(n *Node) *Node {
    switch n.Op {
    case ODCL:
        v := n.Left
        if v.Class() == PAUTOHEAP {
            if prealloc[v] == nil {
                prealloc[v] = callnew(v.Type)
            }
            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])
            nn.SetColas(true)
            nn = typecheck(nn, ctxStmt)
            return walkstmt(nn)
        }
    case ONEW:
    // 如果没有逃逸，直接在栈上分配内存
        if n.Esc == EscNone {
            r := temp(n.Type.Elem())
            r = nod(OAS, r, nil)
            r = typecheck(r, ctxStmt)
            init.Append(r)
            r = nod(OADDR, r.Left, nil)
            r = typecheck(r, ctxExpr)
            n = r
        } else {
      // 逃逸了就在堆上分配内存
            n = callnew(n.Type.Elem())
        }
    }
}</code></pre>
<p><code>runtime.newobject</code> 函数会获取传入类型占用空间的大小，调用 <code>runtime.mallocgc</code> 在堆上申请一片内存空间并返回指向这片内存空间的指针：</p>
<pre><code class="go">func newobject(typ *_type) unsafe.Pointer {
    return mallocgc(typ.size, typ, true)
}</code></pre>
<p><strong>参考文章</strong></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/-kV1nvWvYonGkXhdv3iNWg" target="_blank" rel="noopener">Go 语言 for 和 range 的实现</a></p>
<p><a href="https://my.oschina.net/renhc/blog/2870345" target="_blank" rel="noopener">Go defer实现原理剖析</a></p>
<p><a href="https://mp.weixin.qq.com/s/txj7jQNki_8zIArb9kSHeg" target="_blank" rel="noopener">Golang之轻松化解defer的温柔陷阱</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34:34</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
