<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>SpringMVC</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="SpringMVC工作流程


用户发送的请求首先都会被前端控制器（中央控制器）DispatcherServlet捕获
中央控制器通过处理器映射器HandleMapping找到对应的处理器返回给中央控制器
中央控制器根据返回的处理器调用处理器适配器HandleAdapter，处理器适配器经过适配调用具体的Controller，并将得到的ModelAndView返回给中央控制器
中央控制器将结果传递给视图解析器ViewReslover
视图解析器解析后返回具体视图

开发流程
需要导入的包：
&amp;lt;dependencies&amp;gt;
 &amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
     &amp;lt;arti.."></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">SpringMVC</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC工作流程"><span class="toc-text">SpringMVC工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发流程"><span class="toc-text">开发流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC配置方式"><span class="toc-text">SpringMVC配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一种方式（通过name找到Controller）："><span class="toc-text">第一种方式（通过name找到Controller）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二种方式（通过id找到Controller）："><span class="toc-text">第二种方式（通过id找到Controller）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三种方式（注解）"><span class="toc-text">第三种方式（注解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#功能之间业务跳转"><span class="toc-text">功能之间业务跳转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同功能之间的传值"><span class="toc-text">不同功能之间的传值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#功能方法之间（C-C）"><span class="toc-text">功能方法之间（C-C）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从页面到到功能方法（V-C）"><span class="toc-text">从页面到到功能方法（V-C）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据格式化"><span class="toc-text">数据格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#时间日期"><span class="toc-text">时间日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注解方式"><span class="toc-text">注解方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用日期转换器"><span class="toc-text">使用日期转换器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象转换器"><span class="toc-text">对象转换器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套绑定数据"><span class="toc-text">嵌套绑定数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#转发与重定向"><span class="toc-text">转发与重定向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件上传"><span class="toc-text">文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多文件上传"><span class="toc-text">多文件上传</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON处理"><span class="toc-text">JSON处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套json"><span class="toc-text">嵌套json</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#视图"><span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#物理视图"><span class="toc-text">物理视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑视图"><span class="toc-text">逻辑视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重定向传值"><span class="toc-text">重定向传值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#统一异常处理"><span class="toc-text">统一异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方式一：-通常用于响应到页面）"><span class="toc-text">方式一：(通常用于响应到页面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方式二：注解的方法（通常用于响应到JSON）"><span class="toc-text">方式二：注解的方法（通常用于响应到JSON）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局异常处理"><span class="toc-text">全局异常处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RestFul支持"><span class="toc-text">RestFul支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resetful请求方式"><span class="toc-text">Resetful请求方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拦截器"><span class="toc-text">拦截器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参数注解"><span class="toc-text">参数注解</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a><a href="/tags/spring"><i class="tag post-item-tag">spring</i></a><a href="/tags/spring%20mvc"><i class="tag post-item-tag">spring mvc</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">SpringMVC</h1><time class="has-text-grey" datetime="2019-06-01T00:24:12.000Z">2019-06-01</time><article class="mt-2 post-content"><h1 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h1><p><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg?raw=true" alt=""></p>
<a id="more"></a>
<ol>
<li>用户发送的请求首先都会被<strong>前端控制器（中央控制器）</strong><code>DispatcherServlet</code>捕获</li>
<li>中央控制器通过<strong>处理器映射器</strong><code>HandleMapping</code>找到对应的处理器返回给中央控制器</li>
<li>中央控制器根据返回的处理器调用<strong>处理器适配器</strong><code>HandleAdapter</code>，处理器适配器经过适配调用具体的Controller，并将得到的ModelAndView返回给中央控制器</li>
<li>中央控制器将结果传递给<strong>视图解析器</strong><code>ViewReslover</code></li>
<li>视图解析器解析后返回具体视图</li>
</ol>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><ol>
<li><p>需要导入的包：</p>
<pre><code class="xml">&lt;dependencies&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
     &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
     &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
     &lt;version&gt;4.0.1&lt;/version&gt;
     &lt;scope&gt;provided&lt;/scope&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
     &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
     &lt;version&gt;2.3.3&lt;/version&gt;
     &lt;scope&gt;provided&lt;/scope&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
     &lt;artifactId&gt;jstl&lt;/artifactId&gt;
     &lt;version&gt;1.2&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;
     &lt;artifactId&gt;taglibs-standard-jstlel&lt;/artifactId&gt;
     &lt;version&gt;1.2.5&lt;/version&gt;
     &lt;scope&gt;provided&lt;/scope&gt;
 &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<blockquote>
<p>运行后需要检查tomat相关的out文件lib目录下是否也已经导入，如果没有需要手动加入（project structure-&gt;artifacts-&gt;在lib目录下添加  </p>
</blockquote>
</li>
<li><p>项目目录结构<br><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/springMVC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true" alt=""></p>
</li>
<li><p>配置中央控制器:在<code>web.xml</code>文件中进行配置</p>
<pre><code class="xml">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
      version=&quot;4.0&quot;&gt;

 &lt;!-- 配置过滤器 --&gt;
 &lt;filter&gt;
     &lt;filter-name&gt;myfilter&lt;/filter-name&gt;
     &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;

     &lt;!-- 指定编码 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;encoding&lt;/param-name&gt;
         &lt;param-value&gt;utf-8&lt;/param-value&gt;
     &lt;/init-param&gt;
     &lt;!-- 启动强编码 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
     &lt;/init-param&gt;
 &lt;/filter&gt;
 &lt;filter-mapping&gt;
     &lt;filter-name&gt;myfilter&lt;/filter-name&gt;
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;/filter-mapping&gt;

 &lt;servlet&gt;
     &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
     &lt;!-- 关联中央处理器 --&gt;
     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
     &lt;!-- 读取springmvc的配置文件 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
         &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
     &lt;/init-param&gt;
 &lt;/servlet&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
     &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
</li>
</ol>
</web-app>
```
4. 配置处理器映射器，处理器适配器，视图解析器：在spring配置文件中进行配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">

<pre><code>&lt;!-- 配置处理器映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;
&lt;!-- 配置处理器适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt;
&lt;!-- 配置视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;/bean&gt;


&lt;!-- 配置action --&gt;
&lt;bean name=&quot;/hello.do&quot; class=&quot;com.xm.action.HelloAction&quot;&gt;&lt;/bean&gt;</code></pre></beans>
```
5. 开发模型层
```java
package com.xm.action;

<p>import org.springframework.web.servlet.ModelAndView;<br>import org.springframework.web.servlet.mvc.Controller;</p>
<p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>/**</p>
<ul>
<li>控制层</li>
<li>/<br>public class HelloAction implements Controller {<br>  @Override<br>  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {<pre><code>  ModelAndView mv = new ModelAndView();
  //可以返回视图+数据
  mv.addObject(&quot;hello&quot;,&quot;SpringMVC world!&quot;);
  //返回跳转的地址
  mv.setViewName(&quot;index.jsp&quot;);
  return mv;</code></pre>  }<br>}<pre><code>6. 开发视图层
```jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;springMVC&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${hello}
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul>
<h1 id="SpringMVC配置方式"><a href="#SpringMVC配置方式" class="headerlink" title="SpringMVC配置方式"></a>SpringMVC配置方式</h1><h2 id="第一种方式（通过name找到Controller）："><a href="#第一种方式（通过name找到Controller）：" class="headerlink" title="第一种方式（通过name找到Controller）："></a>第一种方式（通过name找到Controller）：</h2><ol>
<li><p>配置前端控制器：</p>
<pre><code class="xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
      version=&quot;4.0&quot;&gt;

 &lt;!-- 配置过滤器 --&gt;
 &lt;filter&gt;
     &lt;filter-name&gt;myfilter&lt;/filter-name&gt;
     &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;

     &lt;!-- 指定编码 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;encoding&lt;/param-name&gt;
         &lt;param-value&gt;utf-8&lt;/param-value&gt;
     &lt;/init-param&gt;
     &lt;!-- 启动强编码 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
     &lt;/init-param&gt;
 &lt;/filter&gt;
 &lt;filter-mapping&gt;
     &lt;filter-name&gt;myfilter&lt;/filter-name&gt;
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;/filter-mapping&gt;

 &lt;servlet&gt;
     &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
     &lt;!-- 关联中央处理器 --&gt;
     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
     &lt;!-- 读取springmvc的配置文件 --&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
         &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
     &lt;/init-param&gt;
 &lt;/servlet&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
     &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
</li>
</ol>
</web-app>
```
2. 配置处理器映射器：使用`BeanNameUrlHandlerMapping`类型
3. 配置处理器适配器：使用`SimpleControllerHandlerAdapter`类型
4. 配置视图解析器：使用`InternalResourceViewResolver`类型
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">

<pre><code>&lt;!-- 配置处理器映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;
&lt;!-- 配置处理器适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt;
&lt;!-- 配置视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;/bean&gt;</code></pre></beans>
```
5. 实现表现层：实现`Controller`接口
```java
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

<p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>/**</p>
<ul>
<li><p>控制层</p>
</li>
<li><p>/<br>public class HelloAction implements Controller {<br>  @Override<br>  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {</p>
<pre><code>  ModelAndView mv = new ModelAndView();
  //可以返回视图+数据
  mv.addObject(&quot;hello&quot;,&quot;SpringMVC world!&quot;);
  //返回跳转的地址
  mv.setViewName(&quot;index.jsp&quot;);
  return mv;</code></pre><p>  }<br>}</p>
<pre><code>6. 配置action：在applicationContext配置文件中
```xml
&lt;!-- 配置action --&gt;
&lt;bean name=&quot;/hello.do&quot; class=&quot;com.xm.action.HelloAction&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="第二种方式（通过id找到Controller）："><a href="#第二种方式（通过id找到Controller）：" class="headerlink" title="第二种方式（通过id找到Controller）："></a>第二种方式（通过id找到Controller）：</h2><ol>
<li><p>配置前端控制器：跟第一种配置方式一样</p>
</li>
<li><p>配置处理器映射器：使用<code>SimpleUrlHandlerMapping</code>类型</p>
</li>
<li><p>配置处理器适配器：使用<code>HttpRequestHandlerAdapter</code></p>
</li>
<li><p>配置视图解析器：跟第一种方式一样</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans
   https://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/mvc
   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;!-- 配置处理器映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;/&gt;
&lt;!-- 配置处理器适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;
&lt;!-- 配置视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
</beans>
```
5. 开发表现层的action（实现`HttpRequestHandler`接口）
```java
import org.springframework.web.HttpRequestHandler;

<p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p>
<p>public class ActionByHttpRequestHandlerAction implements HttpRequestHandler {<br>    @Override<br>    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {<br>        //设置值<br>        httpServletRequest.setAttribute(“name”,”第二种配置方式”);<br>        //跳转页面到指定页面<br>        httpServletRequest.getRequestDispatcher(“httpRequestHandler.jsp”).forward(httpServletRequest,httpServletResponse);<br>    }<br>}</p>
<pre><code>6. 配置action:使处理器映射器关联具体的id
```xml
&lt;!-- 配置处理器映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;!-- 关联具体的id --&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;/action.do&quot;&gt;secondAction&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置处理器适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;
&lt;!-- 配置视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;

&lt;!-- 配置Action --&gt;
&lt;bean id=&quot;secondAction&quot; class=&quot;com.xm.action.ActionByHttpRequestHandlerAction&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="第三种方式（注解）"><a href="#第三种方式（注解）" class="headerlink" title="第三种方式（注解）"></a>第三种方式（注解）</h2><ol>
<li>配置前端控制器（同前面）</li>
<li>配置注解的映射器和适配器，有两种方式</li>
</ol>
<ul>
<li>分别配置<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code><pre><code class="xml">&lt;!-- 注解映射器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;&lt;/bean&gt;
&lt;!-- 注解适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;&lt;/bean&gt;</code></pre>
</li>
<li>直接使用注解驱动<pre><code class="xml">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</code></pre>
</li>
</ul>
<ol start="3">
<li>配置视图解析器(同前两种方式）</li>
<li>开发action，使用注解方式<strong>不需要实现接口</strong><blockquote>
<p>注解可以加在类上，表示<strong>根路径</strong>，加在方法上表示<strong>具体的路径</strong>  </p>
</blockquote>
</li>
</ol>
<p>可以通过指定请求方式：</p>
<blockquote>
<p>(value=”/test”,method=RequestMethod.POST/GET/..) 此时不能省略value，如果没指定method默认接受任意方式（请求方式不正确会报<strong>405</strong>错误）  </p>
</blockquote>
<p><strong>请求表达式</strong><br>用于通过表达式精确映射请求</p>
<blockquote>
<p><code>(value=&quot;/testparam&quot;,params={&quot;username&quot;,&quot;age!=10&quot;}，headers={&quot;Accept-Language=zh-CN,zh;q=0.8&quot;})</code>表示参数必须含有username和age，并且age不能等于10，同时请求头内的内容必须符合固定值  </p>
</blockquote>
<pre><code class="java">import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
(&quot;/prefix&quot;)
public class AnnotationsAction {

    //方法自定义
    //设置请求路径
    (&quot;/annotation.do&quot;)
    public ModelAndView testAction(HttpServletRequest request, HttpServletResponse response){
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;name&quot;,&quot;注解配置方法&quot;);
        mv.setViewName(&quot;/annotation.jsp&quot;);
        return mv;
    }
}</code></pre>
<ol start="6">
<li>配置注解扫描:使容器创建对象<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.xm.action&quot;&gt;&lt;/context:component-scan&gt;</code></pre>
</li>
</ol>
<h1 id="功能之间业务跳转"><a href="#功能之间业务跳转" class="headerlink" title="功能之间业务跳转"></a>功能之间业务跳转</h1><p>有两种方式实现</p>
<ul>
<li>方式一：通过ModelAndView返回其他业务的内容<pre><code class="java">(&quot;/to-annotation1.do&quot;)
public ModelAndView pageJump1(HttpServletRequest request){
  ModelAndView mv = new ModelAndView();
  mv.setViewName(&quot;/prefix/annotation.do&quot;);//如果有定义根路径，需要加上根路径
  return mv;
}</code></pre>
</li>
<li>方式二：通过字符串直接返回<pre><code class="java">(&quot;/to-annotation2.do&quot;)
public String pageJump2(HttpServletRequest request){
  return &quot;/prefix/annotation.do&quot;;
}</code></pre>
<h1 id="不同功能之间的传值"><a href="#不同功能之间的传值" class="headerlink" title="不同功能之间的传值"></a>不同功能之间的传值</h1><h2 id="功能方法之间（C-C）"><a href="#功能方法之间（C-C）" class="headerlink" title="功能方法之间（C-C）"></a>功能方法之间（C-C）</h2></li>
<li>Request</li>
<li>Session</li>
<li>Cache（分布式缓存）<pre><code class="java">(&quot;/addCar.do&quot;)
public String addCar(HttpServletRequest request){
  request.setAttribute(&quot;tag&quot;,&quot;电动汽车&quot;);
  return &quot;/listCar.do&quot;;
}
</code></pre>
</li>
</ul>
<p>(“/listCar.do”)<br>public ModelAndView listCar(HttpServletRequest request){<br>    //ModelAndView可以传值、跳转页面<br>    ModelAndView mv = new ModelAndView();<br>    Object tag = request.getAttribute(“tag”);<br>    mv.addObject(“tag”,tag);<br>    mv.setViewName(“/car.jsp”);<br>    return mv;<br>}</p>
<pre><code>## 从具体的功能方法到页面（C-V）
- ModelAndView
&gt; setViewName设置跳转地址，addObject传数据  

- Map方式
```java
public String addCar2(Integer carnum, String carname, Map&lt;String,String&gt;){
    System.out.println(carname);
    System.out.println(carnum);
    map.put(&quot;tag&quot;,username);//会自动将数据传递到页面
    return &quot;car.jsp&quot;;
}</code></pre><ul>
<li>Model方式<blockquote>
<p>model带数据，return返回地址  </p>
</blockquote>
</li>
</ul>
<pre><code class="java">(&quot;/addCar2.do&quot;)
public String addCar2(Integer carnum, String carname, Model model){
    System.out.println(carname);
    System.out.println(carnum);
    model.addAttribute(&quot;tag&quot;,carname);
    return &quot;car.jsp&quot;;
}</code></pre>
<h2 id="从页面到到功能方法（V-C）"><a href="#从页面到到功能方法（V-C）" class="headerlink" title="从页面到到功能方法（V-C）"></a>从页面到到功能方法（V-C）</h2><ul>
<li>request.getParameter<pre><code class="java">(&quot;/addCar.do&quot;)
public String addCar(HttpServletRequest request){
    //在这里获取传过来的值
  String carname = request.getParameter(&quot;carname&quot;);
  System.out.println(carname);
  request.setAttribute(&quot;tag&quot;,carname);
  return &quot;/listCar.do&quot;;
}</code></pre>
</li>
<li>指定具体的类型接收具体的参数<pre><code class="html">&lt;form action=&quot;/addCar2.do&quot; method=&quot;post&quot;&gt;
  汽车名称：&lt;input type=&quot;text&quot; name=&quot;carname&quot;&gt;&lt;br&gt;
  购买数量：&lt;input type=&quot;text&quot; name=&quot;carnum&quot;&gt;&lt;br&gt;
  &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
<pre><code class="java">(&quot;/addCar2.do&quot;)
public String addCar2(String carname,Integer carnum){
  System.out.println(carname);
  System.out.println(carnum);
  return &quot;/listCar.do&quot;;
}</code></pre>
<blockquote>
<p>这种方式要求传的类型,名称与形参类型，名称一一对应，一旦类型不匹配，直接报错，找不到相应的跳转页面，不进行跳转  </p>
</blockquote>
</li>
</ul>
<p>当参数是数组类型时：</p>
<pre><code class="html">&lt;form action=&quot;/delCar.do&quot; method=&quot;post&quot;&gt;
    汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;1&quot;&gt;&lt;br&gt;
    汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;2&quot;&gt;&lt;br&gt;
    汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;3&quot;&gt;&lt;br&gt;
    汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;4&quot;&gt;&lt;br&gt;
    汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;5&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
<pre><code class="java">(&quot;/delCar.do&quot;)
public String delCar(Integer[] cids){
    //获取数组的方式1：
    //String[] cids = request.getParameterValues(&quot;cid&quot;);
    //方式2：匹配参数（一般使用这种方式）
    for (Integer cid : cids) {
        System.out.println(cid);
    }
    return &quot;/listCar.do&quot;;
}</code></pre>
<ul>
<li><p>设置<strong>默认值</strong>及<strong>可选参数</strong><br>此时必须使用<code>@RequestParam</code>注解，并在其中使用<code>defaultValue</code>设置默认值，<code>required</code>设置参数是否可选</p>
<pre><code class="java">(&quot;/list&quot;)
public String list(
  @RequestParam(value=&quot;currentpage&quot;,defaultValue=&quot;1&quot;,required=false)Integer currentpage,
  @RequestParam(value=&quot;pagesize&quot;,defaultValue=&quot;10&quot;,required=false)Intrger pagesize)
){
  ....
}</code></pre>
</li>
<li><p>使用封装类型bean来接收多个参数</p>
<pre><code class="java">/**
* 使用该类来接收参数
*/
public class CarDTO {
  private String carname;
  private Integer carnum;
  private Integer[] cids;

  public String getCarname() {
      return carname;
  }

  public void setCarname(String carname) {
      this.carname = carname;
  }

  public Integer getCarnum() {
      return carnum;
  }

  public void setCarnum(Integer carnum) {
      this.carnum = carnum;
  }

  public Integer[] getCids() {
      return cids;
  }

  public void setCids(Integer[] cids) {
      this.cids = cids;
  }
}</code></pre>
<pre><code class="html">&lt;form action=&quot;/updateCar.do&quot; method=&quot;post&quot;&gt;
  汽车名称：&lt;input type=&quot;text&quot; name=&quot;carname&quot;&gt;&lt;br&gt;
  购买数量：&lt;input type=&quot;text&quot; name=&quot;carnum&quot;&gt;&lt;br&gt;
  汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;1&quot;&gt;&lt;br&gt;
  汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;2&quot;&gt;&lt;br&gt;
  汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;3&quot;&gt;&lt;br&gt;
  汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;4&quot;&gt;&lt;br&gt;
  汽车编号：&lt;input type=&quot;checkbox&quot; name=&quot;cids&quot; value=&quot;5&quot;&gt;&lt;br&gt;
  &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
<pre><code class="java">(&quot;/updateCar.do&quot;)
public String updateCar(CarDTO carDTO){
  System.out.println(&quot;汽车名称：&quot;+carDTO.getCarname());
  System.out.println(&quot;汽车数量：&quot;+carDTO.getCarnum());
  System.out.println(&quot;汽车编号：&quot;);
  Integer[] cids = carDTO.getCids();
  for (Integer cid : cids) {
      System.out.println(cid);
  }
  return &quot;/listCar.do&quot;;
}</code></pre>
</li>
</ul>
<h1 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h1><h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>对于类型定义的时间，数字类型，如果在前端直接以字符串方式传输过来，拿到之后无法进行解析匹配，这时候可以通过格式化注解方式进行转换，或者直接就把属性定义成String类型</p>
<pre><code class="java">public class CarDTO {
    private String carname;
    private Integer carnum;
    private Integer[] cids;

    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date create;//如果直接接收会失败，如果想直接接收，需要使用string类型

    @NumberFormat(pattern = &quot;#,###,###.##&quot;)
    private Double price;
}</code></pre>
<p>在页面上，如果希望输出格式化的数据，可以使用jsp的<code>fmt</code>(format)标签</p>
<pre><code class="jsp">&lt;c:forEach items=&quot;${carList}&quot; var=&quot;car&quot;&gt;
    ${car.carname},
    ${car.carnum},
    &lt;fmt:formatDate value=&quot;${car.create}&quot; pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;/&gt;
    &lt;fmt:formatNumber value=&quot;${car.price}&quot; pattern=&quot;#,###,###.##&quot;/&gt;&lt;br&gt;
&lt;/c:forEach&gt;</code></pre>
<h3 id="使用日期转换器"><a href="#使用日期转换器" class="headerlink" title="使用日期转换器"></a>使用日期转换器</h3><p>通过继承Converter接口，实现自定义日期格式</p>
<pre><code class="java">public class DateConverter implements Converter&lt;String, Date&gt; {
    @Override
    public Date convert(String s) {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try {
            sdf.setLenient(false);//是否宽松解析：默认为true
            return sdf.parse(s);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }
}</code></pre>
<p>在springMVC中配置类型转换器</p>
<pre><code class="xml">&lt;mvc:annotation-driven conversion-service=&quot;myConversion&quot;/&gt;
&lt;!--类型转换器 --&gt;
&lt;bean id=&quot;myConversion&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;com.xm.converter.DateConverter&quot;&gt;&lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<h2 id="对象转换器"><a href="#对象转换器" class="headerlink" title="对象转换器"></a>对象转换器</h2><pre><code class="java">public class UserConverter implements Converter&lt;String, User&gt; {
    @Override
    public User convert(String s) {
        System.out.println(s);
        if(s != null){
            String[] split = s.split(&quot;-&quot;);
            System.out.println(split.length);
            if (split != null &amp;&amp; split.length == 4){
                String username = split[0];
                String password = split[1];
                Integer age = Integer.parseInt(split[2]);
                String email = split[3];

                User user = new User();
                user.setUsername(username);
                user.setPassword(password);
                user.setAge(age);
                user.setEmaill(email);

                System.out.println(user);
                return user;
            }
        }
        return null;
    }
}</code></pre>
<pre><code class="xml">&lt;!--类型转换器 --&gt;
&lt;bean id=&quot;myConversion&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;com.xm.converter.DateConverter&quot;&gt;&lt;/bean&gt;
            &lt;bean class=&quot;com.xm.converter.UserConverter&quot;&gt;&lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<h1 id="嵌套绑定数据"><a href="#嵌套绑定数据" class="headerlink" title="嵌套绑定数据"></a>嵌套绑定数据</h1><p>针对内部类的属性：</p>
<pre><code class="java">public class CarDTO {
    private String carname;
    private Integer carnum;
    private Integer[] cids;
    //关联对象
    private CarTypeDTO cartype;
}

public class CarTypeDTO {

    private String cartype;

      public String getCartype() {
        return cartype;
    }

    public void setCartype(String cartype) {
        this.cartype = cartype;
    }</code></pre>
<p>在获取前端传过来的值时，jsp应该使用嵌套调用来获取：</p>
<pre><code class="html">汽车类型：&lt;input type=&quot;text&quot; name=&quot;cartype.cartype&quot;/&gt;</code></pre>
<h1 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h1><p>页面之间的跳转默认使用的是转发</p>
<pre><code class="java">/**
* 转发
*/
(&quot;/addCar.do&quot;)
public String addCar(HttpServletRequest request){
    String carname = request.getParameter(&quot;carname&quot;);
    System.out.println(carname);
    request.setAttribute(&quot;tag&quot;,carname);
    return &quot;forward:/listCar.do&quot;;
}

/**
* 重定向
*/
(&quot;/addCar.do&quot;)
public String addCar(HttpServletRequest request){
    String carname = request.getParameter(&quot;carname&quot;);
    System.out.println(carname);
    request.setAttribute(&quot;tag&quot;,carname);
    return &quot;redirect:/listCar.do&quot;;
}</code></pre>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ol>
<li>导入<code>commons-fileupload.jar</code>和<code>commons-io.jar</code>依赖</li>
<li>开发上传页面<pre><code class="html">&lt;form action=&quot;/uploadImg.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
汽车图片：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre>
</li>
<li>配置文件类型解析器<pre><code class="xml">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
 &lt;!-- 设置最大文件大小(单位KB) --&gt;
 &lt;property name=&quot;maxUploadSize&quot; value=&quot;1048576&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</li>
<li>开发action<br>使用<code>MultipartFile</code>类对文件进行获取，添加<code>@RequestParam</code>注解，<strong>参数名要和前端传的name一致</strong><blockquote>
<p>@RequestParam(“img”) MultipartFile multipartFile  </p>
</blockquote>
</li>
</ol>
<pre><code class="java">package com.xm.action;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;

@Controller
public class upLoadFile {

    (&quot;/uploadImg.do&quot;)
    public String uploadImg(HttpServletRequest request, @RequestParam(&quot;img&quot;) MultipartFile multipartFile) throws IOException {
        //使用request接收普通类型参数
        String name = request.getParameter(&quot;name&quot;);
        System.out.println(name);
        //使用multipartFile接收文件类型的参数
        //得到的文件名
        String originalFilename = multipartFile.getOriginalFilename();
        //存储的目标地址
        File dest = new File(&quot;/Users/xiaoming/IdeaProjects/SpringmvcStudy/File/&quot;+originalFilename);
        //将文件内容写入到指定的目标地方
        multipartFile.transferTo(dest);

        return &quot;/listCar.do&quot;;
    }
}</code></pre>
<h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><p>使用<code>CommonsMultipartFile</code>注解获取前端传来的多个文件放在一个数组里</p>
<pre><code class="java">(&quot;/uploadImg2.do&quot;)
public String uploadImgs(HttpServletRequest request, @RequestParam(&quot;imgs&quot;)CommonsMultipartFile files[]) throws IOException {
    String name = request.getParameter(&quot;name&quot;);
    System.out.println(name);
    //使用CommonsMultipartFile注解获取多个文件封装为数组
    for (CommonsMultipartFile file : files) {
        String filename = file.getOriginalFilename();
        File dest = new File(&quot;/Users/xiaoming/IdeaProjects/SpringmvcStudy/File/&quot;+filename);
        file.transferTo(dest);
    }
    return &quot;/listCar.do&quot;;
}</code></pre>
<h1 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h1><ol>
<li>导入json依赖包：</li>
</ol>
<ul>
<li>jackson-core</li>
<li>jackson-databind</li>
<li>jackson-annotations</li>
</ul>
<ol start="2">
<li>使用<code>ResponseBody</code>注解标识接口，会使该接口返回的数据直接封装成json格式<pre><code class="java">/**
* 响应json
*/
@ResponseBody
(&quot;/listJson.do&quot;)
public List&lt;CarDTO&gt; listJson(HttpServletRequest request){
 //封装数据
 List&lt;CarDTO&gt; list = new ArrayList&lt;&gt;();
 list.add(new CarDTO(&quot;car1&quot;,1,new Date(),2343.345345));
 list.add(new CarDTO(&quot;car2&quot;,2,new Date(),34.232));
 list.add(new CarDTO(&quot;car3&quot;,3,new Date(),235345.234));
 return list;
}</code></pre>
</li>
</ol>
<p>对于时间类型，json会使用<strong>long类型</strong>作为响应，推荐直接使用String或者long类型</p>
<h2 id="嵌套json"><a href="#嵌套json" class="headerlink" title="嵌套json"></a>嵌套json</h2><pre><code class="java">/**
 * 响应json
 */
@ResponseBody
(&quot;/listJson2.do&quot;)
public Map&lt;String,Object&gt; listJson2(HttpServletRequest request){
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
    //封装数据
    List&lt;CarDTO&gt; list = new ArrayList&lt;&gt;();
    list.add(new CarDTO(&quot;car1&quot;,1,new Date(),2343.345345));
    list.add(new CarDTO(&quot;car2&quot;,2,new Date(),34.232));
    list.add(new CarDTO(&quot;car3&quot;,3,new Date(),235345.234));

    map.put(&quot;data&quot;, list);
    return map;
}</code></pre>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h2><p>使用页面完整路径：<br>配置视图解析器并且在action中通过<code>mv.setViewName(&quot;/hello.jsp&quot;)</code>返回跳转的地址</p>
<h2 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h2><p>通过相对路径，可以把页面放入受到保护的目录<strong>WEB-INF</strong>中，页面不能直接访问到，必须通过action做跳转</p>
<ol>
<li>视图解析器<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
 &lt;!-- 逻辑视图 --&gt;
 &lt;!-- 前缀 --&gt;
 &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
 &lt;!-- 后缀 --&gt;
 &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</li>
<li>action<pre><code class="java">@Controller
public class HelloAction{
 @RequestMapping(&quot;/myhello.do&quot;)
 public String myHello(HttpServletRequest request){
     //需要跳转的页面
     //return &quot;/WEB-INF/[前缀]hello.jsp[后缀]
     return &quot;hello&quot;;
 }
}</code></pre>
</li>
</ol>
<h1 id="重定向传值"><a href="#重定向传值" class="headerlink" title="重定向传值"></a>重定向传值</h1><p>当使用页面重定向时，通常request会被刷新，其中原来的数据就不存在了，可以使用<code>RedirectAttributes</code>l类在重定向时将值传给目标页面的request</p>
<pre><code class="java">(&quot;/preAdd.do&quot;)
public String preAdd(RedirectAttributes attributes){
    attributes.addAttribute(&quot;tag&quot;,&quot;重定向传值&quot;);
    return &quot;redirect:/myhello.do&quot;;
}</code></pre>
<h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="方式一：-通常用于响应到页面）"><a href="#方式一：-通常用于响应到页面）" class="headerlink" title="方式一：(通常用于响应到页面）"></a>方式一：(通常用于响应到页面）</h2><ol>
<li>开发自定义的异常类<pre><code class="java">package com.xm.exception;
</code></pre>
</li>
</ol>
<p>public class CustomerException extends Exception {<br>    private String message;</p>
<pre><code>public CustomerException() {
}

public CustomerException(String message) {
    this.message = message;
}

@Override
public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}</code></pre><p>}</p>
<pre><code>2. 开发统一异常处理器
```java
package com.xm.exception;

import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LogExceptionHandler implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
        ModelAndView mv = new ModelAndView();
        CustomerException customerException = null;
        //获取系统的异常信息
        if(e instanceof CustomerException){
            customerException = (CustomerException) e;
        }else {
            customerException = new CustomerException(&quot;系统繁忙&quot;);
        }
        mv.addObject(&quot;msg&quot;,customerException.getMessage());
        //跳转到统一错误信息页面
        mv.setViewName(&quot;error&quot;);
        return mv;
    }
}</code></pre><ol start="3">
<li>在配置文件中配置异常处理Handler<pre><code class="xml">&lt;!-- 配置异常处理 --&gt;
&lt;bean class=&quot;com.xm.exception.LogExceptionHandler&quot;&gt;&lt;/bean&gt;</code></pre>
error.jsp（异常抛出后显示的页面）<pre><code class="xml">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;
</code></pre>
</li>
</ol>
<html>
<head>
    <title>统一异常处理</title>
</head>
<body>
欢迎访问XXX系统，${msg},请稍后重试
</body>
</html>

<pre><code>4. 开发Action
```java
/**
 * 使用默认页面内容显示
 * @param request
 * @return
 */
(&quot;/error-test.do&quot;)
public String errorTest(HttpServletRequest request){
    int i = 1/0;
    System.out.println(i);
    return &quot;hello&quot;;
}

/**
 * 自定义内容显示
 * @param request
 * @return
 * @throws CustomerException
 */
(&quot;/error-test2.do&quot;)
public String errorTest2(HttpServletRequest request) throws CustomerException {
    try {
        int i = 1/0;
        System.out.println(i);
    }catch (Exception e){
        e.printStackTrace();
        throw new CustomerException(&quot;不能除以0小老弟啊&quot;);
    }
    return &quot;hello&quot;;
}</code></pre><h2 id="方式二：注解的方法（通常用于响应到JSON）"><a href="#方式二：注解的方法（通常用于响应到JSON）" class="headerlink" title="方式二：注解的方法（通常用于响应到JSON）"></a>方式二：注解的方法（通常用于响应到JSON）</h2><ul>
<li>不用实现异常Handler接口</li>
<li>不用配置异常Handler实现类</li>
<li>开发基类，所有的Action作为子类继承</li>
</ul>
<ol>
<li><p>开发自定义异常</p>
<pre><code class="java">public class PayException extends Exception {
 private Integer code;
 private String message;

 public PayException(Integer code, String message) {
     this.code = code;
     this.message = message;
 }

 public Integer getCode() {
     return code;
 }

 public void setCode(Integer code) {
     this.code = code;
 }

 @Override
 public String getMessage() {
     return message;
 }

 public void setMessage(String message) {
     this.message = message;
 }
}</code></pre>
</li>
<li><p>开发处理的基类<br>使用<code>@ExceptionHandler</code>注解，同时可以在注解中指定异常类只处理指定的异常</p>
<blockquote>
<p>@ExceptionHandler(‘NumberFormatException.class’)  </p>
</blockquote>
</li>
</ol>
<pre><code class="java">public class BaseAction {

    @ResponseBody   //响应json格式
    @ExceptionHandler   //异常处理器
    public Map&lt;String,Object&gt; myexp(HttpServletRequest req, Exception e){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        if(e instanceof PayException){
            PayException payException = (PayException) e;
            map.put(&quot;code&quot;,payException.getCode());
            map.put(&quot;errot&quot;,payException.getMessage());
        }else{
            map.put(&quot;code&quot;,-1);
            map.put(&quot;error&quot;,&quot;系统繁忙&quot;);
        }
        return map;
    }
}</code></pre>
<ol start="3">
<li><p>开发Action继承类</p>
<pre><code class="java">@Controller
public class PayAction extends BaseAction {

 @ResponseBody
 (&quot;/pay.do&quot;)
 public Map&lt;String,Object&gt; pay(HttpServletRequest req) throws PayException {
     Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
     String money = req.getParameter(&quot;money&quot;);
     if(StringUtils.isEmpty(money)){
         throw new PayException(-2,&quot;参数money输入有误&quot;);
     }
     try {
         int i = 1/0;
         System.out.println(i);
     }catch (Exception e){
         e.printStackTrace();
         throw new PayException(-1,&quot;支付排队中。。。&quot;);
     }
     map.put(&quot;code&quot;,0);
     map.put(&quot;message&quot;,&quot;支付成功&quot;);
     return map;
 }
}</code></pre>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在异常处理器类或开发的基类的前面加上<code>@ControllerAdvice</code>，同时需要配置注解扫描</p>
<h1 id="RestFul支持"><a href="#RestFul支持" class="headerlink" title="RestFul支持"></a>RestFul支持</h1><p>主要针对get请求</p>
</li>
</ol>
<ul>
<li><p>非RESTFul方式：</p>
<blockquote>
<p>https://域名/xxxx?id=3&amp;msg=user  </p>
</blockquote>
</li>
<li><p>RESTFul方式：(简化URL，可读性较差，需要后台识别key）</p>
<blockquote>
<p>https://域名/xxxx/3/user  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>前端控制器拦截所有资源</p>
<pre><code class="xml">&lt;servlet&gt;
 &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
 &lt;!-- 关联中央处理器 --&gt;
 &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
 &lt;!-- 读取springmvc的配置文件 --&gt;
 &lt;init-param&gt;
     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
     &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
 &lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt; 
 &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
 &lt;!-- 拦截所有 --&gt;
 &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
<p>拦截所有后，WEB-INF文件夹下不能够直接访问，静态资源也被拦截，需要释放</p>
</li>
<li><p>配置静态资源释放(springMVC配置文件中）</p>
<pre><code class="xml">&lt;!-- 配置静态资源解析
 表示js及其子目录的所有文件 --&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;&gt;&lt;/mvc:resources&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;&gt;&lt;/mvc:resources&gt;
&lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;&gt;&lt;/mvc:resources&gt;</code></pre>
</li>
<li><p>action：需要在requestMapping中通过占位符设定参数名和顺序，同时使用<code>@PathVariable</code>注解变量</p>
<pre><code class="java">@Controller
public class LogAction {

 //给映射的路径用占位符
 (&quot;/addLog/{id}/{msg}&quot;)
 public String addLog(@PathVariable Integer id,@PathVariable String msg){
     //需要通过url get路径传递过来的动态参数
     //@PathVariable用于注解路径变量
     System.out.println(id);
     System.out.println(msg);
     return &quot;index&quot;;
 }
}</code></pre>
</li>
</ol>
<blockquote>
<p>如果使用了逻辑视图，在功能方法之间跳转，如果存在方法的路径与视图重名，会导致直接跳转到页面，此时应该加上<strong>forward</strong>或者<strong>redirect</strong>来实现功能的跳转  </p>
</blockquote>
<h2 id="Resetful请求方式"><a href="#Resetful请求方式" class="headerlink" title="Resetful请求方式"></a>Resetful请求方式</h2><p>restful提供了get，post，delete，put多种方法进行，但是浏览器表单默认只支持post和get，spring提供了过滤器<code>HiddenHttpMethodFilter</code>,可以将这些请求转化为标砖的http方法，支持四种方式的请求<br><strong>过滤器配置</strong>：</p>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
<p><strong>from表单请求方式</strong></p>
<pre><code class="html">&lt;form action=&quot;delete/1&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;
    ...
&lt;/form&gt;</code></pre>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>在action需要有前提条件的情况下使用，例如：需要先登录才能反问页面</p>
<ol>
<li><p>第一步：开发拦截器<br>需要实现<code>HandlerInterceptor</code>接口</p>
<pre><code class="java">public class LogInterceptor implements HandlerInterceptor {

 /**
  * 在执行具体方法之前调用
  * @param request
  * @param response
  * @param handler
  * @return
  * @throws Exception
  */
 @Override
 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

     //对不要检验的页面放行
     String requestURI = request.getRequestURI();
     if(requestURI.indexOf(&quot;login&quot;)&gt;0){
         return true;
     }
     //得到session是否有内容
     HttpSession session = request.getSession();
     Object user = session.getAttribute(&quot;user&quot;);
     if(user!=null){
         return true;//如果登陆了，正常访问所有action
     }
     request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request,response);
     return false;
 }

</code></pre>
</li>
</ol>
<pre><code>/**
 * 在进入Handler方法之后，返回modelAndView之前执行
 * 如果想要向页面提供一些公共数据或者一些公用的配置信息，可以考虑使用这里的ModelAndView
 * @param request
 * @param response
 * @param handler
 * @param modelAndView
 * @throws Exception
 */
@Override
public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

}

/**
 * 执行完Handler之后执行
 * 日志、系统性能分析
 * @param request
 * @param response
 * @param handler
 * @param ex
 * @throws Exception
 */
@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

}</code></pre><p>}</p>
<pre><code>2. 配置拦截器
```xml
&lt;!-- 配置拦截器 --&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/*&quot;/&gt;&lt;!-- 系统的所有请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/lib/**&quot;&gt; &lt;!-- 设置放行不拦截的路径 --&gt;
        &lt;bean class=&quot;com.xm.interceptor.LogInterceptor&quot;&gt;&lt;/bean&gt;&lt;!-- 登录拦截器 --&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre><h1 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h1><ul>
<li><p><strong>@CookieValue</strong>：用于或者cookie中的指定值</p>
<pre><code class="java">(&quot;/testcookie&quot;)
public String testCookie(@CookieValue(&quot;JESSIONID&quot;) String seesionId){
  System.out.println(sessionId);
  return &quot;success&quot;;
}</code></pre>
</li>
<li><p><strong>@RequestHeader</strong>:用于获取请求头的指定内容</p>
<pre><code class="java">(&quot;/testheader&quot;)
public String testCookie(@RequestHeader(value=&quot;Accept-Language&quot;) String header){
  System.out.println(header);
  return &quot;success&quot;;
}</code></pre>
</li>
<li><p><strong>@SessionAttribute</strong>：用于设置session存储数据,使用时将其注解在Action类上</p>
<blockquote>
<p>@<code>SessionAttributes(value={&quot;user&quot;},types={String.class})</code>表示当使用<code>addAttribute</code>方法加入user时，除了会在request中加入，还会在sessin中也加入user，types指定所有的String类型都加入session中</p>
</blockquote>
</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/06/24/sm%E6%95%B4%E5%90%88/" title="Spring mybatis整合"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Spring mybatis整合</span></a><a class="button is-default" href="/2019/05/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/" title="java基础"><span class="has-text-weight-semibold">下一页: java基础</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备18114217号</a></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>