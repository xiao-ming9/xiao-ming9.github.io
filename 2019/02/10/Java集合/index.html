<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="集合分为三大接口:Collection,Map,Iterator Collection用于存储单个对象的集合,其下有两个子接口:List,Set List接口 有序接口 允许有多个null元素,元素可以重复 具体的实现有常用的:ArrayList,Vector,LinkedList  ArrayList采用动态数组实现,默认构造方法是创建一个空数组添加时每次都扩充一个单位不适合进行删除和插入为了防">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;02&#x2F;10&#x2F;Java%E9%9B%86%E5%90%88&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="集合分为三大接口:Collection,Map,Iterator Collection用于存储单个对象的集合,其下有两个子接口:List,Set List接口 有序接口 允许有多个null元素,元素可以重复 具体的实现有常用的:ArrayList,Vector,LinkedList  ArrayList采用动态数组实现,默认构造方法是创建一个空数组添加时每次都扩充一个单位不适合进行删除和插入为了防">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-01T10:37:40.233Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/02/10/Java%E9%9B%86%E5%90%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java集合 | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/10/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-10 10:52:48" itemprop="dateCreated datePublished" datetime="2019-02-10T10:52:48+08:00">2019-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-01 18:37:40" itemprop="dateModified" datetime="2020-12-01T18:37:40+08:00">2020-12-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>集合分为三大接口:<br><code>Collection</code>,<code>Map</code>,<code>Iterator</code></p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>用于存储单个对象的集合,其下有两个子接口:<br><code>List</code>,<code>Set</code></p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ol>
<li>有序接口</li>
<li>允许有多个null元素,元素可以重复</li>
<li>具体的实现有常用的:<code>ArrayList</code>,<code>Vector</code>,<code>LinkedList</code></li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>采用动态数组实现,默认构造方法是创建一个空数组<br>添加时每次都扩充一个单位<br>不适合进行删除和插入<br>为了防止数组动态扩充次数过多,可以在创建时给定初始容量<br>线程不安全,适合在单线程访问时使用,效率较高</p>
<a id="more"></a>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;


public class ListDemo {

    public static void main(String[] args) {
        arrayList();
    }
    private static void arrayList() {

        List list = new ArrayList();//可以使用集合来存储多个不同类型的元素(对象)
        List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();////可以使用泛型指定对象类型

        //数组添加
        list.add(&quot;笑一笑,十年少&quot;);
        list.add(123);

        list1.add(&quot;飞驰人生&quot;);
        list1.add(&quot;流浪地球&quot;);
        //list1.add(123);//报错

        int size = list1.size();
        for(int i=0;i&lt;size;i++) {
            System.out.println(list.get(i));
            System.out.println(list1.get(i));
        }

        //判断是否包含
        System.out.println(list1.contains(&quot;飞驰人生&quot;));
        //删除
        list1.remove(&quot;飞驰人生&quot;);
        System.out.println(list1.size());
        //转成数组
        String[] array = list1.toArray(new String[] {});
        for(String s: array) {
            System.out.println(s);
        }
    }
}
</code></pre>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>采用动态数组实现,默认构造方法是创建一个容量为10数组<br>添加时每次都扩充一个单位<br>不适合进行删除和插入<br>为了防止数组动态扩充次数过多,可以在创建时给定初始容量<br>线程安全,适合在多线程访问时使用,单效率较低 <strong>(区别)</strong></p>
<pre><code class="java">private static void vector() {
        Vector&lt;String&gt; v = new Vector&lt;String&gt;();
        v.add(&quot;昨夜风疏雨&quot;);
        v.add(&quot;浓睡不消残酒&quot;);

        for(int i=0;i&lt;v.size();i++) {
            System.out.println(v.get(i));
        }
    }</code></pre>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>采用双向链表的数据结构<br>适合插入,删除操作,性能高</p>
<pre><code class="java">private static void linkedList() {
        LinkedList&lt;String&gt; ll = new LinkedList&lt;String&gt;();
        ll.add(&quot;试问卷帘人&quot;);
        ll.add(&quot;却道海棠花依旧&quot;);
        for(int i=0;i&lt;ll.size();i++) {
            System.out.println(ll.get(i));
        }
    }</code></pre>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ol>
<li>无序的</li>
<li>不允许元素重复</li>
<li>具体的实现类有:<code>HashSet</code>,<code>TreeSet</code>,<code>LinkedHashSet</code><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3></li>
</ol>
<p>实现原理:哈希表<br>不允许重复(通过equals检查是否相同),可以有一个null元素<br>不保证顺序恒久不变<br>添加元素把元素作为HashMap的key存储,HashMap的value使用一个固定的Object对象</p>
<pre><code class="java">private static void hashSet() {
        Set&lt;String&gt; set = new HashSet&lt;String&gt;();
        set.add(&quot;知否,&quot;);
        set.add(&quot;知否,&quot;);//相同会自动替换掉上面的
        set.add(&quot;知否 &quot;);
        set.add(&quot;应是绿肥红瘦&quot;);

        String[] names = set.toArray(new String[] {});
        for(String s:names) {
            System.out.print(s);
        }
    }</code></pre>
<p><strong>hashCode</strong><br>是一个定义在object类中的本地方法,它的实现与本地机器相关<br>判断两个对象是否相等,首先是判断两个对象的<code>hashCode</code>是否相等,如果相等,进一步进行equals比较,都相同则是同一个对象<br>若要求自定义对象的属性值一致时认为是同一个对象,则可以重写所在类的<code>hashCode</code>和<code>equals</code>方法</p>
<pre><code class="java">@Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + id;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((sex == null) ? 0 : sex.hashCode());
        return result;
    }

@Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Dog other = (Dog) obj;
        if (age != other.age)
            return false;
        if (id != other.id)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (sex == null) {
            if (other.sex != null)
                return false;
        } else if (!sex.equals(other.sex))
            return false;
        return true;
    }</code></pre>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是有序的,基于二叉树数据结构,对象需要有比较器<br>对象比较器还可以用来去除重复元素</p>
<pre><code class="java">private static void treeSet() {
        Set&lt;String&gt; tree = new TreeSet&lt;String&gt;();
        tree.add(&quot;任侠平生愿&quot;);
        tree.add(&quot;一叶边舟莲波滟&quot;);

        //若是自定义的类,需要实现comparator接口(对象比较器),因为treeSet实现二叉树有序排列
        Set&lt;Cat&gt; catTree = new TreeSet&lt;Cat&gt;(new CatComparator());

        Cat c1 = new Cat(1,&quot;喵喵&quot;);
        Cat c2 = new Cat(2,&quot;旺旺&quot;);
        Cat c3 = new Cat(0,&quot;嘟嘟&quot;);
        //Cat c4 = new Cat(1,&quot;Tom&quot;);//因为age属性相同,执行add方法不会被加入(去除重复元素)
        catTree.add(c1);
        catTree.add(c2);
        catTree.add(c3);
        System.out.println(catTree.size());
    }</code></pre>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>根据添加顺序排序,相同元素添加会改变原有顺序</p>
<pre><code class="java">private static void linkedHashSet() {
        Set&lt;Cat&gt; linkHash = new LinkedHashSet()&lt;Cat&gt;;
        Cat c1 = new Cat(1,&quot;喵喵&quot;);
        Cat c2 = new Cat(2,&quot;旺旺&quot;);
        Cat c3 = new Cat(0,&quot;嘟嘟&quot;);
        linkHash.add(c1);
        linkHash.add(c2);
        linkHash.add(c3);
        System.out.println(catTree.size());
    }</code></pre>
<h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h1><p>用于遍历集合</p>
<h2 id="三种迭代方式"><a href="#三种迭代方式" class="headerlink" title="三种迭代方式"></a>三种迭代方式</h2><pre><code class="java">//foreach迭代
    private static void foreach(Collection&lt;Cat&gt; c) {
        for(Cat cat :c) {
            System.out.println(cat);
        }
    }

    //Iterator
    private static void iterator(Collection&lt;Cat&gt; c) {
        Iterator&lt;Cat&gt; iter = c.iterator();
        while(iter.hasNext()) {
            System.out.println(iter.next());
        }
    }

    private static void enumration() {
        Vector&lt;String&gt; vs = new Vector&lt;String&gt;();
        vs.add(&quot;tom&quot;);
        vs.add(&quot;jack&quot;);
        vs.add(&quot;job&quot;);
        vs.add(&quot;lily&quot;);

        Enumeration&lt;String&gt; es = vs.elements();
        while(es.hasMoreElements()) {
            System.out.println(es.nextElement());
        }
    }</code></pre>
<h2 id="foreach接口"><a href="#foreach接口" class="headerlink" title="foreach接口"></a>foreach接口</h2><p>JDK1.8实现了forEach方法</p>
<pre><code class="java">private static void foreach() {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;tom&quot;);
        list.add(&quot;jack&quot;);
        list.add(&quot;job&quot;);
        list.add(&quot;lily&quot;);

        //多种输出方式
        list.forEach(s-&gt;System.out.println(s));
        list.forEach((String s)-&gt;{System.out.println(s);});
        list.forEach(s-&gt;{System.out.println(s);});
        list.forEach(System.out::print);

    }</code></pre>
<h2 id="四大核心接口"><a href="#四大核心接口" class="headerlink" title="四大核心接口"></a>四大核心接口</h2><p><strong>Consumer&lt;T&gt;</strong> 消费者接口<br><strong>Function&lt;T,R&gt;</strong> 表示接受一个参数并产生结果的函数<br><strong>Supplier&lt;T&gt;</strong> 代表结果供应商<br><strong>Predicater&lt;T&gt;</strong> 断言接口  </p>
<pre><code class="java">private static void functionTest() {
    String s = strToUpp(&quot;abcdefg&quot;,(str)-&gt;str.toUpperCase());
    System.out.println(s);
}

private static String strToUpp(String str,Function&lt;String, String&gt; f) {
    return f.apply(str);
}

public static void supplierTest() {
    List&lt;Integer&gt; list = getNums(10,()-&gt;(int)(Math.random()*100));
    list.forEach(System.out::println);
}

public static List&lt;Integer&gt; getNums(int num,Supplier&lt;Integer&gt; sup){
    List&lt;Integer&gt; list  = new ArrayList&lt;Integer&gt;();

    for(int i=0;i&lt;num;i++) {
        list.add(sup.get());
    }

    return list;
}

public static void predicateTest() {
    List&lt;String&gt; list = Arrays.asList(&quot;AEG&quot;,&quot;MAC&quot;,&quot;Landom&quot;,&quot;eesg&quot;);
    List&lt;String&gt; result = filter(list,(s)-&gt;s.contains(&quot;a&quot;));
    result.forEach(System.out::println);
}

public static List&lt;String&gt; filter(List&lt;String&gt; list,Predicate&lt;String&gt; p){
    List&lt;String&gt; results = new ArrayList&lt;String&gt;();

    for(String s: list) {
        if(p.test(s)) {
            //测试是否包含
            results.add(s);
        }
    }

    return results;
}</code></pre>
<h2 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h2><p>Stream接口的数据源是一个集合,为了函数式编程创造,惰式执行,数据只能被消费一次(<strong>使用一次</strong>)</p>
<p>两种操作类型:</p>
<ol>
<li>中间操作(生成一个Stream),可以再调用别的Stream接口的方法</li>
<li>结束操作(执行计算操作)</li>
</ol>
<pre><code class="java">package Collection;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class StreamDemo {

    public static void main(String[] args) {

        //of方法用于生成Stream
        Stream&lt;String&gt; stream = Stream.of(&quot;good&quot;,&quot;good&quot;,&quot;study&quot;,&quot;day&quot;,&quot;day&quot;,&quot;up&quot;);

        //foreach方法(结束操作)
        stream.forEach((str)-&gt;System.out.println(str));
        stream.forEach(System.out::println);

        //过滤filter方法(中间操作)
        stream.filter((s)-&gt;s.length()&gt;3).forEach(System.out::println);

        //去除重复值
        stream.distinct().forEach(System.out::println);

        //映射map(把流全部映射后再进行操作)
        stream.map(s-&gt;s.toUpperCase()).forEach(System.out::println);

        //平摊flatMap(对于一个流中有不同的元素,每个元素有不同数量的集合,通过该方法把所有集合整合在一个流中)
        Stream&lt;List&lt;Integer&gt;&gt; ss = Stream.of(Arrays.asList(1,2,3),Arrays.asList(4,5));
        ss.flatMap(list-&gt;list.stream()).forEach(s-&gt;System.out.println(s));

        //reduce
        Optional&lt;String&gt; opt = stream.reduce((s1,s2)-&gt;s1.length()&gt;=s2.length()?s1:s2);
        System.out.println(opt.get());

        //collect 
        List&lt;String&gt; list = stream.collect(Collectors.toList());
        list.forEach(s-&gt;System.err.println(s));
    }
}
</code></pre>
<p><strong>关于::的用处</strong>  </p>
<ul>
<li>引用静态方法</li>
<li>引用对象的方法</li>
<li>引用构造方法</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><ol>
<li>键值对存储一组对象</li>
<li>key要不能重复(唯一)</li>
<li>value可以重复<br>具体的实现类有:<code>HashMap</code>,<code>TreeMap</code>,<code>LinkedHashMap</code></li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><pre><code class="java">package Collection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapDemo {

    public static void main(String[] args) {
        hashMap();
    }
    private static void hashMap() {
        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
        //复制
        map.put(1,&quot;Tom&quot;);
        map.put(2,&quot;Jack&quot;);
        map.put(3,&quot;Zip&quot;);

        //从map中取值
        System.out.println(map.get(1));//通过key取value

        //map遍历
        Set&lt;Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();
        for(Entry e:entrySet) {
            System.out.println(e.getKey()+&quot;-&gt;&quot;+e.getValue());
        }

        //第二种遍历方式:通过遍历键拿值
        Set&lt;Integer&gt; keys = map.keySet();
        for(Integer i:keys) {
            String value = map.get(i);
            System.out.println(i+&quot;-&gt;&quot;+value);
        }

        //第三种遍历方式(遍历值)
        Collection&lt;String&gt; values = map.values();
        for(String value:values) {
            System.out.println(value);
        }

        //第四种:foreach
        map.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));

        //判断是否包含
        System.out.println(map.containsKey(6));
    }
}
</code></pre>
<p><strong>HashMap实现原理</strong>  </p>
<ol>
<li>基于哈希表(数组+链表+二叉树(红黑树))</li>
<li>默认加载因子为0.75,表示当数组的数据利用率达到75%就进行空间扩充,默认数组大小是16</li>
<li>把key对象通过hash()方法计算hash值,然后用hash值对数组长度取余数(默认16),来决定该key对象在数组中的存储位置,当该位置有多个对象时,以链表方式存储,当链表长度大于8时,链表转换为红黑树结构存储(提高性能)</li>
<li>当数组容量超过75%时,数据扩充一倍(左移1),扩充次数过多会影响性能(每次扩充哈希表会重新计算每个对象的存储位置),在开发中尽量减少扩充</li>
<li>线程不安全,适合单线程中使用</li>
</ol>
<p>##　 hashTable  </p>
<ol>
<li><p>基于哈希表实现</p>
</li>
<li><p>默认数组大小为11,加载因子为0.75</p>
</li>
<li><p>扩充方法为原数组左移1,再+1</p>
</li>
<li><p><strong>线程安全,适合多线程使用</strong></p>
<pre><code class="java">private static void hashtable() {
 Map&lt;String, String&gt; table = new Hashtable&lt;String, String&gt;();
 table.put(&quot;one&quot;, &quot;Chinese&quot;);
 table.put(&quot;two&quot;,&quot;English&quot;);
 table.put(&quot;three&quot;,&quot;American&quot;);

 table.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));
}</code></pre>
</li>
</ol>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>此类是HashMap的子类,由于HashMap不能保证顺序恒久不变,此类使用一个双重链表来维护元素的添加顺序</p>
<pre><code class="java">private static void linkedHashMap() {
    Map&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;();
    link.put(&quot;one&quot;, &quot;Chinese&quot;);
    link.put(&quot;two&quot;,&quot;English&quot;);
    link.put(&quot;three&quot;,&quot;American&quot;);

    link.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));
}</code></pre>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现,该映射根据键的顺序进行排序,对于自定义对象,根据Comparator进行排序,具体用法同上</p>
<h2 id="Map接口jdk1-8新特性"><a href="#Map接口jdk1-8新特性" class="headerlink" title="Map接口jdk1.8新特性"></a>Map接口jdk1.8新特性</h2><p>Map接口中新增加了一些默认方法</p>
<pre><code class="java">//如果没有该值返回指定值
String name = map.getOrDefault(4, null);

//如果空才添加,put方法放回老的value,putIfAbsent返回新的或者已存在的
map.putIfAbsent(3, &quot;xixi&quot;);

//删除,key和value都匹配时才能删除
map.remove(1, &quot;vince&quot;);

//替换
map.replace(1, &quot;aaa&quot;);//如果key不为空,替换为指定的value
map.replace(1, &quot;jack&quot;, &quot;youoyou&quot;);//键值对匹配才替换新的

//执行函数操作
map.compute(1,(k,v)-&gt;v+&quot;1&quot;);//jack1
map.computeIfAbsent(2,(val)-&gt;val+&quot;test&quot;);//为空就执行后面的函数

//合并
map.merge(1, &quot;888&quot;, (oldVal,newVal)-&gt;oldVal.concat(newVal));//jack888</code></pre>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>该工具类提供了大量针对Collection/Map的操作,总体可以分为四类,都是静态方法</p>
<ol>
<li>排序操作(主要针对List接口)<pre><code class="java">//反转
Collections.reverse(list);
//随机排序
Collections.shuffle(list);
//根据自然升序排序
Collections.sort(list);
//自定义比较器排序
Collections.sort(list,c);
//交换位置
Collections.swap(list, 0, 2);
//所有元素向右移动指定长度
Collections.rotate(list, 2);</code></pre>
</li>
<li>查找和替换(针对Collection相关的接口)<pre><code class="java">//采用二分查找法,搜索返回键值(前提是已排序)
Collections.binarySearch(list, &quot;tom&quot;);
//求最大最小值
Collections.max(list);
Collections.min(list);
//使用指定对象填充(全部变成指定对象)
Collections.fill(list, &quot;duola&quot;);
//返回指定值出现次数
Collections.frequency(list, &quot;lily&quot;);
//替换(替换所有跟指定值相同的值)
Collections.replaceAll(list, &quot;old&quot;, &quot;new&quot;);</code></pre>
</li>
<li>同步控制</li>
</ol>
<p>提供多个<code>synchronizedXXX</code>方法,该方法返回指定集合对应的同步对象,针对HashSet,ArrayList,HashMap等线程不安全的同步问题<br><strong>在使用迭代方法遍历集合时需要手工同步返回的集合</strong></p>
<ol start="4">
<li>设置不可变的集合</li>
</ol>
<ul>
<li>Collections.emptyXXX():返回一个空的不可变的xxx</li>
<li>Collections.singletonXXX():返回一个只包含指定对象的,不可变的集合对象</li>
<li>unmodifiableXXX():返回指定集合对象的不可变视图</li>
</ul>
<h1 id="Optional容器类"><a href="#Optional容器类" class="headerlink" title="Optional容器类"></a>Optional容器类</h1><p>一个可以为null的容器对象，如果值存在isPresent方法会返回true,调用get方法会返回该对象</p>
<pre><code class="java">package collection;

import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args){

        Optional&lt;String&gt; optional1 = Optional.of(&quot;family&quot;);//创建一个非null的Optional
        Optional&lt;String&gt; optional2 = Optional.ofNullable(&quot;house&quot;);//为指定的值创建一个Optional,如果指定值为空返回一个空的Optional
        System.out.println(optional1.isPresent());//如果值存在返回true，否则返回false
        System.out.println(optional2.get());//如果值存在返回该值，否则抛出NoSuchElementException
        optional1.ifPresent((value)-&gt;System.out.println(value.toUpperCase()));//如果Optional实例有值则为其调用consumer,否则不作处理
        System.out.println(optional2.orElse(&quot;无值&quot;));//如果有值就返回，否则返回指定的其他值
        optional2.orElseGet(()-&gt;&quot;default&quot;);//与orElse方法相似，区别在于该方法可以接受Supplier接口的实现用来生成默认值
        Optional&lt;String&gt; optional3 = Optional.ofNullable(null);
        try {
            optional3.orElseThrow(Exception::new);//如果有值将其返回，否则抛出supplier异常
        } catch (Exception e) {
            e.printStackTrace();
        }
        Optional&lt;String&gt; optional4 = optional1.map((value)-&gt;value.toUpperCase());//如果有值，执行mapping函数返回值，如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional
        System.out.println(optional4.orElse(&quot;没有值&quot;));
        Optional&lt;String&gt; optional5 = optional1.flatMap((value)-&gt;Optional.of(value.toUpperCase()));
        System.out.println(optional5.orElse(&quot;没有值&quot;));//与map类似，但该方法不会将返回值封装成Optional封装
        optional4 = optional4.filter((value)-&gt;value.length()&gt;3);//如果有值并且满足断言条件就返回该值的Optional，否则返回空的Optional
        System.out.println(optional4.orElse(&quot;该值长度不大于三&quot;));
    }
}</code></pre>
<h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><pre><code class="java">package collection;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class QueueAndStackDemo {
    public static void main(String[] args) {
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();//队列，先进先出
        Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();//双端队列
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        queue.add(&quot;小白&quot;);
        queue.add(&quot;小黑&quot;);
        queue.add(&quot;小花&quot;);
        queue.add(&quot;小红&quot;);

        System.out.println(queue.size());
        System.out.println(queue.peek());//取值但不删除
        System.out.println(queue.poll());//取值且移除
        queue.remove();//删除

    }

}
</code></pre>
<h1 id="对象的一对多关系"><a href="#对象的一对多关系" class="headerlink" title="对象的一对多关系"></a>对象的一对多关系</h1><pre><code class="java">
import java.util.HashSet;

public class Teacher {

    private String name;
    private int age;
    private HashSet&lt;Student&gt; students = new HashSet&lt;&gt;();

    public Teacher() {
    }

    public Teacher(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public HashSet&lt;Student&gt; getStudents() {
        return students;
    }

    public void setStudents(HashSet&lt;Student&gt; students) {
        this.students = students;
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }
}

public class Student {

    private String name;
    private int age;
    private Teacher teacher;

    public Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Teacher getTeacher() {
        return teacher;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, teacher=&quot; + teacher +
                &#39;}&#39;;
    }
}

package collection;

public class HasManyDemo {
    public static void main(String[] args) {
        Teacher teacher = new Teacher(&quot;邢老师&quot;,8);

        Student student1 = new Student(&quot;小a&quot;,10);
        Student student2 = new Student(&quot;小b&quot;,12);
        Student student3 = new Student(&quot;小c&quot;,4);
        Student student4 = new Student(&quot;小d&quot;,35);

        teacher.getStudents().add(student1);
        teacher.getStudents().add(student2);
        teacher.getStudents().add(student3);
        teacher.getStudents().add(student4);

        student1.setTeacher(teacher);
        student2.setTeacher(teacher);
        student3.setTeacher(teacher);
        student4.setTeacher(teacher);

        print(teacher);
    }

    private static void print(Teacher t1){
        System.out.println(t1.getName());
        System.out.println(t1.getAge());
        for(Student s:t1.getStudents()){
            System.out.println(s);
        }
    }
}</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/15/Java%E6%96%87%E4%BB%B6%E4%B8%8EIO/" rel="prev" title="Java文件与IO">
      <i class="fa fa-chevron-left"></i> Java文件与IO
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/02/12/%E6%B3%9B%E5%9E%8B/" rel="next" title="泛型">
      泛型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection"><span class="nav-number">1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List接口"><span class="nav-number">1.1.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-number">1.1.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector"><span class="nav-number">1.1.2.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList"><span class="nav-number">1.1.3.</span> <span class="nav-text">LinkedList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set接口"><span class="nav-number">1.2.</span> <span class="nav-text">Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet"><span class="nav-number">1.2.1.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet"><span class="nav-number">1.2.2.</span> <span class="nav-text">TreeSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">1.2.3.</span> <span class="nav-text">LinkedHashSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Iterator-迭代器"><span class="nav-number">2.</span> <span class="nav-text">Iterator(迭代器)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三种迭代方式"><span class="nav-number">2.1.</span> <span class="nav-text">三种迭代方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#foreach接口"><span class="nav-number">2.2.</span> <span class="nav-text">foreach接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四大核心接口"><span class="nav-number">2.3.</span> <span class="nav-text">四大核心接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream接口"><span class="nav-number">2.4.</span> <span class="nav-text">Stream接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map接口"><span class="nav-number">3.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">3.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">3.2.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">3.3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map接口jdk1-8新特性"><span class="nav-number">3.4.</span> <span class="nav-text">Map接口jdk1.8新特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collections工具类"><span class="nav-number">4.</span> <span class="nav-text">Collections工具类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Optional容器类"><span class="nav-number">5.</span> <span class="nav-text">Optional容器类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆和栈"><span class="nav-number">6.</span> <span class="nav-text">堆和栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象的一对多关系"><span class="nav-number">7.</span> <span class="nav-text">对象的一对多关系</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">2.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
