<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Java集合</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Java集合</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Collection"><span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List接口"><span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set接口"><span class="toc-text">Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-text">LinkedHashSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterator-迭代器"><span class="toc-text">Iterator(迭代器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#三种迭代方式"><span class="toc-text">三种迭代方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach接口"><span class="toc-text">foreach接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大核心接口"><span class="toc-text">四大核心接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream接口"><span class="toc-text">Stream接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map接口"><span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map接口jdk1-8新特性"><span class="toc-text">Map接口jdk1.8新特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections工具类"><span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional容器类"><span class="toc-text">Optional容器类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆和栈"><span class="toc-text">堆和栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的一对多关系"><span class="toc-text">对象的一对多关系</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Java集合</h1><time class="has-text-grey" datetime="2019-02-10T02:52:48.000Z">2019-02-10</time><article class="mt-2 post-content"><p>集合分为三大接口:<br><code>Collection</code>,<code>Map</code>,<code>Iterator</code></p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>用于存储单个对象的集合,其下有两个子接口:<br><code>List</code>,<code>Set</code></p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ol>
<li>有序接口</li>
<li>允许有多个null元素,元素可以重复</li>
<li>具体的实现有常用的:<code>ArrayList</code>,<code>Vector</code>,<code>LinkedList</code></li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>采用动态数组实现,默认构造方法是创建一个空数组<br>添加时每次都扩充一个单位<br>不适合进行删除和插入<br>为了防止数组动态扩充次数过多,可以在创建时给定初始容量<br>线程不安全,适合在单线程访问时使用,效率较高</p>
<a id="more"></a>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;


public class ListDemo {

    public static void main(String[] args) {
        arrayList();
    }
    private static void arrayList() {

        List list = new ArrayList();//可以使用集合来存储多个不同类型的元素(对象)
        List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();////可以使用泛型指定对象类型

        //数组添加
        list.add(&quot;笑一笑,十年少&quot;);
        list.add(123);

        list1.add(&quot;飞驰人生&quot;);
        list1.add(&quot;流浪地球&quot;);
        //list1.add(123);//报错

        int size = list1.size();
        for(int i=0;i&lt;size;i++) {
            System.out.println(list.get(i));
            System.out.println(list1.get(i));
        }

        //判断是否包含
        System.out.println(list1.contains(&quot;飞驰人生&quot;));
        //删除
        list1.remove(&quot;飞驰人生&quot;);
        System.out.println(list1.size());
        //转成数组
        String[] array = list1.toArray(new String[] {});
        for(String s: array) {
            System.out.println(s);
        }
    }
}
</code></pre>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>采用动态数组实现,默认构造方法是创建一个容量为10数组<br>添加时每次都扩充一个单位<br>不适合进行删除和插入<br>为了防止数组动态扩充次数过多,可以在创建时给定初始容量<br>线程安全,适合在多线程访问时使用,单效率较低 <strong>(区别)</strong></p>
<pre><code class="java">private static void vector() {
        Vector&lt;String&gt; v = new Vector&lt;String&gt;();
        v.add(&quot;昨夜风疏雨&quot;);
        v.add(&quot;浓睡不消残酒&quot;);

        for(int i=0;i&lt;v.size();i++) {
            System.out.println(v.get(i));
        }
    }</code></pre>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>采用双向链表的数据结构<br>适合插入,删除操作,性能高</p>
<pre><code class="java">private static void linkedList() {
        LinkedList&lt;String&gt; ll = new LinkedList&lt;String&gt;();
        ll.add(&quot;试问卷帘人&quot;);
        ll.add(&quot;却道海棠花依旧&quot;);
        for(int i=0;i&lt;ll.size();i++) {
            System.out.println(ll.get(i));
        }
    }</code></pre>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ol>
<li>无序的</li>
<li>不允许元素重复</li>
<li>具体的实现类有:<code>HashSet</code>,<code>TreeSet</code>,<code>LinkedHashSet</code><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3></li>
</ol>
<p>实现原理:哈希表<br>不允许重复(通过equals检查是否相同),可以有一个null元素<br>不保证顺序恒久不变<br>添加元素把元素作为HashMap的key存储,HashMap的value使用一个固定的Object对象</p>
<pre><code class="java">private static void hashSet() {
        Set&lt;String&gt; set = new HashSet&lt;String&gt;();
        set.add(&quot;知否,&quot;);
        set.add(&quot;知否,&quot;);//相同会自动替换掉上面的
        set.add(&quot;知否 &quot;);
        set.add(&quot;应是绿肥红瘦&quot;);

        String[] names = set.toArray(new String[] {});
        for(String s:names) {
            System.out.print(s);
        }
    }</code></pre>
<p><strong>hashCode</strong><br>是一个定义在object类中的本地方法,它的实现与本地机器相关<br>判断两个对象是否相等,首先是判断两个对象的<code>hashCode</code>是否相等,如果相等,进一步进行equals比较,都相同则是同一个对象<br>若要求自定义对象的属性值一致时认为是同一个对象,则可以重写所在类的<code>hashCode</code>和<code>equals</code>方法</p>
<pre><code class="java">@Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + id;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((sex == null) ? 0 : sex.hashCode());
        return result;
    }

@Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Dog other = (Dog) obj;
        if (age != other.age)
            return false;
        if (id != other.id)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (sex == null) {
            if (other.sex != null)
                return false;
        } else if (!sex.equals(other.sex))
            return false;
        return true;
    }</code></pre>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是有序的,基于二叉树数据结构,对象需要有比较器<br>对象比较器还可以用来去除重复元素</p>
<pre><code class="java">private static void treeSet() {
        Set&lt;String&gt; tree = new TreeSet&lt;String&gt;();
        tree.add(&quot;任侠平生愿&quot;);
        tree.add(&quot;一叶边舟莲波滟&quot;);

        //若是自定义的类,需要实现comparator接口(对象比较器),因为treeSet实现二叉树有序排列
        Set&lt;Cat&gt; catTree = new TreeSet&lt;Cat&gt;(new CatComparator());

        Cat c1 = new Cat(1,&quot;喵喵&quot;);
        Cat c2 = new Cat(2,&quot;旺旺&quot;);
        Cat c3 = new Cat(0,&quot;嘟嘟&quot;);
        //Cat c4 = new Cat(1,&quot;Tom&quot;);//因为age属性相同,执行add方法不会被加入(去除重复元素)
        catTree.add(c1);
        catTree.add(c2);
        catTree.add(c3);
        System.out.println(catTree.size());
    }</code></pre>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>根据添加顺序排序,相同元素添加会改变原有顺序</p>
<pre><code class="java">private static void linkedHashSet() {
        Set&lt;Cat&gt; linkHash = new LinkedHashSet()&lt;Cat&gt;;
        Cat c1 = new Cat(1,&quot;喵喵&quot;);
        Cat c2 = new Cat(2,&quot;旺旺&quot;);
        Cat c3 = new Cat(0,&quot;嘟嘟&quot;);
        linkHash.add(c1);
        linkHash.add(c2);
        linkHash.add(c3);
        System.out.println(catTree.size());
    }</code></pre>
<h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h1><p>用于遍历集合</p>
<h2 id="三种迭代方式"><a href="#三种迭代方式" class="headerlink" title="三种迭代方式"></a>三种迭代方式</h2><pre><code class="java">//foreach迭代
    private static void foreach(Collection&lt;Cat&gt; c) {
        for(Cat cat :c) {
            System.out.println(cat);
        }
    }

    //Iterator
    private static void iterator(Collection&lt;Cat&gt; c) {
        Iterator&lt;Cat&gt; iter = c.iterator();
        while(iter.hasNext()) {
            System.out.println(iter.next());
        }
    }

    private static void enumration() {
        Vector&lt;String&gt; vs = new Vector&lt;String&gt;();
        vs.add(&quot;tom&quot;);
        vs.add(&quot;jack&quot;);
        vs.add(&quot;job&quot;);
        vs.add(&quot;lily&quot;);

        Enumeration&lt;String&gt; es = vs.elements();
        while(es.hasMoreElements()) {
            System.out.println(es.nextElement());
        }
    }</code></pre>
<h2 id="foreach接口"><a href="#foreach接口" class="headerlink" title="foreach接口"></a>foreach接口</h2><p>JDK1.8实现了forEach方法</p>
<pre><code class="java">private static void foreach() {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;tom&quot;);
        list.add(&quot;jack&quot;);
        list.add(&quot;job&quot;);
        list.add(&quot;lily&quot;);

        //多种输出方式
        list.forEach(s-&gt;System.out.println(s));
        list.forEach((String s)-&gt;{System.out.println(s);});
        list.forEach(s-&gt;{System.out.println(s);});
        list.forEach(System.out::print);

    }</code></pre>
<h2 id="四大核心接口"><a href="#四大核心接口" class="headerlink" title="四大核心接口"></a>四大核心接口</h2><p><strong>Consumer&lt;T&gt;</strong> 消费者接口<br><strong>Function&lt;T,R&gt;</strong> 表示接受一个参数并产生结果的函数<br><strong>Supplier&lt;T&gt;</strong> 代表结果供应商<br><strong>Predicater&lt;T&gt;</strong> 断言接口  </p>
<pre><code class="java">private static void functionTest() {
    String s = strToUpp(&quot;abcdefg&quot;,(str)-&gt;str.toUpperCase());
    System.out.println(s);
}

private static String strToUpp(String str,Function&lt;String, String&gt; f) {
    return f.apply(str);
}

public static void supplierTest() {
    List&lt;Integer&gt; list = getNums(10,()-&gt;(int)(Math.random()*100));
    list.forEach(System.out::println);
}

public static List&lt;Integer&gt; getNums(int num,Supplier&lt;Integer&gt; sup){
    List&lt;Integer&gt; list  = new ArrayList&lt;Integer&gt;();

    for(int i=0;i&lt;num;i++) {
        list.add(sup.get());
    }

    return list;
}

public static void predicateTest() {
    List&lt;String&gt; list = Arrays.asList(&quot;AEG&quot;,&quot;MAC&quot;,&quot;Landom&quot;,&quot;eesg&quot;);
    List&lt;String&gt; result = filter(list,(s)-&gt;s.contains(&quot;a&quot;));
    result.forEach(System.out::println);
}

public static List&lt;String&gt; filter(List&lt;String&gt; list,Predicate&lt;String&gt; p){
    List&lt;String&gt; results = new ArrayList&lt;String&gt;();

    for(String s: list) {
        if(p.test(s)) {
            //测试是否包含
            results.add(s);
        }
    }

    return results;
}</code></pre>
<h2 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h2><p>Stream接口的数据源是一个集合,为了函数式编程创造,惰式执行,数据只能被消费一次(<strong>使用一次</strong>)</p>
<p>两种操作类型:</p>
<ol>
<li>中间操作(生成一个Stream),可以再调用别的Stream接口的方法</li>
<li>结束操作(执行计算操作)</li>
</ol>
<pre><code class="java">package Collection;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class StreamDemo {

    public static void main(String[] args) {

        //of方法用于生成Stream
        Stream&lt;String&gt; stream = Stream.of(&quot;good&quot;,&quot;good&quot;,&quot;study&quot;,&quot;day&quot;,&quot;day&quot;,&quot;up&quot;);

        //foreach方法(结束操作)
        stream.forEach((str)-&gt;System.out.println(str));
        stream.forEach(System.out::println);

        //过滤filter方法(中间操作)
        stream.filter((s)-&gt;s.length()&gt;3).forEach(System.out::println);

        //去除重复值
        stream.distinct().forEach(System.out::println);

        //映射map(把流全部映射后再进行操作)
        stream.map(s-&gt;s.toUpperCase()).forEach(System.out::println);

        //平摊flatMap(对于一个流中有不同的元素,每个元素有不同数量的集合,通过该方法把所有集合整合在一个流中)
        Stream&lt;List&lt;Integer&gt;&gt; ss = Stream.of(Arrays.asList(1,2,3),Arrays.asList(4,5));
        ss.flatMap(list-&gt;list.stream()).forEach(s-&gt;System.out.println(s));

        //reduce
        Optional&lt;String&gt; opt = stream.reduce((s1,s2)-&gt;s1.length()&gt;=s2.length()?s1:s2);
        System.out.println(opt.get());

        //collect 
        List&lt;String&gt; list = stream.collect(Collectors.toList());
        list.forEach(s-&gt;System.err.println(s));
    }
}
</code></pre>
<p><strong>关于::的用处</strong>  </p>
<ul>
<li>引用静态方法</li>
<li>引用对象的方法</li>
<li>引用构造方法</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><ol>
<li>键值对存储一组对象</li>
<li>key要不能重复(唯一)</li>
<li>value可以重复<br>具体的实现类有:<code>HashMap</code>,<code>TreeMap</code>,<code>LinkedHashMap</code></li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><pre><code class="java">package Collection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapDemo {

    public static void main(String[] args) {
        hashMap();
    }
    private static void hashMap() {
        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
        //复制
        map.put(1,&quot;Tom&quot;);
        map.put(2,&quot;Jack&quot;);
        map.put(3,&quot;Zip&quot;);

        //从map中取值
        System.out.println(map.get(1));//通过key取value

        //map遍历
        Set&lt;Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();
        for(Entry e:entrySet) {
            System.out.println(e.getKey()+&quot;-&gt;&quot;+e.getValue());
        }

        //第二种遍历方式:通过遍历键拿值
        Set&lt;Integer&gt; keys = map.keySet();
        for(Integer i:keys) {
            String value = map.get(i);
            System.out.println(i+&quot;-&gt;&quot;+value);
        }

        //第三种遍历方式(遍历值)
        Collection&lt;String&gt; values = map.values();
        for(String value:values) {
            System.out.println(value);
        }

        //第四种:foreach
        map.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));

        //判断是否包含
        System.out.println(map.containsKey(6));
    }
}
</code></pre>
<p><strong>HashMap实现原理</strong>  </p>
<ol>
<li>基于哈希表(数组+链表+二叉树(红黑树))</li>
<li>默认加载因子为0.75,表示当数组的数据利用率达到75%就进行空间扩充,默认数组大小是16</li>
<li>把key对象通过hash()方法计算hash值,然后用hash值对数组长度取余数(默认16),来决定该key对象在数组中的存储位置,当该位置有多个对象时,以链表方式存储,当链表长度大于8时,链表转换为红黑树结构存储(提高性能)</li>
<li>当数组容量超过75%时,数据扩充一倍(左移1),扩充次数过多会影响性能(每次扩充哈希表会重新计算每个对象的存储位置),在开发中尽量减少扩充</li>
<li>线程不安全,适合单线程中使用</li>
</ol>
<p>##　 hashTable  </p>
<ol>
<li><p>基于哈希表实现</p>
</li>
<li><p>默认数组大小为11,加载因子为0.75</p>
</li>
<li><p>扩充方法为原数组左移1,再+1</p>
</li>
<li><p><strong>线程安全,适合多线程使用</strong></p>
<pre><code class="java">private static void hashtable() {
 Map&lt;String, String&gt; table = new Hashtable&lt;String, String&gt;();
 table.put(&quot;one&quot;, &quot;Chinese&quot;);
 table.put(&quot;two&quot;,&quot;English&quot;);
 table.put(&quot;three&quot;,&quot;American&quot;);

 table.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));
}</code></pre>
</li>
</ol>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>此类是HashMap的子类,由于HashMap不能保证顺序恒久不变,此类使用一个双重链表来维护元素的添加顺序</p>
<pre><code class="java">private static void linkedHashMap() {
    Map&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;();
    link.put(&quot;one&quot;, &quot;Chinese&quot;);
    link.put(&quot;two&quot;,&quot;English&quot;);
    link.put(&quot;three&quot;,&quot;American&quot;);

    link.forEach((key,value)-&gt;System.out.println(key+&quot;-&gt;&quot;+value));
}</code></pre>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现,该映射根据键的顺序进行排序,对于自定义对象,根据Comparator进行排序,具体用法同上</p>
<h2 id="Map接口jdk1-8新特性"><a href="#Map接口jdk1-8新特性" class="headerlink" title="Map接口jdk1.8新特性"></a>Map接口jdk1.8新特性</h2><p>Map接口中新增加了一些默认方法</p>
<pre><code class="java">//如果没有该值返回指定值
String name = map.getOrDefault(4, null);

//如果空才添加,put方法放回老的value,putIfAbsent返回新的或者已存在的
map.putIfAbsent(3, &quot;xixi&quot;);

//删除,key和value都匹配时才能删除
map.remove(1, &quot;vince&quot;);

//替换
map.replace(1, &quot;aaa&quot;);//如果key不为空,替换为指定的value
map.replace(1, &quot;jack&quot;, &quot;youoyou&quot;);//键值对匹配才替换新的

//执行函数操作
map.compute(1,(k,v)-&gt;v+&quot;1&quot;);//jack1
map.computeIfAbsent(2,(val)-&gt;val+&quot;test&quot;);//为空就执行后面的函数

//合并
map.merge(1, &quot;888&quot;, (oldVal,newVal)-&gt;oldVal.concat(newVal));//jack888</code></pre>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>该工具类提供了大量针对Collection/Map的操作,总体可以分为四类,都是静态方法</p>
<ol>
<li>排序操作(主要针对List接口)<pre><code class="java">//反转
Collections.reverse(list);
//随机排序
Collections.shuffle(list);
//根据自然升序排序
Collections.sort(list);
//自定义比较器排序
Collections.sort(list,c);
//交换位置
Collections.swap(list, 0, 2);
//所有元素向右移动指定长度
Collections.rotate(list, 2);</code></pre>
</li>
<li>查找和替换(针对Collection相关的接口)<pre><code class="java">//采用二分查找法,搜索返回键值(前提是已排序)
Collections.binarySearch(list, &quot;tom&quot;);
//求最大最小值
Collections.max(list);
Collections.min(list);
//使用指定对象填充(全部变成指定对象)
Collections.fill(list, &quot;duola&quot;);
//返回指定值出现次数
Collections.frequency(list, &quot;lily&quot;);
//替换(替换所有跟指定值相同的值)
Collections.replaceAll(list, &quot;old&quot;, &quot;new&quot;);</code></pre>
</li>
<li>同步控制</li>
</ol>
<p>提供多个<code>synchronizedXXX</code>方法,该方法返回指定集合对应的同步对象,针对HashSet,ArrayList,HashMap等线程不安全的同步问题<br><strong>在使用迭代方法遍历集合时需要手工同步返回的集合</strong></p>
<ol start="4">
<li>设置不可变的集合</li>
</ol>
<ul>
<li>Collections.emptyXXX():返回一个空的不可变的xxx</li>
<li>Collections.singletonXXX():返回一个只包含指定对象的,不可变的集合对象</li>
<li>unmodifiableXXX():返回指定集合对象的不可变视图</li>
</ul>
<h1 id="Optional容器类"><a href="#Optional容器类" class="headerlink" title="Optional容器类"></a>Optional容器类</h1><p>一个可以为null的容器对象，如果值存在isPresent方法会返回true,调用get方法会返回该对象</p>
<pre><code class="java">package collection;

import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args){

        Optional&lt;String&gt; optional1 = Optional.of(&quot;family&quot;);//创建一个非null的Optional
        Optional&lt;String&gt; optional2 = Optional.ofNullable(&quot;house&quot;);//为指定的值创建一个Optional,如果指定值为空返回一个空的Optional
        System.out.println(optional1.isPresent());//如果值存在返回true，否则返回false
        System.out.println(optional2.get());//如果值存在返回该值，否则抛出NoSuchElementException
        optional1.ifPresent((value)-&gt;System.out.println(value.toUpperCase()));//如果Optional实例有值则为其调用consumer,否则不作处理
        System.out.println(optional2.orElse(&quot;无值&quot;));//如果有值就返回，否则返回指定的其他值
        optional2.orElseGet(()-&gt;&quot;default&quot;);//与orElse方法相似，区别在于该方法可以接受Supplier接口的实现用来生成默认值
        Optional&lt;String&gt; optional3 = Optional.ofNullable(null);
        try {
            optional3.orElseThrow(Exception::new);//如果有值将其返回，否则抛出supplier异常
        } catch (Exception e) {
            e.printStackTrace();
        }
        Optional&lt;String&gt; optional4 = optional1.map((value)-&gt;value.toUpperCase());//如果有值，执行mapping函数返回值，如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional
        System.out.println(optional4.orElse(&quot;没有值&quot;));
        Optional&lt;String&gt; optional5 = optional1.flatMap((value)-&gt;Optional.of(value.toUpperCase()));
        System.out.println(optional5.orElse(&quot;没有值&quot;));//与map类似，但该方法不会将返回值封装成Optional封装
        optional4 = optional4.filter((value)-&gt;value.length()&gt;3);//如果有值并且满足断言条件就返回该值的Optional，否则返回空的Optional
        System.out.println(optional4.orElse(&quot;该值长度不大于三&quot;));
    }
}</code></pre>
<h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><pre><code class="java">package collection;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class QueueAndStackDemo {
    public static void main(String[] args) {
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();//队列，先进先出
        Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();//双端队列
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        queue.add(&quot;小白&quot;);
        queue.add(&quot;小黑&quot;);
        queue.add(&quot;小花&quot;);
        queue.add(&quot;小红&quot;);

        System.out.println(queue.size());
        System.out.println(queue.peek());//取值但不删除
        System.out.println(queue.poll());//取值且移除
        queue.remove();//删除

    }

}
</code></pre>
<h1 id="对象的一对多关系"><a href="#对象的一对多关系" class="headerlink" title="对象的一对多关系"></a>对象的一对多关系</h1><pre><code class="java">
import java.util.HashSet;

public class Teacher {

    private String name;
    private int age;
    private HashSet&lt;Student&gt; students = new HashSet&lt;&gt;();

    public Teacher() {
    }

    public Teacher(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public HashSet&lt;Student&gt; getStudents() {
        return students;
    }

    public void setStudents(HashSet&lt;Student&gt; students) {
        this.students = students;
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }
}

public class Student {

    private String name;
    private int age;
    private Teacher teacher;

    public Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Teacher getTeacher() {
        return teacher;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, teacher=&quot; + teacher +
                &#39;}&#39;;
    }
}

package collection;

public class HasManyDemo {
    public static void main(String[] args) {
        Teacher teacher = new Teacher(&quot;邢老师&quot;,8);

        Student student1 = new Student(&quot;小a&quot;,10);
        Student student2 = new Student(&quot;小b&quot;,12);
        Student student3 = new Student(&quot;小c&quot;,4);
        Student student4 = new Student(&quot;小d&quot;,35);

        teacher.getStudents().add(student1);
        teacher.getStudents().add(student2);
        teacher.getStudents().add(student3);
        teacher.getStudents().add(student4);

        student1.setTeacher(teacher);
        student2.setTeacher(teacher);
        student3.setTeacher(teacher);
        student4.setTeacher(teacher);

        print(teacher);
    }

    private static void print(Teacher t1){
        System.out.println(t1.getName());
        System.out.println(t1.getAge());
        for(Student s:t1.getStudents()){
            System.out.println(s);
        }
    }
}</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/02/12/%E6%B3%9B%E5%9E%8B/" title="泛型"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 泛型</span></a><a class="button is-default" href="/2019/01/15/Java%E6%96%87%E4%BB%B6%E4%B8%8EIO/" title="Java文件与IO"><span class="has-text-weight-semibold">下一页: Java文件与IO</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>