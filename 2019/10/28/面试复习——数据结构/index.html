

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="1. 队列队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。队列有两种：

单队列（单队列就是常见的队列,每次添加元素时，都是添加到队尾，存在“假溢出”的问题，也就是明明有位置却不能添加的情况）
循环队列（避免了“假溢出”的问题）
">
  <meta name="author" content="Silverming">
  <meta name="keywords" content="">
  
  <title>数据结构 - Silverming</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"54ebb03ad7ad5b762ac8ff7958df6d3f","google":"G-M2RT7SDT3L","gtag":"G-M2RT7SDT3L","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tFHjJkaAYKqH8BIXKnJVurUc-MdYXbMMI","app_key":"1qR5F7XyydYd5YJtIpMJBFmP","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Silverming</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:" target="_blank" rel="noopener">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-28 09:25" pubdate>
        2019年10月28日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      226
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 个月前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h1><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。<br>队列有两种：</p>
<ul>
<li>单队列（单队列就是常见的队列,每次添加元素时，都是添加到队尾，<strong>存在“假溢出”的问题</strong>，也就是明明有位置却不能添加的情况）</li>
<li>循环队列（避免了“假溢出”的问题）</li>
</ul>
<a id="more"></a>

<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾：</p>
<p>初始时，<code>front</code>和<code>rear</code>都为0，每添加一个元素，<code>rear</code>后移一位，没删除一个元素，<code>front</code>后移一位。当出现一下这种情况：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E9%98%9F%E5%88%97" srcset="/img/loading.gif" lazyload alt="队列1"></p>
<p>当再往里添加两个元素，<code>rear</code>后移两位后越界，就会出现明明有三个空位，却只能插入一个的情况，这种情况称为假溢出。</p>
<p>针对这种情况，可以采用循环队列解决。循环队列中，入队操作为<code>rear = (rear+1) % size</code>，出队操作为<code>front = (front+1) % size</code>。</p>
<p>此时不能再使用<code>front == rear</code>来判断队列空还是满，可以使用以下方法：</p>
<ul>
<li>设一标志域标识队列空或满</li>
<li>设一个长度域记录队列中元素的个数</li>
<li><strong>少用一个元素空间</strong>，当<code>front == (rear+1) % size</code>时认为队列已满</li>
</ul>
<p>在第三种方法条件下，当<code>rear &gt; front</code>时，队列中元素个数为<code>rear-front</code>；当<code>rear &lt; front</code>时，队列中元素分为两部分：<code>size-front</code>和<code>rear</code>。</p>
<blockquote>
<p>Java集合中有<code>Queue</code>接口，一般情况下<code>Queue</code>的实现类都不允许添加null元素，因为<code>poll()</code>,<code>peek()</code>方法在异常的时候会返回null，添加了null 以后，当获取时不好分辨究竟是否正确返回。</p>
</blockquote>
<h1 id="2-Stack栈"><a href="#2-Stack栈" class="headerlink" title="2. Stack栈"></a>2. Stack栈</h1><p>栈是一种用于存储数据的简单数据结构，有点类似链表或者顺序表（统称线性表），栈与线性表的最大区别是数据的存取的操作，我们可以这样认为栈(Stack)是一种特殊的线性表，其插入和删除操作只允许在线性表的一端进行，一般而言，把允许操作的一端称为栈顶(<code>Top</code>)，不可操作的一端称为栈底(<code>Bottom</code>)，同时把插入元素的操作称为入栈(<code>Push</code>),删除元素的操作称为出栈(<code>Pop</code>)。若栈中没有任何元素，则称为空栈</p>
<p>栈(Stack)是一种有序特殊的线性表，只能在表的一端(称为栈顶，<code>top</code>，总是指向栈顶元素)执行插入和删除操作，最后插入的元素将第一个被删除，因此栈也称为后进先出(Last In First Out,<code>LIFO</code>)或先进后出(First In Last Out <code>FILO</code>)的线性表。栈的基本操作创建栈，判空，入栈，出栈，获取栈顶元素等，注意栈不支持对指定位置进行删除，插入。</p>
<h2 id="顺序栈的整体实现"><a href="#顺序栈的整体实现" class="headerlink" title="顺序栈的整体实现"></a>顺序栈的整体实现</h2><p>顺序栈，顾名思义就是采用顺序表实现的的栈，顺序栈的内部以顺序表为基础，实现对元素的存取操作，当然还可以采用内部数组实现顺序栈，在这里使用内部数据组来实现栈。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.EmptyStackException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeqStack</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">7004488644657135624L</span>;<br><br>    <span class="hljs-comment">/**<br>     * 栈顶指针，-1代表空栈<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**<br>     * 容量大小默认为10<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**<br>     * 存放元素的数组<br>     */</span><br>    <span class="hljs-keyword">private</span> T[] array;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        array = (T[]) <span class="hljs-keyword">new</span> Object[capacity];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqStack</span><span class="hljs-params">()</span></span>&#123;<br>        array= (T[]) <span class="hljs-keyword">new</span> Object[<span class="hljs-keyword">this</span>.capacity];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.top==-<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 添加元素,从栈顶(数组尾部)插入<br>     * <span class="hljs-doctag">@param</span> data<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-comment">//判断容量是否充足</span><br>        <span class="hljs-keyword">if</span>(array.length==size)<br>            ensureCapacity(size*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">//扩容</span><br><br>        <span class="hljs-comment">//从栈顶添加元素</span><br>        array[++top]=data;<br><br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 获取栈顶元素的值,不删除<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())<br>            <span class="hljs-keyword">new</span> EmptyStackException();<br>        <span class="hljs-keyword">return</span> array[top];<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 从栈顶(顺序表尾部)删除<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())<br>            <span class="hljs-keyword">new</span> EmptyStackException();<br>        size--;<br>        <span class="hljs-keyword">return</span> array[top--];<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 扩容的方法<br>     * <span class="hljs-doctag">@param</span> capacity<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-comment">//如果需要拓展的容量比现在数组的容量还小,则无需扩容</span><br>        <span class="hljs-keyword">if</span> (capacity&lt;size)<br>            <span class="hljs-keyword">return</span>;<br><br>        T[] old = array;<br>        array = (T[]) <span class="hljs-keyword">new</span> Object[capacity];<br>        <span class="hljs-comment">//复制元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size ; i++)<br>            array[i]=old[i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        SeqStack&lt;String&gt; s=<span class="hljs-keyword">new</span> SeqStack&lt;&gt;();<br>        s.push(<span class="hljs-string">"A"</span>);<br>        s.push(<span class="hljs-string">"B"</span>);<br>        s.push(<span class="hljs-string">"C"</span>);<br>        System.out.println(<span class="hljs-string">"size-&gt;"</span>+s.size());<br>        <span class="hljs-keyword">int</span> l=s.size();<span class="hljs-comment">//size 在减少,必须先记录</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<br>            System.out.println(<span class="hljs-string">"s.pop-&gt;"</span>+s.pop());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">"s.peek-&gt;"</span>+s.peek());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="链式栈的整体实现"><a href="#链式栈的整体实现" class="headerlink" title="链式栈的整体实现"></a>链式栈的整体实现</h2><p>所谓的链式栈（Linked Stack），就是采用链式存储结构的栈，由于操作的是栈顶一端，因此采用单链表（不带头结点）作为基础，直接实现栈的添加，获取，删除等主要操作即可。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E9%93%BE%E6%A0%88" srcset="/img/loading.gif" lazyload alt="链栈"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">7754751623529062156L</span>;<br><br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; top;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedStack</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.top = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> top==<span class="hljs-keyword">null</span> || top.data==<span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (data==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StackException(<span class="hljs-string">"data can't be null"</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.top==<span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//调用pop()后top可能为null</span><br>            <span class="hljs-keyword">this</span>.top=<span class="hljs-keyword">new</span> Node&lt;&gt;(data);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.top.data==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">this</span>.top.data=data;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; p=<span class="hljs-keyword">new</span> Node&lt;&gt;(data,<span class="hljs-keyword">this</span>.top);<br>            top=p;<span class="hljs-comment">//更新栈顶</span><br>        &#125;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException(<span class="hljs-string">"Stack empty"</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> top.data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException(<span class="hljs-string">"Stack empty"</span>);<br>        &#125;<br><br>        T data=top.data;<br>        top=top.next;<br>        size--;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>两种实现方法的空间复杂度（用于N次push）上都是<code>O(n)</code>，在<code>pop</code>,<code>push</code>,<code>peek</code>,<code>isEmpty</code>的时间复杂度上都是<code>O(1)</code>，由此可知栈的主要操作都可以在常数时间内完成，这主要是因为栈只对一端进行操作，而且操作的只是栈顶元素。</p>
<h2 id="栈的常用应用"><a href="#栈的常用应用" class="headerlink" title="栈的常用应用"></a>栈的常用应用</h2><ul>
<li>符号匹配</li>
<li>中缀表达式转换为后缀表达式</li>
<li>计算后缀表达式</li>
<li>实现函数的嵌套调用</li>
<li>HTML和XML文件中的标签匹配</li>
<li>网页浏览器中已访问页面的历史记录</li>
</ul>
<blockquote>
<p>括号匹配和中缀转后缀实现见算法章</p>
</blockquote>
<h1 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3. 线性表"></a>3. 线性表</h1><blockquote>
<p>线性表是由n(n&gt;=0)个类型相同的数据元素a0,a1,…,an-1组成的有限的序列，在数学中记作(a0,a1,…,an-1)，其中ai的数据类型可以是基本数据类型(int,float等)、字符或类。n代表线性表的元素个数，也称其为长度(Length)。若n=0，则为空表；若n &gt; 0，则ai(0 &lt; i &lt; n-1)有且仅有一个前驱(Predecessor)元素ai-1和一个后继(Successor)元素ai+1，a0没有前驱元素，ai没有后继元素。  ——《java数据结构》</p>
</blockquote>
<h2 id="线性表的顺序存储结构（顺序表）"><a href="#线性表的顺序存储结构（顺序表）" class="headerlink" title="线性表的顺序存储结构（顺序表）"></a>线性表的顺序存储结构（顺序表）</h2><p>线性表的顺序存储结构称之为顺序表(Sequential List),它使用一维数组依次存放从<code>a0</code>到<code>an-1</code>的数据元素(<code>a0,a1,…,an-1</code>)，将<code>ai</code>(<code>0&lt; i &lt;&gt; n-1</code>)存放在数组的第i个元素，使得<code>ai</code>与其前驱<code>ai-1</code>及后继<code>ai+1</code>的存储位置相邻，因此数据元素在内存的物理存储次序反映了线性表数据元素之间的逻辑次序。</p>
<p>数组访问操作的时间复杂度为<code>O(1)</code>，整个过程需要一次乘法和一次加法运算，因为两个操作的执行时间都是常数时间，所以可以认为数组访问操作能在常数时间内完成。这种存取任何一个元素的时间复杂度为O(1)的数据结构称之为随机存取结构。</p>
<p>对于在顺序表中插入或者删除元素，从效率上则显得不太理想了，由于插入或者删除操作是基于位置的，需要移动数组中的其他元素，所以顺序表的插入或删除操作，算法所花费的时间主要是用于移动元素，如在顺序表头部插入或删除时，效率就显得相当糟糕。若在最前插入或删除，则需要移动n（这里假设长度为n）个元素；若在最后插入或删除，则需要移动的元素为0。也就是说，在等概率的情况下，插入或者删除一个顺序表的元素平均需要移动顺序表元素总量的一半，其时间复杂度是O(n)。当然如果在插入时，内部数组容量不足时，也会造成其他开销，如复制元素的时间开销和新建数组的空间开销。 </p>
<h2 id="线性表的链式存储结构（链表）"><a href="#线性表的链式存储结构（链表）" class="headerlink" title="线性表的链式存储结构（链表）"></a>线性表的链式存储结构（链表）</h2><p>链表在初始化时仅需要分配一个元素的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作线性链表的存储结构是用若干个地址分散的存储单元存放数据元素的，逻辑上相邻的数据元素在物理位置上不一定相邻，因此每个存储单元中都会有一个地址指向域，这个地址指向域指明其后继元素的位置。在链表中存储数据的单元称为结点(Node)，一个结点至少包含了数据域和地址域，其中数据域用于存储数据，而地址域用于存储前驱或后继元素的地址。链表的插入和删除都相当便捷，这是由于链表中的结点的存储空间是在插入或者删除过程中动态申请和释放的，不需要预先给单链表分配存储空间的，从而避免了顺序表因存储空间不足需要扩充空间和复制元素的过程，提高了运行效率和存储空间的利用率。</p>
<p>在链表中还可以设置带特殊头节点（没有值）的链表，这样单链表的插入和删除不再区分操作的位置，也就是说头部、中间、尾部插入都可以视为一种情况处理了，这是因为此时头部插入和头部删除无需改变<code>head</code>的指向。</p>
<p>此外，还可以将尾指针的下一个节点指向头指针构成循环链表。处理循环单链表时，需要注意在遍历循环链表时，避免进入死循环即可，也就是在判断循环链表是否到达结尾时条件为：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">this</span>.head)&#123;<br>    p = p.next;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>由于单链表并不是随机存取结构，即使单链表在访问第一个结点时花费的时间为常数时间，但是如果需要访问第<code>i</code>(<code>0&lt;i&lt;n</code>)个结点，需要从头结点<code>head</code>开始遍历部分链表，进行<code>i</code>次的<code>p=p.next</code>操作，这种情况类似于前面计算顺序表需要平均移动元素的总数，因此链表也需要平均进行<code>n/2</code>次的<code>p=p.next</code>操作，也就是说<code>get(i)</code>和<code>set(i,x)</code>的时间复杂度都为<code>O(n)</code>。</p>
<p>由于链表在插入和删除结点方面十分高效的，因此链表比较适合那些插入删除频繁的场景使用，单纯从插入操作来看，假设<code>front</code>指向的是单链表中的一个结点，此时插入<code>front</code>的后继结点所消耗的时间为常数时间<code>O(1)</code>,但如果此时需要在<code>front</code>的前面插入一个结点或者删除结点自己时，由于<code>front</code>并没有前驱指针，单凭<code>front</code>根本无法知道前驱结点，所以必须从链表的表头遍历至<code>front</code>的前一个结点再执行插入或者删除操作，而这个查询操作所消耗的时间为<code>O(n)</code>,因此在已知<code>front</code>结点需要插入前驱结点或者删除结点自己时，消耗的时间为<code>O(n)</code>。当然这种情况并不是无法解决的，可以使用双链表就可以解决这个问题，双链表是每个结点都同时拥有前后继结点的链表，这样的话上面的问题就迎刃而解了。</p>
<p>从前面单链表的插入删除的代码实现上来说，<code>front</code>结点每次插入和删除结点，都需要从表头开始遍历至要插入或者删除结点的前一个结点，而这个过程所花费的时间和访问结点所花费的时间是一样的，即<code>O(n)</code>，也就是说从实现上来说确实单链表的插入删除操作花费时间也是<code>O(n)</code>，而顺序表插入和删除的时间也是<code>O(n)</code>，为什么说单链表的插入和删除的效率高？</p>
<p>链表的插入和删除之所以是<code>O(N)</code>，是因为查询插入点所消耗的，找到插入点后插入操作消耗时间只为<code>O(1)</code>，而顺序表查找插入点的时间为<code>O(1)</code>，但要把后面的元素全部后移一位，消耗时间为<code>O(n)</code>。问题是大部分情况下查找所需时间比移动短多了，还有就是链表不需要连续空间也不需要扩容操作，因此即使时间复杂度都是<code>O(n)</code>，所以相对来说链表更适合插入删除操作。</p>
<h1 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h1><p>堆是一类完全二叉树，常用于实现排序。在一个二叉堆的数组中，每一个元素都要保证大于等于另外两个特定位置的元素。同时相应的，这些元素又要大于等于另外两个相应位置的元素，整个数据结构以此类推。若堆中所有非叶子结点均不大于其左右孩子节点，则称为小顶堆；若堆中所有非叶子结点均不小于其左右孩子节点，则称为大顶堆。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxPQ</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; arr;                                   <span class="hljs-comment">//定义一个数组，</span><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">int</span> N;                   <span class="hljs-comment">//定义队列中的元素个数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxPQ</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> ArrayList();<br>        arr.add(<span class="hljs-number">1</span>);<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;                   <span class="hljs-comment">//方法，返回队列是否为空</span><br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;                                              <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;                                 <span class="hljs-comment">//方法，返回队列中元素的个数</span><br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inSert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;       <span class="hljs-comment">//添加方法，添加元素到结合末尾，并且使用上浮方法到指定的位置</span><br>        arr.add(number);<br>        swim(++N);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//删除方法，删除最大元素并把最小的元素放到第一个，然后使用下浮方法</span><br>        <span class="hljs-keyword">int</span> max = arr.get(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> min  = arr.get(N);<br>        arr.set(<span class="hljs-number">1</span>, min);<br>        arr.remove(N--);<br>        sink(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-comment">//添加到最后然后上浮算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(N &gt; <span class="hljs-number">1</span> &amp;&amp; (arr.get(N/<span class="hljs-number">2</span>) &lt; arr.get(N)))&#123;<br>            <span class="hljs-keyword">int</span> max = arr.get(N);<br>            <span class="hljs-keyword">int</span> min = arr.get(N/<span class="hljs-number">2</span>);<br>            arr.set(N,min );<br>            arr.set(N/<span class="hljs-number">2</span>, max);<br>            N = N/<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//删除后将最小的移到最上面然后下沉算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(number*<span class="hljs-number">2</span> &lt;= N) &#123;<br>            <span class="hljs-keyword">int</span> index = number*<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(index &lt; N &amp;&amp; (arr.get(index) &lt; arr.get(index + <span class="hljs-number">1</span>))) &#123;<br>                index++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!(arr.get(number) &lt; arr.get(index))) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> max = arr.get(index);<br>            <span class="hljs-keyword">int</span> min = arr.get(number);<br>            arr.set(number, max);<br>            arr.set(index, min);<br>            number = index;<br>        &#125;<br><br><br><br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"MaxPQ [arr="</span> + arr + <span class="hljs-string">", N="</span> + N + <span class="hljs-string">"]"</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-二叉查找树"><a href="#5-二叉查找树" class="headerlink" title="5. 二叉查找树"></a>5. 二叉查找树</h1><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有节点的值均小于根节点的值</li>
<li>若右子树不空，则右子树上所有节点的值均大于根节点的值</li>
<li>左、右子树也分别是二叉树</li>
</ol>
<h2 id="二叉树的类型定义"><a href="#二叉树的类型定义" class="headerlink" title="二叉树的类型定义"></a>二叉树的类型定义</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTree</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>        <span class="hljs-keyword">public</span> Node Left;<br>        <span class="hljs-keyword">public</span> Node Right;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Number;  <span class="hljs-comment">//记录该节点和所有子节点个数的值</span><br>        <span class="hljs-keyword">public</span> TKey Key;    <span class="hljs-comment">//节点的key</span><br>        <span class="hljs-keyword">public</span> TValue value;    <span class="hljs-comment">//节点的值</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h2><p>查找操作和二分查找类似，将key和节点的key比较，如果小于，那么就在Left Node节点查找,如果大于，则在Right Node节点查找，如果相等，直接返回Value。</p>
<p>递归方式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TValue <span class="hljs-title">searchBST</span><span class="hljs-params">(Node root,TKey key)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> nulll;<br>    <span class="hljs-keyword">if</span>(T.node.key == key) <span class="hljs-keyword">return</span> T.node.value;<br>    <span class="hljs-keyword">if</span>(T.node.key &lt; key) <span class="hljs-keyword">return</span> searchBST(root.Right,key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchBST(root.Left,key);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>迭代方式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TValue <span class="hljs-title">searchBST</span><span class="hljs-params">(TKey key)</span> </span>&#123;<br>    Node node = root;<br>    <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(node.key == key) <span class="hljs-keyword">return</span> node.value;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.key &lt; key) node = node.Right;<br>        <span class="hljs-keyword">else</span> node = node.Left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入和查找类似，首先查找有没有和key相同的，如果有，更新；如果没有找到，那么创建新的节点，并更新每个节点的Number值。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Tkey key,TValue value)</span></span>&#123;<br>    root = put(root,key,value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node node,TKey key,TValue value)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key,value,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(node.Key &lt; key) &#123;<br>        node.Right = put(node.Right,key,value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.Key &gt; key) &#123;<br>        node.Left = put(node.Left,key,value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> node.Value = value;<br>    x.Number = size(x.Left) + size(x.Right) +<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Node node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == nulll) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> node.Number;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>二叉查找树中，最左和最右节点即为最小值和最大值。</p>
<p>迭代方式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TKey <span class="hljs-title">getMax</span><span class="hljs-params">()</span></span>&#123;<br>    TKey maxItem = <span class="hljs-keyword">null</span>;<br>    Node node = root;<br>    <span class="hljs-keyword">while</span>(node.Right != <span class="hljs-keyword">null</span>)&#123;<br>        node = node.Right;<br>    &#125;<br>    maxItem = node.Key;<br>    <span class="hljs-keyword">return</span> maxItem;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Tkey <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;<br>    TKey minItem = <span class="hljs-keyword">null</span>;<br>    Node node = root;<br>    <span class="hljs-keyword">while</span>(node.Left != <span class="hljs-keyword">null</span>)&#123;<br>        node = node.Left;<br>    &#125;<br>    minItem = node.Key;<br>    <span class="hljs-keyword">return</span> minItem;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>递归方式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TKey <span class="hljs-title">GetMaxRecursive</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> GetMaxRecursive(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> TKey <span class="hljs-title">GetMaxRecursive</span><span class="hljs-params">(Node root)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (root.Right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.Key;<br>    <span class="hljs-keyword">return</span> GetMaxRecursive(root.Right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> TKey <span class="hljs-title">GetMinRecursive</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> GetMinRecursive(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> TKey <span class="hljs-title">GetMinRecursive</span><span class="hljs-params">(Node root)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (root.Left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.Key;<br>    <span class="hljs-keyword">return</span> GetMinRecursive(root.Left);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除需要分一下情况：</p>
<ol>
<li>如果删除的是叶子结点，则删除后仍然为二叉树。</li>
<li>如果被删除的结点只有左、右子树之一为空，只需要将被删除结点的非空子树直接置为其双亲结点的相应子树</li>
<li>如果被删除结点的左右子树均不为空，则找到被删结点的直接前驱（位于被删结点左子树右下角右子树为空的结点），并将其值赋给被删结点，然后删除该前驱结点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(TKey key)</span></span>&#123;<br>    root = delete(root,key);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 返回删除的节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node node,Tkey key)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(key == node.Key)&#123;<br>        node = deleteNode(node);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; node.Key) &#123;<br>        node.left = delete(node.Left,key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.Right = delete(node.Right,key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteNode</span><span class="hljs-params">(Node p)</span> </span>&#123;<br>    Node q = <span class="hljs-keyword">null</span>;<br>    Node s = <span class="hljs-keyword">null</span>;<br>    q = p;<span class="hljs-comment">//令q结点指向要删除的p结点</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == p.Right)&#123; <span class="hljs-comment">//被删结点的右子树为空</span><br>        p = p.Left;<span class="hljs-comment">//将P结点的左子树作为p结点的双亲结点的相应子树</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == p.Left)&#123; <span class="hljs-comment">//被删结点的左子树为空</span><br>        p = p.Right;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//左右子树均不为空</span><br>        s = p.Left;<br>        <span class="hljs-keyword">while</span>(s.Right != <span class="hljs-keyword">null</span>)&#123;<br>            q = s;<br>            s = s.Right;<br>        &#125;<br>        p.Value = s.Value;<span class="hljs-comment">//将直接前驱s结点的值赋给被删结点</span><br>        <span class="hljs-keyword">if</span>(q == p)&#123;<br>            <span class="hljs-comment">//p结点没有前驱结点，即左孩子没有右结点，此时s结点是p的左孩子</span><br>            q.Left = s.Left; <span class="hljs-comment">//删除s结点只需要将其左子树作为q的左子树</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            q.Right = s.Left; <span class="hljs-comment">//删除s结点只需要将其左子树置为q结点的右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有lgN个节点，时间复杂度为O(logn)。在最差的情况下，根节点到最底层叶子节点会有N各节点,此时时间复杂度为O(n)。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N，此时查找特性几乎成了线性。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E9%80%80%E5%8C%96%E6%88%90%E7%BA%BF%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt="二叉查找树退化成线性"></p>
<h1 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6. 红黑树"></a>6. 红黑树</h1><p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在<code>O(logn)</code>时间内做查找，插入和删除，这里的<code>n</code>是树中元素的数目。红黑树查找的最坏时间复杂度也是<code>O(logN)</code>。</p>
<p>红黑树的特点：</p>
<ol>
<li>每个节点不是红色就是黑色的；</li>
<li>根节点总是黑色的；</li>
<li>所有的叶节点都是是黑色的（红黑树的叶子节点都是空节点（NIL或者NULL）</li>
<li>如果结点是红色的，则它的子结点必须是黑色的（反之不一定）</li>
<li>从根节点到叶结点或空字节点的每条路径，必须包含相同数目的黑色结点（即相同的黑色高度）</li>
</ol>
<blockquote>
<p>特性3中的叶子结点，是只为空（NIL或null）的结点<br>特性5确保没有一条路径会比其他路径长出两倍，因而，红黑树是相对接近平衡的二叉树。</p>
</blockquote>
<h2 id="红黑树的结构"><a href="#红黑树的结构" class="headerlink" title="红黑树的结构"></a>红黑树的结构</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTree</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt;  </span>&#123;<br><br>    <span class="hljs-keyword">public</span> RBNode&lt;T&gt; mRoot = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//根结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> RED = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> BLACK = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">//颜色</span><br>        <span class="hljs-keyword">boolean</span> color;<br>        <span class="hljs-comment">//关键字</span><br>        T key;<br>        <span class="hljs-comment">//左子节点</span><br>        RBNode&lt;T&gt; left;<br>        <span class="hljs-comment">//右子节点</span><br>        RBNode&lt;T&gt; right;<br>        <span class="hljs-comment">//父节点</span><br>        RBNode&lt;T&gt; parent;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RBNode</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> color, T key, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right, RBNode&lt;T&gt; parent)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.color = color;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>            <span class="hljs-keyword">this</span>.parent = parent;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + key + (<span class="hljs-keyword">this</span>.color == RED ? <span class="hljs-string">"RED"</span> : <span class="hljs-string">"BLACK"</span>); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="红黑树的修正"><a href="#红黑树的修正" class="headerlink" title="红黑树的修正"></a>红黑树的修正</h2><p>变色、左旋、右旋是红黑树在二叉树上的扩展操作，同时也是基于这三个操作才能遵守红黑树的五个特性。</p>
<h3 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h3><p>变色仅仅指的是红黑树节点的变色。因为红黑树节点必须是【红】或者【黑】这两种颜色，所以变色只是将当前的节点颜色进行变化，以满足特性（2，3，4，5）。</p>
<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*************对红黑树节点x进行左旋操作 ******************/</span><br><span class="hljs-comment">/*<br> * 左旋示意图：对节点x进行左旋<br> *     p                       p<br> *    /                       /<br> *   x                       y<br> *  / \                     / \<br> * lx  y      -----&gt;       x  ry<br> *    / \                 / \<br> *   ly ry               lx ly<br> * 左旋做了三件事：<br> * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)<br> * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)<br> * 3. 将y的左子节点设为x，将x的父节点设为y<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode&lt;T&gt; x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span><br>    RBNode&lt;T&gt; y = x.right;<br>    x.right = y.left;<br>    <span class="hljs-keyword">if</span>(y.left != <span class="hljs-keyword">null</span>) &#123;<br>        y.left.parent = x;<br>    &#125;<br>    <span class="hljs-comment">//2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span><br>    y.parent = x.parent;<br>    <span class="hljs-keyword">if</span>(x.parent == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//x是根结点时，将根结点改为y</span><br>        <span class="hljs-keyword">this</span>.mRoot = y;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(x == x.parent.left) &#123;<br>            x.parent.left = y;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x.parent.right = y;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//3. 将y的左子节点设为x，将x的父节点设为y</span><br>    y.left = x;<br>    x.parent = y;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*************对红黑树节点y进行右旋操作 ******************/</span><br><span class="hljs-comment">/*<br> * 右旋示意图：对节点y进行右旋<br> *        p                   p<br> *       /                   /<br> *      y                   x<br> *     / \                 / \<br> *    x  ry   -----&gt;      lx  y<br> *   / \                     / \<br> * lx  rx                   rx ry<br> * 右旋做了三件事：<br> * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)<br> * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)<br> * 3. 将x的右子节点设为y，将y的父节点设为x<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode&lt;T&gt; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span><br>    RBNode&lt;T&gt; x = y.left;<br>    y.left = x.right;<br>    <span class="hljs-keyword">if</span>(x.right != <span class="hljs-keyword">null</span>)&#123;<br>        x.right.parent = y;<br>    &#125;<br>    <span class="hljs-comment">//2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span><br>    x.parent = y.parent;<br>    <span class="hljs-keyword">if</span>(y.parent == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mRoot = x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(y == y.parent.left) &#123;<br>            y.parent.left = x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            y.parent.right = x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//3. 将x的右子节点设为y，将y的父节点设为x</span><br>    x.right = y;<br>    y.parent = x;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="红黑树结点的添加"><a href="#红黑树结点的添加" class="headerlink" title="红黑树结点的添加"></a>红黑树结点的添加</h2><p>红黑树是在二叉树的基础上进行扩展的，其添加节点也是像二叉树一样进行添加，然后再做调整。</p>
<blockquote>
<p>红黑树的第 5 条特征规定，任一节点到它子树的每个叶子节点的路径中都包含同样数量的黑节点。也就是说当我们往红黑树中插入一个黑色节点时，会违背这条特征。  </p>
<p>同时第 4 条特征规定红色节点的左右孩子一定都是黑色节点，当我们给一个红色节点下插入一个红色节点时，会违背这条特征。</p>
</blockquote>
<p>插入黑色节点的时候担心违背第5条，插入红色节点时担心违背第4条，所以将插入的节点改为红色，然后判断插入的节点的父亲是不是红色，是的话进行修改调整（变色、左旋、右旋）。同时在调整的过程中需要遵守5条特性。</p>
<p>以添加结点的父节点是祖父结点的左孩子的情况分析，分为以下几种情况：</p>
<ol>
<li>如果添加的【红色节点】的【父节点】是黑色，那么树不需要做调整。</li>
<li>如果添加的【红色节点】的【父节点】是红色，那么树需要做调整。</li>
</ol>
<ul>
<li>父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。</li>
<li>父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。</li>
<li>父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。</li>
</ul>
<h3 id="情况1-父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。"><a href="#情况1-父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。" class="headerlink" title="情况1:父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。"></a>情况1:父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。</h3><p>修改过程如下：</p>
<ul>
<li>将父节点和叔叔节点全部染成黑色（新增结点满足特性4），但是这样父亲和叔叔的分支多了一个黑色结点。</li>
<li>将祖父节点染成红色，这样祖父节点的两个分支满足了所有特性，但是需要继续检验祖父结点是否满足红黑树的特性</li>
<li>将祖父节点作为当前插入结点，继续向树根方向进行修改，循环向上直到父节点变为黑色或者到达树根为止。</li>
</ul>
<h3 id="情况2-父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。"><a href="#情况2-父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。" class="headerlink" title="情况2:父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。"></a>情况2:父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。</h3><p><img src="http://qiniu.xiaoming.net.cn/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E6%83%85%E5%86%B52.png" srcset="/img/loading.gif" lazyload alt="情况2"></p>
<p>修改过程如下：</p>
<ul>
<li>将父节点染成黑色；</li>
<li>将祖父节点染成红色；</li>
<li>将祖父节点进行右旋；</li>
</ul>
<p>仅通过以上3个步骤就可以调整完使整个红黑树的结点满足5个特性。</p>
<h3 id="情况3-父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子"><a href="#情况3-父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子" class="headerlink" title="情况3: 父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子"></a>情况3: 父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子</h3><p>修改过程如下：</p>
<p>通过对父节点进行左旋操作，就变成了情况2，再按照情况2继续调整。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%83%85%E5%86%B53.png" srcset="/img/loading.gif" lazyload alt="情况3"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*********************** 向红黑树中插入节点 **********************/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    RBNode&lt;T&gt; node = <span class="hljs-keyword">new</span> RBNode&lt;&gt;(BLACK, key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br>    insert(node);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 1、将节点插入到红黑树中，这个过程与二叉搜索树是一样的<br> * 2、将插入的节点着色为"红色"；将插入的节点着色为红色，不会违背"特性5"！<br> *    少违背了一条特性，意味着需要处理的情况越少。<br> * 3、通过一系列的旋转或者着色等操作，使之重新成为一颗红黑树。<br> * <span class="hljs-doctag">@param</span> node 插入的节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(RBNode&lt;T&gt; node)</span> </span>&#123;<br>    RBNode&lt;T&gt; current = <span class="hljs-keyword">null</span>;<br>    RBNode&lt;T&gt; x = mRoot;<br><br>    <span class="hljs-keyword">while</span>(x != <span class="hljs-keyword">null</span>) &#123;<br>        current = x;<span class="hljs-comment">//跟踪父节点</span><br>        <span class="hljs-keyword">int</span> cmp = node.key.compareTo(x.key);<br>        <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span> ) &#123;<br>            x = x.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x = x.right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//找到位置，将当前current作为node的父节点</span><br>    node.parent = current;<br>    <span class="hljs-comment">//接下来判断node是插在左子节点还是右子节点</span><br>    <span class="hljs-keyword">if</span>(current != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> cmp = node.key.compareTo(current.key);<br>        <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>) &#123;<br>            current.left = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current.right = node;<br>        &#125;<br>        node.color = RED;<br>        insertFixUp(node);<span class="hljs-comment">//调整</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.mRoot = node;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**<br> * 修改整插入node节点之后的红黑树<br> * <span class="hljs-doctag">@param</span> node<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFixUp</span><span class="hljs-params">(RBNode&lt;T&gt; node)</span> </span>&#123;<br>    <span class="hljs-comment">//定义父节点和祖父节点</span><br>    RBNode&lt;T&gt; parent,gparent;<br>    <span class="hljs-comment">//需要修整的条件：父节点存在，且父节点的颜色是红色</span><br>    <span class="hljs-keyword">while</span> (((parent = node.parent) != <span class="hljs-keyword">null</span>) &amp;&amp; isRed(parent)) &#123;<br>        <span class="hljs-comment">//祖父节点</span><br>        gparent = parent.parent;<br>        <span class="hljs-comment">//若父节点是祖父节点的左子节点</span><br>        <span class="hljs-keyword">if</span>(parent == gparent.left) &#123;<br>            <span class="hljs-comment">//获取叔叔节点</span><br>            RBNode&lt;T&gt; uncle = gparent.right;<br>            <span class="hljs-comment">//case1:叔叔节点是红色</span><br>            <span class="hljs-keyword">if</span>(uncle != <span class="hljs-keyword">null</span> &amp;&amp; isRed(uncle)) &#123;<br>                <span class="hljs-comment">//把父亲和叔叔节点涂成黑色</span><br>                parent.color = BLACK;<br>                uncle.color = BLACK;<br>                <span class="hljs-comment">//把祖父节点涂成红色</span><br>                gparent.color = RED;<br>                <span class="hljs-comment">//向上修改</span><br>                node = gparent;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//case2:叔叔节点是黑色，且当前节点是右子节点</span><br>            <span class="hljs-keyword">if</span>(node == parent.right) &#123;<br>                <span class="hljs-comment">//对父节点左旋</span><br>                leftRotate(parent);<br>                <span class="hljs-comment">//将父节点和当前节点对调，方便接下来的右旋</span><br>                RBNode&lt;T&gt; tmp = parent;<br>                parent = node;<br>                node = tmp;<br>            &#125;<br>            <span class="hljs-comment">//case3:叔叔节点是红色，且当前节点是左子节点</span><br>            parent.color = BLACK;<br>            gparent.color = RED;<br>            rightRotate(gparent);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//若父亲节点是祖父节点的右子节点，与上面完全相反</span><br>            RBNode&lt;T&gt; uncle = gparent.left;<br>            <span class="hljs-comment">//case1:叔叔节点也是红色</span><br>            <span class="hljs-keyword">if</span> (uncle != <span class="hljs-keyword">null</span> &amp; isRed(uncle)) &#123;<br>                parent.color = BLACK;<br>                uncle.color = BLACK;<br>                gparent.color = RED;<br>                node = gparent;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//case2: 叔叔节点是黑色的，且当前节点是左子节点</span><br>            <span class="hljs-keyword">if</span> (node == parent.left) &#123;<br>                rightRotate(parent);<br>                RBNode&lt;T&gt; tmp = parent;<br>                parent = node;<br>                node = tmp;<br>            &#125;<br>            <span class="hljs-comment">//case3: 叔叔节点是黑色的，且当前节点是右子节点</span><br>            parent.color = BLACK;<br>            gparent.color = RED;<br>            leftRotate(gparent);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将根结点设置为黑色</span><br>    <span class="hljs-keyword">this</span>.mRoot.color = BLACK;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p>红黑树的删除同样是在二叉树进行删除的操作基础上进行调整的。</p>
<ol>
<li>如果删除节点的左孩子或者右孩子不同时为null，只需要让其子树继承删除该节点的位置</li>
<li>如果删除的节点是叶子结点，直接进行调整</li>
<li>如果删除的节点左右孩子都不为null，需要后继节点替换被删除的节点的值和颜色，这样才不会引起红黑树平衡的破坏，只需要对后继节点删除后进行调整，回归到情况1和2:</li>
</ol>
<ul>
<li>后继节点为左子树最右边的叶子结点</li>
<li>后继节点为右子树最左边的叶子结点</li>
</ul>
<blockquote>
<p>如果需要删除的节点颜色为红色，那么红黑树的结构不被破坏，也就不需要进行调整。如果判断删除节点的颜色为黑色，那么就进行调整；</p>
</blockquote>
<h3 id="删除代码"><a href="#删除代码" class="headerlink" title="删除代码"></a>删除代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*********************** 删除红黑树中的节点 **********************/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        RBNode&lt;T&gt; node;<br>        <span class="hljs-keyword">if</span>((node = search(mRoot,key)) != <span class="hljs-keyword">null</span>) &#123;<br>            remove(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 1、被删除的节点没有儿子，即删除的是叶子节点。那么，直接删除该节点。<br>     * 2、被删除的节点只有一个儿子。那么直接删除该节点，并用该节点的唯一子节点顶替它的初始位置。<br>     * 3、被删除的节点有两个儿子。那么先找出它的后继节点（右孩子中的最小的，该孩子没有子节点或者只有一右孩子）。<br>     *    然后把"它的后继节点的内容"复制给"该节点的内容"；之后，删除"它的后继节点"。<br>     *    在这里后继节点相当与替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。<br>     *    ------这样问题就转化为怎么删除后继即节点的问题？<br>     *    在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子都非空。<br>     *    注：后继节点为补充被删除的节点；<br>     *    即：意味着"要么没有儿子，要么只有一个儿子"。<br>     *    若没有儿子，则回归到（1）。<br>     *    若只有一个儿子，则回归到（2）。<br>     *<br>     * <span class="hljs-doctag">@param</span> node  需要删除的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(RBNode&lt;T&gt; node)</span> </span>&#123;<br>       RBNode&lt;T&gt; child,parent;<br>       <span class="hljs-keyword">boolean</span> color;<br>       <span class="hljs-comment">//删除节点的左右孩子都不为空</span><br>        <span class="hljs-keyword">if</span>((node.left != <span class="hljs-keyword">null</span>) &amp;&amp; (node.right != <span class="hljs-keyword">null</span>)) &#123;<br>            <span class="hljs-comment">//先找到被删除节点的后继节点，用它来取代别删除节点的位置</span><br>            RBNode&lt;T&gt; replace = node;<br>            <span class="hljs-comment">//1. 获取后继节点（右孩子中最小）</span><br>            replace = replace.right;<br>            <span class="hljs-keyword">while</span>(replace.left != <span class="hljs-keyword">null</span>)&#123;<br>                replace = replace.left;<br>            &#125;<br>            <span class="hljs-comment">//2. 处理后继节点和被删除节点的父节点之间的关系</span><br>            <span class="hljs-keyword">if</span>(node.parent != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//被删除节点不是根结点</span><br>                <span class="hljs-keyword">if</span>(node == node.parent.left)&#123;<br>                    node.parent.left = replace;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    node.parent.right = replace;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mRoot = replace;<br>            &#125;<br>            <span class="hljs-comment">//3. 处理后继节点的字节点和被删除节点的字节点之间的关系</span><br>            <span class="hljs-comment">//后继节点肯定不存在左子节点</span><br>            child = replace.right;<br>            parent = replace.parent;<br>            <span class="hljs-comment">//保存后继节点的颜色</span><br>            color = replace.color;<br>            <span class="hljs-comment">//后继节点是被删除的节点的字节点</span><br>            <span class="hljs-keyword">if</span>(parent == node) &#123;<br>                parent = replace;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(child != <span class="hljs-keyword">null</span>) &#123;<br>                    child.parent = parent;<br>                &#125;<br>                parent.left = child;<br>                replace.right = node.right;<br>                node.right.parent = replace;<br>            &#125;<br>            replace.parent = node.parent;<br>            replace.color = node.color;<br>            replace.left = node.left;<br>            node.right.parent = replace;<br>            <span class="hljs-comment">//4. 如果移走的后继节点颜色是黑色，需要进行红黑树修正</span><br>            <span class="hljs-keyword">if</span>(color == BLACK) &#123;<br>                removeFixUp(child,parent);<br>            &#125;<br>            node = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//被删除的节点是叶子节点或者只有一个孩子</span><br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) &#123;<br>                child = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                child = node.right;<br>            &#125;<br>            parent = node.parent;<br>            color = node.color;<br>            <span class="hljs-keyword">if</span>(child != <span class="hljs-keyword">null</span>)&#123;<br>                child.parent = parent;<br>            &#125;<br>            <span class="hljs-comment">//node节点不是根节点</span><br>            <span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span>(parent.left == node) &#123;<br>                    parent.left = child;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent.right = child;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mRoot = child;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(color == BLACK) &#123;<br>                removeFixUp(child,parent);<br>            &#125;<br>            node = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="红黑树删除后节点调整"><a href="#红黑树删除后节点调整" class="headerlink" title="红黑树删除后节点调整"></a>红黑树删除后节点调整</h3><p>删除之后需要修整的节点就是后继节点的子节点（因为此时后继节点已经移走，往下一层会违反红黑树规则的就是后继节点原先的子节点）</p>
<p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p>
<p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p>
<p>分为以下几种情况：</p>
<ol>
<li>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）</li>
<li>当前节点是黑色的，且兄弟节点是黑色的：</li>
</ol>
<ul>
<li>兄弟节点的两个子节点都是黑色的</li>
<li>兄弟节点的左子节点是红色，右子节点是黑色的</li>
<li>兄弟节点的左子节点是任意颜色，右子节点是红色的</li>
</ul>
<h4 id="调整情况1-当前节点是黑色的，且兄弟节点是红色的"><a href="#调整情况1-当前节点是黑色的，且兄弟节点是红色的" class="headerlink" title="调整情况1:当前节点是黑色的，且兄弟节点是红色的"></a>调整情况1:当前节点是黑色的，且兄弟节点是红色的</h4><p>将父节点涂红，将兄弟节点涂黑，然后将当前节点的父节点进行支点左旋，这样会转换为情况2中的某种情况</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%A0%E9%99%A4%E8%B0%83%E6%95%B4%E6%83%85%E5%86%B51.png" srcset="/img/loading.gif" lazyload alt="删除调整情况1"></p>
<h4 id="调整情况2-当前节点是黑色，兄弟节点是黑色"><a href="#调整情况2-当前节点是黑色，兄弟节点是黑色" class="headerlink" title="调整情况2:当前节点是黑色，兄弟节点是黑色"></a>调整情况2:当前节点是黑色，兄弟节点是黑色</h4><h5 id="兄弟节点的两个节点均为黑色"><a href="#兄弟节点的两个节点均为黑色" class="headerlink" title="兄弟节点的两个节点均为黑色"></a>兄弟节点的两个节点均为黑色</h5><p>由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。</p>
<p>这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%A0%E9%99%A4%E8%B0%83%E6%95%B4%E6%83%85%E5%86%B52.png" srcset="/img/loading.gif" lazyload alt="删除调整情况2"></p>
<p>把当前节点的兄弟节点涂红，将当前节点指向其父节点，将其父节点指向当前节点的祖父节点，继续往树根递归判断以及调整</p>
<h5 id="兄弟节点的左子节点是红色，右子节点时黑色的"><a href="#兄弟节点的左子节点是红色，右子节点时黑色的" class="headerlink" title="兄弟节点的左子节点是红色，右子节点时黑色的"></a>兄弟节点的左子节点是红色，右子节点时黑色的</h5><p>把当前节点的兄弟节点涂红，把兄弟节点的左子节点涂黑，然后以兄弟节点作为支点做右旋操作，使之符合下一种情况</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E8%B0%83%E6%95%B4%E6%83%85%E5%86%B53.png" srcset="/img/loading.gif" lazyload alt="删除调整情况3"></p>
<h5 id="兄弟节点的右子节点是红色，左子节点任意颜色"><a href="#兄弟节点的右子节点是红色，左子节点任意颜色" class="headerlink" title="兄弟节点的右子节点是红色，左子节点任意颜色"></a>兄弟节点的右子节点是红色，左子节点任意颜色</h5><p><img src="https://qiniu.xiaoming.net.cn/%E5%88%A0%E9%99%A4%E8%B0%83%E6%95%B4%E6%83%85%E5%86%B54.png" srcset="/img/loading.gif" lazyload alt="删除调整情况4"></p>
<p>把兄弟节点涂成父节点的颜色，再把父节点涂黑，把兄弟节点的左子节点涂黑，然后以当前节点的父节点为支点做左旋操作。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * 红黑树删除修正函数<br>     *<br>     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；<br>     * 目的是将它重新塑造成一颗红黑树。<br>     * 如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。<br>     * 而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。<br>     * 这里我们只修正删除的节点是黑色的情况：<br>     *<br>     * 调整思想：<br>     * 为了保证删除节点的父节点左右两边黑色节点数一致，需要重点关注父节点没删除的那一边节点是不是黑色。<br>     * 如果删除后父亲节点另一边比删除的一边黑色多，就要想办法搞到平衡。<br>     * 1、把父亲节点另一边（即删除节点的兄弟树）其中一个节点弄成红色，也少了一个黑色。<br>     * 2、或者把另一边多的节点（染成黑色）转过来一个<br>     *<br>     * 1）、当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；<br>     * 2）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；<br>     * 3）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；<br>     * 4）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。<br>     *<br>     * 以上四种情况中，2，3，4都是（当前节点是黑色的，且兄弟节点是黑色的）的子集。<br>     *<br>     * 参数说明：<br>     * <span class="hljs-doctag">@param</span> node 删除之后代替的节点（后序节点）<br>     * <span class="hljs-doctag">@param</span> parent 后序节点的父节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFixUp</span><span class="hljs-params">(RBNode&lt;T&gt; node,RBNode&lt;T&gt; parent)</span> </span>&#123;<br>        RBNode&lt;T&gt; other;<br>        RBNode&lt;T&gt; root = mRoot;<br>        <span class="hljs-keyword">while</span> ((node == <span class="hljs-keyword">null</span> || node.color == BLACK) &amp;&amp; node != root) &#123;<br>            <span class="hljs-keyword">if</span> (parent.left == node) &#123;<br>                other = parent.right;<br>                <span class="hljs-keyword">if</span> (other.color == RED) &#123;<br>                    <span class="hljs-comment">//case 1：x的兄弟w是红色的【对应状态1，将其转化为2，3，4】</span><br>                    other.color = BLACK;<br>                    parent.color = RED;<br>                    leftRotate(parent);<br>                    other = parent.right;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> ((other.left == <span class="hljs-keyword">null</span> || other.left.color == BLACK)<br>                        &amp;&amp; (other.right == <span class="hljs-keyword">null</span> || other.right.color == BLACK)) &#123;<br>                    <span class="hljs-comment">//case 2：x的兄弟w是黑色，且w的两个孩子都是黑色的【对应状态2，利用调整思想1网树的根部做递归】</span><br>                    other.color = RED;<br>                    node = parent;<br>                    parent = node.parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (other.right == <span class="hljs-keyword">null</span> || other.right.color == BLACK) &#123;<br>                        <span class="hljs-comment">//case 3:x的兄弟w是黑色的，并且w的左孩子是红色的，右孩子是黑色的【对应状态3，调整到状态4】</span><br>                        other.left.color = BLACK;<br>                        other.color = RED;<br>                        rightRotate(other);<br>                        other = parent.right;<br>                    &#125;<br>                    <span class="hljs-comment">//case 4:x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色【对应状态4，利用调整思想2做调整】</span><br>                    other.color = parent.color;<br>                    parent.color = BLACK;<br>                    other.right.color = BLACK;<br>                    leftRotate(parent);<br>                    node = root;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                other = parent.left;<br>                <span class="hljs-keyword">if</span> (other.color == RED) &#123;<br>                    <span class="hljs-comment">//case 1:x的兄弟w是红色的</span><br>                    other.color = BLACK;<br>                    parent.color = RED;<br>                    rightRotate(parent);<br>                    other = parent.left;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> ((other.left == <span class="hljs-keyword">null</span> || other.left.color == BLACK)<br>                        &amp;&amp; (other.right == <span class="hljs-keyword">null</span> || other.right.color == BLACK)) &#123;<br>                    <span class="hljs-comment">//case 2:x兄弟w是黑色，且w的两个孩子也都是黑色的</span><br>                    other.color = RED;<br>                    node = parent;<br>                    parent = node.parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (other.left == <span class="hljs-keyword">null</span> || other.left.color == BLACK) &#123;<br>                        <span class="hljs-comment">//case 3:x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。</span><br>                        other.right.color = BLACK;<br>                        other.color = RED;<br>                        leftRotate(other);<br>                        other = parent.left;<br>                    &#125;<br>                    <span class="hljs-comment">//case 4:x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span><br>                    other.color = parent.color;<br>                    parent.color = BLACK;<br>                    other.left.color = BLACK;<br>                    rightRotate(parent);<br>                    node = root;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            node.color = BLACK;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="7-B树"><a href="#7-B树" class="headerlink" title="7. B树"></a>7. B树</h1><p>B树是一种平衡多叉查找树，主要用于构建磁盘文件索引。</p>
<p>一颗m阶B树，或为空树，或者必须满足以下特性的m叉树：</p>
<ol>
<li>树中的每个结点最多含有m棵子树</li>
<li>若根结点是非终端节点，则至少有两颗子树</li>
<li>除根结点之外的所有非终端节点至少有<code>m/2</code>（向上取整）棵子树</li>
<li>每个非终端节点中包含信息：<code>n,A0,K1,A1,K2,...,Kn,An</code>。其中：</li>
</ol>
<ul>
<li><code>n</code>表示关键字的个数，必须满足<code>(m/2) -1 &lt;= n &lt;= (m-1)</code>(m/2向上取整)</li>
<li><code>Ki(1&lt;=i&lt;=n)</code>为关键字，且关键字按升序排序</li>
<li>指针<code>Ai(0&lt;=i&lt;=n)</code>指向子树的根节点，<code>Ai-1</code>指向子树中所有节点的关键字均小于<code>Ki</code>,且大于<code>Ki-1</code>。</li>
</ul>
<ol start="5">
<li>所有的叶子结点都出现再同一层，叶子结点不包含任何信息</li>
</ol>
<p>以M=3的3阶B树为例：</p>
<p><img src="https://qiniu.xiaoming.net.cn/3%E9%98%B6B%E6%A0%91.jpg" srcset="/img/loading.gif" lazyload alt="B树"></p>
<p>类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Max 1000 <span class="hljs-comment">//节点中关键字的最大数目：Max=m-1，m是B树的阶</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Min 500 <span class="hljs-comment">//非根节点中关键字的最小数目：Min=m/2-1</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> keynum;<span class="hljs-comment">//节点当前的关键字个数</span><br>    KeyType key[Max+<span class="hljs-number">1</span>];<span class="hljs-comment">//关键字数组，key[0]未用</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">//双亲节点指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">ptr</span>[<span class="hljs-title">m</span>+1];</span><span class="hljs-comment">//孩子节点指针数组</span><br>    Record *recptr[m+<span class="hljs-number">1</span>];<span class="hljs-comment">//记录指针向量，0号单元未用</span><br>&#125; BTNode,*BTree; <span class="hljs-comment">//B树的结点及指针类型</span><br></code></pre></div></td></tr></table></figure>

<h2 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h2><p>在B-树中查找给定关键字的方法类似于二叉排序树上的查找。不同的是在每个结点上确定向下查找的路径不一定是二路而是<code>keynum+1</code>路的。</p>
<p>对结点内的存放有序关键字序列的向量<code>key[1..keynum]</code>用顺序查找或折半查找方法查找。若在某结点内找到待查的关键字<code>K</code>，则返回该结点的地址及<code>K</code>在<code>key[1..keynum]</code>中的位置；否则，确定K在某个<code>key[i]</code>和<code>key[i+1]</code>之间结点后，从磁盘中读<code>son[i]</code>所指的结点继续查找。直到在某结点中查找成功；或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。</p>
<p>时间开销：</p>
<p>B树的高度是<img src="https://qiniu.xiaoming.net.cn/B%E6%A0%91%E9%AB%98%E5%BA%A6.gif" srcset="/img/loading.gif" lazyload alt="B树高度">，而不是其他几种树的<code>H=log2n</code>，其中T为度数（每个节点包含的元素个数），即所谓的阶数，n为总元素个数或总关键字树。</p>
<p>B树查找的时间复杂度为<code>O(Log2-N)</code>。</p>
<h2 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h2><p>B树的插入首先需要查找关键字k的插入位置，若找到，说明关键字已经存在，直接返回；否则查找操作必然在某个叶子节点处结束，在该节点插入后，若其关键字总数未达到m，算法结束，否则需要分裂结点。</p>
<p>分裂的方法是，生成一新结点，从中间位置把结点（不包括中间位置的关键字）分成两部分。前半部分留在旧节点中，后半部分复制到新节点中，中间部分的关键字连同新节点的存储位置插入到父节点中。如果插入后父节点的关键字个数也超过<code>m-1</code>，则继续分裂。这个向上分裂过程如果持续到根节点，则会产生新的根节点。</p>
<p><img src="http://wx-qiniu.xiaoming.net.cn/B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.jpeg" srcset="/img/loading.gif" lazyload alt="B树的插入"></p>
<h2 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h2><p>在B树上删除关键字k的过程可利用前述的查找过程找出该关键字所在的结点，然后根据k所在结点是否为最下层非终端结点进行不同的处理。</p>
<h3 id="该节点为最下层非终端结点"><a href="#该节点为最下层非终端结点" class="headerlink" title="该节点为最下层非终端结点"></a>该节点为最下层非终端结点</h3><p>首先直接从该节点删除关键字k，然后根据以下3种情况分别作相应的处理：</p>
<ol>
<li>如果被删关键字所在结点的原关键字个数<code>n&gt;=(m/2)</code>（向上取整），则删除该关键字后仍然满足B树定义</li>
</ol>
<p><img src="http://wx-qiniu.xiaoming.net.cn/B%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%BD%A21.jpeg" srcset="/img/loading.gif" lazyload alt="B树删除的情形1"></p>
<ol start="2">
<li>如果被删关键字所在结点的关键字个数n等于<code>m/2-1</code>（向上取整），则删去该关键字后该节点将不满足B树的定义，需要调整：如果其左右兄弟结点中有“富余”的关键字，即与该节点相邻的右（或左）兄弟结点中的关键字数目大于<code>m/2-1</code>（向上取整），则可将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在节点中。</li>
</ol>
<p><img src="http://wx-qiniu.xiaoming.net.cn/B%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%BD%A22.jpeg" srcset="/img/loading.gif" lazyload alt="B树删除的情形2"></p>
<ol start="3">
<li>如果相邻兄弟结点中没有多余的关键字，即相邻兄弟结点中的关键字数目均等于<code>m/2-1</code>（向上取整），此时需要把要删除关键字的结点与其左（或右）兄弟结点以及双亲结点中分割两者的关键字合并成一个节点，即在删除关键字后，该节点中剩余的关键字和指针，加上双亲结点中的关键字<code>Ki</code>一起，合并到<code>Ai-1</code>(或<code>Ai</code>)结点，即删除该关键字结点的左（右）兄弟结点。如果导致双亲结点中关键字个数小于<code>m/2-1</code>（向上取整）,则对此双亲结点做同样的处理。如果直到对根节点也做合并处理，则整棵树减少一层。</li>
</ol>
<p><img src="http://wx-qiniu.xiaoming.net.cn/B%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%BD%A23.jpeg" srcset="/img/loading.gif" lazyload alt="B树删除的情形3"></p>
<h3 id="该节点不是最下面非终端节点"><a href="#该节点不是最下面非终端节点" class="headerlink" title="该节点不是最下面非终端节点"></a>该节点不是最下面非终端节点</h3><p>假设被删关键字为该节点中第i个关键字<code>Ki</code>,则可以从指针<code>Ai</code>所指的子树中找出位于最下层非终端节点的最小关键字替代<code>Ki</code>，并将其删除，于是这种情况转化为第1种情况。</p>
<h1 id="8-B-树"><a href="#8-B-树" class="headerlink" title="8. B+树"></a>8. B+树</h1><p>B+树是应文件系统所需而提出的一种B树的类型。一颗m阶B+树和m阶B树的差异在于：</p>
<ol>
<li>在n棵子树的结点中含有n个关键字</li>
<li>所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看作索引部分，节点中仅含其子树（根节点）中的最大（或最小）关键字。</li>
</ol>
<p><img src="http://wx-qiniu.xiaoming.net.cn/3%E9%98%B6B+%E6%A0%91.jpeg" srcset="/img/loading.gif" lazyload alt="3阶B+树"></p>
<p>通常B+树有两个头指针，一个指向根节点，一个指向关键字最小的叶子结点。因此B+树查找方式有两种：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。</p>
<p>为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？</p>
<ol>
<li><p><strong>B+树的磁盘读写代价更低</strong><br>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。<br>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。<br>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。<br>一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
</li>
<li><p><strong>B+树的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
<h1 id="9-B-树"><a href="#9-B-树" class="headerlink" title="9. B*树"></a>9. B*树</h1><p>B*树是B+树的变体，在B+树的基础上（所有的叶子结点包含了全部关键字的信息，以及指向含有这些关键字记录的指针），还具有以下特点：</p>
<p>B*树中非根和非叶子结点再增加指向兄弟的指针；</p>
<p>B*树定义了非叶子结点关键字个数至少为 <code>(2/3) * M</code>，即块的最低使用率为<code>2/3</code>（代替B+树的1/2）</p>
<h2 id="B-树和B-树的分裂："><a href="#B-树和B-树的分裂：" class="headerlink" title="B+树和B*树的分裂："></a>B+树和B*树的分裂：</h2><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，<strong>B*树分配新结点的概率比B+树要低，空间使用率更高</strong>；</p>
<h1 id="10-LSM树"><a href="#10-LSM树" class="headerlink" title="10. LSM树"></a>10. LSM树</h1><p>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。</p>
<p>对于大量的随机写也一样，举一个插入key跨度很大的例子，如<code>7-&gt;1000-&gt;3-&gt;2000 ...</code>,新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</p>
<p>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）。</p>
<p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p>
<p>为了更好的说明LSM树的原理，下面举个比较极端的例子：</p>
<p>现在假设有1000个节点的随机key，对于磁盘来说，肯定是把这1000个节点顺序写入磁盘最快，但是这样一来，读就悲剧了，因为key在磁盘中完全无序，每次读取都要全扫描；</p>
<p>那么，为了让读性能尽量高，数据在磁盘中必须得有序，这就是B+树的原理，但是写就悲剧了，因为会产生大量的随机IO，磁盘寻道速度跟不上。</p>
<p>LSM树本质上就是在读写之间取得平衡，和B+树相比，它牺牲了部分读性能，用来大幅提高写性能。</p>
<p>它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历所有的小树，但在每颗小树内部数据是有序的。</p>
<p>关于LSM Tree，对于最简单的二层LSM Tree而言，内存中的数据和磁盘中的数据merge操作，如下图</p>
<p><img src="http://qiniu.xiaoming.net.cn/LSM%E6%A0%91Merge%E6%93%8D%E4%BD%9C.png" srcset="/img/loading.gif" lazyload alt="Merge操作"></p>
<h1 id="11-BFS和DFS"><a href="#11-BFS和DFS" class="headerlink" title="11. BFS和DFS"></a>11. BFS和DFS</h1><h2 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h2><p><img src="https://qiniu.xiaoming.net.cn/%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" srcset="/img/loading.gif" lazyload alt="树的广度优先遍历"></p>
<p>实现的基本思路是使用队列，首先将根节点入队。之后循环从队列中弹出最早进入的结点，每弹出一个，若该结点有左右子树，则将左、右子树分别入队。循环直到队列为空。</p>
<blockquote>
<p>如果需要确定对应的层次，可以在每次左右子节点入队后再就如一个 null 表示当前 一层结束，弹出时判断是 null 说明当前层结束，继续弹出下一层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义二叉树</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    TreeNode(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>.val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用队列实现BFS</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BFSWithQueue</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>) &#123;<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>        TreeNode treeNode = queue.poll();<br>        <span class="hljs-keyword">if</span>(treeNode.left != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(treeNode.right != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p><img src="https://qiniu.xiaoming.net.cn/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" srcset="/img/loading.gif" lazyload alt="树的深度优先遍历"></p>
<p>DFS遍历可以使用递归或者栈来实现：</p>
<p>使用递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DFSWithRecursion</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) <br>        DFSWithRecursion(root.left);<br>    <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)<br>        DFSWithRecursion(root.right);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>使用栈实现：首先将根节点入栈。然后循环出栈。每弹出一个结点，如果其存在左右子树，先将右子树入栈，再将左子树入栈，循环直到栈为空。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DFSWithStack</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>        TreeNode treeNode = stack.pop();<br>        <span class="hljs-keyword">if</span>(treeNode.right != <span class="hljs-keyword">null</span>)<br>            stack.push(treeNode.right);<br>        <span class="hljs-keyword">if</span>(treeNode.left != <span class="hljs-keyword">null</span>)<br>            stack.push(treeNode.left);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图和树的最大区别在于图的下一个节点可能指向已访问过的节点。因此在使用BFS及DFS遍历时，应维护一个Set，Set中存放已被访问过的节点，在遍历时先判断节点未被访问过再遍历即可。</p>
<h1 id="12-树的先序、中序、后序遍历"><a href="#12-树的先序、中序、后序遍历" class="headerlink" title="12. 树的先序、中序、后序遍历"></a>12. 树的先序、中序、后序遍历</h1><p>树的先序、中序、后序遍历是指对根节点的访问次序，三种遍历的顺序为：</p>
<ul>
<li>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</li>
<li>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</li>
<li>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</li>
</ul>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义二叉树</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    TreeNode(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>.val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//先序遍历(递归实现)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;<br>        System.out.println(root.val);<br>    &#125;<br>    preOrderTraverse1(root.left);<br>    preOrderTraverse1(root.right);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>使用非递归实现：首先将根节点入栈。然后循环出栈。每弹出一个结点，如果其存在左右子树，先将右子树入栈，再将左子树入栈，循环直到栈为空。）</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>        TreeNode treeNode = stack.pop();<br>        <span class="hljs-keyword">if</span>(treeNode.right != <span class="hljs-keyword">null</span>)<br>            stack.push(treeNode.right);<br>        <span class="hljs-keyword">if</span>(treeNode.left != <span class="hljs-keyword">null</span>)<br>            stack.push(treeNode.left);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>		inOrderTraverse1(root.left);<br>		System.out.println(root.val);<br>		inOrderTraverse1(root.right);<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>非递归实现：使用栈</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    TreeNode pnode = root;<br>    <span class="hljs-keyword">while</span>(pnode != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span>(pnode != <span class="hljs-keyword">null</span>) &#123;<br>            stack.push(pnode);<br>            pnode = pnode.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pnode = stack.pop();<br>            System.out.println(pnode.val);<br>            pnode = pnode.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>		postOrderTraverse1(root.left);<br>		postOrderTraverse1(root.right);<br>		System.out.print(root.val);<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>非递归实现：根结点先入栈，然后左子结点或右子结点，特别是右子结点弹出来之后，再弹出根结点，lastVisited 这个结点指针用于指示右子结点已经被访问完了，可以弹出根结点了。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    TreeNode lastNodeVisited = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty() || root != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;<br>            stack.push(root);<br>            root = root.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode pnode = stack.peek();<br>            <span class="hljs-keyword">if</span>(pnode.right != <span class="hljs-keyword">null</span> &amp;&amp; lastNodeVisited != pnode.right) &#123;<br>                root = pnode.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(pnode.val);<br>                lastNodeVisited = stack.pop();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="13-布隆过滤器"><a href="#13-布隆过滤器" class="headerlink" title="13. 布隆过滤器"></a>13. 布隆过滤器</h1><p>布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于1970年提出的。可以把它看作<strong>由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构</strong>。相比于平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 <code>1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb</code> 的空间。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>举个简单的例子：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="布隆过滤器原理"></p>
<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后在对应的位数组的下表的元素设置为 1（当位数组初始化时 ，所有位置均为0）。当第二次存储相同字符串时，因为先前的对应位置已设置为1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p>不同的字符串可能哈希出来的位置相同，这种情况可以适当增加位数组大小或者调整哈希函数。</p>
<p>综上，可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>判断给定数据是否存在：比如判断一个数字是否在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li>
<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li>
</ul>
<h2 id="通过-Java-编程手动实现布隆过滤器"><a href="#通过-Java-编程手动实现布隆过滤器" class="headerlink" title="通过 Java 编程手动实现布隆过滤器"></a>通过 Java 编程手动实现布隆过滤器</h2><p>如果想要手动实现一个的话，需要：</p>
<ul>
<li>一个合适大小的位数组保存数据</li>
<li>几个不同的哈希函数</li>
<li>添加元素到位数组（布隆过滤器）的方法实现</li>
<li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.BitSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloomFilter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>     * 数组的大小<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_SIZE = <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">24</span>;<br><br>    <span class="hljs-comment">/**<br>     * 通过这个数组创建6个不同的hash函数<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] SEEDS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">46</span>, <span class="hljs-number">71</span>, <span class="hljs-number">91</span>, <span class="hljs-number">134</span>&#125;;<br><br>    <span class="hljs-comment">/**<br>     * 位数组<br>     */</span><br>    <span class="hljs-keyword">private</span> BitSet bits = <span class="hljs-keyword">new</span> BitSet(DEFAULT_SIZE);<br><br>    <span class="hljs-comment">/**<br>     * 包含哈希函数类的数组<br>     */</span><br>    <span class="hljs-keyword">private</span> SimplHash[] funcs = <span class="hljs-keyword">new</span> SimplHash[SEEDS.length];<br><br><br>    <span class="hljs-comment">/**<br>     * 静态内部类，用于 hash 操作<br>     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplHash</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cap;<br>        <span class="hljs-keyword">int</span> seed;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimplHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap,<span class="hljs-keyword">int</span> seed)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.cap = cap;<br>            <span class="hljs-keyword">this</span>.seed = seed;<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 计算 hash 值<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object value)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> h;<br>            <span class="hljs-keyword">return</span> (value == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : Math.abs(seed * (cap-<span class="hljs-number">1</span>) &amp; ((h  = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 初始化包含多个 hash 函数的类的数组，每个类中的 hash 函数不一样<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBloomFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SEEDS.length; i++) &#123;<br>            funcs[i] = <span class="hljs-keyword">new</span> SimplHash(DEFAULT_SIZE,SEEDS[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 添加元素到位数组<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(SimplHash func : funcs) &#123;<br>            <span class="hljs-keyword">int</span> hash = func.hash(value);<br>            bits.set(hash,<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 判断指定值是否位于位数组中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contain</span><span class="hljs-params">(Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(SimplHash func :funcs) &#123;<br>            ret = ret &amp;&amp; bits.get(func.hash(value));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>也可以利用Google开源的 Guava 中自带的布隆过滤器。Guava 提供的布隆过滤器的实现还是很不错的但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，就需要用到 Redis 中的布隆过滤器了。</p>
<h2 id="Redis中的布隆过滤器"><a href="#Redis中的布隆过滤器" class="headerlink" title="Redis中的布隆过滤器"></a>Redis中的布隆过滤器</h2><p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module</p>
<p>使用 Docker 安装 RedisBloom后运行，</p>
<p>常用命令一览：</p>
<p>注意： key:布隆过滤器的名称，item : 添加的元素。</p>
<ul>
<li><code>BF.ADD</code> ：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD {key} {item}</code>。</li>
<li><code>BF.MADD</code> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式BF.ADD与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD {key} {item} [item ...]</code> 。</li>
<li><code>BF.EXISTS</code>: 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS {key} {item}</code>。</li>
<li><code>BF.MEXISTS</code> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS {key} {item} [item ...]</code>。</li>
</ul>
<p>另外，BF.RESERVE 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">BF.RESERVE </span><span class="hljs-template-variable">&#123;key&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;error_rate&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;capacity&#125;</span><span class="xml"> [EXPANSION expansion] 。</span><br></code></pre></div></td></tr></table></figure>

<p>下面简单介绍一下每个参数的具体含义：</p>
<ul>
<li><code>key</code>：布隆过滤器的名称</li>
<li><code>error_rate</code> :误报的期望概率。这应该是介于 0 到 1 之间的十进制值。例如，对于期望的误报率0.1％（1000中为1），<code>error_rate</code>应该设置为0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的CPU使用率越高。</li>
<li><code>capacity</code>: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ul>
<p>可选参数：</p>
<ul>
<li><code>expansion</code>：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以 <code>expansion</code>。默认扩展值为2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.ADD myFilter java<br>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.ADD myFilter javaguide<br>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS myFilter java<br>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS myFilter javaguide<br>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS myFilter github<br>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>

<h1 id="14-平衡二叉树"><a href="#14-平衡二叉树" class="headerlink" title="14. 平衡二叉树"></a>14. 平衡二叉树</h1><p>AVL 树是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。</p>
<p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。</p>
<p>平衡二叉查找树，简称平衡二叉树，它具有如下几个性质：</p>
<ul>
<li>可以是空树。</li>
<li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li>
</ul>
<p>平衡二叉树的节点结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">Tree</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>&#123;</span><br><br>    <span class="hljs-keyword">int</span> depth; <span class="hljs-comment">//深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡</span><br><br>    Tree parent; <span class="hljs-comment">//该结点的父节点</span><br><br>    ElementType val; <span class="hljs-comment">//结点值</span><br><br>    Tree lchild;<br><br>    Tree rchild;<br><br>    AVLNode(<span class="hljs-keyword">int</span> val=<span class="hljs-number">0</span>) &#123;<br>        parent = <span class="hljs-literal">NULL</span>;<br>        depth = <span class="hljs-number">0</span>;<br>        lchild = rchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">this</span>-&gt;val=val;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><p>定义：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p>
<h2 id="最小失衡子树"><a href="#最小失衡子树" class="headerlink" title="最小失衡子树"></a>最小失衡子树</h2><p>在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p>
<p>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋与右旋。</p>
<p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p>
<h2 id="AVL树的四种插入节点方式"><a href="#AVL树的四种插入节点方式" class="headerlink" title="AVL树的四种插入节点方式"></a>AVL树的四种插入节点方式</h2><p>假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：</p>
<table>
<thead>
<tr>
<th>插入方式</th>
<th>描述</th>
<th>旋转方式</th>
</tr>
</thead>
<tbody><tr>
<td>LL</td>
<td>在 A 的左子树根节点的左子树上插入节点而破坏平衡</td>
<td>右旋转</td>
</tr>
<tr>
<td>RR</td>
<td>在 A 的右子树根节点的右子树上插入节点而破坏平衡</td>
<td>左旋转</td>
</tr>
<tr>
<td>LR</td>
<td>在 A 的左子树根节点的右子树上插入节点而破坏平衡</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>RL</td>
<td>在 A 的右子树根节点的左子树上插入节点而破坏平衡</td>
<td>先右旋后左旋</td>
</tr>
</tbody></table>
<h2 id="AVL树的四种删除节点方式"><a href="#AVL树的四种删除节点方式" class="headerlink" title="AVL树的四种删除节点方式"></a>AVL树的四种删除节点方式</h2><p>AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：</p>
<ol>
<li>删除叶子节点</li>
<li>删除的节点只有左子树</li>
<li>删除的节点只有右子树</li>
<li>删除的节点既有左子树又有右子树</li>
</ol>
<p>只不过 AVL 树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。</p>
<p>删除操作的大致步骤如下：</p>
<ol>
<li>以前三种情况为基础尝试删除节点，并将访问节点入栈。</li>
<li>如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。</li>
<li>如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。</li>
<li>再依次检查栈顶节点的平衡状态和修正直到栈空。</li>
</ol>
<p>对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。</p>
<h1 id="15-hash-冲突怎么解决"><a href="#15-hash-冲突怎么解决" class="headerlink" title="15. hash 冲突怎么解决"></a>15. hash 冲突怎么解决</h1><h2 id="开放定址法-再散列法"><a href="#开放定址法-再散列法" class="headerlink" title="开放定址法(再散列法)"></a>开放定址法(再散列法)</h2><p>这种方法也称再散列法，其基本思想是：当关键字 key 的哈希地址 <code>p=hash(key)</code> 出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p 为基础，产生另一个哈希地址 p2，…，直到找出一个不冲突的哈希地址 pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">Hi = (hash(<span class="hljs-type">key</span>)+di) % m i=<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，…，n<br></code></pre></div></td></tr></table></figure>
<p>其中 <code>hash(key)</code> 为哈希函数，m 为表长，di 称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p>
<h3 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">dii = <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，…，m<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p>例如，已知哈希表长度 m=11，哈希函数为：<code>hash(key)= key % 11</code>，则 hash(47) = 3，hash(36) = 4，hash(60) = 5，假设下一个关键字为 69，则 hash(69) = 3，与 47 冲突。</p>
<p>如果用线性探测再散列处理冲突，下一个哈希地址为 H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为 H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为 H3=（3 + 3）% 11 = 6，此时不再冲突，将 69 填入 5 号单元。</p>
<h3 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">di=<span class="hljs-number">12</span>，<span class="hljs-number">-12</span>，<span class="hljs-number">22</span>，<span class="hljs-number">-22</span>，…，k2，-k2 ( k&lt;=m/<span class="hljs-number">2</span> )<br></code></pre></div></td></tr></table></figure>

<p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<p>对于上面的例子，如果用二次探测再散列处理冲突，下一个哈希地址为 H1 =（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为 H2 =（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。</p>
<h3 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h3><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">di</span>=伪随机数序列。<br></code></pre></div></td></tr></table></figure>

<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
<p>对于上面的例子，如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为 H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为 H2=（3 + 5）% 11 = 8，此时不再冲突，将 69 填入 8 号单元。</p>
<h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>这种方法是同时构造多个不同的哈希函数：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">Hi = RH1（<span class="hljs-type">key</span>） i=<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，…，k<br></code></pre></div></td></tr></table></figure>

<p>当哈希地址 Hi=RH1（key）发生冲突时，再计算 Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="拉链法的优点"><a href="#拉链法的优点" class="headerlink" title="拉链法的优点"></a>拉链法的优点</h3><p>与开放定址法相比，拉链法有如下几个优点：</p>
<ul>
<li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li>
<li>开放定址法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li>
<li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li>
</ul>
<h3 id="拉链法的缺点"><a href="#拉链法的缺点" class="headerlink" title="拉链法的缺点"></a>拉链法的缺点</h3><p>拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener">什么是平衡二叉树（AVL）</a><br><a href="https://zhuanlan.zhihu.com/p/29520044" target="_blank" rel="noopener">数据结构与算法：hash冲突解决</a>  </p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/10/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/10/26/shell%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">Shell基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.lazyComments('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'xiao-ming9/xiao-ming9.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备18114217号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=粤ICP备18114217号-1"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>粤ICP备18114217号-1</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?54ebb03ad7ad5b762ac8ff7958df6d3f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-M2RT7SDT3L', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M2RT7SDT3L"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-M2RT7SDT3L');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
