<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>算法</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">算法</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-字符串匹配KMP算法"><span class="toc-text">1. 字符串匹配KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#部分匹配值的实现思路"><span class="toc-text">部分匹配值的实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP算法"><span class="toc-text">KMP算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-替换空格"><span class="toc-text">2. 替换空格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-最长公共前缀"><span class="toc-text">3. 最长公共前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-最长回文串"><span class="toc-text">4. 最长回文串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-验证回文串"><span class="toc-text">5. 验证回文串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-最长回文子串"><span class="toc-text">6. 最长回文子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-最长回文子序列"><span class="toc-text">7. 最长回文子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-括号匹配深度"><span class="toc-text">8. 括号匹配深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-把数字字符串转换成整数"><span class="toc-text">9. 把数字字符串转换成整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-两数相加"><span class="toc-text">10. 两数相加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-反转链表"><span class="toc-text">11. 反转链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-删除链表中倒数第k个节点"><span class="toc-text">12. 删除链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-输出链表中倒数第k个节点"><span class="toc-text">13. 输出链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-求斐波纳切数列的第n个数-爬楼梯"><span class="toc-text">14. 求斐波纳切数列的第n个数/爬楼梯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-变态台阶问题"><span class="toc-text">15. 变态台阶问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-二维数组查找"><span class="toc-text">16. 二维数组查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-按奇偶排序数组"><span class="toc-text">17. 按奇偶排序数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-TOP-K-问题"><span class="toc-text">18. TOP K 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排"><span class="toc-text">堆排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快排方式"><span class="toc-text">快排方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空间换时间：bitmap方式-海量数据排序也可以用"><span class="toc-text">空间换时间：bitmap方式(海量数据排序也可以用)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-1亿个-IPV-地址找相同"><span class="toc-text">19. 1亿个 IPV 地址找相同</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法一：hash取模"><span class="toc-text">方法一：hash取模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法二：bitmap"><span class="toc-text">方法二：bitmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-两个栈实现队列"><span class="toc-text">20. 两个栈实现队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-字典树（trie）实现敏感词汇过滤"><span class="toc-text">21. 字典树（trie）实现敏感词汇过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法思路总结："><span class="toc-text">算法思路总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体过程"><span class="toc-text">具体过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码实现"><span class="toc-text">算法代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间空间复杂度"><span class="toc-text">时间空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-给定已有硬币面值，计算需要的最少硬币数目？"><span class="toc-text">22. 给定已有硬币面值，计算需要的最少硬币数目？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-动态规划01背包问题"><span class="toc-text">23. 动态规划01背包问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-最长不重复子串"><span class="toc-text">24. 最长不重复子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-数据求交集"><span class="toc-text">25. 数据求交集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度分析"><span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-如何判断单链表是否有环？如何确定环的入口？"><span class="toc-text">26. 如何判断单链表是否有环？如何确定环的入口？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法一：hash-表"><span class="toc-text">方法一：hash 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法二：双指针（快慢指针）"><span class="toc-text">方法二：双指针（快慢指针）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-找两条链表公共节点"><span class="toc-text">27. 找两条链表公共节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-100G-的文件，只有-100M-内存，对文件进行排序"><span class="toc-text">28. 100G 的文件，只有 100M 内存，对文件进行排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#外部排序-多路归并"><span class="toc-text">外部排序 + 多路归并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位图法"><span class="toc-text">位图法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-100亿个整型数据，乱序，100M内存，求中位数"><span class="toc-text">29. 100亿个整型数据，乱序，100M内存，求中位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><span class="toc-text">30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-二叉树中和为某一值的路径"><span class="toc-text">31. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除"><span class="toc-text">32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-二叉搜索树转双向链表"><span class="toc-text">33. 二叉搜索树转双向链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-有序链表转换二叉搜索树"><span class="toc-text">34. 有序链表转换二叉搜索树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"><span class="toc-text">35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径"><span class="toc-text">36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-二叉树的最近公共祖先"><span class="toc-text">37. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-分5个线程计算1-10000的和，要求全部计算完了再汇总"><span class="toc-text">38. 分5个线程计算1-10000的和，要求全部计算完了再汇总</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-1-N-这些数中1出现的次数"><span class="toc-text">39. 1-N 这些数中1出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#解法一：暴力破解"><span class="toc-text">解法一：暴力破解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学法"><span class="toc-text">数学法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-合并区间"><span class="toc-text">40. 合并区间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-股票的最大利润"><span class="toc-text">41. 股票的最大利润</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-顺时针打印矩阵"><span class="toc-text">42. 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-滑动窗口的最大值"><span class="toc-text">43. 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-从前序与中序遍历序列构造二叉树"><span class="toc-text">44. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度分析-1"><span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-矩阵中的路径"><span class="toc-text">45. 矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法原理："><span class="toc-text">算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法剖析："><span class="toc-text">算法剖析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现"><span class="toc-text">代码实现</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E9%9D%A2%E8%AF%95"><i class="tag post-item-tag">面试</i></a><a href="/tags/%E7%AE%97%E6%B3%95"><i class="tag post-item-tag">算法</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">算法</h1><time class="has-text-grey" datetime="2019-10-29T08:42:37.000Z">2019-10-29</time><article class="mt-2 post-content"><h1 id="1-字符串匹配KMP算法"><a href="#1-字符串匹配KMP算法" class="headerlink" title="1. 字符串匹配KMP算法"></a>1. 字符串匹配KMP算法</h1><p>KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到<code>O(m+n)</code>,而空间复杂度也只有<code>O(m)</code>。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<a id="more"></a>

<p>算法思想大概如下：</p>
<p>有如下字符串：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP1.png" alt="KMP1"></p>
<p>当匹配到以下这种情况时，会出现空格和D不匹配，而前面六个字符”ABCDAB”是匹配的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP2.png" alt="KMP2"></p>
<p>此时可以将搜索项后移4格得到如下情况，然后再继续往下对比下一位：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP3.png" alt="KMP3"></p>
<p>在程序中，通过设置<strong>部分匹配表</strong>保存前面搜索的已知信息，部分匹配表主要用于保存匹配字符串的最长公共前后缀。</p>
<p>部分匹配值就是“前缀”和“后缀”的最长的共有元素的长度。以“ABCDABD”为例：</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>因此可以得出下表：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP4.png" alt="KMP4"></p>
<p>此时需要移动的位数 = 已匹配的字符数 - 对应的部分的匹配值</p>
<p>对于上面的情况：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP2.png" alt="KMP2"></p>
<p>查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<p>由于此时指针指向的是D位置，而并非前面的B位置，为了便于计算，可以将部分匹配值整体右移一位，之后在第0位补上值为-1。例如：</p>
<p><img src="http://qiniu.xiaoming.net.cn/KMP5" alt="KMP5"></p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP6" alt="KMP6"></p>
<p>此时，若匹配到当前位置不符合，只需要将匹配位置移到当前匹配位置的匹配值代表的位置，如上面此时D的匹配值为2，则将搜索词中[2]的位置即A移到当前字符串下，同样相当于右移4位。若匹配值为-1，则从下一个位置开始从头开始匹配。</p>
<h2 id="部分匹配值的实现思路"><a href="#部分匹配值的实现思路" class="headerlink" title="部分匹配值的实现思路"></a>部分匹配值的实现思路</h2><p>对于第一个字符，其匹配值一定是0。之后每增加一位，则与已比较的最后一位的匹配值所指位置的字符比较，相同，则在上一个字符匹配值基础上+1；如果不匹配，则需要指向最后一位字符的前一个字符的匹配值的位置的字符，之后以此类推。</p>
<pre><code class="c">/* 部分匹配表的实现
 * @pattern 需要被匹配到的字符串
 * @prefix 部分匹配表
 * @n pattern长度
 */
void prefix_table(char pattern[],int prefix[],int n) {
    prefix[0] = 0;
    int len = 0;//指向当前字符串对比到的字符的匹配值
    int i = 1;
    while(i &lt; n) {
        if(pattern[len] == pattern[i]) {
            len++;
            prefix[i] = len;
            i++;
        } else {
            if(len &gt; 0){
                len = prefix[len -1];
            } else {
                prefix[i] = 0;
                i++;
            }
        }
    }
}</code></pre>
<p>之后再将整体匹配表的值后移一位</p>
<pre><code class="c">void move_prefix_table(int prefix[],int n) {
    int i;
    for(i = n-1;i &gt; 0;i--) {
        prefix[i] = prefix[i-1];
    }
    prefix[0] = -1;
}</code></pre>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><pre><code class="c">void kmp_search(char text[],char pattern[]) {
    int n = strlen(pattern);    //需要匹配的字符串长度
    int m = strlen(text);       //待匹配字符串长度
    int* prefix = malloc(sizeof(int)*n);

    //获取匹配表
    prefix_table(pattern,prefix,n);
    move_prefix_table(prefix,n);

    int i = 0;      //当前text匹配到的位置
    int j = 0;      //当前pattern匹配到的位置

    while(i &lt; m) {

        //搜索完成
        if(j = n-1 &amp;&amp; text[i] == pattern[j]) {
            printf(&quot;已找到位置：&quot; + (i-j));
            j = prefix[j];//继续往后看看还有没有其他匹配项
        }

        //匹配成功
        if(text[i] == pattern[j]) {
            i++;
            j++;
        } else {
            j = prefix[j];
            //如果到了最开始还不匹配，那么往text的下一个位置从头开始匹配
            if(j == -1) {
                i++;
                j++;
            }
        }
    }
}</code></pre>
<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成<code>%20</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</p>
</blockquote>
<pre><code class="java">public class ReplaceSpaceSolution {

    //方法一：循环遍历替换
    public static String replaceSpace(String str) {
        int len = str.length();
        StringBuilder result = new StringBuilder();
        for (int i = 0; i &lt; len; i++) {
            char c = str.charAt(i);
            if(String.valueOf(c).equals(&quot; &quot;)) {
                result.append(&quot;%20&quot;);
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

    //方法二：使用接口
    public static String replaceSpace2(String str) {
        return str.replaceAll(&quot; &quot;,&quot;%20&quot;);
    }
}</code></pre>
<h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><blockquote>
<p>Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>方法1:</p>
<pre><code class="java">public static  String longestCommonPrefix(String[] strs){

    if(strs.length == 0) return &quot;&quot;;
    String prefix = strs[0];//以第一个字符串先假设为最长前缀
    int len = strs.length;
    for (int i = 1; i &lt; len; i++) {
        //indexOf在找不到的时候返回-1，找到了返回位置
        while (strs[i].indexOf(prefix) != 0) {
            //找不到或者找到的位置不是首位，将前缀去掉一个字符再比较
            prefix = prefix.substring(0, prefix.length() - 1);
            if (prefix.isEmpty()) return &quot;&quot;;
        }
    }
    return prefix;
}</code></pre>
<p>方法2:</p>
<pre><code class="java">public static String longestCommonPrefix2(String[] strs) {
    //将首个字符串逐列与后面的字符串比较
    if(strs == null || strs.length == 0) return &quot;&quot;;
    for (int i = 0; i &lt; strs[0].length(); i++) {
        char c = strs[0].charAt(i);
        for (int j = 1; j &lt; strs.length; j++) {
            if(i == strs[j].length() || c != strs[j].charAt(i)) {
                return strs[0].substring(0,i);
            }
        }
    }
    return strs[0];
}</code></pre>
<p>方法3:</p>
<pre><code class="java">public static String longestCommonPrefix3(String[] strs) {
    // 先利用Arrays.sort(strs)为数组排序，
    // 排序后公共的前缀如果有，第一和最后一个肯定都包括了
    // 再将数组第一个元素和最后一个元素的字符从前往后对比

    //如果检查值不合法就返回空串
    if(!checkStr(strs)) {
        return &quot;&quot;;
    }
    int len = strs.length;
    StringBuffer result = new StringBuffer();
    Arrays.sort(strs);
    int m = strs[0].length();
    int n = strs[len-1].length();
    int num = Math.min(m,n);
    for (int i = 0; i &lt; num; i++) {
        if(strs[0].charAt(i) == strs[len-1].charAt(i)) {
            result.append(strs[0].charAt(i));
        } else
            break;
    }
    return result.toString();
}

private static boolean checkStr(String[] strs) {
    boolean flag = false;
    if(strs != null) {
        //遍历strs检查元素值
        for (int i = 0; i &lt; strs.length; i++) {
            if(strs[i] != null &amp;&amp; strs[i].length() != 0) {
                flag = true;
            } else {
                flag = false;
                break;
            }
        }
    }
    return flag;
}</code></pre>
<h1 id="4-最长回文串"><a href="#4-最长回文串" class="headerlink" title="4. 最长回文串"></a>4. 最长回文串</h1><blockquote>
<p>LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如”Aa”不能当做一个回文字符串。注 意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科</p>
</blockquote>
<p>构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li>字符出现次数为双数的组合+一个只出现一次的字符</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在 <code>hashset</code> 中，如果不在就加进去，如果在就让 <code>count++</code>，然后移除该字符,这样就能找到出现次数为双数的字符个数。</p>
<pre><code class="java">class Solution {
    public int longestPalindrome(String s) {
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        int len = s.length();
        int count = 0;
        // char[] chars = s.toCharArray(); //可以考虑先将字符串转化为字符数组
        for(int i=0;i&lt;len;i++){
            char c = s.charAt(i);
            if(!set.contains(c)) {
                //如果集合里不存在就将其加入到集合
                set.add(c);
            } else {
                //如果集合里已经有了，那么就将该元素删除
                //count+1表示双数的字符个数
                set.remove(c);
                count++;
            }
        }
        //如果集合不为空，可以有一个作为最中间元素
        return set.isEmpty()?count*2:count*2+1;
    }
}</code></pre>
<h1 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5. 验证回文串"></a>5. 验证回文串</h1><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true</code></pre><pre><code class="java">class Solution {
    public boolean isPalindrome(String s) {
        int len = s.length();
        if (len == 0) return true;

        int l = 0;
        int r = len-1;
        //从两边往中间遍历
        while(l&lt; r) {
            char left = s.charAt(l);
            char right = s.charAt(r);
            //排除不是数字和字母的字符
            if(!Character.isLetterOrDigit(left)){
                l++;
            } else if(!Character.isLetterOrDigit(right)) {
                r--;
            } else {
                if( Character.toLowerCase(left) != Character.toLowerCase(right)) {
                    return false;
                }
                l++;
                r--;
            }
        }
        return true;
    }
}</code></pre>
<h1 id="6-最长回文子串"><a href="#6-最长回文子串" class="headerlink" title="6. 最长回文子串"></a>6. 最长回文子串</h1><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot;也是一个有效答案。</code></pre><p>示例 2：</p>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre><p>思路：遍历，以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpeg" alt="回文最大子字符串"></p>
<pre><code class="java">class Solution {
    private int len;//用于确定最长回文子串长度
    private int index;//用于指定从哪里开始

    public String longestPalindrome(String s) {
        int length = s.length();

        if(length &lt; 2) {
            return s;
        }
        for(int i = 0;i&lt;length-1;i++){
            //对单数检索
            palindromeHelper(s,i,i);
            //对双数检索
            palindromeHelper(s,i,i+1);
        }
        return s.substring(index,index+len);
    }

    public void palindromeHelper(String s,int l,int r) {
        int length = s.length();
        //分别往左，往右对比
        while(l &gt;= 0 &amp;&amp; r &lt; length &amp;&amp; s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        //如果长度比已经对比过的长，则进行替换
        if(len &lt; r-l-1) {
            index = l+1;//因为l位置已经不同，所以起始位置是l+1
            len = r-l-1;
        }
    }
}</code></pre>
<h1 id="7-最长回文子序列"><a href="#7-最长回文子序列" class="headerlink" title="7. 最长回文子序列"></a>7. 最长回文子序列</h1><blockquote>
<p>LeetCode: 最长回文子序列 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 </p>
</blockquote>
<blockquote>
<p><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p><strong>解题思路</strong>：主要运用动态规划的思想</p>
<ul>
<li>状态：<code>f[i][j]</code> 表示 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符组成的子串中，最长的回文序列长度是多少。</li>
<li>转移方程：如果 <code>s</code> 第 <code>i</code> 个字符和第 <code>j</code> 个字符相同的话 <code>f[i][j] = f[i + 1][j - 1] + 2</code>;否则 <code>f[i][j] = max(f[i + 1][j], f[i][j - 1])</code></li>
<li>初始化：<code>f[i][i] = 1</code> 单个字符的最长回文序列是1</li>
<li>结果：<code>f[0][n-1]</code></li>
</ul>
<pre><code class="java">class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] result = new int[len][len];
        for(int i = len-1;i &gt;= 0;i--) {
            //单个字符长度为1
            result[i][i] = 1;
            for(int j=i+1;j&lt;len;j++) {
                if(s.charAt(i) == s.charAt(j)) {
                    //如果相同，则在原来序列数量的左右两边各加一个，所以加2
                    result[i][j] = result[i+1][j-1] +2;
                } else {
                    //如果不相同，则是当前位置到上一个位置的值，这个值可能是i这边，也可能是j一边的，取最大值。
                    result[i][j] = Math.max(result[i+1][j],result[i][j-1]);
                }
            }
        }
        return result[0][len-1];
    }
}</code></pre>
<h1 id="8-括号匹配深度"><a href="#8-括号匹配深度" class="headerlink" title="8. 括号匹配深度"></a>8. 括号匹配深度</h1><pre><code>输入描述:
输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&#39;(&#39;和&#39;)&#39;。

输出描述:
输出一个正整数,即这个序列的深度。</code></pre><p>示例：</p>
<pre><code>输入:
(())
输出:
2</code></pre><pre><code class="java">package com.xm.algorithm;

import java.util.Scanner;

public class BracketMatchingDepth {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int i = maxDepth(s);
        System.out.println(&quot;最大深度为：&quot;+i);
        scanner.close();
    }

    public static int maxDepth(String s) {
        int len = s.length();
        int count = 0;
        int depth = 0;
        for(int i=0;i&lt;len;i++) {
            switch (s.charAt(i)) {
                case &#39;(&#39;:count++ ;
                    break;
                case &#39;)&#39;:count--;
                    break;
            }
            //关键在这里需要记录下当前匹配的最大深度
            depth = Math.max(count, depth);
        }
        return depth;
    }
}</code></pre>
<h1 id="9-把数字字符串转换成整数"><a href="#9-把数字字符串转换成整数" class="headerlink" title="9. 把数字字符串转换成整数"></a>9. 把数字字符串转换成整数</h1><blockquote>
<p>剑指offer: 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<pre><code class="java">package com.xm.algorithm;


public class StrToInt {

    public static void main(String[] args) {
        String s = &quot;-12312312&quot;;
        System.out.println(&quot;使用库函数转换：&quot; + Integer.valueOf(s));
        int res = strToInt(s);
        System.out.println(&quot;使用自己写的方法转换：&quot; + res);
    }

    public static int strToInt(String str) {
        int len = str.length();
        int result = 0;
        char[] chars = str.toCharArray();
        int flag = 0;//用于判断是否有符号位
        if(chars[0] == &#39;+&#39;)
            flag = 1;
        else if(chars[0] == &#39;-&#39;)
            flag = 2;
        //判断从哪一位开始，有符号就从第二个开始
        int start = (flag == 0) ? 0 : 1;
        for (int i = start;i&lt;len;i++) {
            if(Character.isDigit(chars[i])) {
                int temp = chars[i] - &#39;0&#39;;
                result = result*10+temp;
            } else {
                return 0;
            }
        }
        return (flag==2)? -result : result;
    }
}</code></pre>
<h1 id="10-两数相加"><a href="#10-两数相加" class="headerlink" title="10. 两数相加"></a>10. 两数相加</h1><p>题目描述</p>
<blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
</blockquote>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>示例：</p>
<pre><code class="java">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<pre><code class="java">package com.xm.algorithm;

public class AddTwoNumber {

    public class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public  ListNode addTwoNumber(ListNode l1,ListNode l2) {
        ListNode p = l1;
        ListNode q = l2;
        int carry = 0;//用于表示进位

        //在这里先定义链表头，后面省去代码根据是不是第一次而创建头节点的问题
        ListNode headNode = new ListNode(0);
        ListNode curr = headNode;

        while(p!=null || q!=null) {
            int x = (p != null) ? p.val:0;
            int y = (q != null) ? q.val:0;
            int sum = x+y+carry;
            curr.next = new ListNode(sum%10);
            carry = sum/10;//只可能为0或1
            curr = curr.next;//往下继续
            if(p.next != null) p = p.next;
            if(q.next != null) q = q.next;
        }

        //最高位有进位
        if(carry &gt; 0) {
            curr.next = new ListNode(carry);
        }
        return headNode.next;
    }
}</code></pre>
<h1 id="11-反转链表"><a href="#11-反转链表" class="headerlink" title="11. 反转链表"></a>11. 反转链表</h1><blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<pre><code class="java">package com.xm.algorithm;

import java.util.List;

public class ReverseList {

    static class ListNode {
        int data;
        ListNode next;

        ListNode(int data) {
            this.data = data;
        }
    }

    public static ListNode reverseList(ListNode head) {
        ListNode next = null;
        ListNode pre = null;

        while(head != null) {
            //记录当前节点的下一个节点
            next = head.next;
            //将当前节点的next域指向上一个节点
            head.next = pre;
            //当前节点作为“上一个节点”以供下一个节点指明
            pre = head;
            head = next;
        }
        return pre;
    }

    public static void main(String[] args) {
        ListNode a = new ListNode(1);
        ListNode b = new ListNode(2);
        ListNode c = new ListNode(3);
        ListNode d = new ListNode(4);
        ListNode e = new ListNode(5);
        a.next = b;
        b.next = c;
        c.next = d;
        d.next = e;
        reverseList(a);
        while (e != null) {
            System.out.println(e.data);
            e = e.next;
        }
    }
}</code></pre>
<h1 id="12-删除链表中倒数第k个节点"><a href="#12-删除链表中倒数第k个节点" class="headerlink" title="12. 删除链表中倒数第k个节点"></a>12. 删除链表中倒数第k个节点</h1><blockquote>
<p>Leetcode: 输入一个链表，删除该链表中倒数第k个结点，并且返回链表的头结点。</p>
</blockquote>
<p>分析：</p>
<p>链表中倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点，</p>
<p>首先两个节点/指针，一个节点 <code>node1</code> 先开始跑，当两者拉开距离 n 后，另一个节点 <code>node2</code> 开始跑，当 <code>node1</code> 跑到最后时，<code>node2</code> 所指的节点就是倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点。</p>
<pre><code class="java">package com.xm.algorithm;

public class RemoveNthFromEnd {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int val) {
            this.val = val;
        }
    }

    public ListNode removeNthFromEnd(ListNode head,int n) {

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node1 = dummy;
        ListNode node2 = dummy;

        while (node1 != null) {
            //node1先开始进入链表
            node1 = node1.next;
            //当node1与node2的距离拉开n个距离时node2开始进入链表
            if(n&lt;1 &amp;&amp; node1!=null){
                node2 = node2.next;
            }
            n--;
        }
        //当node1跑完时，node2的位置便是L-n，而倒数第n位的位置是L-n+1
        node2.next = node2.next.next;
        return dummy.next;
    }
}</code></pre>
<h1 id="13-输出链表中倒数第k个节点"><a href="#13-输出链表中倒数第k个节点" class="headerlink" title="13. 输出链表中倒数第k个节点"></a>13. 输出链表中倒数第k个节点</h1><p>题目描述:</p>
<blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>问题分析</p>
<p>根据上一题的思路求解。</p>
<pre><code class="java">package com.xm.algorithm;

public class FindKthToTail {

    static class  ListNode {
        int val;
        ListNode next;

        ListNode(int val) {
            this.val = val;
        }
    }

    public ListNode findKthToTail(ListNode head,int n) {
        if(head == null || n&lt;=0) {
            return null;
        }
        ListNode node1 = head;
        ListNode node2 = head;
        int count = 0;//用于计算节点个数，判断是否超出范围
        int index = n;//记录n的值，用于后面做判断

        while(node1 != null) {
            count++;
            node1 = node1.next;
            if(n&lt;1 &amp;&amp; node1!=null){
                node2 = node2.next;
            }
            n--;
        }
        if(count&lt;index) {
            return null;
        }
        return node2.next;
    }
}</code></pre>
<h1 id="14-求斐波纳切数列的第n个数-爬楼梯"><a href="#14-求斐波纳切数列的第n个数-爬楼梯" class="headerlink" title="14. 求斐波纳切数列的第n个数/爬楼梯"></a>14. 求斐波纳切数列的第n个数/爬楼梯</h1><blockquote>
<p>Leecode:假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
</blockquote>
<p>分析：</p>
<p>动态规划思想，爬上最后一层楼梯可能是差一阶或两阶，即<code>f(N)=f(N-1)+f(N-2)</code>，此时数列变成”1 1 2 3 5 …”</p>
<pre><code class="java">class Solution {
    public int fib(int N) {
        if(N&lt;1) {
            return 0;
        }
        if(N==1 || N==2) {
              // 斐波那契数列
              return 1;
              // 爬楼梯
            return N;
        }

        int f1 = 1;
          // 斐波那契数列
        int f2 = 1;
          // 爬楼梯
          int f2 = 2;
        int result = 0;
        for(int i=3;i&lt;=N;i++) {
            result = f1 +f2;
            f1 = f2;
            f2 = result;
        }
        return result;
    }
}</code></pre>
<h1 id="15-变态台阶问题"><a href="#15-变态台阶问题" class="headerlink" title="15. 变态台阶问题"></a>15. 变态台阶问题</h1><p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>假设 <code>n&gt;=2</code>，第一步有n种跳法：跳 1 级、跳 2 级,到跳 n 级。 跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1)； 跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2) …… 跳 n-1 级，剩下 1 级，则剩下跳法是 f(1)； 跳 n 级，剩下 0 级，则剩下跳法是 f(0) </p>
<p>所以在 n&gt;=2 的情况下： <code>f(n)=f(n-1)+f(n-2)+...+f(1)</code> 因为 <code>f(n-1)=f(n-2)+f(n-3)+...+f(1)</code>,所以 <code>f(n)=2*f(n-1)</code>, 又 <code>f(1)=1</code>,所以可得 <code>f(n)=2^(number-1)</code></p>
<p>示例代码：</p>
<pre><code class="java">int JumpFloorII(int number) {
    return 1 &lt;&lt; --number;//2^(number-1)用位移操作进行，更快
}</code></pre>
<h1 id="16-二维数组查找"><a href="#16-二维数组查找" class="headerlink" title="16. 二维数组查找"></a>16. 二维数组查找</h1><p><strong>题目描述：</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>问题解析：</strong><br>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增， 因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>
<pre><code class="java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row = matrix.length-1;//行数
        int column = 0;//列数

        //边界条件
        while(row&gt;=0 &amp;&amp; column&lt;matrix[0].length) {
            if(matrix[row][column] &gt; target) {
                row--;
            } else if(matrix[row][column] &lt; target) {
                column ++;
            } else {
                return true;
            }
        }
        return false;
    }
}</code></pre>
<h1 id="17-按奇偶排序数组"><a href="#17-按奇偶排序数组" class="headerlink" title="17. 按奇偶排序数组"></a>17. 按奇偶排序数组</h1><blockquote>
<p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
</blockquote>
<pre><code class="java">class Solution {
    public int[] sortArrayByParity(int[] A) {
        int len = A.length;
        if(len == 0 || len ==1) {
            return A;
        }
        int[] arrays = new int[len];
        int count = 0;//用来计算偶数个数
        int index = 0;//用来指明当前到达那个位置

        //先统计偶数个数
        for(int i=0;i&lt;len;i++) {
            if(A[i]%2 == 0) {
                count++;
            }
        }
        //奇数只在插在偶数个数之后的位置
        for(int i=0;i&lt;len;i++) {
            if(A[i]%2 == 0) {
                arrays[index++] = A[i];
            } else {
                arrays[count++] = A[i];
            }
        }
        return arrays;
    }
}</code></pre>
<h1 id="18-TOP-K-问题"><a href="#18-TOP-K-问题" class="headerlink" title="18. TOP K 问题"></a>18. TOP K 问题</h1><p>从 1 亿个数中找出最大的前 100 个。</p>
<h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>利用小顶堆，首先遍历 100 个数放入堆中，后面每次遍历与堆顶比较，比堆顶大就替换堆顶并对堆进行调整。</p>
<p>堆排的时间复杂度是<code>n*logn</code>,适用场景：</p>
<ul>
<li>不会改变数据的输入顺序（按顺序读的）；</li>
<li>不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）；</li>
<li>由于（2），决定了它特别适合处理海量数据。</li>
</ul>
<pre><code class="java">public class TopK {

    public static void main(String[] args) {

        //假设这是给定的数据
        int[] a = { 1, 17, 3, 4, 5, 6, 7, 16, 9, 10, 11, 12, 13, 14, 15, 8 };
        //寻找前4个最大的数
        int[] b = topK(a, 4);
        for (int i = 0; i &lt; b.length; i++) {
            System.out.print(b[i] + &quot;, &quot;);
        }
    }

    //对堆的 index 节点进行调整使其符合小顶堆定义
    public static void heapify(int[] array, int index, int length) {
        int left = index * 2 + 1;//左孩子
        int right = index * 2 + 2;//右孩子
        int smallest = index;
        if (left &lt; length &amp;&amp; array[left] &lt; array[index]) {
            smallest = left;
        }
        if (right &lt; length &amp;&amp; array[right] &lt; array[smallest]) {
            smallest = right;
        }
        if (index != smallest) {
            swap(array, smallest, index);
            //递归往下继续调整
            heapify(array, smallest, length);
        }
    }

    public static void swap(int[] array, int a, int b) {
        int temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }

    /**
     * 初始化小顶堆
     */
    public static void buildHeap(int[] array) {
        int length = array.length;
        /** 
         * 由于单个结点的完全二叉树满足堆的特性，所以叶子结点都是堆。因此可以忽略叶子结点元素
         * 对 n 个结点的完全二叉树建堆的过程是：依次将编号为 n/2,n/2-1,...1 的结点为根的子树筛选为子堆
         */
        for (int i = length / 2 - 1; i &gt;= 0; i--) {
            heapify(array, i, length);
        }
    }

    /**
     * 设置新的堆顶
     */
    public static void setTop(int[] array, int top) {
        array[0] = top;
        heapify(array, 0, array.length);
    }

    public static int[] topK(int[] array, int k) {
        int[] top = new int[k];
        for (int i = 0; i &lt; k; i++) {
            top[i] = array[i];
        }
        //先建堆，然后依次比较剩余元素与堆顶元素的大小，比堆顶小的， 说明它应该在堆中出现，则用它来替换掉堆顶元素，然后沉降。
        buildHeap(top);
        for (int j = k; j &lt; array.length; j++) {
            int temp = top[0];
            if (array[j] &gt; temp) {
                setTop(top, array[j]);
            }
        }
        return top;
    }
}</code></pre>
<h2 id="快排方式"><a href="#快排方式" class="headerlink" title="快排方式"></a>快排方式</h2><p>分治函数会返回一个 position，在 position 左边的数都比第 position 个数小，在 position 右边的数都比第 position 大。通过不断调用分治函数，直到它输出的 position = K-1，此时 position 前面的K个数（0到K-1）就是要找的前K个数。</p>
<p>时间复杂度为 n ，特点：</p>
<ul>
<li>partition函数会不断地交换元素的位置，所以它肯定会改变数据输入的顺序；</li>
<li>既然要交换元素的位置，那么所有元素必须要读到内存空间中，所以它会占用比较大的空间，至少能容纳整个数组；</li>
<li>数据越多，占用的空间必然越大，海量数据处理起来相对吃力。</li>
</ul>
<pre><code class="java">public class TopK {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array = { 9, 3, 1, 10, 5, 7, 6, 2, 8, 0 };
        getTopK(array, 4);
        for (int i = 0; i &lt; array.length; i++) {
            System.out.print(array[i] + &quot;, &quot;);
        }
    }

    /**
     * 从数组的右端向左扫描找到第一个大于它的元素，将这个元素放在 `l` 位置，
     * 从数组的左端向右扫描直到找到第一个小于等于枢轴的元素，
     * 放到右边高端刚交换完空出的位置。
     * 不断进行这个过程，就可以保证左指针 i 的左侧元素都不小于切分元素，
     * 右指针 j 的右侧元素都不大于切分元素。
     * 当两个指针相遇时，将枢轴的值放到该位置。
     */
    public static int partition(int[] array, int low, int high) {
        if (array != null &amp;&amp; low &lt; high) {
            int flag = array[low];
            while (low &lt; high) {
                while (low &lt; high &amp;&amp; array[high] &lt;= flag) {
                    high--;
                }
                array[low] = array[high];
                while (low &lt; high &amp;&amp; array[low] &gt;= flag) {
                    low++;
                }
                array[high] = array[low];
            }
            array[low] = flag;
            return low;
        }
        return 0;
    }

    public static void getTopK(int[] array, int k) {
        if (array != null &amp;&amp; array.length &gt; 0) {
            int low = 0;
            int high = array.length - 1;
            int index = partition(array, low, high);
            //不断调整分治的位置，直到position = k-1
            while (index != k - 1) {
                //大了，往前调整
                if (index &gt; k - 1) {
                    high = index - 1;
                    index = partition(array, low, high);
                }
                //小了，往后调整
                if (index &lt; k - 1) {
                    low = index + 1;
                    index = partition(array, low, high);
                }
            }
        }
    }
}</code></pre>
<h2 id="空间换时间：bitmap方式-海量数据排序也可以用"><a href="#空间换时间：bitmap方式-海量数据排序也可以用" class="headerlink" title="空间换时间：bitmap方式(海量数据排序也可以用)"></a>空间换时间：bitmap方式(海量数据排序也可以用)</h2><p>bitmap（比特位图法），是空间换时间的典型代表。它是一种，用若干个 bit 来表示集合的数据结构。</p>
<p>例如，集合S={1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。</p>
<p>上述集合S，可以用<code>1010101010000000</code>这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。</p>
<p>假设TopK的n个元素都是int，且元素之间没有重复，只需要申请2^32个bit，即4G的内存，就能够用bitmap表示这n元素。</p>
<p>扫描一次所有n个元素，以生成bitmap，其时间复杂度是O(n)。生成后，取TopK只需要找到最高位的k个bit即可。算法总时间复杂度也是O(n)。</p>
<p>bitmap 算法有一个缺陷，如果集合元素有重复，相同的元素会被去重，如果需要考虑重复元素，则需要通过比特位图精准计数的方式：</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXESzU0WNiaUjvAwXZNjLuyicktn7fl7Y48D34ib5r4cv0WlMicjA5dScK4oA/640?wx_fmt=jpeg" alt="bitmap求topK_1"></p>
<p>TopK的集合经过比特位图计数处理后，会记录每个bit对应在集合S中出现过多少次。</p>
<p>接下来，找TopK的过程，就是bitmap从高位的计数开始，往低位的计数扫描，得到count之和等于k，对应的bit就是TopK所求。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXEY1hhFg7yJ9DF30oeg2Y6lQM7ztxUyMOypBDgtjdO9GLAtyQUlcZl7w/640?wx_fmt=jpeg" alt="bitmap求topK_2"></p>
<p>如上图所示，k=5：</p>
<ol>
<li>第一个非0的count是1，对应的bit是9；</li>
<li>第二个非0的count也是1，对应的bit是8；</li>
<li>第三个非0的count是2，对应的bit是7；</li>
<li>第四个非0的count是2，对应的bit是6，但TopK只缺1个数字了，故只有1个6入选；</li>
</ol>
<p>故，最终的TopK={9, 8, 7, 7, 6}。</p>
<p>结论：通过比特位图精准计数的方式，求解TopK，算法整体只需要不到2次扫描，时间复杂度为O(n)，比减治法的随机选择会更快。</p>
<h1 id="19-1亿个-IPV-地址找相同"><a href="#19-1亿个-IPV-地址找相同" class="headerlink" title="19. 1亿个 IPV 地址找相同"></a>19. 1亿个 IPV 地址找相同</h1><h2 id="方法一：hash取模"><a href="#方法一：hash取模" class="headerlink" title="方法一：hash取模"></a>方法一：hash取模</h2><p>按照IP地址的 <code>hash(IP)%1024</code> 值，将海量日志存储到 1024 个小文件中，每个小文件最多包含 4M 个IP地址(IP地址最多有 <code>2^32=4G</code> 种取值可能)。 </p>
<p>对于每个小文件，可以构建一个 IP 作为 key，出现次数作为 value 的hash_map，并记录当前出现次数最多的 1 个 IP 地址。有了 1024 个小文件中的出现次数最多的 IP，我们就可以轻松得到总体上出现次数最多的 IP。</p>
<h2 id="方法二：bitmap"><a href="#方法二：bitmap" class="headerlink" title="方法二：bitmap"></a>方法二：bitmap</h2><p>申请一个长度为2^32的bit类型的数组，每个位置上是一个bit，只可表示0或者1两种状态，空间为 512 M。</p>
<p>每个 IP 地址转化成无符号整数 k，数组下标 <code>0~2^32-1</code> 与 k 对应起来。如果 <code>k==1</code> ,就把 <code>bitmap[0]=1</code>；如果 <code>k==n</code>,把 <code>bitmap[n-1] =1</code>；</p>
<p>最后只要从 bitmap 的零位一直遍历到最后，然后提取出对应为1的下标整数k，再转换成ip地址，就完成了从小到大的排序。空间复杂度很小，时间复杂度O（n）</p>
<p><img src="https://img-blog.csdnimg.cn/20190913234217803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjkwNzg1,size_16,color_FFFFFF,t_70" alt="bitmap计算ipv地址"></p>
<h1 id="20-两个栈实现队列"><a href="#20-两个栈实现队列" class="headerlink" title="20. 两个栈实现队列"></a>20. 两个栈实现队列</h1><p><img src="https://camo.githubusercontent.com/cd901d44121195e36bc4ea24dde717e707843a69/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33656132383062352d626537642d343731622d616337362d6666303230333834333537632e676966" alt="两个栈实现队列"></p>
<p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<pre><code class="java">Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();
Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();

public void push(int node) {
    in.push(node);
}

public void pop() {
    if(out.isEmpty()) {
        while(!in.isEmpty()) {
            out.push(in.pop());
        }
    }

    if (out.isEmpty())
        throw new Exception(&quot;queue is empty&quot;);

    return out.pop();
}</code></pre>
<h1 id="21-字典树（trie）实现敏感词汇过滤"><a href="#21-字典树（trie）实现敏感词汇过滤" class="headerlink" title="21. 字典树（trie）实现敏感词汇过滤"></a>21. 字典树（trie）实现敏感词汇过滤</h1><p>trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的。</p>
<h2 id="算法思路总结："><a href="#算法思路总结：" class="headerlink" title="算法思路总结："></a>算法思路总结：</h2><p>首先对需要屏蔽的词汇构建字典树（Trie Tree），然后创建三个指针，begin 指针指向匹配字符串起始位置，position 指针指向当前需要对比的字符，tempNode首先指向字典树的根节点。</p>
<p>每次 position 位置字符与 tempNode 子节点对比，如果不匹配则 position 和 begin 均加 1再继续比较；</p>
<p>如果匹配 tempNode 指向所匹配节点继续比较，同时 position+1，直到 tempNode 指向叶子节点则说明匹配到敏感词汇，将 begin 位置到 position 位置的字符屏蔽用 <code>*</code>代替,然后 position +1，begin 指向 position 位置，tempNode 指向跟节点，继续往下执行。</p>
<p>若匹配过程中到某一个 tempNode 节点时，其子节点已经没有匹配的字符，说明当前词汇不符合敏感词汇，则将 begin+1，同时 position 指向 begin，tempNode 再次指向根节点。</p>
<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>首先建立个敏感词前缀树，根节点为空：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%BB%BA%E7%AB%8B%E5%89%8D%E7%BC%80%E6%A0%91.png" alt="建立前缀树"></p>
<p>准备好待处理字符串：“哈哈大王八子大猪蹄子哦” ，声明三个指针，分别指向前缀树的根节点以及待处理字符串的开始字符</p>
<p>position 指向的字符与根节点的所有子节点进行匹配，不匹配，position 和 begin 分别指向待处理字符串的下一个字符，tempNode 依旧指向根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%A3%B0%E6%98%8E%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88.png" alt="声明三个指针"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B1.png" alt="指针匹配过程1"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B2.png" alt="指针匹配过程2"></p>
<p>此时根节点有一个子节点与 position 指向的字符相等，都为‘大’，则 tempNode 指向该节点，同时 position 前进一步，指向‘王’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B3.png" alt="指针匹配过程3"></p>
<p>此时把 position 指向的‘王’ 和 tempNode 的所有子节点进行匹配，匹配失败，说明 从 begin 起头所有串是不存在敏感词的，可以直接输出。此时 begin 前进一位，position 回退到 begin 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B4.png" alt="指针匹配过程4"></p>
<p>此时再把 position 指向的‘王’与 tempNode 的所有子节点进行匹配，匹配成功，所以 tempNode 指向该节点，同时 position 前进一位，指向’八’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B5.png" alt="指针匹配过程5"></p>
<p>此时再把 position 指向的‘王’ 与 tempNode 的所有子节点进行匹配，匹配成功，此时 tempNode 指向它的子节点‘八’，同时 position 前进一位。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B6.png" alt="指针匹配过程6"></p>
<p>继续把 position 指向的字符 与tempNode 的所有子节点进行匹配，匹配失败。说明以begin起头的不存在非法字符，可以加入到结果集中。 此时 begin 向前走一位，position 回退到 begin 的位置，同时 tempNode 回退到根节点。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B7.png" alt="指针匹配过程7"></p>
<p>同理，可以发现子’子’不匹配，则直接把它加入结果集，同时position 和 begin 向前走一位，tempNode 指向根节点。</p>
<p>此时 position 指向 ‘大’，与 tempNode 的所有子节点进行匹配，匹配成功，则 position 和 tempNode 都走一位，循环执行….</p>
<p>直到 position 指向‘子’，tempNode指向‘蹄’（图中begin指针应该指向‘大’）</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B8.png" alt="指针匹配过程8"></p>
<p>此时把 position 与 tempNode 的所有子节点进行匹配，匹配成功，tempNode 指向它的子节点‘子’，此时检查发现tempNode是敏感词树的叶子节点，说明从 begin 开始的位置到 position 这段是敏感词，用和谐词替换掉。替换之后 position 前进一位，begin 跳到 position 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B9.png" alt="指针匹配过程9"></p>
<h2 id="算法代码实现"><a href="#算法代码实现" class="headerlink" title="算法代码实现"></a>算法代码实现</h2><p>前缀树结构：</p>
<pre><code class="java">private class TreeNode{

    //是否最后一个字
    private boolean isKeyWordsEnd = false;

    //子节点
    private Map&lt;Character,TreeNode&gt; subNodes = new HashMap&lt;&gt;();

    public void addSubNode(Character key, TreeNode node){
        subNodes.put(key,node);
    }

    public TreeNode getSubNode(Character key){
        return subNodes.get(key);
    }

    public boolean isKeyWordsEnd(){
        return isKeyWordsEnd;
    }

    public void setKeyWordsEnd(Boolean end){
        isKeyWordsEnd = end;
    }
}</code></pre>
<p>构建前缀树的方法:</p>
<pre><code class="java">public void addSensitiveWord(String words){

    TreeNode tempNode = rootNode;

    for(int i = 0;  i &lt; words.length(); i++){

        Character c = words.charAt(i);
        if(!isSymbol(c)){
            continue;
        }

        TreeNode node = tempNode.getSubNode(c);
        if (node == null){
            node = new TreeNode();
            tempNode.addSubNode(c,node);
        }
        // 指针移动
        tempNode = node;

        //如果到了最后一个字符
        if(i == words.length() -1){
            tempNode.setKeyWordsEnd(true);
        }
    }
}</code></pre>
<p>算法具体实现：</p>
<pre><code class="java">public String filter(String text){

    if (StringUtils.isEmpty(text)){
        return text;
    }

    String sensitiveWords = &quot;***&quot;;
    StringBuilder result = new StringBuilder();

    TreeNode tempNode = rootNode;
    int begin = 0;
    int position = 0;

    while (position &lt; text.length()){

        Character c = text.charAt(position);

        //如果非匹配字符，则直接跳过
        if(!isSymbol(c)){ //每次
            if(tempNode == rootNode){
                result.append(c);
                begin++;
            }
            position++;
            continue;
        }

        tempNode = tempNode.getSubNode(c);

        //如果匹配失败
        if(tempNode == null) {
            //说明以begin起头的那一段不存在非法词汇
            result.append(text.charAt(begin));
            begin++;
            position = begin;
            tempNode = rootNode;
            continue;

        } else if(tempNode.isKeyWordsEnd()){
            //替换敏感词
            result.append(sensitiveWords);
            position++;
            begin = position;
            tempNode = rootNode;
        } else if(position &gt; text.length() &amp;&amp; (begin+1) &lt; text.length()) {
                /** 
                 * 防止出现有相同后缀的敏感词汇
                 * 如fabcd，abc，当字符串最后fabc, 此时指begin指f, 
                 * 指position指到c, 根据循环中的判断c的isKeywordsEnd为true, 
                 * position++, 此时跳出循环, 然后将fabc加到StringBuilder中, 
                 * 但是abc这个敏感词没有被过滤掉
                 */
                begin = begin +1;
                position = begin;
                tempNode = rootNode;
                continue;
        } else {
            position++;
        }       
    }   
    result.append(text.substring(begin)); //把剩下的动加入合法集

    return result.toString();
}</code></pre>
<h2 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h2><p>如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p>
<h1 id="22-给定已有硬币面值，计算需要的最少硬币数目？"><a href="#22-给定已有硬币面值，计算需要的最少硬币数目？" class="headerlink" title="22. 给定已有硬币面值，计算需要的最少硬币数目？"></a>22. 给定已有硬币面值，计算需要的最少硬币数目？</h1><p>使用动态规划的思想解决：</p>
<p><a href="https://xiaoming.net.cn/2019/11/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" target="_blank" rel="noopener">详情看这里</a></p>
<h1 id="23-动态规划01背包问题"><a href="#23-动态规划01背包问题" class="headerlink" title="23. 动态规划01背包问题"></a>23. 动态规划01背包问题</h1><p>假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。</p>
<p>状态：<code>maxValue[i][j]</code>表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>状态转移方程：<code>maxValue[i][j] = max{maxValue[i-1][j],maxValue[i-1][j-w[i]]+P[i]}</code>，其中 <code>w[i]</code> 表示第 i 颗宝石的重量，<code>P[i]</code> 表示第 i 颗宝石的价值。</p>
<p>物理意义：<code>当前背包能装入的最大价值为只有 i-1 个宝石时背包能装入的最大价值</code> 和 <code>腾出第 i 颗宝石重量后剩余背包容量装入 i-1 个宝石的最大价值加上装入第 i 颗宝石价值</code> 的较大值.</p>
<pre><code class="java">public class KnapsackProblem {

    /**
     * @param w 每一个宝石的重量
     * @param v 每一个宝石的价值
     * @param capacity 背包的容量
     */
    public static void solution(int[] w,int[] v,int capacity) {
        //maxValue[i][j]表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值
        int[][] maxValue = new int[w.length][capacity]; 
        //初始化
        for(int j = 0; j &lt; capacity; j++) {
            maxValue[0][j] = 0; //没有宝石时价值为0
        }
        for(int i = 0; i &lt; w.length; i++) {
            maxValue[i][0] = 0; //容量为0时价值为0
        }

        for(int i = 1; i &lt; w.length; i++) { //从有1个宝石算起
            for(int j = 1; j &lt; capacity; j++) { //从容量为1算起
                if(w[i] &lt; j) {
                    maxValue[i][j] = Math.max(maxValue[i-1][j],maxValue[i-1][j-w[i]] + v[i]);
                } else {
                    //无法承载此颗宝石重量
                    maxVlue[i][j] = maxValue[i-1][j];
                }
            }
        }
    }
    //打印结果
    for(int i=0;i&lt;6;i++) {
        for(int j=0;j&lt;9;j++) {
            System.out.printf(&quot;%-5d&quot;,temp[i][j]);
        }
        System.out.println();
    }
}</code></pre>
<h1 id="24-最长不重复子串"><a href="#24-最长不重复子串" class="headerlink" title="24. 最长不重复子串"></a>24. 最长不重复子串</h1><blockquote>
<p>LeeCode：给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
</blockquote>
<p>思路：采用窗口滑动思想，利用 HashMap，其中 key 存储字符，value 存储当前字符的下一个位置。窗口（i，j）从左往右扫描，当 key 不重复时，j+1，继续往右扫描；当出现 key 重复时，i 跳过 key 字符第一次出现的位置到它的下一个位置，而长度就是 j-i+1 的长度。</p>
<pre><code class="java">public  int lengthOfLongestSubstring03(String s) {
    int n = s.length(), ans = 0;
    //创建map窗口,i为左区间，j为右区间，右边界移动
    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    for (int j = 0, i = 0; j &lt; n; j++) {
        // 如果窗口中包含当前字符，
        if (map.containsKey(s.charAt(j))) {
            //左边界移动到 相同字符的下一个位置和i当前位置中更靠右的位置，这样是为了防止i向左移动
            i = Math.max(map.get(s.charAt(j)), i);
        }
        //比对当前无重复字段长度和储存的长度，选最大值并替换
        //j-i+1是因为此时i,j索引仍处于不重复的位置，j还没有向后移动，取的[i,j]长度
        ans = Math.max(ans, j - i + 1);
        // 将当前字符为key，下一个索引为value放入map中
        // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了
        map.put(s.charAt(j), j+1);
    }
    return ans;
}</code></pre>
<h1 id="25-数据求交集"><a href="#25-数据求交集" class="headerlink" title="25. 数据求交集"></a>25. 数据求交集</h1><blockquote>
<p>LeeCode: 给定两个数组，编写一个函数来计算它们的交集。</p>
</blockquote>
<pre><code class="java">class Solution {

  public int[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) {
    int [] output = new int[set1.size()];
    int idx = 0;
    for (Integer s : set1)
      if (set2.contains(s)) output[idx++] = s;

    return Arrays.copyOf(output, idx);
  }

  public int[] intersection(int[] nums1, int[] nums2) {
    HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;();
    for (Integer n : nums1) set1.add(n);
    HashSet&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;();
    for (Integer n : nums2) set2.add(n);

    if (set1.size() &lt; set2.size()) return set_intersection(set1, set2);
    else return set_intersection(set2, set1);
  }
}</code></pre>
<p>也可以使用<code>retainAll</code>函数：</p>
<pre><code class="java">class Solution {
  public int[] intersection(int[] nums1, int[] nums2) {
    HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;();
    for (Integer n : nums1) set1.add(n);
    HashSet&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;();
    for (Integer n : nums2) set2.add(n);

    set1.retainAll(set2);

    int [] output = new int[set1.size()];
    int idx = 0;
    for (int s : set1) output[idx++] = s;
    return output;
  }
}</code></pre>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(m+n)O(m+n)，其中 n 和 m 是数组的长度。O(n)O(n) 的时间用于转换 nums1 在集合中，O(m)O(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 O(1)O(1)。</li>
<li>空间复杂度：O(m+n)O(m+n)，最坏的情况是数组中的所有元素都不同。</li>
</ul>
<h1 id="26-如何判断单链表是否有环？如何确定环的入口？"><a href="#26-如何判断单链表是否有环？如何确定环的入口？" class="headerlink" title="26. 如何判断单链表是否有环？如何确定环的入口？"></a>26. 如何判断单链表是否有环？如何确定环的入口？</h1><h2 id="方法一：hash-表"><a href="#方法一：hash-表" class="headerlink" title="方法一：hash 表"></a>方法一：hash 表</h2><pre><code class="java">public class Solution {
    public boolean hasCycle(ListNode head) {
        Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();
        ListNode node = head;
        while(node != null) {
            if(set.contains(node)) {
                return true;
                //对于需要返回节点的，直接返回这个node
                //即 return node;
            } else {
                set.add(node);
                node = node.next;
            }
        }
        return false;
        //这里相应改成return null;
    }
}</code></pre>
<ul>
<li>时间复杂度：<code>O(n)</code>，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 <code>O(1)</code> 的时间。</li>
<li>空间复杂度：<code>O(n)</code>，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</li>
</ul>
<h2 id="方法二：双指针（快慢指针）"><a href="#方法二：双指针（快慢指针）" class="headerlink" title="方法二：双指针（快慢指针）"></a>方法二：双指针（快慢指针）</h2><p>如果存在循环，快指针会再次追上慢指针，没有说明不存在环形链表；如果需要返回入口节点，则将两个指针一个指向头节点，一个指向相遇点，然后分别向前走直到相遇，该点就是入口点。</p>
<p>理解如下：</p>
<ol>
<li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li>
<li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li>
<li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li>
<li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li>
<li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li>
<li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li>
<li>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</li>
</ol>
<pre><code class="java">/**
 * 不需要求入口
 */
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
/**
 * 求入口
 */
public class Solution {

    private ListNode getIntersect(ListNode head) {
        ListNode tortoise = head;
        ListNode hare = head;

        while (hare != null &amp;&amp; hare.next != null) {
            tortoise = tortoise.next;
            hare = hare.next.next;
            if (tortoise == hare) {
                return tortoise;
            }
        }

        return null;
}

    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        ListNode intersect = getIntersect(head);
        if (intersect == null) {
            return null;
        }

        ListNode ptr1 = head;
        ListNode ptr2 = intersect;
        while (ptr1 != ptr2) {
            ptr1 = ptr1.next;
            ptr2 = ptr2.next;
        }
        return ptr1;
    }
}</code></pre>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。</li>
</ul>
<h1 id="27-找两条链表公共节点"><a href="#27-找两条链表公共节点" class="headerlink" title="27. 找两条链表公共节点"></a>27. 找两条链表公共节点</h1><blockquote>
<p>Leecode:编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p>使用双指针法：</p>
<ul>
<li>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</li>
<li>当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li>
<li>若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。</li>
<li>想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。</li>
<li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/Bp 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</li>
</ul>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 : O(m+n)O(m+n)。</li>
<li>空间复杂度 : O(1)O(1)。</li>
</ul>
<pre><code class="java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA;
        ListNode pB = headB;
        while (pA != pB) {
            pA = pA.next;
            pB = pB.next;
            if (pA == null &amp;&amp; pB == null) {
                return null;
            }
            if (pA == null) {
                pA = headB;
            }
            if (pB == null) {
                pB = headA;
            }
        }
        return pA;
    }
}</code></pre>
<h1 id="28-100G-的文件，只有-100M-内存，对文件进行排序"><a href="#28-100G-的文件，只有-100M-内存，对文件进行排序" class="headerlink" title="28. 100G 的文件，只有 100M 内存，对文件进行排序"></a>28. 100G 的文件，只有 100M 内存，对文件进行排序</h1><h2 id="外部排序-多路归并"><a href="#外部排序-多路归并" class="headerlink" title="外部排序 + 多路归并"></a>外部排序 + 多路归并</h2><p><img src="http://qiniu.xiaoming.net.cn/%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F.jpeg" alt="大文件排序"></p>
<p>100G 数据，按照 100M 内存拆分，然后排序成有序的数据，然后写入到 file1,file2…file100。</p>
<p>之后进行多路归并排序：</p>
<ol>
<li><p>从 file1,file2,file3，…，file100 取出第一个数，即最大或者最小的，所有的初始指针都是第一行。</p>
<pre><code>min1 = min(fil1,file2,file3, … ,file100)；</code></pre></li>
<li><p>min1 写入到大数据文件,大数据行数指针 + 1,min1 对应的行数指针 +1。</p>
</li>
<li><p>从对应的行指针取出第二个数进行对比，继续归并</p>
</li>
</ol>
<h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><p>前提是内存容得下这么大的位图。每读一个数，相应的位图位置标 1，如果又重复数，可以建一个数组相应的 count++，遍历完文件之后对对应位置为 1 的输出下标。</p>
<h1 id="29-100亿个整型数据，乱序，100M内存，求中位数"><a href="#29-100亿个整型数据，乱序，100M内存，求中位数" class="headerlink" title="29. 100亿个整型数据，乱序，100M内存，求中位数"></a>29. 100亿个整型数据，乱序，100M内存，求中位数</h1><p>这里认为是带符号的int,所以4字节，占32位。</p>
<p>假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入    <code>file_0</code> 文件中；如果最高位为 1，则将该数字写入 <code>file_1</code> 文件中。</p>
<p>从而将 100 亿个数字分成了两个文件，假设 <code>file_0</code> 文件中有 60亿 个数字，<code>file_1</code> 文件中有 40 亿个数字。那么中位数就在 <code>file_0</code> 文件中，并且是 <code>file_0</code> 文件中所有数字排序之后的第 10 亿个数字。（<code>file_1</code> 中的数都是负数，<code>file_0</code> 中的数都是正数，也即这里一共只有 40 亿个负数，那么排序之后的第 50 亿个数一定位于 <code>file_0</code> 中）</p>
<p>现在，只需要处理 <code>file_0</code> 文件了（不需要再考虑 <code>file_1</code> 文件）。对于 <code>file_0</code> 文件，同样采取上面的措施处理：将 <code>file_0</code> 文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的次高位（第31位），如果数字的次高位为 0，写入 <code>file_0_0</code> 文件中；如果次高位为1，写入<code>file_0_1</code> 文件中。</p>
<p>现假设 <code>file_0_0</code> 文件中有30亿个数字，<code>file_0_1</code> 中也有30亿个数字，则中位数就是：<code>file_0_0</code> 文件中的数字从小到大排序之后的第 10 亿个数字。</p>
<p>抛弃 <code>file_0_1</code> 文件，继续对 <code>file_0_0</code> 文件 根据次次高位(第30位) 划分，假设此次划分的两个文件为：<code>file_0_0_0</code> 中有5亿个数字，<code>file_0_0_1</code> 中有25亿个数字，那么中位数就是 <code>file_0_0_1</code> 文件中的所有数字排序之后的第 5 亿个数。</p>
<p>以此类推，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p>
<h1 id="30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><a href="#30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199" class="headerlink" title="30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"></a>30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</h1><pre><code class="java">public class MaximumProduct {

    /**
     * 求出最大乘积是多少
     * @param number
     * @return
     */
    private int getMaximumProduct(int number) {
        if(number == 0){
            return 1;
        } else if(number &lt; 10) {
            return number;
        } else {
           return Math.max(getMaximumProduct(number / 10) * (number % 10),getMaximumProduct(number / 10 -1) * 9);
        }
    }

    private int solve(int number) {

        //用于存储每一位数
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        int result = 0;

        while (number &gt; 0){
            //获取除个位数以外的部分
            int n = number/10;
            //个位数取9时，高位部分减1
            int m = number/10-1;
            //比较个位数取 9 和按原数计算哪个数乘积比较大
            if(getMaximumProduct(n) * (number%10) &lt; getMaximumProduct(m) * 9) {
                //个位数取9比较大，存入数组，相应的把number变为高位部分，继续比较
                number = m;
                list.add(9);
            } else {
                //原数大，则存入数组，相应把number变为高位部分，继续比较
                list.add(number%10);
                number = n;
            }
        }
        int size = list.size();
        for (int i = size-1; i &gt;= 0; i--) {
            result = result * 10 + list.get(i);
        }
        return result;
    }
}</code></pre>
<h1 id="31-二叉树中和为某一值的路径"><a href="#31-二叉树中和为某一值的路径" class="headerlink" title="31. 二叉树中和为某一值的路径"></a>31. 二叉树中和为某一值的路径</h1><blockquote>
<p>Leecode:输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
</blockquote>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //存储结果集
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    //存储每一条路径
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
        recur(root,sum);
        return result;
    }

    private void recur(TreeNode root,int sum) {
        if(root == null) {
            return;
        }
        sum -= root.val;
        path.add(root.val);
        //当左右子树都为空说明已经到了叶子结点，如果 sum 已经减为 0，说明该路径可以，加入结果集
        if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0) {
            //需要拷贝路径加入，直接加入的话后续path一变会导致结果集的数据跟着改变
            result.add(new ArrayList&lt;&gt;(path));
        }
        //递归左子节点
        recur(root.left,sum);
        //递归右子节点
        recur(root.right,sum);
        //路径恢复，向上回溯前，需要将当前节点从路径 path 中删除
        path.remove(path.size()-1);
    }
}</code></pre>
<ul>
<li>时间复杂度 O(N)：N 为二叉树的节点数，先序遍历需要遍历所有节点。</li>
<li>空间复杂度 O(N)：最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。</li>
</ul>
<h1 id="32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除"><a href="#32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除" class="headerlink" title="32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除"></a>32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除</h1><pre><code class="java">public class Solution {

    public static String solution(String a,String b) {
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; b.length(); i++) {
            set.add(b.charAt(i));
        }
        for (int i = 0; i &lt; a.length(); i++) {
            char c = a.charAt(i);
            if(!set.contains(c)) {
                builder.append(c);
            }
        }
        return builder.toString();
    }
}</code></pre>
<h1 id="33-二叉搜索树转双向链表"><a href="#33-二叉搜索树转双向链表" class="headerlink" title="33. 二叉搜索树转双向链表"></a>33. 二叉搜索树转双向链表</h1><blockquote>
<p>Leecode:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
</blockquote>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpeg" alt="二叉搜索树转双向链表"></p>
<p>递归方式：改写中序遍历，遍历过程中使用一全局变量 pre 存储其前一个结点,当遍历该结点时，只需该节点的前驱(left)指向pre，pre的后继指向该节点。对于头结点应特殊处理。</p>
<pre><code class="java">private TreeNode pre = null;
private TreeNode head = null;

public TreeNode Convert(TreeNode root) {
    inOrder(root);
    return head;
}

private void inOrder(TreeNode node) {
    if (node == null)
        return;
    inOrder(node.left);
    node.left = pre;
    if (pre != null)
        pre.right = node;
    pre = node;
    if (head == null)
        head = node;
    inOrder(node.right);
}</code></pre>
<p>非递归版本：</p>
<pre><code class="java">    public Node treeToDoublyList(Node root) {
        if(root == null){
            return null;
        }
         Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
         Node current = root;
         Node pre = null, head = null, tail = null;
         while(!stack.isEmpty() || current != null) {
             while(current != null) {
                 stack.push(current);
                 current = current.left;
             }
             current = stack.pop();
             tail = current;
             if(pre == null) {//处理头结点
                 head = current;
             }else {
                 pre.right = current;
                 current.left = pre;
             }
            pre = current;
            current = current.right;
         }
         tail.right = head;
         head.left = tail;
         return head;
    }</code></pre>
<h1 id="34-有序链表转换二叉搜索树"><a href="#34-有序链表转换二叉搜索树" class="headerlink" title="34. 有序链表转换二叉搜索树"></a>34. 有序链表转换二叉搜索树</h1><blockquote>
<p>Leecode:给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
</blockquote>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<pre><code>给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5</code></pre><p>解题思路：给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。</p>
<ol>
<li>由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。</li>
<li>我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 <code>slow_ptr</code> 和 <code>fast_ptr</code>。<code>slow_ptr</code> 每次向后移动一个节点而 <code>fast_ptr</code> 每次移动两个节点。当 <code>fast_ptr</code> 到链表的末尾时 <code>slow_ptr</code> 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。</li>
<li>当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 <code>prev_ptr</code> 的指针记录 <code>slow_ptr</code> 之前的元素，也就是满足 <code>prev_ptr.next = slow_ptr</code>。断开左侧部分就是让 <code>prev_ptr.next = None</code>。</li>
<li>我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 <code>slow_ptr.next</code> 作为头指针。</li>
</ol>
<pre><code class="java">class Solution {

  private ListNode findMiddleElement(ListNode head) {

    // The pointer used to disconnect the left half from the mid node.
    ListNode prevPtr = null;
    ListNode slowPtr = head;
    ListNode fastPtr = head;

    // Iterate until fastPr doesn&#39;t reach the end of the linked list.
    while (fastPtr != null &amp;&amp; fastPtr.next != null) {
      prevPtr = slowPtr;
      slowPtr = slowPtr.next;
      fastPtr = fastPtr.next.next;
    }

    // Handling the case when slowPtr was equal to head.
    if (prevPtr != null) {
      prevPtr.next = null;
    }

    return slowPtr;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // If the head doesn&#39;t exist, then the linked list is empty
    if (head == null) {
      return null;
    }

    // Find the middle element for the list.
    ListNode mid = this.findMiddleElement(head);

    // The mid becomes the root of the BST.
    TreeNode node = new TreeNode(mid.val);

    // Base case when there is just one element in the linked list
    if (head == mid) {
      return node;
    }

    // Recursively form balanced BSTs using the left and right halves of the original list.
    node.left = this.sortedListToBST(head);
    node.right = this.sortedListToBST(mid.next);
    return node;
  }
}</code></pre>
<h1 id="35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"><a href="#35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？" class="headerlink" title="35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"></a>35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？</h1><p>在二叉树中有关系：度为0的结点个数 = 度为2的结点个数 + 1，表示为：n0 = n2 +1；<br>因为度为1的结点只可能出现在最后一个结点，或者根本就不存在度为1的结点。<br>假设:存在度为1的结点；<br>n0 + n2 + 1 = 1699，解其可得，n0 与 n2 都不为整数，这与事实不符，所以可以得出，不存在度数为1的点(虽然计算得出是的确不存在，但并不是一定不存在)<br>所以可得度为1的结点是不存在的；<br>即：n0 + n2 = 1699，解 n0 = 850</p>
<h1 id="36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径"><a href="#36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径" class="headerlink" title="36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径"></a>36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径</h1><blockquote>
<p>Leecode：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物（网格中的障碍物和空位置分别用 1 和 0 来表示，1 代表障碍物）。那么从左上角到右下角将会有多少条不同的路径？</p>
</blockquote>
<p>解题思路：动态规划的思想，到达一个格子可以从上方到达，也可以从左边到达，所以分别计算上方和左侧两个格子的到达数相加就是当前格子的路径数。具体如下：</p>
<p>如果格子上有障碍，那么不考虑包含这个格子的任何路径。从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个动态规划问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 <code>DP</code> 数组。</p>
<p>注意： 根据题目描述，包含障碍物的格点有权值 1，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p>
<p>算法思路如下：</p>
<ol>
<li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</li>
<li>否则，如果 <code>obstacleGrid[0,0]</code> 是 0，我们初始化这个值为 1 然后继续算法。</li>
<li>遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j]</code> = <code>obstacleGrid[i,j-1]</code>。</li>
<li>遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li>
<li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li>
<li>如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</li>
</ol>
<pre><code class="java">class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

        int R = obstacleGrid.length;
        int C = obstacleGrid[0].length;

        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        obstacleGrid[0][0] = 1;

        //遍历第一列
        for (int i = 1; i &lt; R; i++) {
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 &amp;&amp; obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }

        //遍历第一行
        for (int i = 1; i &lt; C; i++) {
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 &amp;&amp; obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }

        for (int i = 1; i &lt; R; i++) {
            for (int j = 1; j &lt; C; j++) {
                if (obstacleGrid[i][j] == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                } else {
                    obstacleGrid[i][j] = 0;
                }
            }
        }

        //返回最后一格的值
        return obstacleGrid[R - 1][C - 1];
    }
}</code></pre>
<ul>
<li>时间复杂度 ： O(M×N) 。长方形网格的大小是 M×N，而访问每个格点恰好一次。</li>
<li>空间复杂度 ： O(1)。我们利用 obstacleGrid 作为 DP 数组，因此不需要额外的空间</li>
</ul>
<h1 id="37-二叉树的最近公共祖先"><a href="#37-二叉树的最近公共祖先" class="headerlink" title="37. 二叉树的最近公共祖先"></a>37. 二叉树的最近公共祖先</h1><blockquote>
<p>Leecode:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
</blockquote>
<p>解题思路：</p>
<p>递归，这种方法非常直观。先深度遍历改树。当遇到节点 p 或 q 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最近的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是p或q中的一个，对于这个节点,子树递归返回一个真标志。</p>
<p>让我们看看基于这个想法的形式算法。</p>
<p>算法：</p>
<ol>
<li>从根节点开始遍历树。</li>
<li>如果当前节点本身是 p 或 q 中的一个，我们会将变量 mid 标记为 true，并继续搜索左右分支中的另一个节点。</li>
<li>如果左分支或右分支中的任何一个返回 true，则表示在下面找到了两个节点中的一个。</li>
<li>如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 true，这意味着我们找到了节点 p 和 q 的最近公共祖先。</li>
</ol>
<pre><code class="java">class Solution {

    private TreeNode ans;

    public Solution() {
        this.ans = null;
    }

    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {

        if (currentNode == null) {
            return false;
        }

        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;
        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;
        int mid = (currentNode == p || currentNode == q) ? 1 : 0;


        if (mid + left + right &gt;= 2) {
            this.ans = currentNode;
        }

        return (mid + left + right &gt; 0);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.recurseTree(root, p, q);
        return this.ans;
    }
}</code></pre>
<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h1 id="38-分5个线程计算1-10000的和，要求全部计算完了再汇总"><a href="#38-分5个线程计算1-10000的和，要求全部计算完了再汇总" class="headerlink" title="38. 分5个线程计算1-10000的和，要求全部计算完了再汇总"></a>38. 分5个线程计算1-10000的和，要求全部计算完了再汇总</h1><pre><code class="java">import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Solution {
    public static void main(String[] args) {
        CountDownLatchApply countDownLatchApply = new CountDownLatchApply();
        long l1 = System.currentTimeMillis();
        countDownLatchApply.getTotal2();
        long l2 = System.currentTimeMillis();
        System.out.println(&quot;循环遍历:&quot; + (l2-l1));

        long l3 = System.currentTimeMillis();
        countDownLatchApply.getTotal();
        long l4 = System.currentTimeMillis();
        System.out.println(&quot;countDownLatch:&quot; + (l4-l3));
    }

    public void getTotal2() {
        int result = 0;
        for (int i = 1; i &lt;= 1000000; i++) {
                result += i;
        }
        System.out.println(&quot;循环遍历结果：&quot; + result);
    }

    public void getTotal() {
        final int totalCount = 5;
        CountDownLatch countDownLatch = new CountDownLatch(totalCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        int[] total = new int[5];
        int result = 0;
        for (int i = 0; i &lt; totalCount; i++) {
            int finalI = i;
            executorService.execute(()-&gt;{
                int sum = 0;
                for (int j = 1; j &lt;= 200000; j++) {
                    sum += (j + finalI*200000);
                }
                total[finalI] = sum;
                countDownLatch.countDown();
            });
        }
        try {
            countDownLatch.await(); //main线程会阻塞在这里
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 0; i &lt; 5; i++) {
            result += total[i];
        }
        System.out.println(&quot;countDownLatch结果：&quot; + result);
    }
}</code></pre>
<h1 id="39-1-N-这些数中1出现的次数"><a href="#39-1-N-这些数中1出现的次数" class="headerlink" title="39. 1-N 这些数中1出现的次数"></a>39. 1-N 这些数中1出现的次数</h1><blockquote>
<p>Leecode: 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
</blockquote>
<p>示例：</p>
<pre><code>输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</code></pre><h2 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h2><p>思路：</p>
<ol>
<li>将 i 从 1 遍历到 n：</li>
<li>将 i 转成字符串，数 ’1’ 的个数</li>
<li>将每个字符串里 ’1’ 的个数累加到变量 countr</li>
<li>返回 countr</li>
</ol>
<pre><code class="java">public int countDigitOne(int n) {
    int count = 0;
    for (int i = 0; i &lt;= n; i++) {
        String s1 = String.valueOf(i);
        int len1 = s1.length();
        String s2 = s1.replaceAll(&quot;1&quot;, &quot;&quot;);
        int len2 = s2.length();
        count += (len1 - len2);
    }
    return count;
}</code></pre>
<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(n*log10(n))：从 1 遍历到 n 每次遍历中，我们把整数转成字符串去数 ’1’ 的个数，这个过程会花费 m 的时间，其中 m 为字符串的长度，其最大值为 log10(n)。</li>
<li>空间复杂度：需要申请O(log10(n)) 个额外的空间来存储 countr 和整数转换成的字符串 str。</li>
</ul>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>下面的图列出了求个位数，十位数，百位数…的规则:</p>
<p><img src="http://qiniu.xiaoming.net.cn/Leecode%E6%B1%821%E4%B8%AA%E6%95%B0%E6%95%B0%E5%AD%A6%E5%8F%91%E5%88%86%E6%9E%90.png" alt="Leecode求1个数数学法原理"></p>
<p>由上图所示，可以观察到每 10 个数，个位上的 ’1’ 就会出现一次。同样的，每 100 个数，十位上的 ’1’ 就会出现一次。这个规律可以用 <code>(n/(i*10))*i</code> 公式来表示。</p>
<p>同时，如果十位上的数是 ’1’，那么最后 ’1’ 的数量要加上 x+1，其中 x 是个位上的数值。如果十位上的数大于 ’1’，那么十位上为 ’1’ 的所有的数都是符合要求的，这时候最后 ’1’ 的数量要加 10。</p>
<p>这个规律可以用公式 <code>min(max((n mod (i*10))−i+1,0),i)</code> 来表示。</p>
<p>来看一个例子，有一个数 n=1234。</p>
<p>个位上 ’1’ 的数量 = <code>1234/10 (对应 1,11,21,...1221) + min(4,1) (对应 1231) = 124</code></p>
<p>十位上 ’1’ 的数量 = <code>(1234/100)*10 (对应 10,11,12,...,110,111,...1919) + min(21, 10) (对应 1210,1211,...1219) = 130</code></p>
<p>百位上 ’1’ 的数量 = <code>(1234/1000)*100 (对应 100,101,102,...,199) + min(135, 100) (对应1100,1101...1199) = 200</code></p>
<p>千位上 ’1’ 的数量 = <code>(1234/10000)*10000 + min(235, 1000) (对应1000,1001,...1234) = 235</code></p>
<p>因此，总数 = 124+130+200+235 = 689。</p>
<p>算法实现：</p>
<ul>
<li>将 i 从 1 遍历到 n，每次遍历 i 扩大 10 倍：</li>
<li><code>(n/(i*10))*i</code> 表示 (i*10) 位上 ’1’ 的个数。</li>
<li><code>{min(max(({n mod (i*10)} )-i+1,0),i)}</code> 表示需要额外数的 (i*10) 位上 ’1’ 的个数。</li>
</ul>
<pre><code class="java">int countDigitOne(int n) {
    int count = 0;
    for (long i = 1; i &lt;= n; i *= 10) {
        long divider = i * 10;
        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0L), i);
    }
    return count;
}</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log10(n)),遍历的次数等于 n 转成字符串后字符串的长度，其值为 log10(n)。</li>
<li>空间复杂度：只需要 O(1) 的额外空间。</li>
</ul>
<h1 id="40-合并区间"><a href="#40-合并区间" class="headerlink" title="40. 合并区间"></a>40. 合并区间</h1><blockquote>
<p>Leecode：给出一个区间的集合，请合并所有重叠的区间</p>
</blockquote>
<pre><code>示例 1:
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><pre><code>示例 2:
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><p><strong>解题思路</strong>：</p>
<p>首先，我们将列表根据区间开始范围从小到大进行排序。然后，将第一个区间插入 merged 数组中，然后按顺序考虑之后的每个区间：如果当前区间的左端点在前一个区间的右端点之后，那么他们不会重合，可以直接将这个区间插入 merged 中；否则，他们重合，将当前区间的右端点更新为前一个区间的右端点 end 值和当前右端点值较大的一个，完成合并。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E5%9B%BE%E8%A7%A3.png" alt="合并区间图解"></p>
<p><strong>代码实现</strong></p>
<pre><code class="java">import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;

public class MergeInterval {

    public int[][] merge(int[][] intervals) {

        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() {
            @Override
            //从小到大排序
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });

        LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();
        for(int[] interval : intervals) {
            if(list.isEmpty() || list.getLast()[1] &lt; interval[0]) {
                list.add(interval);
            } else {
                list.getLast()[1]  = Math.max(list.getLast()[1],interval[1]);
            }
        }
        return list.toArray(new int[0][2]);
    }
}</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(nlogn)，除去 sort 的开销，只需要一次线性扫描，所以主要的时间开销是排序的 O(nlgn)</p>
</li>
<li><p>空间复杂度：O(1) (or O(n))，如果可以原地排序 intervals ，就不需要额外的存储空间；否则，就需要一个线性大小的空间去存储 intervals 的备份，来完成排序过程。</p>
</li>
</ul>
<h1 id="41-股票的最大利润"><a href="#41-股票的最大利润" class="headerlink" title="41. 股票的最大利润"></a>41. 股票的最大利润</h1><blockquote>
<p>Leecode：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
</blockquote>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>解题思路</strong>：</p>
<p>假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length == 0) {
            return 0;
        }
        int minPrice = prices[0];
        int maxProfit = 0;
        for(int i = 1; i &lt; prices.length; i++) {
            minPrice = Math.min(minPrice,prices[i]);
            maxProfit = Math.max(maxProfit,prices[i] - minPrice);
        }
        return maxProfit;
    }
}</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
</ul>
<h1 id="42-顺时针打印矩阵"><a href="#42-顺时针打印矩阵" class="headerlink" title="42. 顺时针打印矩阵"></a>42. 顺时针打印矩阵</h1><blockquote>
<p>Leetcode:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<p>示例 1：</p>
<pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]</code></pre><p>示例 2：</p>
<pre><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p><strong>解题思路</strong></p>
<ol>
<li><strong>空值处理</strong>： 当 <code>matrix</code> 为空时，直接返回空列表 <code>[]</code> 即可。</li>
<li><strong>初始化</strong>： 矩阵 左、右、上、下 四个边界 <code>l</code> ,<code>r</code> ,<code>t</code> ,<code>b</code> ，用于打印的结果列表 <code>res</code> 。</li>
<li><strong>循环打印</strong>： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；</li>
</ol>
<ul>
<li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li>
<li>边界向内收缩 1 （代表已被打印）；</li>
<li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li>
</ul>
<ol start="4">
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">打印方向</th>
<th>1. 根据边界打印</th>
<th>2. 边界向内收缩</th>
<th>3. 是否打印完毕</th>
</tr>
</thead>
<tbody><tr>
<td align="left">从左向右</td>
<td>左边界 <code>l</code> ，右边界 <code>r</code></td>
<td>上边界 <code>t</code> 加 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从上向下</td>
<td>上边界 <code>t</code> ，下边界 <code>b</code></td>
<td>右边界 <code>r</code> 减 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
<tr>
<td align="left">从右向左</td>
<td>右边界 <code>r</code> ，左边界 <code>l</code></td>
<td>下边界 <code>b</code> 减 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从下向上</td>
<td>下边界 <code>b</code> ，上边界 <code>t</code></td>
<td>左边界 l 加 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
</tbody></table>
<pre><code class="java">package com.xm.algorithm;

public class SpiralOrder {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0 || matrix == null) {
            return new int[0];
        }
        //左边界
        int l = 0;
        //右边界
        int r = matrix[0].length-1;
        //上边界
        int t = 0;
        //下边界
        int b = matrix.length-1;
        //输出结果集
        int[] result = new int[(r+1) * (b+1)];
        int x = 0;

        while(true) {
            //从左到右遍历
            for (int i = l; i &lt;= r; i++) {
                result[x++] = matrix[t][i];
            }
            if(++t &gt; b) {
                break;
            }
            //从上到下遍历
            for (int i = t; i &lt;= b; i++) {
                result[x++] = matrix[i][r];
            }
            if(--r &lt; l) {
                break;
            }
            //从右往左遍历
            for (int i = r; i &gt;= l; i--) {
                result[x++] = matrix[b][i];
            }
            if(--b &lt; t) {
                break;
            }
            //从下往上遍历
            for (int i = b; i &gt;= t; i--) {
                result[x++] = matrix[i][l];
            }
            if(++l &gt; r) {
                break;
            }
        }
        return result;
    }
}</code></pre>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 <code>O(MN)</code> ： M,N 分别为矩阵行数和列数。</li>
<li>空间复杂度 <code>O(1)</code> ： 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> 使用常数大小的额外空间（ <code>res</code> 为必须使用的空间）。</li>
</ul>
<h1 id="43-滑动窗口的最大值"><a href="#43-滑动窗口的最大值" class="headerlink" title="43. 滑动窗口的最大值"></a>43. 滑动窗口的最大值</h1><blockquote>
<p>Leecode：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
</blockquote>
<p>返回滑动窗口中的最大值。</p>
<p>示例：</p>
<pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>解题思路</strong>：</p>
<p>动态规划：算法的思想是将输入数组分割成有 k 个元素的块。若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p>
<p>开头元素为 i ，结尾元素为 j 的当前滑动窗口可能在一个块内，也可能在两个块中。</p>
<p>建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向左-&gt;右。<br>建立数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向右-&gt;左。</p>
<p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 i 到下标 j 的滑动窗口。 根据定义，<code>right[i]</code> 是左侧块内的最大元素， <code>left[j]</code> 是右侧块内的最大元素。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="滑动窗口的最大值"></p>
<p>算法流程如下：</p>
<ol>
<li>从左到右遍历数组，建立数组 left。</li>
<li>从右到左遍历数组，建立数组 right。</li>
<li>建立输出数组 <code>max(right[i], left[i + k - 1])，其中 i 取值范围为 (0, n - k + 1)</code>。</li>
</ol>
<pre><code class="java">class Solution {
  public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    if (n * k == 0) return new int[0];
    if (k == 1) return nums;

    int [] left = new int[n];
    left[0] = nums[0];
    int [] right = new int[n];
    right[n - 1] = nums[n - 1];
    for (int i = 1; i &lt; n; i++) {
      // from left to right
      if (i % k == 0) left[i] = nums[i];  // block_start
      else left[i] = Math.max(left[i - 1], nums[i]);

      // from right to left
      int j = n - i - 1;
      if ((j + 1) % k == 0) right[j] = nums[j];  // block_end
      else right[j] = Math.max(right[j + 1], nums[j]);
    }

    int [] output = new int[n - k + 1];
    for (int i = 0; i &lt; n - k + 1; i++)
      output[i] = Math.max(left[i + k - 1], right[i]);

    return output;
  }
}</code></pre>
<h1 id="44-从前序与中序遍历序列构造二叉树"><a href="#44-从前序与中序遍历序列构造二叉树" class="headerlink" title="44. 从前序与中序遍历序列构造二叉树"></a>44. 从前序与中序遍历序列构造二叉树</h1><blockquote>
<p>剑指offer第7题</p>
</blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意: 可以假设树中没有重复的元素。</p>
<p>例如，给出：</p>
<pre><code>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p>
<pre><code>        3
   / \
  9  20
    /  \
   15   7</code></pre><p><strong>解题思路</strong>：</p>
<p>根据前序遍历结果，首节点一定是根结点，在中序遍历中找到根结点，根节点左边的都是左子树，根结点右边的都是右子树。</p>
<p>另外，由于是遍历同一颗树，所以左子树和右子树的节点数量是相同的。利用这个关系，可以定义出如下边界：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="从前序和中序遍历序列构造二叉树"></p>
<p>接下来就只需要分别递归构建左右子树即可：</p>
<pre><code class="java">public class RebuildBinaryTree {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(inLen);
        // 构造中序遍历中根结点和下标的映射关系
        for (int i = 0; i &lt; inLen; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(preorder, 0, preLen - 1, 0, inLen - 1, map);
    }

    /**
     * 递归构建二叉树
     * @param preorder 前序遍历结果
     * @param preLeft 当前前序遍历根结点（当前遍历的最左边界）
     * @param preRight 当前前序遍历的最又边界
     * @param inLeft 当前中序遍历的最左边界
     * @param inRight 当前中序遍历的最右边界
     * @param map 存储根结点在中序遍历的映射关系
     * @return 二叉树
     */
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight,
                               int inLeft, int inRight, HashMap&lt;Integer, Integer&gt; map) {
        if (preLeft &gt; preRight || inLeft &gt; inRight) {
            return null;
        }
        TreeNode head = new TreeNode(preorder[preLeft]);
        Integer pIndex = map.get(preorder[preLeft]);
        head.left = buildTree(preorder, preLeft + 1, pIndex - inLeft + preLeft,
                inLeft, pIndex - 1, map);
        head.right = buildTree(preorder, pIndex - inLeft + preLeft + 1,
                preRight, pIndex + 1, inRight, map);
        return head;
    }
}

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }
}</code></pre>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：<code>O(n)</code>，其中 n 是树中的节点个数。</li>
<li>空间复杂度：<code>O(n)</code>，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 <code>h &lt; n</code>，所以（在最坏情况下）总空间复杂度为 <code>O(n)</code>。</li>
</ul>
<h1 id="45-矩阵中的路径"><a href="#45-矩阵中的路径" class="headerlink" title="45. 矩阵中的路径"></a>45. 矩阵中的路径</h1><blockquote>
<p>剑指 offer 12 题</p>
</blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<pre><code>[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</code></pre><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
输出：true</code></pre><p>示例 2：</p>
<pre><code>输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;
输出：false</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
</blockquote>
<h3 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h3><ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
<h3 id="算法剖析："><a href="#算法剖析：" class="headerlink" title="算法剖析："></a>算法剖析：</h3><ul>
<li><p><strong>递归参数：</strong> 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>
</li>
<li><p><strong>终止条件：</strong></p>
<ol>
<li><p><strong>返回 false：</strong> </p>
<p>① 行或列索引越界 <strong>或</strong> ② 当前矩阵元素与目标字符不同 <strong>或</strong> ③ 当前矩阵元素已访问过 <em>（③ 可合并至 ② ）</em> 。</p>
</li>
<li><p><strong>返回 true ：</strong> 字符串 <code>word</code> 已全部匹配，即 <code>k = len(word) - 1</code> 。</p>
</li>
</ol>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>标记当前矩阵元素：</strong> 将 <code>board[i][j]</code> 值暂存于变量 <code>tmp</code> ，并修改为字符 <code>&#39;/&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li><strong>搜索下一单元格：</strong> 朝当前元素的 <strong>上、下、左、右</strong> 四个方向开启下层递归，使用 <code>或</code> 连接 <em>（代表只需一条可行路径）</em> ，并记录结果至 <code>res</code> 。</li>
<li><strong>还原当前矩阵元素：</strong> 将 <code>tmp</code> 暂存值还原至 <code>board[i][j]</code> 元素。</li>
</ol>
</li>
<li><p><strong>回溯返回值：</strong> 返回 <code>res</code> ，代表是否搜索到目标字符串。</p>
</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt="剑指offer12题矩阵中的路径"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9B%9E%E6%BA%AF.png" alt="剑指offer12题矩阵中的路径回溯"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">public class WordSearchInMatrix {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        // 这里遍历了任意开始的位置
        for (int i = 0; i &lt; board.length; i++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                if (bfs(board, words, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean bfs(char[][] board, char[] words, int i, int j, int k) {
        //判断下标是否越界，值是否相等
        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length
                || board[i][j] != words[k]) {
            return false;
        }
        if (k == words.length - 1) {
            return true;
        }
        char temp = board[i][j];
        board[i][j] = &#39;/&#39;;
        //深度递归遍历（顺序为下、上、右、左）
        boolean res = bfs(board, words, i + 1, j, k + 1) || bfs(board, words, i - 1, j, k + 1)
                || bfs(board, words, i, j + 1, k + 1) || bfs(board, words, i, j - 1, k + 1);
        board[i][j] = temp;
        return res;
    }
}</code></pre>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://blog.csdn.net/CleverCode/article/details/81743736" target="_blank" rel="noopener">100G 数据，只有 100M 内存，怎么排序</a><br><a href="https://blog.csdn.net/u014106566/article/details/101224875" target="_blank" rel="noopener">求比n小的一个数，使其各位数的乘积最大</a><br><a href="https://www.nowcoder.com/discuss/383652?type=all&order=time&pos=&page=1" target="_blank" rel="noopener">牛客网——腾讯WXG后端一面面经</a><br><a href="https://blog.csdn.net/You_are_my_dream/article/details/55005158" target="_blank" rel="noopener">完全二叉树的叶子节点总数问题</a><br><a href="https://www.cnblogs.com/kubidemanong/p/10834993.html" target="_blank" rel="noopener">【面试被虐】说说游戏中的敏感词过滤是如何实现的？</a> </p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/11/08/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%20Spring/" title="JavaSpring"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: JavaSpring</span></a><a class="button is-default" href="/2019/10/28/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><span class="has-text-weight-semibold">下一页: 数据结构</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>&lt;a href=&quot;http://www.beian.miit.gov.cn/&quot;&gt;备案号&lt;/a&gt;</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>