

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="1. 字符串匹配KMP算法KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到O(m+n),而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。">
  <meta name="author" content="Silverming">
  <meta name="keywords" content="">
  
  <title>算法 - Silverming</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"54ebb03ad7ad5b762ac8ff7958df6d3f","google":"G-M2RT7SDT3L","gtag":"G-M2RT7SDT3L","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tFHjJkaAYKqH8BIXKnJVurUc-MdYXbMMI","app_key":"1qR5F7XyydYd5YJtIpMJBFmP","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Silverming</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-29 16:42" pubdate>
        2019年10月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      354
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年11月14日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="1-字符串匹配KMP算法"><a href="#1-字符串匹配KMP算法" class="headerlink" title="1. 字符串匹配KMP算法"></a>1. 字符串匹配KMP算法</h1><p>KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到<code>O(m+n)</code>,而空间复杂度也只有<code>O(m)</code>。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<a id="more"></a>

<p>算法思想大概如下：</p>
<p>有如下字符串：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP1.png" alt="KMP1"></p>
<p>当匹配到以下这种情况时，会出现空格和D不匹配，而前面六个字符”ABCDAB”是匹配的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP2.png" alt="KMP2"></p>
<p>此时可以将搜索项后移4格得到如下情况，然后再继续往下对比下一位：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP3.png" alt="KMP3"></p>
<p>在程序中，通过设置<strong>部分匹配表</strong>保存前面搜索的已知信息，部分匹配表主要用于保存匹配字符串的最长公共前后缀。</p>
<p>部分匹配值就是“前缀”和“后缀”的最长的共有元素的长度。以“ABCDABD”为例：</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>因此可以得出下表：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP4.png" alt="KMP4"></p>
<p>此时需要移动的位数 = 已匹配的字符数 - 对应的部分的匹配值</p>
<p>对于上面的情况：</p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP2.png" alt="KMP2"></p>
<p>查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<p>由于此时指针指向的是D位置，而并非前面的B位置，为了便于计算，可以将部分匹配值整体右移一位，之后在第0位补上值为-1。例如：</p>
<p><img src="http://qiniu.xiaoming.net.cn/KMP5" alt="KMP5"></p>
<p><img src="https://qiniu.xiaoming.net.cn/KMP6" alt="KMP6"></p>
<p>此时，若匹配到当前位置不符合，只需要将匹配位置移到当前匹配位置的匹配值代表的位置，如上面此时D的匹配值为2，则将搜索词中[2]的位置即A移到当前字符串下，同样相当于右移4位。若匹配值为-1，则从下一个位置开始从头开始匹配。</p>
<h2 id="部分匹配值的实现思路"><a href="#部分匹配值的实现思路" class="headerlink" title="部分匹配值的实现思路"></a>部分匹配值的实现思路</h2><p>对于第一个字符，其匹配值一定是0。之后每增加一位，则与已比较的最后一位的匹配值所指位置的字符比较，相同，则在上一个字符匹配值基础上+1；如果不匹配，则需要指向最后一位字符的前一个字符的匹配值的位置的字符，之后以此类推。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 部分匹配表的实现<br> * @pattern 需要被匹配到的字符串<br> * @prefix 部分匹配表<br> * @n pattern长度<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prefix_table</span><span class="hljs-params">(<span class="hljs-keyword">char</span> pattern[],<span class="hljs-keyword">int</span> prefix[],<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-comment">//指向当前字符串对比到的字符的匹配值</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n) &#123;<br>        <span class="hljs-keyword">if</span>(pattern[len] == pattern[i]) &#123;<br>            len++;<br>            prefix[i] = len;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>                len = prefix[len <span class="hljs-number">-1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prefix[i] = <span class="hljs-number">0</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>之后再将整体匹配表的值后移一位</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move_prefix_table</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prefix[],<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = n<span class="hljs-number">-1</span>;i &gt; <span class="hljs-number">0</span>;i--) &#123;<br>        prefix[i] = prefix[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp_search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-built_in">text</span>[],<span class="hljs-keyword">char</span> pattern[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(pattern);    <span class="hljs-comment">//需要匹配的字符串长度</span><br>    <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">text</span>);       <span class="hljs-comment">//待匹配字符串长度</span><br>    <span class="hljs-keyword">int</span>* prefix = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*n);<br>    <br>    <span class="hljs-comment">//获取匹配表</span><br>    prefix_table(pattern,prefix,n);<br>    move_prefix_table(prefix,n);<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;      <span class="hljs-comment">//当前text匹配到的位置</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;      <span class="hljs-comment">//当前pattern匹配到的位置</span><br>    <br>    <span class="hljs-keyword">while</span>(i &lt; m) &#123;<br>    <br>        <span class="hljs-comment">//搜索完成</span><br>        <span class="hljs-keyword">if</span>(j = n<span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">text</span>[i] == pattern[j]) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"已找到位置："</span> + (i-j));<br>            j = prefix[j];<span class="hljs-comment">//继续往后看看还有没有其他匹配项</span><br>        &#125;<br>    <br>        <span class="hljs-comment">//匹配成功</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">text</span>[i] == pattern[j]) &#123;<br>            i++;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = prefix[j];<br>            <span class="hljs-comment">//如果到了最开始还不匹配，那么往text的下一个位置从头开始匹配</span><br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>) &#123;<br>                i++;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成<code>%20</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaceSpaceSolution</span> </span>&#123;<br><br>    <span class="hljs-comment">//方法一：循环遍历替换</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = str.length();<br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">char</span> c = str.charAt(i);<br>            <span class="hljs-keyword">if</span>(String.valueOf(c).equals(<span class="hljs-string">" "</span>)) &#123;<br>                result.append(<span class="hljs-string">"%20"</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br><br>    <span class="hljs-comment">//方法二：使用接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceSpace2</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str.replaceAll(<span class="hljs-string">" "</span>,<span class="hljs-string">"%20"</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><blockquote>
<p>Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>方法1:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    String prefix = strs[<span class="hljs-number">0</span>];<span class="hljs-comment">//以第一个字符串先假设为最长前缀</span><br>    <span class="hljs-keyword">int</span> len = strs.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">//indexOf在找不到的时候返回-1，找到了返回位置</span><br>        <span class="hljs-keyword">while</span> (strs[i].indexOf(prefix) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//找不到或者找到的位置不是首位，将前缀去掉一个字符再比较</span><br>            prefix = prefix.substring(<span class="hljs-number">0</span>, prefix.length() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (prefix.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prefix;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>方法2:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestCommonPrefix2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>    <span class="hljs-comment">//将首个字符串逐列与后面的字符串比较</span><br>    <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length(); i++) &#123;<br>        <span class="hljs-keyword">char</span> c = strs[<span class="hljs-number">0</span>].charAt(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(i == strs[j].length() || c != strs[j].charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>方法3:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestCommonPrefix3</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>    <span class="hljs-comment">// 先利用Arrays.sort(strs)为数组排序，</span><br>    <span class="hljs-comment">// 排序后公共的前缀如果有，第一和最后一个肯定都包括了</span><br>    <span class="hljs-comment">// 再将数组第一个元素和最后一个元素的字符从前往后对比</span><br><br>    <span class="hljs-comment">//如果检查值不合法就返回空串</span><br>    <span class="hljs-keyword">if</span>(!checkStr(strs)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> len = strs.length;<br>    StringBuffer result = <span class="hljs-keyword">new</span> StringBuffer();<br>    Arrays.sort(strs);<br>    <span class="hljs-keyword">int</span> m = strs[<span class="hljs-number">0</span>].length();<br>    <span class="hljs-keyword">int</span> n = strs[len-<span class="hljs-number">1</span>].length();<br>    <span class="hljs-keyword">int</span> num = Math.min(m,n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-keyword">if</span>(strs[<span class="hljs-number">0</span>].charAt(i) == strs[len-<span class="hljs-number">1</span>].charAt(i)) &#123;<br>            result.append(strs[<span class="hljs-number">0</span>].charAt(i));<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result.toString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkStr</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(strs != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//遍历strs检查元素值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(strs[i] != <span class="hljs-keyword">null</span> &amp;&amp; strs[i].length() != <span class="hljs-number">0</span>) &#123;<br>                flag = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flag = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="4-最长回文串"><a href="#4-最长回文串" class="headerlink" title="4. 最长回文串"></a>4. 最长回文串</h1><blockquote>
<p>LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如”Aa”不能当做一个回文字符串。注 意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科</p>
</blockquote>
<p>构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li>字符出现次数为双数的组合+一个只出现一次的字符</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在 <code>hashset</code> 中，如果不在就加进去，如果在就让 <code>count++</code>，然后移除该字符,这样就能找到出现次数为双数的字符个数。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// char[] chars = s.toCharArray(); //可以考虑先将字符串转化为字符数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span>(!set.contains(c)) &#123;<br>                <span class="hljs-comment">//如果集合里不存在就将其加入到集合</span><br>                set.add(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果集合里已经有了，那么就将该元素删除</span><br>                <span class="hljs-comment">//count+1表示双数的字符个数</span><br>                set.remove(c);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果集合不为空，可以有一个作为最中间元素</span><br>        <span class="hljs-keyword">return</span> set.isEmpty()?count*<span class="hljs-number">2</span>:count*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5. 验证回文串"></a>5. 验证回文串</h1><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<figure class="highlight smalltalk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">"A man, a plan, a canal: Panama"</span><br>输出: <span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//从两边往中间遍历</span><br>        <span class="hljs-keyword">while</span>(l&lt; r) &#123;<br>            <span class="hljs-keyword">char</span> left = s.charAt(l);<br>            <span class="hljs-keyword">char</span> right = s.charAt(r);<br>            <span class="hljs-comment">//排除不是数字和字母的字符</span><br>            <span class="hljs-keyword">if</span>(!Character.isLetterOrDigit(left))&#123;<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!Character.isLetterOrDigit(right)) &#123;<br>                r--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>( Character.toLowerCase(left) != Character.toLowerCase(right)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="6-最长回文子串"><a href="#6-最长回文子串" class="headerlink" title="6. 最长回文子串"></a>6. 最长回文子串</h1><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">输入: <span class="hljs-string">"babad"</span><br>输出: <span class="hljs-string">"bab"</span><br>注意: <span class="hljs-string">"aba"</span>也是一个有效答案。<br></code></pre></div></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">输入: <span class="hljs-string">"cbbd"</span><br>输出: <span class="hljs-string">"bb"</span><br></code></pre></div></td></tr></table></figure>

<p>思路：遍历，以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpeg" alt="回文最大子字符串"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len;<span class="hljs-comment">//用于确定最长回文子串长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;<span class="hljs-comment">//用于指定从哪里开始</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <br>        <span class="hljs-keyword">if</span>(length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-comment">//对单数检索</span><br>            palindromeHelper(s,i,i);<br>            <span class="hljs-comment">//对双数检索</span><br>            palindromeHelper(s,i,i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(index,index+len);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">palindromeHelper</span><span class="hljs-params">(String s,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-comment">//分别往左，往右对比</span><br>        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; length &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>            l--;<br>            r++;<br>        &#125;<br>        <span class="hljs-comment">//如果长度比已经对比过的长，则进行替换</span><br>        <span class="hljs-keyword">if</span>(len &lt; r-l-<span class="hljs-number">1</span>) &#123;<br>            index = l+<span class="hljs-number">1</span>;<span class="hljs-comment">//因为l位置已经不同，所以起始位置是l+1</span><br>            len = r-l-<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="7-最长回文子序列"><a href="#7-最长回文子序列" class="headerlink" title="7. 最长回文子序列"></a>7. 最长回文子序列</h1><blockquote>
<p>LeetCode: 最长回文子序列 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 </p>
</blockquote>
<blockquote>
<p><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p><strong>解题思路</strong>：主要运用动态规划的思想</p>
<ul>
<li>状态：<code>f[i][j]</code> 表示 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符组成的子串中，最长的回文序列长度是多少。</li>
<li>转移方程：如果 <code>s</code> 第 <code>i</code> 个字符和第 <code>j</code> 个字符相同的话 <code>f[i][j] = f[i + 1][j - 1] + 2</code>;否则 <code>f[i][j] = max(f[i + 1][j], f[i][j - 1])</code></li>
<li>初始化：<code>f[i][i] = 1</code> 单个字符的最长回文序列是1</li>
<li>结果：<code>f[0][n-1]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len-<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-comment">//单个字符长度为1</span><br>            result[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++) &#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;<br>                    <span class="hljs-comment">//如果相同，则在原来序列数量的左右两边各加一个，所以加2</span><br>                    result[i][j] = result[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] +<span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不相同，则是当前位置到上一个位置的值，这个值可能是i这边，也可能是j一边的，取最大值。</span><br>                    result[i][j] = Math.max(result[i+<span class="hljs-number">1</span>][j],result[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>][len-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="8-括号匹配深度"><a href="#8-括号匹配深度" class="headerlink" title="8. 括号匹配深度"></a>8. 括号匹配深度</h1><figure class="highlight hsp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs hsp">输入描述:<br>输入包括一个合法的括号序列s,s长度<span class="hljs-keyword">length</span>(<span class="hljs-number">2</span> ≤ <span class="hljs-keyword">length</span> ≤ <span class="hljs-number">50</span>),序列中只包含<span class="hljs-string">'('</span>和<span class="hljs-string">')'</span>。<br><br>输出描述:<br>输出一个正整数,即这个序列的深度。<br></code></pre></div></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>(())<br><span class="hljs-section">输出:</span><br>2<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BracketMatchingDepth</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        <span class="hljs-keyword">int</span> i = maxDepth(s);<br>        System.out.println(<span class="hljs-string">"最大深度为："</span>+i);<br>        scanner.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>            <span class="hljs-keyword">switch</span> (s.charAt(i)) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:count++ ;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:count--;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//关键在这里需要记录下当前匹配的最大深度</span><br>            depth = Math.max(count, depth);<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="9-把数字字符串转换成整数"><a href="#9-把数字字符串转换成整数" class="headerlink" title="9. 把数字字符串转换成整数"></a>9. 把数字字符串转换成整数</h1><blockquote>
<p>剑指offer: 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrToInt</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">"-12312312"</span>;<br>        System.out.println(<span class="hljs-string">"使用库函数转换："</span> + Integer.valueOf(s));<br>        <span class="hljs-keyword">int</span> res = strToInt(s);<br>        System.out.println(<span class="hljs-string">"使用自己写的方法转换："</span> + res);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = str.length();<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于判断是否有符号位</span><br>        <span class="hljs-keyword">if</span>(chars[<span class="hljs-number">0</span>] == <span class="hljs-string">'+'</span>)<br>            flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chars[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>)<br>            flag = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//判断从哪一位开始，有符号就从第二个开始</span><br>        <span class="hljs-keyword">int</span> start = (flag == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start;i&lt;len;i++) &#123;<br>            <span class="hljs-keyword">if</span>(Character.isDigit(chars[i])) &#123;<br>                <span class="hljs-keyword">int</span> temp = chars[i] - <span class="hljs-string">'0'</span>;<br>                result = result*<span class="hljs-number">10</span>+temp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (flag==<span class="hljs-number">2</span>)? -result : result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="10-两数相加"><a href="#10-两数相加" class="headerlink" title="10. 两数相加"></a>10. 两数相加</h1><p>题目描述</p>
<blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
</blockquote>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddTwoNumber</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>            val = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  ListNode <span class="hljs-title">addTwoNumber</span><span class="hljs-params">(ListNode l1,ListNode l2)</span> </span>&#123;<br>        ListNode p = l1;<br>        ListNode q = l2;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于表示进位</span><br><br>        <span class="hljs-comment">//在这里先定义链表头，后面省去代码根据是不是第一次而创建头节点的问题</span><br>        ListNode headNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode curr = headNode;<br><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span> || q!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = (p != <span class="hljs-keyword">null</span>) ? p.val:<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> y = (q != <span class="hljs-keyword">null</span>) ? q.val:<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> sum = x+y+carry;<br>            curr.next = <span class="hljs-keyword">new</span> ListNode(sum%<span class="hljs-number">10</span>);<br>            carry = sum/<span class="hljs-number">10</span>;<span class="hljs-comment">//只可能为0或1</span><br>            curr = curr.next;<span class="hljs-comment">//往下继续</span><br>            <span class="hljs-keyword">if</span>(p.next != <span class="hljs-keyword">null</span>) p = p.next;<br>            <span class="hljs-keyword">if</span>(q.next != <span class="hljs-keyword">null</span>) q = q.next;<br>        &#125;<br><br>        <span class="hljs-comment">//最高位有进位</span><br>        <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>) &#123;<br>            curr.next = <span class="hljs-keyword">new</span> ListNode(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> headNode.next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="11-反转链表"><a href="#11-反转链表" class="headerlink" title="11. 反转链表"></a>11. 反转链表</h1><blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseList</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> data;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-keyword">int</span> data) &#123;<br>            <span class="hljs-keyword">this</span>.data = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode next = <span class="hljs-keyword">null</span>;<br>        ListNode pre = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//记录当前节点的下一个节点</span><br>            next = head.next;<br>            <span class="hljs-comment">//将当前节点的next域指向上一个节点</span><br>            head.next = pre;<br>            <span class="hljs-comment">//当前节点作为“上一个节点”以供下一个节点指明</span><br>            pre = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ListNode a = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode b = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        ListNode c = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        ListNode d = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        ListNode e = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        a.next = b;<br>        b.next = c;<br>        c.next = d;<br>        d.next = e;<br>        reverseList(a);<br>        <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(e.data);<br>            e = e.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="12-删除链表中倒数第k个节点"><a href="#12-删除链表中倒数第k个节点" class="headerlink" title="12. 删除链表中倒数第k个节点"></a>12. 删除链表中倒数第k个节点</h1><blockquote>
<p>Leetcode: 输入一个链表，删除该链表中倒数第k个结点，并且返回链表的头结点。</p>
</blockquote>
<p>分析：</p>
<p>链表中倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点，</p>
<p>首先两个节点/指针，一个节点 <code>node1</code> 先开始跑，当两者拉开距离 n 后，另一个节点 <code>node2</code> 开始跑，当 <code>node1</code> 跑到最后时，<code>node2</code> 所指的节点就是倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveNthFromEnd</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        ListNode node1 = dummy;<br>        ListNode node2 = dummy;<br>        <br>        <span class="hljs-keyword">while</span> (node1 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//node1先开始进入链表</span><br>            node1 = node1.next;<br>            <span class="hljs-comment">//当node1与node2的距离拉开n个距离时node2开始进入链表</span><br>            <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span> &amp;&amp; node1!=<span class="hljs-keyword">null</span>)&#123;<br>                node2 = node2.next;<br>            &#125;<br>            n--;<br>        &#125;<br>        <span class="hljs-comment">//当node1跑完时，node2的位置便是L-n，而倒数第n位的位置是L-n+1</span><br>        node2.next = node2.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="13-输出链表中倒数第k个节点"><a href="#13-输出链表中倒数第k个节点" class="headerlink" title="13. 输出链表中倒数第k个节点"></a>13. 输出链表中倒数第k个节点</h1><p>题目描述:</p>
<blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>问题分析</p>
<p>根据上一题的思路求解。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindKthToTail</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ListNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">findKthToTail</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || n&lt;=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode node1 = head;<br>        ListNode node2 = head;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于计算节点个数，判断是否超出范围</span><br>        <span class="hljs-keyword">int</span> index = n;<span class="hljs-comment">//记录n的值，用于后面做判断</span><br><br>        <span class="hljs-keyword">while</span>(node1 != <span class="hljs-keyword">null</span>) &#123;<br>            count++;<br>            node1 = node1.next;<br>            <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span> &amp;&amp; node1!=<span class="hljs-keyword">null</span>)&#123;<br>                node2 = node2.next;<br>            &#125;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&lt;index) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node2.next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="14-求斐波纳切数列的第n个数-爬楼梯"><a href="#14-求斐波纳切数列的第n个数-爬楼梯" class="headerlink" title="14. 求斐波纳切数列的第n个数/爬楼梯"></a>14. 求斐波纳切数列的第n个数/爬楼梯</h1><blockquote>
<p>Leecode:假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
</blockquote>
<p>分析：</p>
<p>动态规划思想，爬上最后一层楼梯可能是差一阶或两阶，即<code>f(N)=f(N-1)+f(N-2)</code>，此时数列变成”1 1 2 3 5 …”</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(N&lt;<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span> || N==<span class="hljs-number">2</span>) &#123;<br>          	<span class="hljs-comment">// 斐波那契数列</span><br>          	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>          	<span class="hljs-comment">// 爬楼梯</span><br>            <span class="hljs-keyword">return</span> N;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> f1 = <span class="hljs-number">1</span>;<br>      	<span class="hljs-comment">// 斐波那契数列</span><br>        <span class="hljs-keyword">int</span> f2 = <span class="hljs-number">1</span>;<br>      	<span class="hljs-comment">// 爬楼梯</span><br>      	<span class="hljs-keyword">int</span> f2 = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=N;i++) &#123;<br>            result = f1 +f2;<br>            f1 = f2;<br>            f2 = result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="15-变态台阶问题"><a href="#15-变态台阶问题" class="headerlink" title="15. 变态台阶问题"></a>15. 变态台阶问题</h1><p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>假设 <code>n&gt;=2</code>，第一步有n种跳法：跳 1 级、跳 2 级,到跳 n 级。 跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1)； 跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2) …… 跳 n-1 级，剩下 1 级，则剩下跳法是 f(1)； 跳 n 级，剩下 0 级，则剩下跳法是 f(0) </p>
<p>所以在 n&gt;=2 的情况下： <code>f(n)=f(n-1)+f(n-2)+...+f(1)</code> 因为 <code>f(n-1)=f(n-2)+f(n-3)+...+f(1)</code>,所以 <code>f(n)=2*f(n-1)</code>, 又 <code>f(1)=1</code>,所以可得 <code>f(n)=2^(number-1)</code></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; --number;<span class="hljs-comment">//2^(number-1)用位移操作进行，更快</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="16-二维数组查找"><a href="#16-二维数组查找" class="headerlink" title="16. 二维数组查找"></a>16. 二维数组查找</h1><p><strong>题目描述：</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>问题解析：</strong><br>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增， 因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = matrix.length-<span class="hljs-number">1</span>;<span class="hljs-comment">//行数</span><br>        <span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>;<span class="hljs-comment">//列数</span><br>        <br>        <span class="hljs-comment">//边界条件</span><br>        <span class="hljs-keyword">while</span>(row&gt;=<span class="hljs-number">0</span> &amp;&amp; column&lt;matrix[<span class="hljs-number">0</span>].length) &#123;<br>            <span class="hljs-keyword">if</span>(matrix[row][column] &gt; target) &#123;<br>                row--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][column] &lt; target) &#123;<br>                column ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="17-按奇偶排序数组"><a href="#17-按奇偶排序数组" class="headerlink" title="17. 按奇偶排序数组"></a>17. 按奇偶排序数组</h1><blockquote>
<p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArrayByParity(<span class="hljs-keyword">int</span>[] A) &#123;<br>        <span class="hljs-keyword">int</span> len = A.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || len ==<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> A;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] arrays = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来计算偶数个数</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来指明当前到达那个位置</span><br><br>        <span class="hljs-comment">//先统计偶数个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>            <span class="hljs-keyword">if</span>(A[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//奇数只在插在偶数个数之后的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>            <span class="hljs-keyword">if</span>(A[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                arrays[index++] = A[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                arrays[count++] = A[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrays;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="18-TOP-K-问题"><a href="#18-TOP-K-问题" class="headerlink" title="18. TOP K 问题"></a>18. TOP K 问题</h1><p>从 1 亿个数中找出最大的前 100 个。</p>
<h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>利用小顶堆，首先遍历 100 个数放入堆中，后面每次遍历与堆顶比较，比堆顶大就替换堆顶并对堆进行调整。</p>
<p>堆排的时间复杂度是<code>n*logn</code>,适用场景：</p>
<ul>
<li>不会改变数据的输入顺序（按顺序读的）；</li>
<li>不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）；</li>
<li>由于（2），决定了它特别适合处理海量数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopK</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//假设这是给定的数据</span><br>        <span class="hljs-keyword">int</span>[] a = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">16</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span> &#125;;<br>        <span class="hljs-comment">//寻找前4个最大的数</span><br>        <span class="hljs-keyword">int</span>[] b = topK(a, <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++) &#123;<br>            System.out.print(b[i] + <span class="hljs-string">", "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//对堆的 index 节点进行调整使其符合小顶堆定义</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子</span><br>        <span class="hljs-keyword">int</span> right = index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<span class="hljs-comment">//右孩子</span><br>        <span class="hljs-keyword">int</span> smallest = index;<br>        <span class="hljs-keyword">if</span> (left &lt; length &amp;&amp; array[left] &lt; array[index]) &#123;<br>            smallest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; length &amp;&amp; array[right] &lt; array[smallest]) &#123;<br>            smallest = right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != smallest) &#123;<br>            swap(array, smallest, index);<br>            <span class="hljs-comment">//递归往下继续调整</span><br>            heapify(array, smallest, length);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = array[a];<br>        array[a] = array[b];<br>        array[b] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 初始化小顶堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = array.length;<br>        <span class="hljs-comment">/** <br>         * 由于单个结点的完全二叉树满足堆的特性，所以叶子结点都是堆。因此可以忽略叶子结点元素<br>         * 对 n 个结点的完全二叉树建堆的过程是：依次将编号为 n/2,n/2-1,...1 的结点为根的子树筛选为子堆<br>         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            heapify(array, i, length);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 设置新的堆顶<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> top)</span> </span>&#123;<br>        array[<span class="hljs-number">0</span>] = top;<br>        heapify(array, <span class="hljs-number">0</span>, array.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] topK(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span>[] top = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            top[i] = array[i];<br>        &#125;<br>        <span class="hljs-comment">//先建堆，然后依次比较剩余元素与堆顶元素的大小，比堆顶小的， 说明它应该在堆中出现，则用它来替换掉堆顶元素，然后沉降。</span><br>        buildHeap(top);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &lt; array.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> temp = top[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (array[j] &gt; temp) &#123;<br>                setTop(top, array[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="快排方式"><a href="#快排方式" class="headerlink" title="快排方式"></a>快排方式</h2><p>分治函数会返回一个 position，在 position 左边的数都比第 position 个数小，在 position 右边的数都比第 position 大。通过不断调用分治函数，直到它输出的 position = K-1，此时 position 前面的K个数（0到K-1）就是要找的前K个数。</p>
<p>时间复杂度为 n ，特点：</p>
<ul>
<li>partition函数会不断地交换元素的位置，所以它肯定会改变数据输入的顺序；</li>
<li>既然要交换元素的位置，那么所有元素必须要读到内存空间中，所以它会占用比较大的空间，至少能容纳整个数组；</li>
<li>数据越多，占用的空间必然越大，海量数据处理起来相对吃力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopK</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">int</span>[] array = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;;<br>        getTopK(array, <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            System.out.print(array[i] + <span class="hljs-string">", "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 从数组的右端向左扫描找到第一个大于它的元素，将这个元素放在 `l` 位置，<br>     * 从数组的左端向右扫描直到找到第一个小于等于枢轴的元素，<br>     * 放到右边高端刚交换完空出的位置。<br>     * 不断进行这个过程，就可以保证左指针 i 的左侧元素都不小于切分元素，<br>     * 右指针 j 的右侧元素都不大于切分元素。<br>     * 当两个指针相遇时，将枢轴的值放到该位置。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (array != <span class="hljs-keyword">null</span> &amp;&amp; low &lt; high) &#123;<br>            <span class="hljs-keyword">int</span> flag = array[low];<br>            <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>                <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; array[high] &lt;= flag) &#123;<br>                    high--;<br>                &#125;<br>                array[low] = array[high];<br>                <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; array[low] &gt;= flag) &#123;<br>                    low++;<br>                &#125;<br>                array[high] = array[low];<br>            &#125;<br>            array[low] = flag;<br>            <span class="hljs-keyword">return</span> low;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTopK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (array != <span class="hljs-keyword">null</span> &amp;&amp; array.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> high = array.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> index = partition(array, low, high);<br>            <span class="hljs-comment">//不断调整分治的位置，直到position = k-1</span><br>            <span class="hljs-keyword">while</span> (index != k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">//大了，往前调整</span><br>                <span class="hljs-keyword">if</span> (index &gt; k - <span class="hljs-number">1</span>) &#123;<br>                    high = index - <span class="hljs-number">1</span>;<br>                    index = partition(array, low, high);<br>                &#125;<br>                <span class="hljs-comment">//小了，往后调整</span><br>                <span class="hljs-keyword">if</span> (index &lt; k - <span class="hljs-number">1</span>) &#123;<br>                    low = index + <span class="hljs-number">1</span>;<br>                    index = partition(array, low, high);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="空间换时间：bitmap方式-海量数据排序也可以用"><a href="#空间换时间：bitmap方式-海量数据排序也可以用" class="headerlink" title="空间换时间：bitmap方式(海量数据排序也可以用)"></a>空间换时间：bitmap方式(海量数据排序也可以用)</h2><p>bitmap（比特位图法），是空间换时间的典型代表。它是一种，用若干个 bit 来表示集合的数据结构。</p>
<p>例如，集合S={1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。</p>
<p>上述集合S，可以用<code>1010101010000000</code>这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。</p>
<p>假设TopK的n个元素都是int，且元素之间没有重复，只需要申请2^32个bit，即4G的内存，就能够用bitmap表示这n元素。</p>
<p>扫描一次所有n个元素，以生成bitmap，其时间复杂度是O(n)。生成后，取TopK只需要找到最高位的k个bit即可。算法总时间复杂度也是O(n)。</p>
<p>bitmap 算法有一个缺陷，如果集合元素有重复，相同的元素会被去重，如果需要考虑重复元素，则需要通过比特位图精准计数的方式：</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXESzU0WNiaUjvAwXZNjLuyicktn7fl7Y48D34ib5r4cv0WlMicjA5dScK4oA/640?wx_fmt=jpeg" alt="bitmap求topK_1"></p>
<p>TopK的集合经过比特位图计数处理后，会记录每个bit对应在集合S中出现过多少次。</p>
<p>接下来，找TopK的过程，就是bitmap从高位的计数开始，往低位的计数扫描，得到count之和等于k，对应的bit就是TopK所求。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXEY1hhFg7yJ9DF30oeg2Y6lQM7ztxUyMOypBDgtjdO9GLAtyQUlcZl7w/640?wx_fmt=jpeg" alt="bitmap求topK_2"></p>
<p>如上图所示，k=5：</p>
<ol>
<li>第一个非0的count是1，对应的bit是9；</li>
<li>第二个非0的count也是1，对应的bit是8；</li>
<li>第三个非0的count是2，对应的bit是7；</li>
<li>第四个非0的count是2，对应的bit是6，但TopK只缺1个数字了，故只有1个6入选；</li>
</ol>
<p>故，最终的TopK={9, 8, 7, 7, 6}。</p>
<p>结论：通过比特位图精准计数的方式，求解TopK，算法整体只需要不到2次扫描，时间复杂度为O(n)，比减治法的随机选择会更快。</p>
<h1 id="19-1亿个-IPV-地址找相同"><a href="#19-1亿个-IPV-地址找相同" class="headerlink" title="19. 1亿个 IPV 地址找相同"></a>19. 1亿个 IPV 地址找相同</h1><h2 id="方法一：hash取模"><a href="#方法一：hash取模" class="headerlink" title="方法一：hash取模"></a>方法一：hash取模</h2><p>按照IP地址的 <code>hash(IP)%1024</code> 值，将海量日志存储到 1024 个小文件中，每个小文件最多包含 4M 个IP地址(IP地址最多有 <code>2^32=4G</code> 种取值可能)。 </p>
<p>对于每个小文件，可以构建一个 IP 作为 key，出现次数作为 value 的hash_map，并记录当前出现次数最多的 1 个 IP 地址。有了 1024 个小文件中的出现次数最多的 IP，我们就可以轻松得到总体上出现次数最多的 IP。</p>
<h2 id="方法二：bitmap"><a href="#方法二：bitmap" class="headerlink" title="方法二：bitmap"></a>方法二：bitmap</h2><p>申请一个长度为2^32的bit类型的数组，每个位置上是一个bit，只可表示0或者1两种状态，空间为 512 M。</p>
<p>每个 IP 地址转化成无符号整数 k，数组下标 <code>0~2^32-1</code> 与 k 对应起来。如果 <code>k==1</code> ,就把 <code>bitmap[0]=1</code>；如果 <code>k==n</code>,把 <code>bitmap[n-1] =1</code>；</p>
<p>最后只要从 bitmap 的零位一直遍历到最后，然后提取出对应为1的下标整数k，再转换成ip地址，就完成了从小到大的排序。空间复杂度很小，时间复杂度O（n）</p>
<p><img src="https://img-blog.csdnimg.cn/20190913234217803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjkwNzg1,size_16,color_FFFFFF,t_70" alt="bitmap计算ipv地址"></p>
<h1 id="20-两个栈实现队列"><a href="#20-两个栈实现队列" class="headerlink" title="20. 两个栈实现队列"></a>20. 两个栈实现队列</h1><p><img src="https://camo.githubusercontent.com/cd901d44121195e36bc4ea24dde717e707843a69/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33656132383062352d626537642d343731622d616337362d6666303230333834333537632e676966" alt="两个栈实现队列"></p>
<p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stack&lt;Integer&gt; in = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>Stack&lt;Integer&gt; out = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>    in.push(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(out.isEmpty()) &#123;<br>        <span class="hljs-keyword">while</span>(!in.isEmpty()) &#123;<br>            out.push(in.pop());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (out.isEmpty())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"queue is empty"</span>);<br>    <br>    <span class="hljs-keyword">return</span> out.pop();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="21-字典树（trie）实现敏感词汇过滤"><a href="#21-字典树（trie）实现敏感词汇过滤" class="headerlink" title="21. 字典树（trie）实现敏感词汇过滤"></a>21. 字典树（trie）实现敏感词汇过滤</h1><p>trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的。</p>
<h2 id="算法思路总结："><a href="#算法思路总结：" class="headerlink" title="算法思路总结："></a>算法思路总结：</h2><p>首先对需要屏蔽的词汇构建字典树（Trie Tree），然后创建三个指针，begin 指针指向匹配字符串起始位置，position 指针指向当前需要对比的字符，tempNode首先指向字典树的根节点。</p>
<p>每次 position 位置字符与 tempNode 子节点对比，如果不匹配则 position 和 begin 均加 1再继续比较；</p>
<p>如果匹配 tempNode 指向所匹配节点继续比较，同时 position+1，直到 tempNode 指向叶子节点则说明匹配到敏感词汇，将 begin 位置到 position 位置的字符屏蔽用 <code>*</code>代替,然后 position +1，begin 指向 position 位置，tempNode 指向跟节点，继续往下执行。</p>
<p>若匹配过程中到某一个 tempNode 节点时，其子节点已经没有匹配的字符，说明当前词汇不符合敏感词汇，则将 begin+1，同时 position 指向 begin，tempNode 再次指向根节点。</p>
<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>首先建立个敏感词前缀树，根节点为空：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%BB%BA%E7%AB%8B%E5%89%8D%E7%BC%80%E6%A0%91.png" alt="建立前缀树"></p>
<p>准备好待处理字符串：“哈哈大王八子大猪蹄子哦” ，声明三个指针，分别指向前缀树的根节点以及待处理字符串的开始字符</p>
<p>position 指向的字符与根节点的所有子节点进行匹配，不匹配，position 和 begin 分别指向待处理字符串的下一个字符，tempNode 依旧指向根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%A3%B0%E6%98%8E%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88.png" alt="声明三个指针"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B1.png" alt="指针匹配过程1"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B2.png" alt="指针匹配过程2"></p>
<p>此时根节点有一个子节点与 position 指向的字符相等，都为‘大’，则 tempNode 指向该节点，同时 position 前进一步，指向‘王’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B3.png" alt="指针匹配过程3"></p>
<p>此时把 position 指向的‘王’ 和 tempNode 的所有子节点进行匹配，匹配失败，说明 从 begin 起头所有串是不存在敏感词的，可以直接输出。此时 begin 前进一位，position 回退到 begin 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B4.png" alt="指针匹配过程4"></p>
<p>此时再把 position 指向的‘王’与 tempNode 的所有子节点进行匹配，匹配成功，所以 tempNode 指向该节点，同时 position 前进一位，指向’八’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B5.png" alt="指针匹配过程5"></p>
<p>此时再把 position 指向的‘王’ 与 tempNode 的所有子节点进行匹配，匹配成功，此时 tempNode 指向它的子节点‘八’，同时 position 前进一位。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B6.png" alt="指针匹配过程6"></p>
<p>继续把 position 指向的字符 与tempNode 的所有子节点进行匹配，匹配失败。说明以begin起头的不存在非法字符，可以加入到结果集中。 此时 begin 向前走一位，position 回退到 begin 的位置，同时 tempNode 回退到根节点。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B7.png" alt="指针匹配过程7"></p>
<p>同理，可以发现子’子’不匹配，则直接把它加入结果集，同时position 和 begin 向前走一位，tempNode 指向根节点。</p>
<p>此时 position 指向 ‘大’，与 tempNode 的所有子节点进行匹配，匹配成功，则 position 和 tempNode 都走一位，循环执行….</p>
<p>直到 position 指向‘子’，tempNode指向‘蹄’（图中begin指针应该指向‘大’）</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B8.png" alt="指针匹配过程8"></p>
<p>此时把 position 与 tempNode 的所有子节点进行匹配，匹配成功，tempNode 指向它的子节点‘子’，此时检查发现tempNode是敏感词树的叶子节点，说明从 begin 开始的位置到 position 这段是敏感词，用和谐词替换掉。替换之后 position 前进一位，begin 跳到 position 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B9.png" alt="指针匹配过程9"></p>
<h2 id="算法代码实现"><a href="#算法代码实现" class="headerlink" title="算法代码实现"></a>算法代码实现</h2><p>前缀树结构：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;<br> <br>    <span class="hljs-comment">//是否最后一个字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isKeyWordsEnd = <span class="hljs-keyword">false</span>;<br> <br>    <span class="hljs-comment">//子节点</span><br>    <span class="hljs-keyword">private</span> Map&lt;Character,TreeNode&gt; subNodes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSubNode</span><span class="hljs-params">(Character key, TreeNode node)</span></span>&#123;<br>        subNodes.put(key,node);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getSubNode</span><span class="hljs-params">(Character key)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> subNodes.get(key);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isKeyWordsEnd</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> isKeyWordsEnd;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKeyWordsEnd</span><span class="hljs-params">(Boolean end)</span></span>&#123;<br>        isKeyWordsEnd = end;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>构建前缀树的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSensitiveWord</span><span class="hljs-params">(String words)</span></span>&#123;<br> <br>    TreeNode tempNode = rootNode;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  i &lt; words.length(); i++)&#123;<br> <br>        Character c = words.charAt(i);<br>        <span class="hljs-keyword">if</span>(!isSymbol(c))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        TreeNode node = tempNode.getSubNode(c);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)&#123;<br>            node = <span class="hljs-keyword">new</span> TreeNode();<br>            tempNode.addSubNode(c,node);<br>        &#125;<br>        <span class="hljs-comment">// 指针移动</span><br>        tempNode = node;<br> <br>        <span class="hljs-comment">//如果到了最后一个字符</span><br>        <span class="hljs-keyword">if</span>(i == words.length() -<span class="hljs-number">1</span>)&#123;<br>            tempNode.setKeyWordsEnd(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>算法具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filter</span><span class="hljs-params">(String text)</span></span>&#123;<br> <br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(text))&#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br> <br>    String sensitiveWords = <span class="hljs-string">"***"</span>;<br>    StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br> <br>    TreeNode tempNode = rootNode;<br>    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">while</span> (position &lt; text.length())&#123;<br><br>        Character c = text.charAt(position);<br> <br>        <span class="hljs-comment">//如果非匹配字符，则直接跳过</span><br>        <span class="hljs-keyword">if</span>(!isSymbol(c))&#123; <span class="hljs-comment">//每次</span><br>            <span class="hljs-keyword">if</span>(tempNode == rootNode)&#123;<br>                result.append(c);<br>                begin++;<br>            &#125;<br>            position++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        tempNode = tempNode.getSubNode(c);<br> <br>        <span class="hljs-comment">//如果匹配失败</span><br>        <span class="hljs-keyword">if</span>(tempNode == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//说明以begin起头的那一段不存在非法词汇</span><br>            result.append(text.charAt(begin));<br>            begin++;<br>            position = begin;<br>            tempNode = rootNode;<br>            <span class="hljs-keyword">continue</span>;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempNode.isKeyWordsEnd())&#123;<br>            <span class="hljs-comment">//替换敏感词</span><br>            result.append(sensitiveWords);<br>            position++;<br>            begin = position;<br>            tempNode = rootNode;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position &gt; text.length() &amp;&amp; (begin+<span class="hljs-number">1</span>) &lt; text.length()) &#123;<br>                <span class="hljs-comment">/** <br>                 * 防止出现有相同后缀的敏感词汇<br>                 * 如fabcd，abc，当字符串最后fabc, 此时指begin指f, <br>                 * 指position指到c, 根据循环中的判断c的isKeywordsEnd为true, <br>                 * position++, 此时跳出循环, 然后将fabc加到StringBuilder中, <br>                 * 但是abc这个敏感词没有被过滤掉<br>                 */</span><br>                begin = begin +<span class="hljs-number">1</span>;<br>                position = begin;<br>                tempNode = rootNode;<br>                <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            position++;<br>        &#125;       <br>    &#125;   <br>    result.append(text.substring(begin)); <span class="hljs-comment">//把剩下的动加入合法集</span><br> <br>    <span class="hljs-keyword">return</span> result.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h2><p>如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p>
<h1 id="22-给定已有硬币面值，计算需要的最少硬币数目？"><a href="#22-给定已有硬币面值，计算需要的最少硬币数目？" class="headerlink" title="22. 给定已有硬币面值，计算需要的最少硬币数目？"></a>22. 给定已有硬币面值，计算需要的最少硬币数目？</h1><p>使用动态规划的思想解决：</p>
<p><a href="https://xiaoming.net.cn/2019/11/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" target="_blank" rel="noopener">详情看这里</a></p>
<h1 id="23-动态规划01背包问题"><a href="#23-动态规划01背包问题" class="headerlink" title="23. 动态规划01背包问题"></a>23. 动态规划01背包问题</h1><p>假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。</p>
<p>状态：<code>maxValue[i][j]</code>表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>状态转移方程：<code>maxValue[i][j] = max{maxValue[i-1][j],maxValue[i-1][j-w[i]]+P[i]}</code>，其中 <code>w[i]</code> 表示第 i 颗宝石的重量，<code>P[i]</code> 表示第 i 颗宝石的价值。</p>
<p>物理意义：<code>当前背包能装入的最大价值为只有 i-1 个宝石时背包能装入的最大价值</code> 和 <code>腾出第 i 颗宝石重量后剩余背包容量装入 i-1 个宝石的最大价值加上装入第 i 颗宝石价值</code> 的较大值.</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnapsackProblem</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>     * <span class="hljs-doctag">@param</span> w 每一个宝石的重量<br>     * <span class="hljs-doctag">@param</span> v 每一个宝石的价值<br>     * <span class="hljs-doctag">@param</span> capacity 背包的容量<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w,<span class="hljs-keyword">int</span>[] v,<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-comment">//maxValue[i][j]表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值</span><br>        <span class="hljs-keyword">int</span>[][] maxValue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[w.length][capacity]; <br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; capacity; j++) &#123;<br>            maxValue[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//没有宝石时价值为0</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.length; i++) &#123;<br>            maxValue[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//容量为0时价值为0</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; w.length; i++) &#123; <span class="hljs-comment">//从有1个宝石算起</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; capacity; j++) &#123; <span class="hljs-comment">//从容量为1算起</span><br>                <span class="hljs-keyword">if</span>(w[i] &lt; j) &#123;<br>                    maxValue[i][j] = Math.max(maxValue[i-<span class="hljs-number">1</span>][j],maxValue[i-<span class="hljs-number">1</span>][j-w[i]] + v[i]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//无法承载此颗宝石重量</span><br>                    maxVlue[i][j] = maxValue[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++) &#123;<br>            System.out.printf(<span class="hljs-string">"%-5d"</span>,temp[i][j]);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="24-最长不重复子串"><a href="#24-最长不重复子串" class="headerlink" title="24. 最长不重复子串"></a>24. 最长不重复子串</h1><blockquote>
<p>LeeCode：给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
</blockquote>
<p>思路：采用窗口滑动思想，利用 HashMap，其中 key 存储字符，value 存储当前字符的下一个位置。窗口（i，j）从左往右扫描，当 key 不重复时，j+1，继续往右扫描；当出现 key 重复时，i 跳过 key 字符第一次出现的位置到它的下一个位置，而长度就是 j-i+1 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring03</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length(), ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//创建map窗口,i为左区间，j为右区间，右边界移动</span><br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-comment">// 如果窗口中包含当前字符，</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(j))) &#123;<br>            <span class="hljs-comment">//左边界移动到 相同字符的下一个位置和i当前位置中更靠右的位置，这样是为了防止i向左移动</span><br>            i = Math.max(map.get(s.charAt(j)), i);<br>        &#125;<br>        <span class="hljs-comment">//比对当前无重复字段长度和储存的长度，选最大值并替换</span><br>        <span class="hljs-comment">//j-i+1是因为此时i,j索引仍处于不重复的位置，j还没有向后移动，取的[i,j]长度</span><br>        ans = Math.max(ans, j - i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 将当前字符为key，下一个索引为value放入map中</span><br>        <span class="hljs-comment">// value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了</span><br>        map.put(s.charAt(j), j+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="25-数据求交集"><a href="#25-数据求交集" class="headerlink" title="25. 数据求交集"></a>25. 数据求交集</h1><blockquote>
<p>LeeCode: 给定两个数组，编写一个函数来计算它们的交集。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;<br>    <span class="hljs-keyword">int</span> [] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set1.size()];<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Integer s : set1)<br>      <span class="hljs-keyword">if</span> (set2.contains(s)) output[idx++] = s;<br><br>    <span class="hljs-keyword">return</span> Arrays.copyOf(output, idx);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (Integer n : nums1) set1.add(n);<br>    HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (Integer n : nums2) set2.add(n);<br><br>    <span class="hljs-keyword">if</span> (set1.size() &lt; set2.size()) <span class="hljs-keyword">return</span> set_intersection(set1, set2);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> set_intersection(set2, set1);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>也可以使用<code>retainAll</code>函数：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (Integer n : nums1) set1.add(n);<br>    HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (Integer n : nums2) set2.add(n);<br><br>    set1.retainAll(set2);<br><br>    <span class="hljs-keyword">int</span> [] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set1.size()];<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s : set1) output[idx++] = s;<br>    <span class="hljs-keyword">return</span> output;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(m+n)O(m+n)，其中 n 和 m 是数组的长度。O(n)O(n) 的时间用于转换 nums1 在集合中，O(m)O(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 O(1)O(1)。</li>
<li>空间复杂度：O(m+n)O(m+n)，最坏的情况是数组中的所有元素都不同。</li>
</ul>
<h1 id="26-如何判断单链表是否有环？如何确定环的入口？"><a href="#26-如何判断单链表是否有环？如何确定环的入口？" class="headerlink" title="26. 如何判断单链表是否有环？如何确定环的入口？"></a>26. 如何判断单链表是否有环？如何确定环的入口？</h1><h2 id="方法一：hash-表"><a href="#方法一：hash-表" class="headerlink" title="方法一：hash 表"></a>方法一：hash 表</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        ListNode node = head;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(node)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//对于需要返回节点的，直接返回这个node</span><br>                <span class="hljs-comment">//即 return node;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.add(node);<br>                node = node.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//这里相应改成return null;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>时间复杂度：<code>O(n)</code>，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 <code>O(1)</code> 的时间。</li>
<li>空间复杂度：<code>O(n)</code>，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</li>
</ul>
<h2 id="方法二：双指针（快慢指针）"><a href="#方法二：双指针（快慢指针）" class="headerlink" title="方法二：双指针（快慢指针）"></a>方法二：双指针（快慢指针）</h2><p>如果存在循环，快指针会再次追上慢指针，没有说明不存在环形链表；如果需要返回入口节点，则将两个指针一个指向头节点，一个指向相遇点，然后分别向前走直到相遇，该点就是入口点。</p>
<p>理解如下：</p>
<ol>
<li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li>
<li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li>
<li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li>
<li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li>
<li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li>
<li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li>
<li>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 不需要求入口<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    ListNode slow = head;<br>    ListNode fast = head.next;<br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">/**<br> * 求入口<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">getIntersect</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode tortoise = head;<br>        ListNode hare = head;<br><br>        <span class="hljs-keyword">while</span> (hare != <span class="hljs-keyword">null</span> &amp;&amp; hare.next != <span class="hljs-keyword">null</span>) &#123;<br>            tortoise = tortoise.next;<br>            hare = hare.next.next;<br>            <span class="hljs-keyword">if</span> (tortoise == hare) &#123;<br>                <span class="hljs-keyword">return</span> tortoise;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        ListNode intersect = getIntersect(head);<br>        <span class="hljs-keyword">if</span> (intersect == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        ListNode ptr1 = head;<br>        ListNode ptr2 = intersect;<br>        <span class="hljs-keyword">while</span> (ptr1 != ptr2) &#123;<br>            ptr1 = ptr1.next;<br>            ptr2 = ptr2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ptr1;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。</li>
</ul>
<h1 id="27-找两条链表公共节点"><a href="#27-找两条链表公共节点" class="headerlink" title="27. 找两条链表公共节点"></a>27. 找两条链表公共节点</h1><blockquote>
<p>Leecode:编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p>使用双指针法：</p>
<ul>
<li>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</li>
<li>当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li>
<li>若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。</li>
<li>想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。</li>
<li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/Bp 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</li>
</ul>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 : O(m+n)O(m+n)。</li>
<li>空间复杂度 : O(1)O(1)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode pA = headA;<br>        ListNode pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA.next;<br>            pB = pB.next;<br>            <span class="hljs-keyword">if</span> (pA == <span class="hljs-keyword">null</span> &amp;&amp; pB == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pA == <span class="hljs-keyword">null</span>) &#123;<br>                pA = headB;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pB == <span class="hljs-keyword">null</span>) &#123;<br>                pB = headA;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="28-100G-的文件，只有-100M-内存，对文件进行排序"><a href="#28-100G-的文件，只有-100M-内存，对文件进行排序" class="headerlink" title="28. 100G 的文件，只有 100M 内存，对文件进行排序"></a>28. 100G 的文件，只有 100M 内存，对文件进行排序</h1><h2 id="外部排序-多路归并"><a href="#外部排序-多路归并" class="headerlink" title="外部排序 + 多路归并"></a>外部排序 + 多路归并</h2><p><img src="http://qiniu.xiaoming.net.cn/%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F.jpeg" alt="大文件排序"></p>
<p>100G 数据，按照 100M 内存拆分，然后排序成有序的数据，然后写入到 file1,file2…file100。</p>
<p>之后进行多路归并排序：</p>
<ol>
<li><p>从 file1,file2,file3，…，file100 取出第一个数，即最大或者最小的，所有的初始指针都是第一行。</p>
<figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-built_in">min1</span> = <span class="hljs-built_in">min</span>(fil1,file2,file3, … ,file100)；<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>min1 写入到大数据文件,大数据行数指针 + 1,min1 对应的行数指针 +1。</p>
</li>
<li><p>从对应的行指针取出第二个数进行对比，继续归并</p>
</li>
</ol>
<h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><p>前提是内存容得下这么大的位图。每读一个数，相应的位图位置标 1，如果又重复数，可以建一个数组相应的 count++，遍历完文件之后对对应位置为 1 的输出下标。</p>
<h1 id="29-100亿个整型数据，乱序，100M内存，求中位数"><a href="#29-100亿个整型数据，乱序，100M内存，求中位数" class="headerlink" title="29. 100亿个整型数据，乱序，100M内存，求中位数"></a>29. 100亿个整型数据，乱序，100M内存，求中位数</h1><p>这里认为是带符号的int,所以4字节，占32位。</p>
<p>假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入    <code>file_0</code> 文件中；如果最高位为 1，则将该数字写入 <code>file_1</code> 文件中。</p>
<p>从而将 100 亿个数字分成了两个文件，假设 <code>file_0</code> 文件中有 60亿 个数字，<code>file_1</code> 文件中有 40 亿个数字。那么中位数就在 <code>file_0</code> 文件中，并且是 <code>file_0</code> 文件中所有数字排序之后的第 10 亿个数字。（<code>file_1</code> 中的数都是负数，<code>file_0</code> 中的数都是正数，也即这里一共只有 40 亿个负数，那么排序之后的第 50 亿个数一定位于 <code>file_0</code> 中）</p>
<p>现在，只需要处理 <code>file_0</code> 文件了（不需要再考虑 <code>file_1</code> 文件）。对于 <code>file_0</code> 文件，同样采取上面的措施处理：将 <code>file_0</code> 文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的次高位（第31位），如果数字的次高位为 0，写入 <code>file_0_0</code> 文件中；如果次高位为1，写入<code>file_0_1</code> 文件中。</p>
<p>现假设 <code>file_0_0</code> 文件中有30亿个数字，<code>file_0_1</code> 中也有30亿个数字，则中位数就是：<code>file_0_0</code> 文件中的数字从小到大排序之后的第 10 亿个数字。</p>
<p>抛弃 <code>file_0_1</code> 文件，继续对 <code>file_0_0</code> 文件 根据次次高位(第30位) 划分，假设此次划分的两个文件为：<code>file_0_0_0</code> 中有5亿个数字，<code>file_0_0_1</code> 中有25亿个数字，那么中位数就是 <code>file_0_0_1</code> 文件中的所有数字排序之后的第 5 亿个数。</p>
<p>以此类推，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p>
<h1 id="30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><a href="#30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199" class="headerlink" title="30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"></a>30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaximumProduct</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>     * 求出最大乘积是多少<br>     * <span class="hljs-doctag">@param</span> number<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaximumProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number &lt; <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> number;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> Math.max(getMaximumProduct(number / <span class="hljs-number">10</span>) * (number % <span class="hljs-number">10</span>),getMaximumProduct(number / <span class="hljs-number">10</span> -<span class="hljs-number">1</span>) * <span class="hljs-number">9</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//用于存储每一位数</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (number &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//获取除个位数以外的部分</span><br>            <span class="hljs-keyword">int</span> n = number/<span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//个位数取9时，高位部分减1</span><br>            <span class="hljs-keyword">int</span> m = number/<span class="hljs-number">10</span>-<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//比较个位数取 9 和按原数计算哪个数乘积比较大</span><br>            <span class="hljs-keyword">if</span>(getMaximumProduct(n) * (number%<span class="hljs-number">10</span>) &lt; getMaximumProduct(m) * <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-comment">//个位数取9比较大，存入数组，相应的把number变为高位部分，继续比较</span><br>                number = m;<br>                list.add(<span class="hljs-number">9</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//原数大，则存入数组，相应把number变为高位部分，继续比较</span><br>                list.add(number%<span class="hljs-number">10</span>);<br>                number = n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> size = list.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result = result * <span class="hljs-number">10</span> + list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="31-二叉树中和为某一值的路径"><a href="#31-二叉树中和为某一值的路径" class="headerlink" title="31. 二叉树中和为某一值的路径"></a>31. 二叉树中和为某一值的路径</h1><blockquote>
<p>Leecode:输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode(int x) &#123; val = x; &#125;<br> * &#125;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//存储结果集</span><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//存储每一条路径</span><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>        recur(root,sum);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum -= root.val;<br>        path.add(root.val);<br>        <span class="hljs-comment">//当左右子树都为空说明已经到了叶子结点，如果 sum 已经减为 0，说明该路径可以，加入结果集</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//需要拷贝路径加入，直接加入的话后续path一变会导致结果集的数据跟着改变</span><br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        &#125;<br>        <span class="hljs-comment">//递归左子节点</span><br>        recur(root.left,sum);<br>        <span class="hljs-comment">//递归右子节点</span><br>        recur(root.right,sum);<br>        <span class="hljs-comment">//路径恢复，向上回溯前，需要将当前节点从路径 path 中删除</span><br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N)：N 为二叉树的节点数，先序遍历需要遍历所有节点。</li>
<li>空间复杂度 O(N)：最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。</li>
</ul>
<h1 id="32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除"><a href="#32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除" class="headerlink" title="32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除"></a>32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">solution</span><span class="hljs-params">(String a,String b)</span> </span>&#123;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.length(); i++) &#123;<br>            set.add(b.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = a.charAt(i);<br>            <span class="hljs-keyword">if</span>(!set.contains(c)) &#123;<br>                builder.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="33-二叉搜索树转双向链表"><a href="#33-二叉搜索树转双向链表" class="headerlink" title="33. 二叉搜索树转双向链表"></a>33. 二叉搜索树转双向链表</h1><blockquote>
<p>Leecode:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
</blockquote>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpeg" alt="二叉搜索树转双向链表"></p>
<p>递归方式：改写中序遍历，遍历过程中使用一全局变量 pre 存储其前一个结点,当遍历该结点时，只需该节点的前驱(left)指向pre，pre的后继指向该节点。对于头结点应特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TreeNode pre = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">private</span> TreeNode head = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    inOrder(root);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    inOrder(node.left);<br>    node.left = pre;<br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>)<br>        pre.right = node;<br>    pre = node;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)<br>        head = node;<br>    inOrder(node.right);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>非递归版本：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>     Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>     Node current = root;<br>     Node pre = <span class="hljs-keyword">null</span>, head = <span class="hljs-keyword">null</span>, tail = <span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">while</span>(!stack.isEmpty() || current != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">while</span>(current != <span class="hljs-keyword">null</span>) &#123;<br>             stack.push(current);<br>             current = current.left;<br>         &#125;<br>         current = stack.pop();<br>         tail = current;<br>         <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//处理头结点</span><br>             head = current;<br>         &#125;<span class="hljs-keyword">else</span> &#123;<br>             pre.right = current;<br>             current.left = pre;<br>         &#125;<br>        pre = current;<br>        current = current.right;<br>     &#125;<br>     tail.right = head;<br>     head.left = tail;<br>     <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="34-有序链表转换二叉搜索树"><a href="#34-有序链表转换二叉搜索树" class="headerlink" title="34. 有序链表转换二叉搜索树"></a>34. 有序链表转换二叉搜索树</h1><blockquote>
<p>Leecode:给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
</blockquote>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">给定的有序链表： [<span class="hljs-number">-10</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>],<br><br>一个可能的答案是：[<span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-10</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：<br><br>      <span class="hljs-number">0</span><br>     / \<br>   <span class="hljs-number">-3</span>   <span class="hljs-number">9</span><br>   /   /<br> <span class="hljs-number">-10</span>  <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
<p>解题思路：给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。</p>
<ol>
<li>由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。</li>
<li>我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 <code>slow_ptr</code> 和 <code>fast_ptr</code>。<code>slow_ptr</code> 每次向后移动一个节点而 <code>fast_ptr</code> 每次移动两个节点。当 <code>fast_ptr</code> 到链表的末尾时 <code>slow_ptr</code> 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。</li>
<li>当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 <code>prev_ptr</code> 的指针记录 <code>slow_ptr</code> 之前的元素，也就是满足 <code>prev_ptr.next = slow_ptr</code>。断开左侧部分就是让 <code>prev_ptr.next = None</code>。</li>
<li>我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 <code>slow_ptr.next</code> 作为头指针。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">findMiddleElement</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>    <span class="hljs-comment">// The pointer used to disconnect the left half from the mid node.</span><br>    ListNode prevPtr = <span class="hljs-keyword">null</span>;<br>    ListNode slowPtr = head;<br>    ListNode fastPtr = head;<br><br>    <span class="hljs-comment">// Iterate until fastPr doesn't reach the end of the linked list.</span><br>    <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>) &#123;<br>      prevPtr = slowPtr;<br>      slowPtr = slowPtr.next;<br>      fastPtr = fastPtr.next.next;<br>    &#125;<br><br>    <span class="hljs-comment">// Handling the case when slowPtr was equal to head.</span><br>    <span class="hljs-keyword">if</span> (prevPtr != <span class="hljs-keyword">null</span>) &#123;<br>      prevPtr.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slowPtr;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>    <span class="hljs-comment">// If the head doesn't exist, then the linked list is empty</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Find the middle element for the list.</span><br>    ListNode mid = <span class="hljs-keyword">this</span>.findMiddleElement(head);<br><br>    <span class="hljs-comment">// The mid becomes the root of the BST.</span><br>    TreeNode node = <span class="hljs-keyword">new</span> TreeNode(mid.val);<br><br>    <span class="hljs-comment">// Base case when there is just one element in the linked list</span><br>    <span class="hljs-keyword">if</span> (head == mid) &#123;<br>      <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// Recursively form balanced BSTs using the left and right halves of the original list.</span><br>    node.left = <span class="hljs-keyword">this</span>.sortedListToBST(head);<br>    node.right = <span class="hljs-keyword">this</span>.sortedListToBST(mid.next);<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"><a href="#35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？" class="headerlink" title="35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"></a>35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？</h1><p>在二叉树中有关系：度为0的结点个数 = 度为2的结点个数 + 1，表示为：n0 = n2 +1；<br>因为度为1的结点只可能出现在最后一个结点，或者根本就不存在度为1的结点。<br>假设:存在度为1的结点；<br>n0 + n2 + 1 = 1699，解其可得，n0 与 n2 都不为整数，这与事实不符，所以可以得出，不存在度数为1的点(虽然计算得出是的确不存在，但并不是一定不存在)<br>所以可得度为1的结点是不存在的；<br>即：n0 + n2 = 1699，解 n0 = 850</p>
<h1 id="36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径"><a href="#36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径" class="headerlink" title="36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径"></a>36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径</h1><blockquote>
<p>Leecode：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物（网格中的障碍物和空位置分别用 1 和 0 来表示，1 代表障碍物）。那么从左上角到右下角将会有多少条不同的路径？</p>
</blockquote>
<p>解题思路：动态规划的思想，到达一个格子可以从上方到达，也可以从左边到达，所以分别计算上方和左侧两个格子的到达数相加就是当前格子的路径数。具体如下：</p>
<p>如果格子上有障碍，那么不考虑包含这个格子的任何路径。从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个动态规划问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 <code>DP</code> 数组。</p>
<p>注意： 根据题目描述，包含障碍物的格点有权值 1，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p>
<p>算法思路如下：</p>
<ol>
<li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</li>
<li>否则，如果 <code>obstacleGrid[0,0]</code> 是 0，我们初始化这个值为 1 然后继续算法。</li>
<li>遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j]</code> = <code>obstacleGrid[i,j-1]</code>。</li>
<li>遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li>
<li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li>
<li>如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> R = obstacleGrid.length;<br>        <span class="hljs-keyword">int</span> C = obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//遍历第一列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; R; i++) &#123;<br>            obstacleGrid[i][<span class="hljs-number">0</span>] = (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历第一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; C; i++) &#123;<br>            obstacleGrid[<span class="hljs-number">0</span>][i] = (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; R; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; C; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    obstacleGrid[i][j] = obstacleGrid[i - <span class="hljs-number">1</span>][j] + obstacleGrid[i][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    obstacleGrid[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//返回最后一格的值</span><br>        <span class="hljs-keyword">return</span> obstacleGrid[R - <span class="hljs-number">1</span>][C - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>时间复杂度 ： O(M×N) 。长方形网格的大小是 M×N，而访问每个格点恰好一次。</li>
<li>空间复杂度 ： O(1)。我们利用 obstacleGrid 作为 DP 数组，因此不需要额外的空间</li>
</ul>
<h1 id="37-二叉树的最近公共祖先"><a href="#37-二叉树的最近公共祖先" class="headerlink" title="37. 二叉树的最近公共祖先"></a>37. 二叉树的最近公共祖先</h1><blockquote>
<p>Leecode:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
</blockquote>
<p>解题思路：</p>
<p>递归，这种方法非常直观。先深度遍历改树。当遇到节点 p 或 q 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最近的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是p或q中的一个，对于这个节点,子树递归返回一个真标志。</p>
<p>让我们看看基于这个想法的形式算法。</p>
<p>算法：</p>
<ol>
<li>从根节点开始遍历树。</li>
<li>如果当前节点本身是 p 或 q 中的一个，我们会将变量 mid 标记为 true，并继续搜索左右分支中的另一个节点。</li>
<li>如果左分支或右分支中的任何一个返回 true，则表示在下面找到了两个节点中的一个。</li>
<li>如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 true，这意味着我们找到了节点 p 和 q 的最近公共祖先。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TreeNode ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ans = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recurseTree</span><span class="hljs-params">(TreeNode currentNode, TreeNode p, TreeNode q)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (currentNode == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-keyword">this</span>.recurseTree(currentNode.left, p, q) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-keyword">this</span>.recurseTree(currentNode.right, p, q) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = (currentNode == p || currentNode == q) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br><br>        <span class="hljs-keyword">if</span> (mid + left + right &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">this</span>.ans = currentNode;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (mid + left + right &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.recurseTree(root, p, q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h1 id="38-分5个线程计算1-10000的和，要求全部计算完了再汇总"><a href="#38-分5个线程计算1-10000的和，要求全部计算完了再汇总" class="headerlink" title="38. 分5个线程计算1-10000的和，要求全部计算完了再汇总"></a>38. 分5个线程计算1-10000的和，要求全部计算完了再汇总</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CountDownLatchApply countDownLatchApply = <span class="hljs-keyword">new</span> CountDownLatchApply();<br>        <span class="hljs-keyword">long</span> l1 = System.currentTimeMillis();<br>        countDownLatchApply.getTotal2();<br>        <span class="hljs-keyword">long</span> l2 = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">"循环遍历:"</span> + (l2-l1));<br><br>        <span class="hljs-keyword">long</span> l3 = System.currentTimeMillis();<br>        countDownLatchApply.getTotal();<br>        <span class="hljs-keyword">long</span> l4 = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">"countDownLatch:"</span> + (l4-l3));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000000</span>; i++) &#123;<br>                result += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"循环遍历结果："</span> + result);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalCount = <span class="hljs-number">5</span>;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(totalCount);<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">int</span>[] total = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalCount; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            executorService.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">200000</span>; j++) &#123;<br>                    sum += (j + finalI*<span class="hljs-number">200000</span>);<br>                &#125;<br>                total[finalI] = sum;<br>                countDownLatch.countDown();<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await(); <span class="hljs-comment">//main线程会阻塞在这里</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            result += total[i];<br>        &#125;<br>        System.out.println(<span class="hljs-string">"countDownLatch结果："</span> + result);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="39-1-N-这些数中1出现的次数"><a href="#39-1-N-这些数中1出现的次数" class="headerlink" title="39. 1-N 这些数中1出现的次数"></a>39. 1-N 这些数中1出现的次数</h1><blockquote>
<p>Leecode: 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: <span class="hljs-number">13</span><br>输出: <span class="hljs-number">6</span> <br>解释: 数字 <span class="hljs-number">1</span> 出现在以下数字中: <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span> 。<br></code></pre></div></td></tr></table></figure>

<h2 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h2><p>思路：</p>
<ol>
<li>将 i 从 1 遍历到 n：</li>
<li>将 i 转成字符串，数 ’1’ 的个数</li>
<li>将每个字符串里 ’1’ 的个数累加到变量 countr</li>
<li>返回 countr</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        String s1 = String.valueOf(i);<br>        <span class="hljs-keyword">int</span> len1 = s1.length();<br>        String s2 = s1.replaceAll(<span class="hljs-string">"1"</span>, <span class="hljs-string">""</span>);<br>        <span class="hljs-keyword">int</span> len2 = s2.length();<br>        count += (len1 - len2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(n*log10(n))：从 1 遍历到 n 每次遍历中，我们把整数转成字符串去数 ’1’ 的个数，这个过程会花费 m 的时间，其中 m 为字符串的长度，其最大值为 log10(n)。</li>
<li>空间复杂度：需要申请O(log10(n)) 个额外的空间来存储 countr 和整数转换成的字符串 str。</li>
</ul>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>下面的图列出了求个位数，十位数，百位数…的规则:</p>
<p><img src="http://qiniu.xiaoming.net.cn/Leecode%E6%B1%821%E4%B8%AA%E6%95%B0%E6%95%B0%E5%AD%A6%E5%8F%91%E5%88%86%E6%9E%90.png" alt="Leecode求1个数数学法原理"></p>
<p>由上图所示，可以观察到每 10 个数，个位上的 ’1’ 就会出现一次。同样的，每 100 个数，十位上的 ’1’ 就会出现一次。这个规律可以用 <code>(n/(i*10))*i</code> 公式来表示。</p>
<p>同时，如果十位上的数是 ’1’，那么最后 ’1’ 的数量要加上 x+1，其中 x 是个位上的数值。如果十位上的数大于 ’1’，那么十位上为 ’1’ 的所有的数都是符合要求的，这时候最后 ’1’ 的数量要加 10。</p>
<p>这个规律可以用公式 <code>min(max((n mod (i*10))−i+1,0),i)</code> 来表示。</p>
<p>来看一个例子，有一个数 n=1234。</p>
<p>个位上 ’1’ 的数量 = <code>1234/10 (对应 1,11,21,...1221) + min(4,1) (对应 1231) = 124</code></p>
<p>十位上 ’1’ 的数量 = <code>(1234/100)*10 (对应 10,11,12,...,110,111,...1919) + min(21, 10) (对应 1210,1211,...1219) = 130</code></p>
<p>百位上 ’1’ 的数量 = <code>(1234/1000)*100 (对应 100,101,102,...,199) + min(135, 100) (对应1100,1101...1199) = 200</code></p>
<p>千位上 ’1’ 的数量 = <code>(1234/10000)*10000 + min(235, 1000) (对应1000,1001,...1234) = 235</code></p>
<p>因此，总数 = 124+130+200+235 = 689。</p>
<p>算法实现：</p>
<ul>
<li>将 i 从 1 遍历到 n，每次遍历 i 扩大 10 倍：</li>
<li><code>(n/(i*10))*i</code> 表示 (i*10) 位上 ’1’ 的个数。</li>
<li><code>{min(max(({n mod (i*10)} )-i+1,0),i)}</code> 表示需要额外数的 (i*10) 位上 ’1’ 的个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">long</span> divider = i * <span class="hljs-number">10</span>;<br>        count += (n / divider) * i + Math.min(Math.max(n % divider - i + <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>), i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log10(n)),遍历的次数等于 n 转成字符串后字符串的长度，其值为 log10(n)。</li>
<li>空间复杂度：只需要 O(1) 的额外空间。</li>
</ul>
<h1 id="40-合并区间"><a href="#40-合并区间" class="headerlink" title="40. 合并区间"></a>40. 合并区间</h1><blockquote>
<p>Leecode：给出一个区间的集合，请合并所有重叠的区间</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:<br>输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></div></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">示例 <span class="hljs-number">2</span>:<br>输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></div></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>首先，我们将列表根据区间开始范围从小到大进行排序。然后，将第一个区间插入 merged 数组中，然后按顺序考虑之后的每个区间：如果当前区间的左端点在前一个区间的右端点之后，那么他们不会重合，可以直接将这个区间插入 merged 中；否则，他们重合，将当前区间的右端点更新为前一个区间的右端点 end 值和当前右端点值较大的一个，完成合并。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E5%9B%BE%E8%A7%A3.png" alt="合并区间图解"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeInterval</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">//从小到大排序</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br><br>        LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] interval : intervals) &#123;<br>            <span class="hljs-keyword">if</span>(list.isEmpty() || list.getLast()[<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]) &#123;<br>                list.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                list.getLast()[<span class="hljs-number">1</span>]  = Math.max(list.getLast()[<span class="hljs-number">1</span>],interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(nlogn)，除去 sort 的开销，只需要一次线性扫描，所以主要的时间开销是排序的 O(nlgn)</p>
</li>
<li><p>空间复杂度：O(1) (or O(n))，如果可以原地排序 intervals ，就不需要额外的存储空间；否则，就需要一个线性大小的空间去存储 intervals 的备份，来完成排序过程。</p>
</li>
</ul>
<h1 id="41-股票的最大利润"><a href="#41-股票的最大利润" class="headerlink" title="41. 股票的最大利润"></a>41. 股票的最大利润</h1><blockquote>
<p>Leecode：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">5</span><br>解释: 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span><span class="hljs-number">-1</span> = <span class="hljs-number">5</span> 。<br>     注意利润不能是 <span class="hljs-number">7</span><span class="hljs-number">-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></div></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出: <span class="hljs-number">0</span><br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></div></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            minPrice = Math.min(minPrice,prices[i]);<br>            maxProfit = Math.max(maxProfit,prices[i] - minPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
</ul>
<h1 id="42-顺时针打印矩阵"><a href="#42-顺时针打印矩阵" class="headerlink" title="42. 顺时针打印矩阵"></a>42. 顺时针打印矩阵</h1><blockquote>
<p>Leetcode:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br></code></pre></div></td></tr></table></figure>

<p><strong>解题思路</strong></p>
<ol>
<li><strong>空值处理</strong>： 当 <code>matrix</code> 为空时，直接返回空列表 <code>[]</code> 即可。</li>
<li><strong>初始化</strong>： 矩阵 左、右、上、下 四个边界 <code>l</code> ,<code>r</code> ,<code>t</code> ,<code>b</code> ，用于打印的结果列表 <code>res</code> 。</li>
<li><strong>循环打印</strong>： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；</li>
</ol>
<ul>
<li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li>
<li>边界向内收缩 1 （代表已被打印）；</li>
<li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li>
</ul>
<ol start="4">
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">打印方向</th>
<th>1. 根据边界打印</th>
<th>2. 边界向内收缩</th>
<th>3. 是否打印完毕</th>
</tr>
</thead>
<tbody><tr>
<td align="left">从左向右</td>
<td>左边界 <code>l</code> ，右边界 <code>r</code></td>
<td>上边界 <code>t</code> 加 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从上向下</td>
<td>上边界 <code>t</code> ，下边界 <code>b</code></td>
<td>右边界 <code>r</code> 减 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
<tr>
<td align="left">从右向左</td>
<td>右边界 <code>r</code> ，左边界 <code>l</code></td>
<td>下边界 <code>b</code> 减 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从下向上</td>
<td>下边界 <code>b</code> ，上边界 <code>t</code></td>
<td>左边界 l 加 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xm.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiralOrder</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span> || matrix == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">//左边界</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//右边界</span><br>        <span class="hljs-keyword">int</span> r = matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//上边界</span><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//下边界</span><br>        <span class="hljs-keyword">int</span> b = matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//输出结果集</span><br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(r+<span class="hljs-number">1</span>) * (b+<span class="hljs-number">1</span>)];<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//从左到右遍历</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) &#123;<br>                result[x++] = matrix[t][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(++t &gt; b) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//从上到下遍历</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t; i &lt;= b; i++) &#123;<br>                result[x++] = matrix[i][r];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(--r &lt; l) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//从右往左遍历</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r; i &gt;= l; i--) &#123;<br>                result[x++] = matrix[b][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(--b &lt; t) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//从下往上遍历</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b; i &gt;= t; i--) &#123;<br>                result[x++] = matrix[i][l];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(++l &gt; r) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度 <code>O(MN)</code> ： M,N 分别为矩阵行数和列数。</li>
<li>空间复杂度 <code>O(1)</code> ： 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> 使用常数大小的额外空间（ <code>res</code> 为必须使用的空间）。</li>
</ul>
<h1 id="43-滑动窗口的最大值"><a href="#43-滑动窗口的最大值" class="headerlink" title="43. 滑动窗口的最大值"></a>43. 滑动窗口的最大值</h1><blockquote>
<p>Leecode：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
</blockquote>
<p>返回滑动窗口中的最大值。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], 和 k = <span class="hljs-number">3</span><br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[<span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>] <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> [<span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>] <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span> [<span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>] <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span> [<span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>] <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span> [<span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] <span class="hljs-number">7</span>       <span class="hljs-number">6</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span> [<span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]      <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>动态规划：算法的思想是将输入数组分割成有 k 个元素的块。若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p>
<p>开头元素为 i ，结尾元素为 j 的当前滑动窗口可能在一个块内，也可能在两个块中。</p>
<p>建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向左-&gt;右。<br>建立数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向右-&gt;左。</p>
<p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 i 到下标 j 的滑动窗口。 根据定义，<code>right[i]</code> 是左侧块内的最大元素， <code>left[j]</code> 是右侧块内的最大元素。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="滑动窗口的最大值"></p>
<p>算法流程如下：</p>
<ol>
<li>从左到右遍历数组，建立数组 left。</li>
<li>从右到左遍历数组，建立数组 right。</li>
<li>建立输出数组 <code>max(right[i], left[i + k - 1])，其中 i 取值范围为 (0, n - k + 1)</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n * k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br><br>    <span class="hljs-keyword">int</span> [] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    left[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> [] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    right[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-comment">// from left to right</span><br>      <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) left[i] = nums[i];  <span class="hljs-comment">// block_start</span><br>      <span class="hljs-keyword">else</span> left[i] = Math.max(left[i - <span class="hljs-number">1</span>], nums[i]);<br><br>      <span class="hljs-comment">// from right to left</span><br>      <span class="hljs-keyword">int</span> j = n - i - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>) right[j] = nums[j];  <span class="hljs-comment">// block_end</span><br>      <span class="hljs-keyword">else</span> right[j] = Math.max(right[j + <span class="hljs-number">1</span>], nums[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> [] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k + <span class="hljs-number">1</span>; i++)<br>      output[i] = Math.max(left[i + k - <span class="hljs-number">1</span>], right[i]);<br><br>    <span class="hljs-keyword">return</span> output;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="44-从前序与中序遍历序列构造二叉树"><a href="#44-从前序与中序遍历序列构造二叉树" class="headerlink" title="44. 从前序与中序遍历序列构造二叉树"></a>44. 从前序与中序遍历序列构造二叉树</h1><blockquote>
<p>剑指offer第7题</p>
</blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意: 可以假设树中没有重复的元素。</p>
<p>例如，给出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">前序遍历 preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>中序遍历 inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br></code></pre></div></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">3</span><br> / \<br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  \<br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>根据前序遍历结果，首节点一定是根结点，在中序遍历中找到根结点，根节点左边的都是左子树，根结点右边的都是右子树。</p>
<p>另外，由于是遍历同一颗树，所以左子树和右子树的节点数量是相同的。利用这个关系，可以定义出如下边界：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="从前序和中序遍历序列构造二叉树"></p>
<p>接下来就只需要分别递归构建左右子树即可：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RebuildBinaryTree</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> preLen = preorder.length;<br>        <span class="hljs-keyword">int</span> inLen = inorder.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;(inLen);<br>        <span class="hljs-comment">// 构造中序遍历中根结点和下标的映射关系</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inLen; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, preLen - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inLen - <span class="hljs-number">1</span>, map);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 递归构建二叉树<br>     * <span class="hljs-doctag">@param</span> preorder 前序遍历结果<br>     * <span class="hljs-doctag">@param</span> preLeft 当前前序遍历根结点（当前遍历的最左边界）<br>     * <span class="hljs-doctag">@param</span> preRight 当前前序遍历的最又边界<br>     * <span class="hljs-doctag">@param</span> inLeft 当前中序遍历的最左边界<br>     * <span class="hljs-doctag">@param</span> inRight 当前中序遍历的最右边界<br>     * <span class="hljs-doctag">@param</span> map 存储根结点在中序遍历的映射关系<br>     * <span class="hljs-doctag">@return</span> 二叉树<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preLeft, <span class="hljs-keyword">int</span> preRight,<br>                               <span class="hljs-keyword">int</span> inLeft, <span class="hljs-keyword">int</span> inRight, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode head = <span class="hljs-keyword">new</span> TreeNode(preorder[preLeft]);<br>        Integer pIndex = map.get(preorder[preLeft]);<br>        head.left = buildTree(preorder, preLeft + <span class="hljs-number">1</span>, pIndex - inLeft + preLeft,<br>                inLeft, pIndex - <span class="hljs-number">1</span>, map);<br>        head.right = buildTree(preorder, pIndex - inLeft + preLeft + <span class="hljs-number">1</span>,<br>                preRight, pIndex + <span class="hljs-number">1</span>, inRight, map);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：<code>O(n)</code>，其中 n 是树中的节点个数。</li>
<li>空间复杂度：<code>O(n)</code>，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 <code>h &lt; n</code>，所以（在最坏情况下）总空间复杂度为 <code>O(n)</code>。</li>
</ul>
<h1 id="45-矩阵中的路径"><a href="#45-矩阵中的路径" class="headerlink" title="45. 矩阵中的路径"></a>45. 矩阵中的路径</h1><blockquote>
<p>剑指 offer 12 题</p>
</blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"e"</span>],<br>[<span class="hljs-string">"s"</span>,<span class="hljs-string">"f"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"s"</span>],<br>[<span class="hljs-string">"a"</span>,<span class="hljs-string">"d"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"e"</span>]]<br></code></pre></div></td></tr></table></figure>

<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"E"</span>],[<span class="hljs-string">"S"</span>,<span class="hljs-string">"F"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"S"</span>],[<span class="hljs-string">"A"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"E"</span>]], word = <span class="hljs-string">"ABCCED"</span><br>输出：true<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">board</span> = [[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>]], <span class="hljs-attr">word</span> = <span class="hljs-string">"abcd"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
</blockquote>
<h3 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h3><ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
<h3 id="算法剖析："><a href="#算法剖析：" class="headerlink" title="算法剖析："></a>算法剖析：</h3><ul>
<li><p><strong>递归参数：</strong> 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>
</li>
<li><p><strong>终止条件：</strong></p>
<ol>
<li><p><strong>返回 false：</strong> </p>
<p>① 行或列索引越界 <strong>或</strong> ② 当前矩阵元素与目标字符不同 <strong>或</strong> ③ 当前矩阵元素已访问过 <em>（③ 可合并至 ② ）</em> 。</p>
</li>
<li><p><strong>返回 true ：</strong> 字符串 <code>word</code> 已全部匹配，即 <code>k = len(word) - 1</code> 。</p>
</li>
</ol>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>标记当前矩阵元素：</strong> 将 <code>board[i][j]</code> 值暂存于变量 <code>tmp</code> ，并修改为字符 <code>&#39;/&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li><strong>搜索下一单元格：</strong> 朝当前元素的 <strong>上、下、左、右</strong> 四个方向开启下层递归，使用 <code>或</code> 连接 <em>（代表只需一条可行路径）</em> ，并记录结果至 <code>res</code> 。</li>
<li><strong>还原当前矩阵元素：</strong> 将 <code>tmp</code> 暂存值还原至 <code>board[i][j]</code> 元素。</li>
</ol>
</li>
<li><p><strong>回溯返回值：</strong> 返回 <code>res</code> ，代表是否搜索到目标字符串。</p>
</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt="剑指offer12题矩阵中的路径"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9B%9E%E6%BA%AF.png" alt="剑指offer12题矩阵中的路径回溯"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordSearchInMatrix</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] words = word.toCharArray();<br>        <span class="hljs-comment">// 这里遍历了任意开始的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (bfs(board, words, i, j, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">char</span>[] words, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//判断下标是否越界，值是否相等</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length<br>                || board[i][j] != words[k]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == words.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span> temp = board[i][j];<br>        board[i][j] = <span class="hljs-string">'/'</span>;<br>        <span class="hljs-comment">//深度递归遍历（顺序为下、上、右、左）</span><br>        <span class="hljs-keyword">boolean</span> res = bfs(board, words, i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || bfs(board, words, i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>)<br>                || bfs(board, words, i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || bfs(board, words, i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>);<br>        board[i][j] = temp;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="46-Z-字形变换"><a href="#46-Z-字形变换" class="headerlink" title="46. Z 字形变换"></a>46. Z 字形变换</h1><blockquote>
<p>leetcodee 第六题</p>
</blockquote>
<p>将一个给定字符串 s ，根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：(И字型)</p>
<figure class="highlight tp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tp"><span class="hljs-keyword">P</span>   A   H   N <br>A <span class="hljs-keyword">P</span> L S I I G<br><span class="hljs-keyword">Y</span>   I   <span class="hljs-keyword">R</span><br></code></pre></div></td></tr></table></figure>


<p>之后，输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>解题的思路关键在于想到这种方式：首先构造一个长度为 numRows 的数组，在数组中来回移动放入字符串的值，这样就满足了题目要求了。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>从这道题开始，因为工作需要，改用 go 实现代码了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">"strings"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convert</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, numRows <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-comment">// 行数大直接返回整个字符串</span><br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt;= numRows &#123;<br>		<span class="hljs-keyword">return</span> s<br>	&#125;<br>	<span class="hljs-comment">// 1. 初始化一个Builder数组</span><br>	resultArray := <span class="hljs-built_in">make</span>([]strings.Builder, numRows)<br>	<span class="hljs-comment">// 2. 指针在数组上来回移动赋值</span><br>	curPoint := <span class="hljs-number">0</span><br>	backPoint := <span class="hljs-literal">false</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>		resultArray[curPoint].WriteByte(s[i])<br>		<span class="hljs-comment">// 3. 到边界时反转</span><br>		<span class="hljs-keyword">if</span> curPoint == <span class="hljs-number">0</span> || curPoint == numRows<span class="hljs-number">-1</span> &#123;<br>			backPoint = !backPoint<br>		&#125;<br><br>		<span class="hljs-comment">// 当前所在的数组格子</span><br>		<span class="hljs-keyword">if</span> backPoint &#123;<br>			curPoint += <span class="hljs-number">1</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			curPoint -= <span class="hljs-number">1</span><br>		&#125;<br>	&#125;<br><br>	result := strings.Builder&#123;&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> resultArray &#123;<br>		result.WriteString(resultArray[i].String())<br>	&#125;<br>	<span class="hljs-keyword">return</span> result.String()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="47-字符串转整数"><a href="#47-字符串转整数" class="headerlink" title="47. 字符串转整数"></a>47. 字符串转整数</h1><blockquote>
<p>Leetcode 第 8 题</p>
</blockquote>
<p>请实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br> 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p>注意：本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。</p>
<p>示例 1：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">"42"</span><br>输出：<span class="hljs-number">42</span><br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">"42"</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">"42"</span>（当前没有读入字符，因为这里不存在 '-' 或者 '+'）<br>         ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">"42"</span>（读入 <span class="hljs-string">"42"</span>）<br>           ^<br>解析得到整数 <span class="hljs-number">42</span> 。<br>由于 <span class="hljs-string">"42"</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">42</span> 。<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">"   -42"</span><br>输出：<span class="hljs-number">-42</span><br>解释：<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">"   -42"</span>（读入前导空格，但忽视掉）<br>            ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">"   -42"</span>（读入 '-' 字符，所以结果应该是负数）<br>             ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">"   -42"</span>（读入 <span class="hljs-string">"42"</span>）<br>               ^<br>解析得到整数 <span class="hljs-number">-42</span> 。<br>由于 <span class="hljs-string">"-42"</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">-42</span> 。<br></code></pre></div></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">"4193 with words"</span><br>输出：<span class="hljs-number">4193</span><br>解释：<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">"4193 with words"</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">"4193 with words"</span>（当前没有读入字符，因为这里不存在 '-' 或者 '+'）<br>         ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">"4193 with words"</span>（读入 <span class="hljs-string">"4193"</span>；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 <span class="hljs-number">4193</span> 。<br>由于 <span class="hljs-string">"4193"</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">4193</span> 。<br></code></pre></div></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">"words and 987"</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">"words and 987"</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">"words and 987"</span>（当前没有读入字符，因为这里不存在 '-' 或者 '+'）<br>         ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">"words and 987"</span>（由于当前字符 'w' 不是一个数字，所以读入停止）<br>         ^<br>解析得到整数 <span class="hljs-number">0</span> ，因为没有读入任何数字。<br>由于 <span class="hljs-number">0</span> 在范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 内，最终结果为 <span class="hljs-number">0</span> 。<br></code></pre></div></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">"-91283472332"</span><br>输出：<span class="hljs-number">-2147483648</span><br>解释：<br>第 <span class="hljs-number">1</span> 步：<span class="hljs-string">"-91283472332"</span>（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 <span class="hljs-number">2</span> 步：<span class="hljs-string">"-91283472332"</span>（读入 '-' 字符，所以结果应该是负数）<br>          ^<br>第 <span class="hljs-number">3</span> 步：<span class="hljs-string">"-91283472332"</span>（读入 <span class="hljs-string">"91283472332"</span>）<br>                     ^<br>解析得到整数 <span class="hljs-number">-91283472332</span> 。<br>由于 <span class="hljs-number">-91283472332</span> 小于范围 [<span class="hljs-number">-231</span>, <span class="hljs-number">231</span> - <span class="hljs-number">1</span>] 的下界，最终结果被截断为 <span class="hljs-number">-231</span> = <span class="hljs-number">-2147483648</span> 。<br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题有两种解题思路，第一种比较直接，就是挨个字符进行判断，需要考虑各种边界条件。</p>
<p>比较简洁的方法是使用自动状态机的方式，本题可以建立如下的状态机：</p>
<p>也可以用下面的表格来表示这个自动机：</p>
<table>
<thead>
<tr>
<th></th>
<th>‘’</th>
<th>+/-</th>
<th>number</th>
<th>other</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>start</td>
<td>signed</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>signed</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>in_number</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>end</td>
<td>end</td>
<td>end</td>
<td>end</td>
<td>end</td>
</tr>
</tbody></table>
<p>接下来编程部分就非常简单了：只需要把上面这个状态转换表抄进代码即可。</p>
<p>另外自动机也需要记录当前已经输入的数字，只要在 s’ 为 in_number 时，更新输入的数字，即可最终得到输入的数字。</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="方法一：考虑各种边界的解法"><a href="#方法一：考虑各种边界的解法" class="headerlink" title="方法一：考虑各种边界的解法"></a>方法一：考虑各种边界的解法</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>		ret         <span class="hljs-keyword">int32</span> <span class="hljs-comment">// 结果</span><br>		isNegative  <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否负数</span><br>		signed      <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否已经出现过'+'，'-'</span><br>		isStartZero <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否0开头，再出现'-'，'+'，return 0</span><br>	)<br>	s = strings.TrimSpace(s)<br><br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>		<span class="hljs-comment">// 如果是以0开头并且是第一个数字，还要满足前面没有正负符号，比如 000+100 这种就不行</span><br>		<span class="hljs-keyword">if</span> v == <span class="hljs-string">'0'</span> &amp;&amp; ret == <span class="hljs-number">0</span> &amp;&amp; !signed &#123;<br>			isStartZero = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 0 开头再出现正负，直接返回</span><br>		<span class="hljs-keyword">if</span> isStartZero &amp;&amp; (v == <span class="hljs-string">'+'</span> || v == <span class="hljs-string">'-'</span>) &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-comment">// 第一次出现正负符号，标记，下次再出现就 break</span><br>		<span class="hljs-keyword">if</span> v == <span class="hljs-string">'+'</span> &amp;&amp; !signed &#123;<br>			signed = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 例如 "123-"</span><br>		<span class="hljs-keyword">if</span> v == <span class="hljs-string">'-'</span> &amp;&amp; !signed &amp;&amp; ret == <span class="hljs-number">0</span>&#123;<br>			signed = <span class="hljs-literal">true</span><br>			isNegative = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 不符合条件，break 掉</span><br>		<span class="hljs-keyword">if</span> v &lt; <span class="hljs-string">'0'</span> || v &gt; <span class="hljs-string">'9'</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-comment">// 计算边界（ ret*10+v &lt; int32Max || -(ret*10 -v ) &gt; int32Min</span><br>		<span class="hljs-keyword">if</span> isNegative &#123;<br>			<span class="hljs-comment">// 化开防止溢出</span><br>			<span class="hljs-keyword">if</span> -ret &lt; (math.MinInt32+(v-<span class="hljs-string">'0'</span>))/<span class="hljs-number">10</span> &#123;<br>				ret = math.MinInt32<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">if</span> ret &gt; (math.MaxInt32-(v-<span class="hljs-string">'0'</span>))/<span class="hljs-number">10</span> &#123;<br>				ret = math.MaxInt32<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>		ret = ret*<span class="hljs-number">10</span> + (v - <span class="hljs-string">'0'</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> isNegative &#123;<br>		ret = -ret<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(ret)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="方法二：状态机解法"><a href="#方法二：状态机解法" class="headerlink" title="方法二：状态机解法"></a>方法二：状态机解法</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Automaton 状态机解法</span><br><span class="hljs-keyword">type</span> Automaton <span class="hljs-keyword">struct</span> &#123;<br>	Sign   <span class="hljs-keyword">int</span><br>	Status <span class="hljs-keyword">string</span><br>	Ret    <span class="hljs-keyword">int64</span><br><br>	table <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span> <span class="hljs-comment">// 状态表</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initAutomaton</span><span class="hljs-params">()</span> <span class="hljs-title">Automaton</span></span> &#123;<br>	<span class="hljs-keyword">return</span> Automaton&#123;<br>		Sign:   <span class="hljs-number">1</span>,<br>		Status: <span class="hljs-string">"start"</span>,<br>		Ret:    <span class="hljs-number">0</span>,<br>		table: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>&#123;<br>			<span class="hljs-string">"start"</span>:     &#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"signed"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;,<br>			<span class="hljs-string">"signed"</span>:    &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;,<br>			<span class="hljs-string">"in_number"</span>: &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;,<br>			<span class="hljs-string">"end"</span>:       &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>&#125;,<br>		&#125;,<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Automaton)</span> <span class="hljs-title">get</span><span class="hljs-params">(c <span class="hljs-keyword">uint8</span>)</span></span> &#123;<br>	a.Status = a.table[a.Status][getCol(c)]<br>	<span class="hljs-keyword">if</span> a.Status == <span class="hljs-string">"in_number"</span> &#123;<br>		a.Ret = a.Ret*<span class="hljs-number">10</span> + <span class="hljs-keyword">int64</span>(c-<span class="hljs-string">'0'</span>)<br>		<span class="hljs-keyword">if</span> a.Sign == <span class="hljs-number">1</span> &#123;<br>			a.Ret = min(a.Ret, math.MaxInt32)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			a.Ret = min(a.Ret, -math.MinInt32)<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a.Status == <span class="hljs-string">"signed"</span> &#123;<br>		<span class="hljs-keyword">if</span> c == <span class="hljs-string">'+'</span> &#123;<br>			a.Sign = <span class="hljs-number">1</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			a.Sign = <span class="hljs-number">-1</span><br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCol</span><span class="hljs-params">(c <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">if</span> c == <span class="hljs-string">' '</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">int64</span></span> &#123;<br>	<span class="hljs-keyword">if</span> a &gt;= b &#123;<br>		<span class="hljs-keyword">return</span> b<br>	&#125;<br>	<span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    automaton := initAutomaton()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>		automaton.get(s[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> automaton.Sign * <span class="hljs-keyword">int</span>(automaton.Ret)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="48-盛最多水的容器"><a href="#48-盛最多水的容器" class="headerlink" title="48. 盛最多水的容器"></a>48. 盛最多水的容器</h1><blockquote>
<p>Leetcode 11 题 </p>
</blockquote>
<p>给 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：不能倾斜容器。</p>
<p>示例1:</p>
<p><img src="https://qiniu.xiaoming.net.cn/leetcode%20%E5%AE%B9%E9%87%8F%E6%9C%80%E5%A4%9A.jpg" alt="leetcode 容量最多"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></div></td></tr></table></figure>

<p>示例2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p>示例3:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：height = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure>

<p>示例4:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题需要使用双指针的解法（第一次看到这道题完全没思路…）。</p>
<p>题目中的示例为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br> ^                       ^<br></code></pre></div></td></tr></table></figure>


<p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 <code>min(1,7)∗8=8</code>。</p>
<p>此时我们需要移动一个指针。移动哪一个呢？应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由 <code>两个指针指向的数字中较小值 * 指针之间的距离</code>决定的。如果我们移动数字较大的那个指针，<strong>那么前者<code>两个指针指向的数字中较小值</code>不会增加，后者<code>指针之间的距离</code>会减小，那么这个乘积会减小</strong>。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动数字较小的那个指针。</p>
<p>所以，我们将左指针向右移动：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br>    ^                    ^<br></code></pre></div></td></tr></table></figure>

<p>此时可以容纳的水量为 <code>min(8,7)∗7=49</code>。由于右指针对应的数字较小，我们移动右指针：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br>    ^                 ^<br></code></pre></div></td></tr></table></figure>

<p>此时可以容纳的水量为<code>min(8,3)∗6=18</code>。由于右指针对应的数字较小，我们移动右指针：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br>    ^              ^<br></code></pre></div></td></tr></table></figure>

<p>此时可以容纳的水量为 <code>min(8,8)∗5=40</code>。两指针对应的数字相同，我们可以任意移动一个，例如左指针：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br>       ^           ^<br></code></pre></div></td></tr></table></figure>


<p>此时可以容纳的水量为 <code>min(6,8)∗4=24</code>。由于左指针对应的数字较小，我们移动左指针，并且可以发现，<strong>在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合</strong>。在这期间，对应的可以容纳的水量为：<code>min(2,8)∗3=6</code>，<code>min(5,8)∗2=10</code>，<code>min(4,8)∗1=4</code>。</p>
<p>在我们移动指针的过程中，计算到的最多可以容纳的数量为 4949，即为最终的答案。</p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-comment">// 声明左右指针</span><br>	lp := <span class="hljs-number">0</span><br>	rp := <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>	<span class="hljs-comment">// 初始化最大容量</span><br>	maxContain := <span class="hljs-number">0</span><br><br>	<span class="hljs-comment">// for循环直到左右指针重合</span><br>	<span class="hljs-keyword">for</span> lp != rp &#123;<br>		<span class="hljs-comment">// 计算容量</span><br>		curContain := math.Min(<span class="hljs-keyword">float64</span>(height[lp]), <span class="hljs-keyword">float64</span>(height[rp])) * <span class="hljs-keyword">float64</span>(rp-lp)<br>		maxContain = <span class="hljs-keyword">int</span>(math.Max(<span class="hljs-keyword">float64</span>(maxContain), curContain))<br><br>		<span class="hljs-comment">// 移动对应数值较小的指针</span><br>		<span class="hljs-keyword">if</span> height[lp] &lt; height[rp] &#123;<br>			lp++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			rp--<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxContain<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="49-三数之和"><a href="#49-三数之和" class="headerlink" title="49. 三数之和"></a>49. 三数之和</h1><blockquote>
<p>leetcode 第 15 题</p>
</blockquote>
<p>给一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]<br>输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></div></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中要求找到所有不重复且和为 0 的三元组，这个“不重复”的要求使得我们<strong>无法简单地使用三重循环枚举所有的三元组</strong>。这是因为在最坏的情况下，数组中的元素全部为 0，即：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure>


<p>任意一个三元组的和都为 0。如果直接使用三重循环枚举三元组，会得到 <code>O(N^3)</code> 个满足题目要求的三元组（其中 N 是数组的长度）,时间复杂度至少为 <code>O(N^3)</code>。在这之后，还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p>
<p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p>
<ul>
<li><p><strong>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素</strong>；</p>
</li>
<li><p><strong>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素</strong>。</p>
</li>
</ul>
<p>也就是说，枚举的三元组 (a, b, c)满足 <code>a≤b≤c</code>，保证了只有(a,b,c) 这个顺序会被枚举到，而(b,a,c)、(c,b,a) 等等这些不会，这样就减少了重复。要实现这一点，可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p>
<p>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br> ^  ^  ^<br></code></pre></div></td></tr></table></figure>


<p>我们使用三重循环枚举到的第一个三元组为 (0,1,2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0,1,2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0,1,3)。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pseudocode">nums.sort()<br>for first = 0 .. n-1<br>    // 只有和上一次枚举的元素不相同，我们才会进行枚举<br>    if first == 0 or nums[first] != nums[first-1] then<br>        for second = first+1 .. n-1<br>            if second == first+1 or nums[second] != nums[second-1] then<br>                for third = second+1 .. n-1<br>                    if third == second+1 or nums[third] != nums[third-1] then<br>                        // 判断是否有 a+b+c==0<br>                        check(first, second, third)<br></code></pre></div></td></tr></table></figure>

<p>这种方法的时间复杂度仍然为 <code>O(N^3)</code>，毕竟还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，可以发现，如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 a+b+c=0。当第二重循环往后枚举一个元素 b’ 时，由于 b’ &gt; b，那么满足 a+b’+c’=0 的 c’ 一定有 c’ &lt; c，即 c’ 在数组中一定出现在 c 的左侧。也就是说，我们<strong>可以从小到大枚举 b，同时从大到小枚举 c ，即第二重循环和第三重循环实际上是并列的关系</strong>。</p>
<p>有了这样的发现，我们就可以保持第二重循环不变，而将<strong>第三重循环变成一个从数组最右端开始向左移动的指针</strong>，从而得到下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pseudocode">nums.sort()<br>for first = 0 .. n-1<br>    if first == 0 or nums[first] != nums[first-1] then<br>        // 第三重循环对应的指针<br>        third = n-1<br>        for second = first+1 .. n-1<br>            if second == first+1 or nums[second] != nums[second-1] then<br>                // 向左移动指针，直到 a+b+c 不大于 0<br>                while nums[first]+nums[second]+nums[third] &gt; 0<br>                    third = third-1<br>                // 判断是否有 a+b+c==0<br>                check(first, second, third)<br></code></pre></div></td></tr></table></figure>

<p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 <code>O(N^2)</code> 减少至 O(N)。为什么是 O(N)呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 <code>O(N)</code>，<strong>均摊下来</strong>，每次也向左移动一个位置，因此时间复杂度为 <code>O(N)</code>。</p>
<p>注意到我们的伪代码中还有第一重循环，时间复杂度为 <code>O(N)</code>，因此枚举的总时间复杂度为 <code>O(N^2)</code>。由于排序的时间复杂度为 <code>O(N \log N)</code>，在渐进意义下小于前者，因此算法的总时间复杂度为 <code>O(N^2)</code>。</p>
<p>上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足 <code>b*≤*c</code>），具体可以参考下面的代码，均给出了详细的注释。</p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">var</span> ret [][]<span class="hljs-keyword">int</span><br>	length := <span class="hljs-built_in">len</span>(nums)<br>	sort.Ints(nums)<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>		<span class="hljs-comment">// 跟上一次相同的值可以跳过</span><br>		<span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 双指针遍历，这里左指针是j，右指针是k</span><br>		k := length - <span class="hljs-number">1</span><br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>			<span class="hljs-comment">// 同样，跟上一次相同就略过，只需要看不同的</span><br>			<span class="hljs-keyword">if</span> j != i+<span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// 保持左指针不大于右指针，注意这里要大于0，如果已经小于0那就跳过了，后面都会一直小于0</span><br>			<span class="hljs-keyword">for</span> j &lt; k &amp;&amp; nums[i]+nums[j]+nums[k] &gt; <span class="hljs-number">0</span> &#123;<br>				k--<br>			&#125;<br>			<span class="hljs-comment">// 如果指针重合，由于在 a 不变的情况下，随着 b 的增加，c 只能减少，所以后续不会再有 a+b+c=0</span><br>			<span class="hljs-comment">// 此时可以退出本次循环</span><br>			<span class="hljs-keyword">if</span> j == k &#123;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>			<span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="hljs-number">0</span> &#123;<br>				ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="50-最接近的三数之和"><a href="#50-最接近的三数之和" class="headerlink" title="50. 最接近的三数之和"></a>50. 最接近的三数之和</h1><blockquote>
<p>Leetcode 第 16 题</p>
</blockquote>
<p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-4</span>], target = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">2</span><br>解释：与 target 最接近的和是 <span class="hljs-number">2</span> (<span class="hljs-number">-1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>) 。<br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题最简单的思路就是直接暴力破解。但是更好的解法也是和上面的三数之和一样，采用双指针夹逼的方式来遍历，所以首先需要先让数组有序。具体思路参考上一题。</p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 双指针夹逼法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-comment">// 记录最接近的和（不要用MaxInt64，防止没有空间导致溢出）</span><br>	closest := math.MaxInt32<br>	<span class="hljs-comment">// 生序排序</span><br>	sort.Ints(nums)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; i++ &#123;<br>		<span class="hljs-comment">// 保证和上一次枚举的元素不相等</span><br>		<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		lp, rp := i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>		<span class="hljs-comment">// 保证左指针小于右指针</span><br>		<span class="hljs-keyword">for</span> lp &lt; rp &#123;<br>			<span class="hljs-comment">// 如果和为 target 直接返回答案</span><br>			sum := nums[i] + nums[lp] + nums[rp]<br>			<span class="hljs-keyword">if</span> sum == target &#123;<br>				<span class="hljs-keyword">return</span> sum<br>			&#125;<br>			<span class="hljs-keyword">if</span> abs(sum-target) &lt; abs(closest-target) &#123;<br>				closest = sum<br>			&#125;<br>			<span class="hljs-comment">// 相同数直接跳过</span><br>			<span class="hljs-keyword">if</span> sum &lt; target &#123;<br>				lp++<br>				<span class="hljs-keyword">for</span> lp &lt; rp &amp;&amp; nums[lp] == nums[lp<span class="hljs-number">-1</span>] &#123;<br>					lp++<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				rp--<br>				<span class="hljs-keyword">for</span> lp &lt; rp &amp;&amp; nums[rp] == nums[rp+<span class="hljs-number">1</span>] &#123;<br>					rp--<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> closest<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * x<br>	&#125;<br>	<span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2)，其中 N 是数组 <code>nums</code> 的长度。我们首先需要 O<em>(</em>N<em>log*N) 的时间对数组进行排序，随后在枚举的过程中，使用一重循环 O(N) 枚举 a，双指针 O(N) 枚举 b 和 c，故一共是 O</em>(*N2)。</li>
<li>空间复杂度 O<em>(log*N)。排序需要使用 O</em>(log*N) 的空间。然而我们修改了输入的数组nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums 的副本并进行排序，此时空间复杂度为 O(N)。</li>
</ul>
<h1 id="51-整数转罗马数字"><a href="#51-整数转罗马数字" class="headerlink" title="51. 整数转罗马数字"></a>51. 整数转罗马数字</h1><blockquote>
<p>Leetcode 第 12 题</p>
</blockquote>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">字符          数值<br>I             <span class="hljs-number">1</span><br>V             <span class="hljs-number">5</span><br>X             <span class="hljs-number">10</span><br>L             <span class="hljs-number">50</span><br>C             <span class="hljs-number">100</span><br>D             <span class="hljs-number">500</span><br>M             <span class="hljs-number">1000</span><br></code></pre></div></td></tr></table></figure>


<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p>
</li>
<li><p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </p>
</li>
<li><p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
</li>
</ul>
<p>给一个整数，将其转为罗马数字。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E6%98%A0%E5%B0%84.png" alt="罗马数字映射"></p>
<p>用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，<strong>选择尽可能大的符号值</strong>。对于 140，最大可以选择的符号值为 <code>C=100</code>。接下来，对于剩余的数字 40，最大可以选择的符号值为 <code>XL=40</code>。因此，140 的对应的罗马数字为 <code>C+XL=CXL</code>。</p>
<p>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，<strong>寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至  num 为 0</strong>。最后得到的字符串即为 num 的罗马数字表示。</p>
<p>编程时，可以建立一个数值-符号对的列表，<strong>按数值从大到小排列</strong>。遍历映射表中的每个数值-符号对，若当前数值 value 不超过 num，则从  num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。</p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 罗马数字与数字的映射关系</span><br><span class="hljs-keyword">var</span> numRomanMap = []<span class="hljs-keyword">struct</span> &#123;<br>	value  <span class="hljs-keyword">int</span><br>	symbol <span class="hljs-keyword">string</span><br>&#125;&#123;<br>	&#123;<span class="hljs-number">1000</span>, <span class="hljs-string">"M"</span>&#125;,<br>	&#123;<span class="hljs-number">900</span>, <span class="hljs-string">"CM"</span>&#125;,<br>	&#123;<span class="hljs-number">500</span>, <span class="hljs-string">"D"</span>&#125;,<br>	&#123;<span class="hljs-number">400</span>, <span class="hljs-string">"CD"</span>&#125;,<br>	&#123;<span class="hljs-number">100</span>, <span class="hljs-string">"C"</span>&#125;,<br>	&#123;<span class="hljs-number">90</span>, <span class="hljs-string">"XC"</span>&#125;,<br>	&#123;<span class="hljs-number">50</span>, <span class="hljs-string">"L"</span>&#125;,<br>	&#123;<span class="hljs-number">40</span>, <span class="hljs-string">"XL"</span>&#125;,<br>	&#123;<span class="hljs-number">10</span>, <span class="hljs-string">"X"</span>&#125;,<br>	&#123;<span class="hljs-number">9</span>, <span class="hljs-string">"IX"</span>&#125;,<br>	&#123;<span class="hljs-number">5</span>, <span class="hljs-string">"V"</span>&#125;,<br>	&#123;<span class="hljs-number">4</span>, <span class="hljs-string">"IV"</span>&#125;,<br>	&#123;<span class="hljs-number">1</span>, <span class="hljs-string">"I"</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">var</span> ret []<span class="hljs-keyword">byte</span><br>	<span class="hljs-comment">// 循环映射表，以此减去最大的部分</span><br>	<span class="hljs-keyword">for</span> _, nummap := <span class="hljs-keyword">range</span> numRomanMap &#123;<br>		<span class="hljs-keyword">for</span> num &gt;= nummap.value &#123;<br>			ret = <span class="hljs-built_in">append</span>(ret,nummap.symbol...)<br>			num = num-nummap.value<br>		&#125;<br>		<span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(ret)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(ret)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)。由于映射表的长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3，因此循环次数有一个确定的上限。对于本题给出的数据范围，循环次数不会超过 15 次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="52-电话号码的字母组合"><a href="#52-电话号码的字母组合" class="headerlink" title="52. 电话号码的字母组合"></a>52. 电话号码的字母组合</h1><blockquote>
<p>Leetcode 17 题</p>
</blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%89%8B%E6%9C%BA9%E9%94%AE%E5%AD%97%E6%AF%8D.png" alt="手机9键字母"></p>
<p>示例 1：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">"23"</span><br>输出：[<span class="hljs-string">"ad"</span>,<span class="hljs-string">"ae"</span>,<span class="hljs-string">"af"</span>,<span class="hljs-string">"bd"</span>,<span class="hljs-string">"be"</span>,<span class="hljs-string">"bf"</span>,<span class="hljs-string">"cd"</span>,<span class="hljs-string">"ce"</span>,<span class="hljs-string">"cf"</span>]<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">""</span><br>输出：[]<br></code></pre></div></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">"2"</span><br>输出：[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>]<br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题在一看到<strong>要求拿到全部组合</strong>的时候，就应该联想到广度优先和深度优先这两种遍历的思路。</p>
<p>深度优先的解法就是通过递归来进行，而广度优先则是借助于队列来实现。</p>
<h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> phoneMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br>	<span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>,<br>	<span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>,<br>	<span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>,<br>	<span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>,<br>	<span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>,<br>	<span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>,<br>	<span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>,<br>	<span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> results []<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 深度优先</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations1</span><span class="hljs-params">(digits <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-keyword">string</span>&#123;&#125;<br>	&#125;<br>	results = []<span class="hljs-keyword">string</span>&#123;&#125;<br>	recursion(digits,<span class="hljs-number">0</span>,<span class="hljs-string">""</span>)<br>	<span class="hljs-keyword">return</span> results<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recursion</span><span class="hljs-params">(digits <span class="hljs-keyword">string</span>, index <span class="hljs-keyword">int</span>, currentResult <span class="hljs-keyword">string</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(digits) &#123;<br>		results = <span class="hljs-built_in">append</span>(results, currentResult)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	currentNum := <span class="hljs-keyword">string</span>(digits[index])<br>	chars := phoneMap[currentNum]<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(chars); i++ &#123;<br>		recursion(digits, index+<span class="hljs-number">1</span>, currentResult+<span class="hljs-keyword">string</span>(chars[i]))<br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 广度优先</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations2</span><span class="hljs-params">(digits <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-keyword">string</span>&#123;&#125;<br>	<br>	resultQueue  := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">""</span>&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(digits); i++ &#123;<br>		currentNum := <span class="hljs-keyword">string</span>(digits[i])<br>		chars := phoneMap[currentNum]<br>		currentQueueLen := <span class="hljs-built_in">len</span>(resultQueue)<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; currentQueueLen; j++ &#123;<br>			tmpResult := resultQueue[<span class="hljs-number">0</span>]<br>			resultQueue = resultQueue[<span class="hljs-number">1</span>:]<br>			<span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(chars); k++ &#123;<br>				resultQueue = <span class="hljs-built_in">append</span>(resultQueue,tmpResult + <span class="hljs-keyword">string</span>(chars[k]))<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> resultQueue<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="53-四数之和"><a href="#53-四数之和" class="headerlink" title="53. 四数之和"></a>53. 四数之和</h1><blockquote>
<p>leetcode 第 18 题</p>
</blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a、b、c 和 d 互不相同</code></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">0</span><br>输出：[[<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></div></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]]<br></code></pre></div></td></tr></table></figure>

<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的思路跟三数之和类似，也是采用排序加双指针的方式来解题，不同在于其外层有两个循环，因为是四个数的和。</p>
<h2 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">var</span> ret [][]<span class="hljs-keyword">int</span><br>	sort.Ints(nums)<br>	n := <span class="hljs-built_in">len</span>(nums)<br><br>	<span class="hljs-comment">// 第一重循环</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-3</span> &amp;&amp; nums[i]+nums[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]+nums[i+<span class="hljs-number">3</span>] &lt;= target; i++ &#123;<br>		<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] || nums[i]+nums[n<span class="hljs-number">-3</span>]+nums[n<span class="hljs-number">-2</span>]+nums[n<span class="hljs-number">-1</span>] &lt; target &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 第二重循环</span><br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n<span class="hljs-number">-2</span> &amp;&amp; nums[i]+nums[j]+nums[j+<span class="hljs-number">1</span>]+nums[j+<span class="hljs-number">2</span>] &lt;= target; j++ &#123;<br>			<span class="hljs-keyword">if</span> j &gt; i+<span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] || nums[i]+nums[j]+nums[n<span class="hljs-number">-2</span>]+nums[n<span class="hljs-number">-1</span>] &lt; target &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// 左指针</span><br>			<span class="hljs-keyword">for</span> lp := j + <span class="hljs-number">1</span>; lp &lt; n<span class="hljs-number">-1</span> &amp;&amp; nums[i]+nums[j]+nums[lp]+nums[lp+<span class="hljs-number">1</span>] &lt;= target; lp++ &#123;<br>				<span class="hljs-keyword">if</span> lp &gt; j+<span class="hljs-number">1</span> &amp;&amp; nums[lp] == nums[lp<span class="hljs-number">-1</span>] || nums[i]+nums[j]+nums[lp]+nums[n<span class="hljs-number">-1</span>] &lt; target &#123;<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>				rp := n - <span class="hljs-number">1</span> <span class="hljs-comment">// 右指针</span><br>				<span class="hljs-keyword">for</span> rp &gt; lp &amp;&amp; (nums[i]+nums[j]+nums[lp]+nums[rp] &gt; target) &#123;<br>					rp--<br>				&#125;<br>				<span class="hljs-keyword">if</span> lp == rp &#123;<br>					<span class="hljs-keyword">break</span><br>				&#125;<br>				<span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[lp]+nums[rp] == target &#123;<br>					ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;nums[i], nums[j], nums[lp], nums[rp]&#125;)<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<code>O(n^3)</code>，其中 n 是数组的长度。排序的时间复杂度是 <code>O(nlogn)</code>，枚举四元组的时间复杂度是 O<em>(</em>n3)，因此总时间复杂度为 O(n^3+n log n)=<em>O</em>(n^3)。</li>
<li>空间复杂度：O<em>(log*n)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O</em>(*n)。</li>
</ul>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://blog.csdn.net/CleverCode/article/details/81743736" target="_blank" rel="noopener">100G 数据，只有 100M 内存，怎么排序</a><br><a href="https://blog.csdn.net/u014106566/article/details/101224875" target="_blank" rel="noopener">求比n小的一个数，使其各位数的乘积最大</a><br><a href="https://www.nowcoder.com/discuss/383652?type=all&order=time&pos=&page=1" target="_blank" rel="noopener">牛客网——腾讯WXG后端一面面经</a><br><a href="https://blog.csdn.net/You_are_my_dream/article/details/55005158" target="_blank" rel="noopener">完全二叉树的叶子节点总数问题</a><br><a href="https://www.cnblogs.com/kubidemanong/p/10834993.html" target="_blank" rel="noopener">【面试被虐】说说游戏中的敏感词过滤是如何实现的？</a> </p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/11/08/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%20Spring/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaSpring</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/10/28/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="hidden-mobile">数据结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'xiao-ming9/xiao-ming9.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备18114217号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=粤ICP备18114217号-1"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" alt="police-icon"/>
            
            <span>粤ICP备18114217号-1</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?54ebb03ad7ad5b762ac8ff7958df6d3f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-M2RT7SDT3L', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M2RT7SDT3L"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-M2RT7SDT3L');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
