<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1. 字符串匹配KMP算法KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到O(m+n),而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。">
<meta name="keywords" content="面试,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;29&#x2F;%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="1. 字符串匹配KMP算法KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到O(m+n),而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050103.png">
<meta property="og:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050107.png">
<meta property="og:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050110.png">
<meta property="og:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050109.png">
<meta property="og:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050107.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;KMP5">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdn.net&#x2F;20140819173649739">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;bb17670ba0c3dfd23f7ef2222bd6d6d2d80fd11e&#x2F;68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f392f313635626333326636663138333366663f773d37323326683d33373126663d706e6726733d39333035">
<meta property="og:image" content="https:&#x2F;&#x2F;ss.csdn.net&#x2F;p?https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_jpg&#x2F;YrezxckhYOxyjTHsJnqyMvp4peu6NiaXESzU0WNiaUjvAwXZNjLuyicktn7fl7Y48D34ib5r4cv0WlMicjA5dScK4oA&#x2F;640?wx_fmt=jpeg">
<meta property="og:image" content="https:&#x2F;&#x2F;ss.csdn.net&#x2F;p?https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_jpg&#x2F;YrezxckhYOxyjTHsJnqyMvp4peu6NiaXEY1hhFg7yJ9DF30oeg2Y6lQM7ztxUyMOypBDgtjdO9GLAtyQUlcZl7w&#x2F;640?wx_fmt=jpeg">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190913234217803.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjkwNzg1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;cd901d44121195e36bc4ea24dde717e707843a69&#x2F;68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33656132383062352d626537642d343731622d616337362d6666303230333834333537632e676966">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%BB%BA%E7%AB%8B%E5%89%8D%E7%BC%80%E6%A0%91.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%A3%B0%E6%98%8E%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B6.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B7.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B8.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B9.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;Leecode%E6%B1%821%E4%B8%AA%E6%95%B0%E6%95%B0%E5%AD%A6%E5%8F%91%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9B%9E%E6%BA%AF.png">
<meta property="og:updated_time" content="2020-12-01T10:34:32.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blogimg&#x2F;asset&#x2F;201305&#x2F;bg2013050103.png">

<link rel="canonical" href="http://yoursite.com/2019/10/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>算法 | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-29 16:42:37" itemprop="dateCreated datePublished" datetime="2019-10-29T16:42:37+08:00">2019-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-01 18:34:32" itemprop="dateModified" datetime="2020-12-01T18:34:32+08:00">2020-12-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-字符串匹配KMP算法"><a href="#1-字符串匹配KMP算法" class="headerlink" title="1. 字符串匹配KMP算法"></a>1. 字符串匹配KMP算法</h1><p>KMP算法是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到<code>O(m+n)</code>,而空间复杂度也只有<code>O(m)</code>。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<a id="more"></a>

<p>算法思想大概如下：</p>
<p>有如下字符串：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" alt="KMP1"></p>
<p>当匹配到以下这种情况时，会出现空格和D不匹配，而前面六个字符”ABCDAB”是匹配的：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="KMP2"></p>
<p>此时可以将搜索项后移4格得到如下情况，然后再继续往下对比下一位：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png" alt="KMP3"></p>
<p>在程序中，通过设置<strong>部分匹配表</strong>保存前面搜索的已知信息，部分匹配表主要用于保存匹配字符串的最长公共前后缀。</p>
<p>部分匹配值就是“前缀”和“后缀”的最长的共有元素的长度。以“ABCDABD”为例：</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>因此可以得出下表：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" alt="KMP4"></p>
<p>此时需要移动的位数 = 已匹配的字符数 - 对应的部分的匹配值</p>
<p>对于上面的情况：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="KMP2"></p>
<p>查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<p>由于此时指针指向的是D位置，而并非前面的B位置，为了便于计算，可以将部分匹配值整体右移一位，之后在第0位补上值为-1。例如：</p>
<p><img src="http://qiniu.xiaoming.net.cn/KMP5" alt="KMP5"></p>
<p><img src="https://img-blog.csdn.net/20140819173649739" alt="KMP6"></p>
<p>此时，若匹配到当前位置不符合，只需要将匹配位置移到当前匹配位置的匹配值代表的位置，如上面此时D的匹配值为2，则将搜索词中[2]的位置即A移到当前字符串下，同样相当于右移4位。若匹配值为-1，则从下一个位置开始从头开始匹配。</p>
<h2 id="部分匹配值的实现思路"><a href="#部分匹配值的实现思路" class="headerlink" title="部分匹配值的实现思路"></a>部分匹配值的实现思路</h2><p>对于第一个字符，其匹配值一定是0。之后每增加一位，则与已比较的最后一位的匹配值所指位置的字符比较，相同，则在上一个字符匹配值基础上+1；如果不匹配，则需要指向最后一位字符的前一个字符的匹配值的位置的字符，之后以此类推。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 部分匹配表的实现</span></span><br><span class="line"><span class="comment"> * @pattern 需要被匹配到的字符串</span></span><br><span class="line"><span class="comment"> * @prefix 部分匹配表</span></span><br><span class="line"><span class="comment"> * @n pattern长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prefix_table</span><span class="params">(<span class="keyword">char</span> pattern[],<span class="keyword">int</span> prefix[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//指向当前字符串对比到的字符的匹配值</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pattern[len] == pattern[i]) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            prefix[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                len = prefix[len <span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后再将整体匹配表的值后移一位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_prefix_table</span><span class="params">(<span class="keyword">int</span> prefix[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">        prefix[i] = prefix[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_search</span><span class="params">(<span class="keyword">char</span> <span class="built_in">text</span>[],<span class="keyword">char</span> pattern[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(pattern);    <span class="comment">//需要匹配的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(<span class="built_in">text</span>);       <span class="comment">//待匹配字符串长度</span></span><br><span class="line">    <span class="keyword">int</span>* prefix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取匹配表</span></span><br><span class="line">    prefix_table(pattern,prefix,n);</span><br><span class="line">    move_prefix_table(prefix,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;      <span class="comment">//当前text匹配到的位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;      <span class="comment">//当前pattern匹配到的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; m) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//搜索完成</span></span><br><span class="line">        <span class="keyword">if</span>(j = n<span class="number">-1</span> &amp;&amp; <span class="built_in">text</span>[i] == pattern[j]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"已找到位置："</span> + (i-j));</span><br><span class="line">            j = prefix[j];<span class="comment">//继续往后看看还有没有其他匹配项</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">text</span>[i] == pattern[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = prefix[j];</span><br><span class="line">            <span class="comment">//如果到了最开始还不匹配，那么往text的下一个位置从头开始匹配</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成<code>%20</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceSpaceSolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：循环遍历替换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(String.valueOf(c).equals(<span class="string">" "</span>)) &#123;</span><br><span class="line">                result.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：使用接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.replaceAll(<span class="string">" "</span>,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><blockquote>
<p>Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>方法1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String prefix = strs[<span class="number">0</span>];<span class="comment">//以第一个字符串先假设为最长前缀</span></span><br><span class="line">    <span class="keyword">int</span> len = strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//indexOf在找不到的时候返回-1，找到了返回位置</span></span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//找不到或者找到的位置不是首位，将前缀去掉一个字符再比较</span></span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix2</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将首个字符串逐列与后面的字符串比较</span></span><br><span class="line">    <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == strs[j].length() || c != strs[j].charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix3</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先利用Arrays.sort(strs)为数组排序，</span></span><br><span class="line">    <span class="comment">// 排序后公共的前缀如果有，第一和最后一个肯定都包括了</span></span><br><span class="line">    <span class="comment">// 再将数组第一个元素和最后一个元素的字符从前往后对比</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果检查值不合法就返回空串</span></span><br><span class="line">    <span class="keyword">if</span>(!checkStr(strs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = strs.length;</span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    Arrays.sort(strs);</span><br><span class="line">    <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">    <span class="keyword">int</span> n = strs[len-<span class="number">1</span>].length();</span><br><span class="line">    <span class="keyword">int</span> num = Math.min(m,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].charAt(i) == strs[len-<span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">            result.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStr</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历strs检查元素值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i] != <span class="keyword">null</span> &amp;&amp; strs[i].length() != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-最长回文串"><a href="#4-最长回文串" class="headerlink" title="4. 最长回文串"></a>4. 最长回文串</h1><blockquote>
<p>LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如”Aa”不能当做一个回文字符串。注 意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科</p>
</blockquote>
<p>构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li>字符出现次数为双数的组合+一个只出现一次的字符</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在 <code>hashset</code> 中，如果不在就加进去，如果在就让 <code>count++</code>，然后移除该字符,这样就能找到出现次数为双数的字符个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// char[] chars = s.toCharArray(); //可以考虑先将字符串转化为字符数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(c)) &#123;</span><br><span class="line">                <span class="comment">//如果集合里不存在就将其加入到集合</span></span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果集合里已经有了，那么就将该元素删除</span></span><br><span class="line">                <span class="comment">//count+1表示双数的字符个数</span></span><br><span class="line">                set.remove(c);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果集合不为空，可以有一个作为最中间元素</span></span><br><span class="line">        <span class="keyword">return</span> set.isEmpty()?count*<span class="number">2</span>:count*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5. 验证回文串"></a>5. 验证回文串</h1><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = len-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从两边往中间遍历</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt; r) &#123;</span><br><span class="line">            <span class="keyword">char</span> left = s.charAt(l);</span><br><span class="line">            <span class="keyword">char</span> right = s.charAt(r);</span><br><span class="line">            <span class="comment">//排除不是数字和字母的字符</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(left))&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(right)) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>( Character.toLowerCase(left) != Character.toLowerCase(right)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-最长回文子串"><a href="#6-最长回文子串" class="headerlink" title="6. 最长回文子串"></a>6. 最长回文子串</h1><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>思路：遍历，以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度</p>
<p><img src="https://camo.githubusercontent.com/bb17670ba0c3dfd23f7ef2222bd6d6d2d80fd11e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f392f313635626333326636663138333366663f773d37323326683d33373126663d706e6726733d39333035" alt="回文最大子字符串"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;<span class="comment">//用于确定最长回文子串长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;<span class="comment">//用于指定从哪里开始</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//对单数检索</span></span><br><span class="line">            palindromeHelper(s,i,i);</span><br><span class="line">            <span class="comment">//对双数检索</span></span><br><span class="line">            palindromeHelper(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(index,index+len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">palindromeHelper</span><span class="params">(String s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">//分别往左，往右对比</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; length &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果长度比已经对比过的长，则进行替换</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; r-l-<span class="number">1</span>) &#123;</span><br><span class="line">            index = l+<span class="number">1</span>;<span class="comment">//因为l位置已经不同，所以起始位置是l+1</span></span><br><span class="line">            len = r-l-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-最长回文子序列"><a href="#7-最长回文子序列" class="headerlink" title="7. 最长回文子序列"></a>7. 最长回文子序列</h1><blockquote>
<p>LeetCode: 最长回文子序列 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 </p>
</blockquote>
<blockquote>
<p><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p><strong>解题思路</strong>：主要运用动态规划的思想</p>
<ul>
<li>状态：<code>f[i][j]</code> 表示 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符组成的子串中，最长的回文序列长度是多少。</li>
<li>转移方程：如果 <code>s</code> 第 <code>i</code> 个字符和第 <code>j</code> 个字符相同的话 <code>f[i][j] = f[i + 1][j - 1] + 2</code>;否则 <code>f[i][j] = max(f[i + 1][j], f[i][j - 1])</code></li>
<li>初始化：<code>f[i][i] = 1</code> 单个字符的最长回文序列是1</li>
<li>结果：<code>f[0][n-1]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//单个字符长度为1</span></span><br><span class="line">            result[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">//如果相同，则在原来序列数量的左右两边各加一个，所以加2</span></span><br><span class="line">                    result[i][j] = result[i+<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不相同，则是当前位置到上一个位置的值，这个值可能是i这边，也可能是j一边的，取最大值。</span></span><br><span class="line">                    result[i][j] = Math.max(result[i+<span class="number">1</span>][j],result[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-括号匹配深度"><a href="#8-括号匹配深度" class="headerlink" title="8. 括号匹配深度"></a>8. 括号匹配深度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&apos;(&apos;和&apos;)&apos;。</span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BracketMatchingDepth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> i = maxDepth(s);</span><br><span class="line">        System.out.println(<span class="string">"最大深度为："</span>+i);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:count++ ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:count--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关键在这里需要记录下当前匹配的最大深度</span></span><br><span class="line">            depth = Math.max(count, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-把数字字符串转换成整数"><a href="#9-把数字字符串转换成整数" class="headerlink" title="9. 把数字字符串转换成整数"></a>9. 把数字字符串转换成整数</h1><blockquote>
<p>剑指offer: 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrToInt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"-12312312"</span>;</span><br><span class="line">        System.out.println(<span class="string">"使用库函数转换："</span> + Integer.valueOf(s));</span><br><span class="line">        <span class="keyword">int</span> res = strToInt(s);</span><br><span class="line">        System.out.println(<span class="string">"使用自己写的方法转换："</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//用于判断是否有符号位</span></span><br><span class="line">        <span class="keyword">if</span>(chars[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(chars[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//判断从哪一位开始，有符号就从第二个开始</span></span><br><span class="line">        <span class="keyword">int</span> start = (flag == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = chars[i] - <span class="string">'0'</span>;</span><br><span class="line">                result = result*<span class="number">10</span>+temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (flag==<span class="number">2</span>)? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-两数相加"><a href="#10-两数相加" class="headerlink" title="10. 两数相加"></a>10. 两数相加</h1><p>题目描述</p>
<blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
</blockquote>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ListNode <span class="title">addTwoNumber</span><span class="params">(ListNode l1,ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p = l1;</span><br><span class="line">        ListNode q = l2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//用于表示进位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里先定义链表头，后面省去代码根据是不是第一次而创建头节点的问题</span></span><br><span class="line">        ListNode headNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span> || q!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x+y+carry;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            carry = sum/<span class="number">10</span>;<span class="comment">//只可能为0或1</span></span><br><span class="line">            curr = curr.next;<span class="comment">//往下继续</span></span><br><span class="line">            <span class="keyword">if</span>(p.next != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(q.next != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最高位有进位</span></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-反转链表"><a href="#11-反转链表" class="headerlink" title="11. 反转链表"></a>11. 反转链表</h1><blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//记录当前节点的下一个节点</span></span><br><span class="line">            next = head.next;</span><br><span class="line">            <span class="comment">//将当前节点的next域指向上一个节点</span></span><br><span class="line">            head.next = pre;</span><br><span class="line">            <span class="comment">//当前节点作为“上一个节点”以供下一个节点指明</span></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode a = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode b = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode c = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode d = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode e = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.next = c;</span><br><span class="line">        c.next = d;</span><br><span class="line">        d.next = e;</span><br><span class="line">        reverseList(a);</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(e.data);</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-删除链表中倒数第k个节点"><a href="#12-删除链表中倒数第k个节点" class="headerlink" title="12. 删除链表中倒数第k个节点"></a>12. 删除链表中倒数第k个节点</h1><blockquote>
<p>Leetcode: 输入一个链表，删除该链表中倒数第k个结点，并且返回链表的头结点。</p>
</blockquote>
<p>分析：</p>
<p>链表中倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点，</p>
<p>首先两个节点/指针，一个节点 <code>node1</code> 先开始跑，当两者拉开距离 n 后，另一个节点 <code>node2</code> 开始跑，当 <code>node1</code> 跑到最后时，<code>node2</code> 所指的节点就是倒数第 k 个节点也就是正数第 <code>(L-K+1)</code> 个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode node1 = dummy;</span><br><span class="line">        ListNode node2 = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//node1先开始进入链表</span></span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            <span class="comment">//当node1与node2的距离拉开n个距离时node2开始进入链表</span></span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">1</span> &amp;&amp; node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当node1跑完时，node2的位置便是L-n，而倒数第n位的位置是L-n+1</span></span><br><span class="line">        node2.next = node2.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-输出链表中倒数第k个节点"><a href="#13-输出链表中倒数第k个节点" class="headerlink" title="13. 输出链表中倒数第k个节点"></a>13. 输出链表中倒数第k个节点</h1><p>题目描述:</p>
<blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>问题分析</p>
<p>根据上一题的思路求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindKthToTail</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || n&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        ListNode node2 = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于计算节点个数，判断是否超出范围</span></span><br><span class="line">        <span class="keyword">int</span> index = n;<span class="comment">//记录n的值，用于后面做判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">1</span> &amp;&amp; node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-求斐波纳切数列的第n个数-爬楼梯"><a href="#14-求斐波纳切数列的第n个数-爬楼梯" class="headerlink" title="14. 求斐波纳切数列的第n个数/爬楼梯"></a>14. 求斐波纳切数列的第n个数/爬楼梯</h1><blockquote>
<p>Leecode:假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
</blockquote>
<p>分析：</p>
<p>动态规划思想，爬上最后一层楼梯可能是差一阶或两阶，即<code>f(N)=f(N-1)+f(N-2)</code>，此时数列变成”1 1 2 3 5 …”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++) &#123;</span><br><span class="line">            result = f1 +f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15-变态台阶问题"><a href="#15-变态台阶问题" class="headerlink" title="15. 变态台阶问题"></a>15. 变态台阶问题</h1><p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>假设 <code>n&gt;=2</code>，第一步有n种跳法：跳 1 级、跳 2 级,到跳 n 级。 跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1)； 跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2) …… 跳 n-1 级，剩下 1 级，则剩下跳法是 f(1)； 跳 n 级，剩下 0 级，则剩下跳法是 f(0) </p>
<p>所以在 n&gt;=2 的情况下： <code>f(n)=f(n-1)+f(n-2)+...+f(1)</code> 因为 <code>f(n-1)=f(n-2)+f(n-3)+...+f(1)</code>,所以 <code>f(n)=2*f(n-1)</code>, 又 <code>f(1)=1</code>,所以可得 <code>f(n)=2^(number-1)</code></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; --number;<span class="comment">//2^(number-1)用位移操作进行，更快</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-二维数组查找"><a href="#16-二维数组查找" class="headerlink" title="16. 二维数组查找"></a>16. 二维数组查找</h1><p><strong>题目描述：</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>问题解析：</strong><br>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增， 因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length-<span class="number">1</span>;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;<span class="comment">//列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span> &amp;&amp; column&lt;matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][column] &gt; target) &#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][column] &lt; target) &#123;</span><br><span class="line">                column ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-按奇偶排序数组"><a href="#17-按奇偶排序数组" class="headerlink" title="17. 按奇偶排序数组"></a>17. 按奇偶排序数组</h1><blockquote>
<p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len ==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用来计算偶数个数</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//用来指明当前到达那个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先统计偶数个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数只在插在偶数个数之后的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                arrays[index++] = A[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrays[count++] = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-TOP-K-问题"><a href="#18-TOP-K-问题" class="headerlink" title="18. TOP K 问题"></a>18. TOP K 问题</h1><p>从 1 亿个数中找出最大的前 100 个。</p>
<h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>利用小顶堆，首先遍历 100 个数放入堆中，后面每次遍历与堆顶比较，比堆顶大就替换堆顶并对堆进行调整。</p>
<p>堆排的时间复杂度是<code>n*logn</code>,适用场景：</p>
<ul>
<li>不会改变数据的输入顺序（按顺序读的）；</li>
<li>不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）；</li>
<li>由于（2），决定了它特别适合处理海量数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假设这是给定的数据</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        <span class="comment">//寻找前4个最大的数</span></span><br><span class="line">        <span class="keyword">int</span>[] b = topK(a, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对堆的 index 节点进行调整使其符合小顶堆定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">int</span> right = index * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">//右孩子</span></span><br><span class="line">        <span class="keyword">int</span> smallest = index;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; length &amp;&amp; array[left] &lt; array[index]) &#123;</span><br><span class="line">            smallest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; length &amp;&amp; array[right] &lt; array[smallest]) &#123;</span><br><span class="line">            smallest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != smallest) &#123;</span><br><span class="line">            swap(array, smallest, index);</span><br><span class="line">            <span class="comment">//递归往下继续调整</span></span><br><span class="line">            heapify(array, smallest, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[a];</span><br><span class="line">        array[a] = array[b];</span><br><span class="line">        array[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化小顶堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 由于单个结点的完全二叉树满足堆的特性，所以叶子结点都是堆。因此可以忽略叶子结点元素</span></span><br><span class="line"><span class="comment">         * 对 n 个结点的完全二叉树建堆的过程是：依次将编号为 n/2,n/2-1,...1 的结点为根的子树筛选为子堆</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(array, i, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置新的堆顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTop</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        array[<span class="number">0</span>] = top;</span><br><span class="line">        heapify(array, <span class="number">0</span>, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            top[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先建堆，然后依次比较剩余元素与堆顶元素的大小，比堆顶小的， 说明它应该在堆中出现，则用它来替换掉堆顶元素，然后沉降。</span></span><br><span class="line">        buildHeap(top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = top[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; temp) &#123;</span><br><span class="line">                setTop(top, array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快排方式"><a href="#快排方式" class="headerlink" title="快排方式"></a>快排方式</h2><p>分治函数会返回一个 position，在 position 左边的数都比第 position 个数小，在 position 右边的数都比第 position 大。通过不断调用分治函数，直到它输出的 position = K-1，此时 position 前面的K个数（0到K-1）就是要找的前K个数。</p>
<p>时间复杂度为 n ，特点：</p>
<ul>
<li>partition函数会不断地交换元素的位置，所以它肯定会改变数据输入的顺序；</li>
<li>既然要交换元素的位置，那么所有元素必须要读到内存空间中，所以它会占用比较大的空间，至少能容纳整个数组；</li>
<li>数据越多，占用的空间必然越大，海量数据处理起来相对吃力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        getTopK(array, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数组的右端向左扫描找到第一个大于它的元素，将这个元素放在 `l` 位置，</span></span><br><span class="line"><span class="comment">     * 从数组的左端向右扫描直到找到第一个小于等于枢轴的元素，</span></span><br><span class="line"><span class="comment">     * 放到右边高端刚交换完空出的位置。</span></span><br><span class="line"><span class="comment">     * 不断进行这个过程，就可以保证左指针 i 的左侧元素都不小于切分元素，</span></span><br><span class="line"><span class="comment">     * 右指针 j 的右侧元素都不大于切分元素。</span></span><br><span class="line"><span class="comment">     * 当两个指针相遇时，将枢轴的值放到该位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array != <span class="keyword">null</span> &amp;&amp; low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = array[low];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &lt;= flag) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[low] = array[high];</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &gt;= flag) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                array[high] = array[low];</span><br><span class="line">            &#125;</span><br><span class="line">            array[low] = flag;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTopK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array != <span class="keyword">null</span> &amp;&amp; array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> index = partition(array, low, high);</span><br><span class="line">            <span class="comment">//不断调整分治的位置，直到position = k-1</span></span><br><span class="line">            <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//大了，往前调整</span></span><br><span class="line">                <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                    high = index - <span class="number">1</span>;</span><br><span class="line">                    index = partition(array, low, high);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//小了，往后调整</span></span><br><span class="line">                <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                    low = index + <span class="number">1</span>;</span><br><span class="line">                    index = partition(array, low, high);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间换时间：bitmap方式-海量数据排序也可以用"><a href="#空间换时间：bitmap方式-海量数据排序也可以用" class="headerlink" title="空间换时间：bitmap方式(海量数据排序也可以用)"></a>空间换时间：bitmap方式(海量数据排序也可以用)</h2><p>bitmap（比特位图法），是空间换时间的典型代表。它是一种，用若干个 bit 来表示集合的数据结构。</p>
<p>例如，集合S={1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。</p>
<p>上述集合S，可以用<code>1010101010000000</code>这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。</p>
<p>假设TopK的n个元素都是int，且元素之间没有重复，只需要申请2^32个bit，即4G的内存，就能够用bitmap表示这n元素。</p>
<p>扫描一次所有n个元素，以生成bitmap，其时间复杂度是O(n)。生成后，取TopK只需要找到最高位的k个bit即可。算法总时间复杂度也是O(n)。</p>
<p>bitmap 算法有一个缺陷，如果集合元素有重复，相同的元素会被去重，如果需要考虑重复元素，则需要通过比特位图精准计数的方式：</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXESzU0WNiaUjvAwXZNjLuyicktn7fl7Y48D34ib5r4cv0WlMicjA5dScK4oA/640?wx_fmt=jpeg" alt="bitmap求topK_1"></p>
<p>TopK的集合经过比特位图计数处理后，会记录每个bit对应在集合S中出现过多少次。</p>
<p>接下来，找TopK的过程，就是bitmap从高位的计数开始，往低位的计数扫描，得到count之和等于k，对应的bit就是TopK所求。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/YrezxckhYOxyjTHsJnqyMvp4peu6NiaXEY1hhFg7yJ9DF30oeg2Y6lQM7ztxUyMOypBDgtjdO9GLAtyQUlcZl7w/640?wx_fmt=jpeg" alt="bitmap求topK_2"></p>
<p>如上图所示，k=5：</p>
<ol>
<li>第一个非0的count是1，对应的bit是9；</li>
<li>第二个非0的count也是1，对应的bit是8；</li>
<li>第三个非0的count是2，对应的bit是7；</li>
<li>第四个非0的count是2，对应的bit是6，但TopK只缺1个数字了，故只有1个6入选；</li>
</ol>
<p>故，最终的TopK={9, 8, 7, 7, 6}。</p>
<p>结论：通过比特位图精准计数的方式，求解TopK，算法整体只需要不到2次扫描，时间复杂度为O(n)，比减治法的随机选择会更快。</p>
<h1 id="19-1亿个-IPV-地址找相同"><a href="#19-1亿个-IPV-地址找相同" class="headerlink" title="19. 1亿个 IPV 地址找相同"></a>19. 1亿个 IPV 地址找相同</h1><h2 id="方法一：hash取模"><a href="#方法一：hash取模" class="headerlink" title="方法一：hash取模"></a>方法一：hash取模</h2><p>按照IP地址的 <code>hash(IP)%1024</code> 值，将海量日志存储到 1024 个小文件中，每个小文件最多包含 4M 个IP地址(IP地址最多有 <code>2^32=4G</code> 种取值可能)。 </p>
<p>对于每个小文件，可以构建一个 IP 作为 key，出现次数作为 value 的hash_map，并记录当前出现次数最多的 1 个 IP 地址。有了 1024 个小文件中的出现次数最多的 IP，我们就可以轻松得到总体上出现次数最多的 IP。</p>
<h2 id="方法二：bitmap"><a href="#方法二：bitmap" class="headerlink" title="方法二：bitmap"></a>方法二：bitmap</h2><p>申请一个长度为2^32的bit类型的数组，每个位置上是一个bit，只可表示0或者1两种状态，空间为 512 M。</p>
<p>每个 IP 地址转化成无符号整数 k，数组下标 <code>0~2^32-1</code> 与 k 对应起来。如果 <code>k==1</code> ,就把 <code>bitmap[0]=1</code>；如果 <code>k==n</code>,把 <code>bitmap[n-1] =1</code>；</p>
<p>最后只要从 bitmap 的零位一直遍历到最后，然后提取出对应为1的下标整数k，再转换成ip地址，就完成了从小到大的排序。空间复杂度很小，时间复杂度O（n）</p>
<p><img src="https://img-blog.csdnimg.cn/20190913234217803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjkwNzg1,size_16,color_FFFFFF,t_70" alt="bitmap计算ipv地址"></p>
<h1 id="20-两个栈实现队列"><a href="#20-两个栈实现队列" class="headerlink" title="20. 两个栈实现队列"></a>20. 两个栈实现队列</h1><p><img src="https://camo.githubusercontent.com/cd901d44121195e36bc4ea24dde717e707843a69/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33656132383062352d626537642d343731622d616337362d6666303230333834333537632e676966" alt="两个栈实现队列"></p>
<p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!in.isEmpty()) &#123;</span><br><span class="line">            out.push(in.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-字典树（trie）实现敏感词汇过滤"><a href="#21-字典树（trie）实现敏感词汇过滤" class="headerlink" title="21. 字典树（trie）实现敏感词汇过滤"></a>21. 字典树（trie）实现敏感词汇过滤</h1><p>trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的。</p>
<h2 id="算法思路总结："><a href="#算法思路总结：" class="headerlink" title="算法思路总结："></a>算法思路总结：</h2><p>首先对需要屏蔽的词汇构建字典树（Trie Tree），然后创建三个指针，begin 指针指向匹配字符串起始位置，position 指针指向当前需要对比的字符，tempNode首先指向字典树的根节点。</p>
<p>每次 position 位置字符与 tempNode 子节点对比，如果不匹配则 position 和 begin 均加 1再继续比较；</p>
<p>如果匹配 tempNode 指向所匹配节点继续比较，同时 position+1，直到 tempNode 指向叶子节点则说明匹配到敏感词汇，将 begin 位置到 position 位置的字符屏蔽用 <code>*</code>代替,然后 position +1，begin 指向 position 位置，tempNode 指向跟节点，继续往下执行。</p>
<p>若匹配过程中到某一个 tempNode 节点时，其子节点已经没有匹配的字符，说明当前词汇不符合敏感词汇，则将 begin+1，同时 position 指向 begin，tempNode 再次指向根节点。</p>
<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>首先建立个敏感词前缀树，根节点为空：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%BB%BA%E7%AB%8B%E5%89%8D%E7%BC%80%E6%A0%91.png" alt="建立前缀树"></p>
<p>准备好待处理字符串：“哈哈大王八子大猪蹄子哦” ，声明三个指针，分别指向前缀树的根节点以及待处理字符串的开始字符</p>
<p>position 指向的字符与根节点的所有子节点进行匹配，不匹配，position 和 begin 分别指向待处理字符串的下一个字符，tempNode 依旧指向根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%A3%B0%E6%98%8E%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88.png" alt="声明三个指针"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B1.png" alt="指针匹配过程1"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B2.png" alt="指针匹配过程2"></p>
<p>此时根节点有一个子节点与 position 指向的字符相等，都为‘大’，则 tempNode 指向该节点，同时 position 前进一步，指向‘王’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B3.png" alt="指针匹配过程3"></p>
<p>此时把 position 指向的‘王’ 和 tempNode 的所有子节点进行匹配，匹配失败，说明 从 begin 起头所有串是不存在敏感词的，可以直接输出。此时 begin 前进一位，position 回退到 begin 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B4.png" alt="指针匹配过程4"></p>
<p>此时再把 position 指向的‘王’与 tempNode 的所有子节点进行匹配，匹配成功，所以 tempNode 指向该节点，同时 position 前进一位，指向’八’</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B5.png" alt="指针匹配过程5"></p>
<p>此时再把 position 指向的‘王’ 与 tempNode 的所有子节点进行匹配，匹配成功，此时 tempNode 指向它的子节点‘八’，同时 position 前进一位。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B6.png" alt="指针匹配过程6"></p>
<p>继续把 position 指向的字符 与tempNode 的所有子节点进行匹配，匹配失败。说明以begin起头的不存在非法字符，可以加入到结果集中。 此时 begin 向前走一位，position 回退到 begin 的位置，同时 tempNode 回退到根节点。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B7.png" alt="指针匹配过程7"></p>
<p>同理，可以发现子’子’不匹配，则直接把它加入结果集，同时position 和 begin 向前走一位，tempNode 指向根节点。</p>
<p>此时 position 指向 ‘大’，与 tempNode 的所有子节点进行匹配，匹配成功，则 position 和 tempNode 都走一位，循环执行….</p>
<p>直到 position 指向‘子’，tempNode指向‘蹄’（图中begin指针应该指向‘大’）</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B8.png" alt="指针匹配过程8"></p>
<p>此时把 position 与 tempNode 的所有子节点进行匹配，匹配成功，tempNode 指向它的子节点‘子’，此时检查发现tempNode是敏感词树的叶子节点，说明从 begin 开始的位置到 position 这段是敏感词，用和谐词替换掉。替换之后 position 前进一位，begin 跳到 position 的位置，tempNode 回退到根节点</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B9.png" alt="指针匹配过程9"></p>
<h2 id="算法代码实现"><a href="#算法代码实现" class="headerlink" title="算法代码实现"></a>算法代码实现</h2><p>前缀树结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//是否最后一个字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isKeyWordsEnd = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//子节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character,TreeNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character key, TreeNode node)</span></span>&#123;</span><br><span class="line">        subNodes.put(key,node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getSubNode</span><span class="params">(Character key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subNodes.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeyWordsEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isKeyWordsEnd;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyWordsEnd</span><span class="params">(Boolean end)</span></span>&#123;</span><br><span class="line">        isKeyWordsEnd = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建前缀树的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSensitiveWord</span><span class="params">(String words)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    TreeNode tempNode = rootNode;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; words.length(); i++)&#123;</span><br><span class="line"> </span><br><span class="line">        Character c = words.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!isSymbol(c))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        TreeNode node = tempNode.getSubNode(c);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            tempNode.addSubNode(c,node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针移动</span></span><br><span class="line">        tempNode = node;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果到了最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(i == words.length() -<span class="number">1</span>)&#123;</span><br><span class="line">            tempNode.setKeyWordsEnd(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(text))&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String sensitiveWords = <span class="string">"***"</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> </span><br><span class="line">    TreeNode tempNode = rootNode;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (position &lt; text.length())&#123;</span><br><span class="line"></span><br><span class="line">        Character c = text.charAt(position);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果非匹配字符，则直接跳过</span></span><br><span class="line">        <span class="keyword">if</span>(!isSymbol(c))&#123; <span class="comment">//每次</span></span><br><span class="line">            <span class="keyword">if</span>(tempNode == rootNode)&#123;</span><br><span class="line">                result.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            position++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tempNode = tempNode.getSubNode(c);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果匹配失败</span></span><br><span class="line">        <span class="keyword">if</span>(tempNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明以begin起头的那一段不存在非法词汇</span></span><br><span class="line">            result.append(text.charAt(begin));</span><br><span class="line">            begin++;</span><br><span class="line">            position = begin;</span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tempNode.isKeyWordsEnd())&#123;</span><br><span class="line">            <span class="comment">//替换敏感词</span></span><br><span class="line">            result.append(sensitiveWords);</span><br><span class="line">            position++;</span><br><span class="line">            begin = position;</span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position &gt; text.length() &amp;&amp; (begin+<span class="number">1</span>) &lt; text.length()) &#123;</span><br><span class="line">                <span class="comment">/** </span></span><br><span class="line"><span class="comment">                 * 防止出现有相同后缀的敏感词汇</span></span><br><span class="line"><span class="comment">                 * 如fabcd，abc，当字符串最后fabc, 此时指begin指f, </span></span><br><span class="line"><span class="comment">                 * 指position指到c, 根据循环中的判断c的isKeywordsEnd为true, </span></span><br><span class="line"><span class="comment">                 * position++, 此时跳出循环, 然后将fabc加到StringBuilder中, </span></span><br><span class="line"><span class="comment">                 * 但是abc这个敏感词没有被过滤掉</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                begin = begin +<span class="number">1</span>;</span><br><span class="line">                position = begin;</span><br><span class="line">                tempNode = rootNode;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            position++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;   </span><br><span class="line">    result.append(text.substring(begin)); <span class="comment">//把剩下的动加入合法集</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h2><p>如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p>
<h1 id="22-给定已有硬币面值，计算需要的最少硬币数目？"><a href="#22-给定已有硬币面值，计算需要的最少硬币数目？" class="headerlink" title="22. 给定已有硬币面值，计算需要的最少硬币数目？"></a>22. 给定已有硬币面值，计算需要的最少硬币数目？</h1><p>使用动态规划的思想解决：</p>
<p><a href="https://xiaoming.net.cn/2019/11/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" target="_blank" rel="noopener">详情看这里</a></p>
<h1 id="23-动态规划01背包问题"><a href="#23-动态规划01背包问题" class="headerlink" title="23. 动态规划01背包问题"></a>23. 动态规划01背包问题</h1><p>假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。</p>
<p>状态：<code>maxValue[i][j]</code>表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>状态转移方程：<code>maxValue[i][j] = max{maxValue[i-1][j],maxValue[i-1][j-w[i]]+P[i]}</code>，其中 <code>w[i]</code> 表示第 i 颗宝石的重量，<code>P[i]</code> 表示第 i 颗宝石的价值。</p>
<p>物理意义：<code>当前背包能装入的最大价值为只有 i-1 个宝石时背包能装入的最大价值</code> 和 <code>腾出第 i 颗宝石重量后剩余背包容量装入 i-1 个宝石的最大价值加上装入第 i 颗宝石价值</code> 的较大值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w 每一个宝石的重量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 每一个宝石的价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 背包的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] w,<span class="keyword">int</span>[] v,<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//maxValue[i][j]表示前 i 个宝石装到剩余体积为 j 的背包里能达到的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[w.length][capacity]; </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; capacity; j++) &#123;</span><br><span class="line">            maxValue[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">//没有宝石时价值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            maxValue[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//容量为0时价值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w.length; i++) &#123; <span class="comment">//从有1个宝石算起</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; capacity; j++) &#123; <span class="comment">//从容量为1算起</span></span><br><span class="line">                <span class="keyword">if</span>(w[i] &lt; j) &#123;</span><br><span class="line">                    maxValue[i][j] = Math.max(maxValue[i-<span class="number">1</span>][j],maxValue[i-<span class="number">1</span>][j-w[i]] + v[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//无法承载此颗宝石重量</span></span><br><span class="line">                    maxVlue[i][j] = maxValue[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%-5d"</span>,temp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-最长不重复子串"><a href="#24-最长不重复子串" class="headerlink" title="24. 最长不重复子串"></a>24. 最长不重复子串</h1><blockquote>
<p>LeeCode：给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
</blockquote>
<p>思路：采用窗口滑动思想，利用 HashMap，其中 key 存储字符，value 存储当前字符的下一个位置。窗口（i，j）从左往右扫描，当 key 不重复时，j+1，继续往右扫描；当出现 key 重复时，i 跳过 key 字符第一次出现的位置到它的下一个位置，而长度就是 j-i+1 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring03</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建map窗口,i为左区间，j为右区间，右边界移动</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果窗口中包含当前字符，</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">            <span class="comment">//左边界移动到 相同字符的下一个位置和i当前位置中更靠右的位置，这样是为了防止i向左移动</span></span><br><span class="line">            i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比对当前无重复字段长度和储存的长度，选最大值并替换</span></span><br><span class="line">        <span class="comment">//j-i+1是因为此时i,j索引仍处于不重复的位置，j还没有向后移动，取的[i,j]长度</span></span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将当前字符为key，下一个索引为value放入map中</span></span><br><span class="line">        <span class="comment">// value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了</span></span><br><span class="line">        map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-数据求交集"><a href="#25-数据求交集" class="headerlink" title="25. 数据求交集"></a>25. 数据求交集</h1><blockquote>
<p>LeeCode: 给定两个数组，编写一个函数来计算它们的交集。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer s : set1)</span><br><span class="line">      <span class="keyword">if</span> (set2.contains(s)) output[idx++] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(output, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set1.size() &lt; set2.size()) <span class="keyword">return</span> set_intersection(set1, set2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> set_intersection(set2, set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>retainAll</code>函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    set1.retainAll(set2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : set1) output[idx++] = s;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(m+n)O(m+n)，其中 n 和 m 是数组的长度。O(n)O(n) 的时间用于转换 nums1 在集合中，O(m)O(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 O(1)O(1)。</li>
<li>空间复杂度：O(m+n)O(m+n)，最坏的情况是数组中的所有元素都不同。</li>
</ul>
<h1 id="26-如何判断单链表是否有环？如何确定环的入口？"><a href="#26-如何判断单链表是否有环？如何确定环的入口？" class="headerlink" title="26. 如何判断单链表是否有环？如何确定环的入口？"></a>26. 如何判断单链表是否有环？如何确定环的入口？</h1><h2 id="方法一：hash-表"><a href="#方法一：hash-表" class="headerlink" title="方法一：hash 表"></a>方法一：hash 表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//对于需要返回节点的，直接返回这个node</span></span><br><span class="line">                <span class="comment">//即 return node;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//这里相应改成return null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：<code>O(n)</code>，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 <code>O(1)</code> 的时间。</li>
<li>空间复杂度：<code>O(n)</code>，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</li>
</ul>
<h2 id="方法二：双指针（快慢指针）"><a href="#方法二：双指针（快慢指针）" class="headerlink" title="方法二：双指针（快慢指针）"></a>方法二：双指针（快慢指针）</h2><p>如果存在循环，快指针会再次追上慢指针，没有说明不存在环形链表；如果需要返回入口节点，则将两个指针一个指向头节点，一个指向相遇点，然后分别向前走直到相遇，该点就是入口点。</p>
<p>理解如下：</p>
<ol>
<li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li>
<li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li>
<li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li>
<li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li>
<li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li>
<li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li>
<li>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不需要求入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tortoise = head;</span><br><span class="line">        ListNode hare = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hare != <span class="keyword">null</span> &amp;&amp; hare.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tortoise = tortoise.next;</span><br><span class="line">            hare = hare.next.next;</span><br><span class="line">            <span class="keyword">if</span> (tortoise == hare) &#123;</span><br><span class="line">                <span class="keyword">return</span> tortoise;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。</li>
</ul>
<h1 id="27-找两条链表公共节点"><a href="#27-找两条链表公共节点" class="headerlink" title="27. 找两条链表公共节点"></a>27. 找两条链表公共节点</h1><blockquote>
<p>Leecode:编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p>使用双指针法：</p>
<ul>
<li>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</li>
<li>当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li>
<li>若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。</li>
<li>想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。</li>
<li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/Bp 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</li>
</ul>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 : O(m+n)O(m+n)。</li>
<li>空间复杂度 : O(1)O(1)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">            <span class="keyword">if</span> (pA == <span class="keyword">null</span> &amp;&amp; pB == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pA == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pA = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pB == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pB = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="28-100G-的文件，只有-100M-内存，对文件进行排序"><a href="#28-100G-的文件，只有-100M-内存，对文件进行排序" class="headerlink" title="28. 100G 的文件，只有 100M 内存，对文件进行排序"></a>28. 100G 的文件，只有 100M 内存，对文件进行排序</h1><h2 id="外部排序-多路归并"><a href="#外部排序-多路归并" class="headerlink" title="外部排序 + 多路归并"></a>外部排序 + 多路归并</h2><p><img src="http://qiniu.xiaoming.net.cn/%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F.jpeg" alt="大文件排序"></p>
<p>100G 数据，按照 100M 内存拆分，然后排序成有序的数据，然后写入到 file1,file2…file100。</p>
<p>之后进行多路归并排序：</p>
<ol>
<li><p>从 file1,file2,file3，…，file100 取出第一个数，即最大或者最小的，所有的初始指针都是第一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min1 = min(fil1,file2,file3, … ,file100)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>min1 写入到大数据文件,大数据行数指针 + 1,min1 对应的行数指针 +1。</p>
</li>
<li><p>从对应的行指针取出第二个数进行对比，继续归并</p>
</li>
</ol>
<h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><p>前提是内存容得下这么大的位图。每读一个数，相应的位图位置标 1，如果又重复数，可以建一个数组相应的 count++，遍历完文件之后对对应位置为 1 的输出下标。</p>
<h1 id="29-100亿个整型数据，乱序，100M内存，求中位数"><a href="#29-100亿个整型数据，乱序，100M内存，求中位数" class="headerlink" title="29. 100亿个整型数据，乱序，100M内存，求中位数"></a>29. 100亿个整型数据，乱序，100M内存，求中位数</h1><p>这里认为是带符号的int,所以4字节，占32位。</p>
<p>假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入    <code>file_0</code> 文件中；如果最高位为 1，则将该数字写入 <code>file_1</code> 文件中。</p>
<p>从而将 100 亿个数字分成了两个文件，假设 <code>file_0</code> 文件中有 60亿 个数字，<code>file_1</code> 文件中有 40 亿个数字。那么中位数就在 <code>file_0</code> 文件中，并且是 <code>file_0</code> 文件中所有数字排序之后的第 10 亿个数字。（<code>file_1</code> 中的数都是负数，<code>file_0</code> 中的数都是正数，也即这里一共只有 40 亿个负数，那么排序之后的第 50 亿个数一定位于 <code>file_0</code> 中）</p>
<p>现在，只需要处理 <code>file_0</code> 文件了（不需要再考虑 <code>file_1</code> 文件）。对于 <code>file_0</code> 文件，同样采取上面的措施处理：将 <code>file_0</code> 文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的次高位（第31位），如果数字的次高位为 0，写入 <code>file_0_0</code> 文件中；如果次高位为1，写入<code>file_0_1</code> 文件中。</p>
<p>现假设 <code>file_0_0</code> 文件中有30亿个数字，<code>file_0_1</code> 中也有30亿个数字，则中位数就是：<code>file_0_0</code> 文件中的数字从小到大排序之后的第 10 亿个数字。</p>
<p>抛弃 <code>file_0_1</code> 文件，继续对 <code>file_0_0</code> 文件 根据次次高位(第30位) 划分，假设此次划分的两个文件为：<code>file_0_0_0</code> 中有5亿个数字，<code>file_0_0_1</code> 中有25亿个数字，那么中位数就是 <code>file_0_0_1</code> 文件中的所有数字排序之后的第 5 亿个数。</p>
<p>以此类推，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p>
<h1 id="30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><a href="#30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199" class="headerlink" title="30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"></a>30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出最大乘积是多少</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaximumProduct</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(getMaximumProduct(number / <span class="number">10</span>) * (number % <span class="number">10</span>),getMaximumProduct(number / <span class="number">10</span> -<span class="number">1</span>) * <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用于存储每一位数</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//获取除个位数以外的部分</span></span><br><span class="line">            <span class="keyword">int</span> n = number/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//个位数取9时，高位部分减1</span></span><br><span class="line">            <span class="keyword">int</span> m = number/<span class="number">10</span>-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//比较个位数取 9 和按原数计算哪个数乘积比较大</span></span><br><span class="line">            <span class="keyword">if</span>(getMaximumProduct(n) * (number%<span class="number">10</span>) &lt; getMaximumProduct(m) * <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="comment">//个位数取9比较大，存入数组，相应的把number变为高位部分，继续比较</span></span><br><span class="line">                number = m;</span><br><span class="line">                list.add(<span class="number">9</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//原数大，则存入数组，相应把number变为高位部分，继续比较</span></span><br><span class="line">                list.add(number%<span class="number">10</span>);</span><br><span class="line">                number = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="31-二叉树中和为某一值的路径"><a href="#31-二叉树中和为某一值的路径" class="headerlink" title="31. 二叉树中和为某一值的路径"></a>31. 二叉树中和为某一值的路径</h1><blockquote>
<p>Leecode:输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储结果集</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//存储每一条路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root,sum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//当左右子树都为空说明已经到了叶子结点，如果 sum 已经减为 0，说明该路径可以，加入结果集</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//需要拷贝路径加入，直接加入的话后续path一变会导致结果集的数据跟着改变</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归左子节点</span></span><br><span class="line">        recur(root.left,sum);</span><br><span class="line">        <span class="comment">//递归右子节点</span></span><br><span class="line">        recur(root.right,sum);</span><br><span class="line">        <span class="comment">//路径恢复，向上回溯前，需要将当前节点从路径 path 中删除</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N)：N 为二叉树的节点数，先序遍历需要遍历所有节点。</li>
<li>空间复杂度 O(N)：最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。</li>
</ul>
<h1 id="32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除"><a href="#32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除" class="headerlink" title="32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除"></a>32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String a,String b)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); i++) &#123;</span><br><span class="line">            set.add(b.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = a.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(c)) &#123;</span><br><span class="line">                builder.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="33-二叉搜索树转双向链表"><a href="#33-二叉搜索树转双向链表" class="headerlink" title="33. 二叉搜索树转双向链表"></a>33. 二叉搜索树转双向链表</h1><blockquote>
<p>Leecode:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
</blockquote>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpeg" alt="二叉搜索树转双向链表"></p>
<p>递归方式：改写中序遍历，遍历过程中使用一全局变量 pre 存储其前一个结点,当遍历该结点时，只需该节点的前驱(left)指向pre，pre的后继指向该节点。对于头结点应特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    node.left = pre;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        head = node;</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     Node current = root;</span><br><span class="line">     Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>, tail = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stack.push(current);</span><br><span class="line">             current = current.left;</span><br><span class="line">         &#125;</span><br><span class="line">         current = stack.pop();</span><br><span class="line">         tail = current;</span><br><span class="line">         <span class="keyword">if</span>(pre == <span class="keyword">null</span>) &#123;<span class="comment">//处理头结点</span></span><br><span class="line">             head = current;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             pre.right = current;</span><br><span class="line">             current.left = pre;</span><br><span class="line">         &#125;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = current.right;</span><br><span class="line">     &#125;</span><br><span class="line">     tail.right = head;</span><br><span class="line">     head.left = tail;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="34-有序链表转换二叉搜索树"><a href="#34-有序链表转换二叉搜索树" class="headerlink" title="34. 有序链表转换二叉搜索树"></a>34. 有序链表转换二叉搜索树</h1><blockquote>
<p>Leecode:给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
</blockquote>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<p>解题思路：给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。</p>
<ol>
<li>由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。</li>
<li>我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 <code>slow_ptr</code> 和 <code>fast_ptr</code>。<code>slow_ptr</code> 每次向后移动一个节点而 <code>fast_ptr</code> 每次移动两个节点。当 <code>fast_ptr</code> 到链表的末尾时 <code>slow_ptr</code> 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。</li>
<li>当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 <code>prev_ptr</code> 的指针记录 <code>slow_ptr</code> 之前的元素，也就是满足 <code>prev_ptr.next = slow_ptr</code>。断开左侧部分就是让 <code>prev_ptr.next = None</code>。</li>
<li>我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 <code>slow_ptr.next</code> 作为头指针。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddleElement</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pointer used to disconnect the left half from the mid node.</span></span><br><span class="line">    ListNode prevPtr = <span class="keyword">null</span>;</span><br><span class="line">    ListNode slowPtr = head;</span><br><span class="line">    ListNode fastPtr = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate until fastPr doesn't reach the end of the linked list.</span></span><br><span class="line">    <span class="keyword">while</span> (fastPtr != <span class="keyword">null</span> &amp;&amp; fastPtr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prevPtr = slowPtr;</span><br><span class="line">      slowPtr = slowPtr.next;</span><br><span class="line">      fastPtr = fastPtr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling the case when slowPtr was equal to head.</span></span><br><span class="line">    <span class="keyword">if</span> (prevPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prevPtr.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slowPtr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the head doesn't exist, then the linked list is empty</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the middle element for the list.</span></span><br><span class="line">    ListNode mid = <span class="keyword">this</span>.findMiddleElement(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The mid becomes the root of the BST.</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case when there is just one element in the linked list</span></span><br><span class="line">    <span class="keyword">if</span> (head == mid) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively form balanced BSTs using the left and right halves of the original list.</span></span><br><span class="line">    node.left = <span class="keyword">this</span>.sortedListToBST(head);</span><br><span class="line">    node.right = <span class="keyword">this</span>.sortedListToBST(mid.next);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"><a href="#35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？" class="headerlink" title="35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"></a>35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？</h1><p>在二叉树中有关系：度为0的结点个数 = 度为2的结点个数 + 1，表示为：n0 = n2 +1；<br>因为度为1的结点只可能出现在最后一个结点，或者根本就不存在度为1的结点。<br>假设:存在度为1的结点；<br>n0 + n2 + 1 = 1699，解其可得，n0 与 n2 都不为整数，这与事实不符，所以可以得出，不存在度数为1的点(虽然计算得出是的确不存在，但并不是一定不存在)<br>所以可得度为1的结点是不存在的；<br>即：n0 + n2 = 1699，解 n0 = 850</p>
<h1 id="36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径"><a href="#36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径" class="headerlink" title="36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径"></a>36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径</h1><blockquote>
<p>Leecode：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物（网格中的障碍物和空位置分别用 1 和 0 来表示，1 代表障碍物）。那么从左上角到右下角将会有多少条不同的路径？</p>
</blockquote>
<p>解题思路：动态规划的思想，到达一个格子可以从上方到达，也可以从左边到达，所以分别计算上方和左侧两个格子的到达数相加就是当前格子的路径数。具体如下：</p>
<p>如果格子上有障碍，那么不考虑包含这个格子的任何路径。从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个动态规划问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 <code>DP</code> 数组。</p>
<p>注意： 根据题目描述，包含障碍物的格点有权值 1，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p>
<p>算法思路如下：</p>
<ol>
<li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</li>
<li>否则，如果 <code>obstacleGrid[0,0]</code> 是 0，我们初始化这个值为 1 然后继续算法。</li>
<li>遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j]</code> = <code>obstacleGrid[i,j-1]</code>。</li>
<li>遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li>
<li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li>
<li>如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回最后一格的值</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 ： O(M×N) 。长方形网格的大小是 M×N，而访问每个格点恰好一次。</li>
<li>空间复杂度 ： O(1)。我们利用 obstacleGrid 作为 DP 数组，因此不需要额外的空间</li>
</ul>
<h1 id="37-二叉树的最近公共祖先"><a href="#37-二叉树的最近公共祖先" class="headerlink" title="37. 二叉树的最近公共祖先"></a>37. 二叉树的最近公共祖先</h1><blockquote>
<p>Leecode:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
</blockquote>
<p>解题思路：</p>
<p>递归，这种方法非常直观。先深度遍历改树。当遇到节点 p 或 q 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最近的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是p或q中的一个，对于这个节点,子树递归返回一个真标志。</p>
<p>让我们看看基于这个想法的形式算法。</p>
<p>算法：</p>
<ol>
<li>从根节点开始遍历树。</li>
<li>如果当前节点本身是 p 或 q 中的一个，我们会将变量 mid 标记为 true，并继续搜索左右分支中的另一个节点。</li>
<li>如果左分支或右分支中的任何一个返回 true，则表示在下面找到了两个节点中的一个。</li>
<li>如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 true，这意味着我们找到了节点 p 和 q 的最近公共祖先。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recurseTree</span><span class="params">(TreeNode currentNode, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="keyword">this</span>.recurseTree(currentNode.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="keyword">this</span>.recurseTree(currentNode.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (currentNode == p || currentNode == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mid + left + right &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ans = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (mid + left + right &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.recurseTree(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h1 id="38-分5个线程计算1-10000的和，要求全部计算完了再汇总"><a href="#38-分5个线程计算1-10000的和，要求全部计算完了再汇总" class="headerlink" title="38. 分5个线程计算1-10000的和，要求全部计算完了再汇总"></a>38. 分5个线程计算1-10000的和，要求全部计算完了再汇总</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchApply countDownLatchApply = <span class="keyword">new</span> CountDownLatchApply();</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        countDownLatchApply.getTotal2();</span><br><span class="line">        <span class="keyword">long</span> l2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"循环遍历:"</span> + (l2-l1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l3 = System.currentTimeMillis();</span><br><span class="line">        countDownLatchApply.getTotal();</span><br><span class="line">        <span class="keyword">long</span> l4 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch:"</span> + (l4-l3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotal2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"循环遍历结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalCount = <span class="number">5</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span>[] total = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">200000</span>; j++) &#123;</span><br><span class="line">                    sum += (j + finalI*<span class="number">200000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                total[finalI] = sum;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await(); <span class="comment">//main线程会阻塞在这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            result += total[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-1-N-这些数中1出现的次数"><a href="#39-1-N-这些数中1出现的次数" class="headerlink" title="39. 1-N 这些数中1出现的次数"></a>39. 1-N 这些数中1出现的次数</h1><blockquote>
<p>Leecode: 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 13</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</span><br></pre></td></tr></table></figure>

<h2 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h2><p>思路：</p>
<ol>
<li>将 i 从 1 遍历到 n：</li>
<li>将 i 转成字符串，数 ’1’ 的个数</li>
<li>将每个字符串里 ’1’ 的个数累加到变量 countr</li>
<li>返回 countr</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        String s1 = String.valueOf(i);</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        String s2 = s1.replaceAll(<span class="string">"1"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        count += (len1 - len2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析:</p>
<ul>
<li>时间复杂度：O(n*log10(n))：从 1 遍历到 n 每次遍历中，我们把整数转成字符串去数 ’1’ 的个数，这个过程会花费 m 的时间，其中 m 为字符串的长度，其最大值为 log10(n)。</li>
<li>空间复杂度：需要申请O(log10(n)) 个额外的空间来存储 countr 和整数转换成的字符串 str。</li>
</ul>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>下面的图列出了求个位数，十位数，百位数…的规则:</p>
<p><img src="http://qiniu.xiaoming.net.cn/Leecode%E6%B1%821%E4%B8%AA%E6%95%B0%E6%95%B0%E5%AD%A6%E5%8F%91%E5%88%86%E6%9E%90.png" alt="Leecode求1个数数学法原理"></p>
<p>由上图所示，可以观察到每 10 个数，个位上的 ’1’ 就会出现一次。同样的，每 100 个数，十位上的 ’1’ 就会出现一次。这个规律可以用 <code>(n/(i*10))*i</code> 公式来表示。</p>
<p>同时，如果十位上的数是 ’1’，那么最后 ’1’ 的数量要加上 x+1，其中 x 是个位上的数值。如果十位上的数大于 ’1’，那么十位上为 ’1’ 的所有的数都是符合要求的，这时候最后 ’1’ 的数量要加 10。</p>
<p>这个规律可以用公式 <code>min(max((n mod (i*10))−i+1,0),i)</code> 来表示。</p>
<p>来看一个例子，有一个数 n=1234。</p>
<p>个位上 ’1’ 的数量 = <code>1234/10 (对应 1,11,21,...1221) + min(4,1) (对应 1231) = 124</code></p>
<p>十位上 ’1’ 的数量 = <code>(1234/100)*10 (对应 10,11,12,...,110,111,...1919) + min(21, 10) (对应 1210,1211,...1219) = 130</code></p>
<p>百位上 ’1’ 的数量 = <code>(1234/1000)*100 (对应 100,101,102,...,199) + min(135, 100) (对应1100,1101...1199) = 200</code></p>
<p>千位上 ’1’ 的数量 = <code>(1234/10000)*10000 + min(235, 1000) (对应1000,1001,...1234) = 235</code></p>
<p>因此，总数 = 124+130+200+235 = 689。</p>
<p>算法实现：</p>
<ul>
<li>将 i 从 1 遍历到 n，每次遍历 i 扩大 10 倍：</li>
<li><code>(n/(i*10))*i</code> 表示 (i*10) 位上 ’1’ 的个数。</li>
<li><code>{min(max(({n mod (i*10)} )-i+1,0),i)}</code> 表示需要额外数的 (i*10) 位上 ’1’ 的个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> divider = i * <span class="number">10</span>;</span><br><span class="line">        count += (n / divider) * i + Math.min(Math.max(n % divider - i + <span class="number">1</span>, <span class="number">0L</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log10(n)),遍历的次数等于 n 转成字符串后字符串的长度，其值为 log10(n)。</li>
<li>空间复杂度：只需要 O(1) 的额外空间。</li>
</ul>
<h1 id="40-合并区间"><a href="#40-合并区间" class="headerlink" title="40. 合并区间"></a>40. 合并区间</h1><blockquote>
<p>Leecode：给出一个区间的集合，请合并所有重叠的区间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>首先，我们将列表根据区间开始范围从小到大进行排序。然后，将第一个区间插入 merged 数组中，然后按顺序考虑之后的每个区间：如果当前区间的左端点在前一个区间的右端点之后，那么他们不会重合，可以直接将这个区间插入 merged 中；否则，他们重合，将当前区间的右端点更新为前一个区间的右端点 end 值和当前右端点值较大的一个，完成合并。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E5%9B%BE%E8%A7%A3.png" alt="合并区间图解"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeInterval</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.isEmpty() || list.getLast()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                list.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.getLast()[<span class="number">1</span>]  = Math.max(list.getLast()[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(nlogn)，除去 sort 的开销，只需要一次线性扫描，所以主要的时间开销是排序的 O(nlgn)</p>
</li>
<li><p>空间复杂度：O(1) (or O(n))，如果可以原地排序 intervals ，就不需要额外的存储空间；否则，就需要一个线性大小的空间去存储 intervals 的备份，来完成排序过程。</p>
</li>
</ul>
<h1 id="41-股票的最大利润"><a href="#41-股票的最大利润" class="headerlink" title="41. 股票的最大利润"></a>41. 股票的最大利润</h1><blockquote>
<p>Leecode：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            minPrice = Math.min(minPrice,prices[i]);</span><br><span class="line">            maxProfit = Math.max(maxProfit,prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
</ul>
<h1 id="42-顺时针打印矩阵"><a href="#42-顺时针打印矩阵" class="headerlink" title="42. 顺时针打印矩阵"></a>42. 顺时针打印矩阵</h1><blockquote>
<p>Leetcode:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong></p>
<ol>
<li><strong>空值处理</strong>： 当 <code>matrix</code> 为空时，直接返回空列表 <code>[]</code> 即可。</li>
<li><strong>初始化</strong>： 矩阵 左、右、上、下 四个边界 <code>l</code> ,<code>r</code> ,<code>t</code> ,<code>b</code> ，用于打印的结果列表 <code>res</code> 。</li>
<li><strong>循环打印</strong>： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；</li>
</ol>
<ul>
<li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li>
<li>边界向内收缩 1 （代表已被打印）；</li>
<li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li>
</ul>
<ol start="4">
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">打印方向</th>
<th>1. 根据边界打印</th>
<th>2. 边界向内收缩</th>
<th>3. 是否打印完毕</th>
</tr>
</thead>
<tbody><tr>
<td align="left">从左向右</td>
<td>左边界 <code>l</code> ，右边界 <code>r</code></td>
<td>上边界 <code>t</code> 加 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从上向下</td>
<td>上边界 <code>t</code> ，下边界 <code>b</code></td>
<td>右边界 <code>r</code> 减 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
<tr>
<td align="left">从右向左</td>
<td>右边界 <code>r</code> ，左边界 <code>l</code></td>
<td>下边界 <code>b</code> 减 1</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td align="left">从下向上</td>
<td>下边界 <code>b</code> ，上边界 <code>t</code></td>
<td>左边界 l 加 1</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//上边界</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下边界</span></span><br><span class="line">        <span class="keyword">int</span> b = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[(r+<span class="number">1</span>) * (b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//从左到右遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                result[x++] = matrix[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从上到下遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; i++) &#123;</span><br><span class="line">                result[x++] = matrix[i][r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右往左遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">                result[x++] = matrix[b][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从下往上遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t; i--) &#123;</span><br><span class="line">                result[x++] = matrix[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度 <code>O(MN)</code> ： M,N 分别为矩阵行数和列数。</li>
<li>空间复杂度 <code>O(1)</code> ： 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> 使用常数大小的额外空间（ <code>res</code> 为必须使用的空间）。</li>
</ul>
<h1 id="43-滑动窗口的最大值"><a href="#43-滑动窗口的最大值" class="headerlink" title="43. 滑动窗口的最大值"></a>43. 滑动窗口的最大值</h1><blockquote>
<p>Leecode：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
</blockquote>
<p>返回滑动窗口中的最大值。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>动态规划：算法的思想是将输入数组分割成有 k 个元素的块。若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p>
<p>开头元素为 i ，结尾元素为 j 的当前滑动窗口可能在一个块内，也可能在两个块中。</p>
<p>建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向左-&gt;右。<br>建立数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向右-&gt;左。</p>
<p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 i 到下标 j 的滑动窗口。 根据定义，<code>right[i]</code> 是左侧块内的最大元素， <code>left[j]</code> 是右侧块内的最大元素。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="滑动窗口的最大值"></p>
<p>算法流程如下：</p>
<ol>
<li>从左到右遍历数组，建立数组 left。</li>
<li>从右到左遍历数组，建立数组 right。</li>
<li>建立输出数组 <code>max(right[i], left[i + k - 1])，其中 i 取值范围为 (0, n - k + 1)</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> [] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// from left to right</span></span><br><span class="line">      <span class="keyword">if</span> (i % k == <span class="number">0</span>) left[i] = nums[i];  <span class="comment">// block_start</span></span><br><span class="line">      <span class="keyword">else</span> left[i] = Math.max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// from right to left</span></span><br><span class="line">      <span class="keyword">int</span> j = n - i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ((j + <span class="number">1</span>) % k == <span class="number">0</span>) right[j] = nums[j];  <span class="comment">// block_end</span></span><br><span class="line">      <span class="keyword">else</span> right[j] = Math.max(right[j + <span class="number">1</span>], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++)</span><br><span class="line">      output[i] = Math.max(left[i + k - <span class="number">1</span>], right[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="44-从前序与中序遍历序列构造二叉树"><a href="#44-从前序与中序遍历序列构造二叉树" class="headerlink" title="44. 从前序与中序遍历序列构造二叉树"></a>44. 从前序与中序遍历序列构造二叉树</h1><blockquote>
<p>剑指offer第7题</p>
</blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意: 可以假设树中没有重复的元素。</p>
<p>例如，给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>根据前序遍历结果，首节点一定是根结点，在中序遍历中找到根结点，根节点左边的都是左子树，根结点右边的都是右子树。</p>
<p>另外，由于是遍历同一颗树，所以左子树和右子树的节点数量是相同的。利用这个关系，可以定义出如下边界：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="从前序和中序遍历序列构造二叉树"></p>
<p>接下来就只需要分别递归构建左右子树即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebuildBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = preorder.length;</span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(inLen);</span><br><span class="line">        <span class="comment">// 构造中序遍历中根结点和下标的映射关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inLen; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preLen - <span class="number">1</span>, <span class="number">0</span>, inLen - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归构建二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preorder 前序遍历结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preLeft 当前前序遍历根结点（当前遍历的最左边界）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preRight 当前前序遍历的最又边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inLeft 当前中序遍历的最左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inRight 当前中序遍历的最右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 存储根结点在中序遍历的映射关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">        Integer pIndex = map.get(preorder[preLeft]);</span><br><span class="line">        head.left = buildTree(preorder, preLeft + <span class="number">1</span>, pIndex - inLeft + preLeft,</span><br><span class="line">                inLeft, pIndex - <span class="number">1</span>, map);</span><br><span class="line">        head.right = buildTree(preorder, pIndex - inLeft + preLeft + <span class="number">1</span>,</span><br><span class="line">                preRight, pIndex + <span class="number">1</span>, inRight, map);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：<code>O(n)</code>，其中 n 是树中的节点个数。</li>
<li>空间复杂度：<code>O(n)</code>，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 <code>h &lt; n</code>，所以（在最坏情况下）总空间复杂度为 <code>O(n)</code>。</li>
</ul>
<h1 id="45-矩阵中的路径"><a href="#45-矩阵中的路径" class="headerlink" title="45. 矩阵中的路径"></a>45. 矩阵中的路径</h1><blockquote>
<p>剑指 offer 12 题</p>
</blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</span><br></pre></td></tr></table></figure>

<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
</blockquote>
<h3 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h3><ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
<h3 id="算法剖析："><a href="#算法剖析：" class="headerlink" title="算法剖析："></a>算法剖析：</h3><ul>
<li><p><strong>递归参数：</strong> 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>
</li>
<li><p><strong>终止条件：</strong></p>
<ol>
<li><p><strong>返回 false：</strong> </p>
<p>① 行或列索引越界 <strong>或</strong> ② 当前矩阵元素与目标字符不同 <strong>或</strong> ③ 当前矩阵元素已访问过 <em>（③ 可合并至 ② ）</em> 。</p>
</li>
<li><p><strong>返回 true ：</strong> 字符串 <code>word</code> 已全部匹配，即 <code>k = len(word) - 1</code> 。</p>
</li>
</ol>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>标记当前矩阵元素：</strong> 将 <code>board[i][j]</code> 值暂存于变量 <code>tmp</code> ，并修改为字符 <code>&#39;/&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li><strong>搜索下一单元格：</strong> 朝当前元素的 <strong>上、下、左、右</strong> 四个方向开启下层递归，使用 <code>或</code> 连接 <em>（代表只需一条可行路径）</em> ，并记录结果至 <code>res</code> 。</li>
<li><strong>还原当前矩阵元素：</strong> 将 <code>tmp</code> 暂存值还原至 <code>board[i][j]</code> 元素。</li>
</ol>
</li>
<li><p><strong>回溯返回值：</strong> 返回 <code>res</code> ，代表是否搜索到目标字符串。</p>
</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt="剑指offer12题矩阵中的路径"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%89%91%E6%8C%87offer12%E9%A2%98%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9B%9E%E6%BA%AF.png" alt="剑指offer12题矩阵中的路径回溯"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearchInMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="comment">// 这里遍历了任意开始的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bfs(board, words, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下标是否越界，值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length</span><br><span class="line">                || board[i][j] != words[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == words.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">        <span class="comment">//深度递归遍历（顺序为下、上、右、左）</span></span><br><span class="line">        <span class="keyword">boolean</span> res = bfs(board, words, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || bfs(board, words, i - <span class="number">1</span>, j, k + <span class="number">1</span>)</span><br><span class="line">                || bfs(board, words, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || bfs(board, words, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://blog.csdn.net/CleverCode/article/details/81743736" target="_blank" rel="noopener">100G 数据，只有 100M 内存，怎么排序</a><br><a href="https://blog.csdn.net/u014106566/article/details/101224875" target="_blank" rel="noopener">求比n小的一个数，使其各位数的乘积最大</a><br><a href="https://www.nowcoder.com/discuss/383652?type=all&order=time&pos=&page=1" target="_blank" rel="noopener">牛客网——腾讯WXG后端一面面经</a><br><a href="https://blog.csdn.net/You_are_my_dream/article/details/55005158" target="_blank" rel="noopener">完全二叉树的叶子节点总数问题</a><br><a href="https://www.cnblogs.com/kubidemanong/p/10834993.html" target="_blank" rel="noopener">【面试被虐】说说游戏中的敏感词过滤是如何实现的？</a> </p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/28/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="数据结构">
      <i class="fa fa-chevron-left"></i> 数据结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/08/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%20Spring/" rel="next" title="JavaSpring">
      JavaSpring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-字符串匹配KMP算法"><span class="nav-number">1.</span> <span class="nav-text">1. 字符串匹配KMP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#部分匹配值的实现思路"><span class="nav-number">1.1.</span> <span class="nav-text">部分匹配值的实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP算法"><span class="nav-number">1.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-替换空格"><span class="nav-number">2.</span> <span class="nav-text">2. 替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-最长公共前缀"><span class="nav-number">3.</span> <span class="nav-text">3. 最长公共前缀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-最长回文串"><span class="nav-number">4.</span> <span class="nav-text">4. 最长回文串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-验证回文串"><span class="nav-number">5.</span> <span class="nav-text">5. 验证回文串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-最长回文子串"><span class="nav-number">6.</span> <span class="nav-text">6. 最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-最长回文子序列"><span class="nav-number">7.</span> <span class="nav-text">7. 最长回文子序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-括号匹配深度"><span class="nav-number">8.</span> <span class="nav-text">8. 括号匹配深度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-把数字字符串转换成整数"><span class="nav-number">9.</span> <span class="nav-text">9. 把数字字符串转换成整数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-两数相加"><span class="nav-number">10.</span> <span class="nav-text">10. 两数相加</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-反转链表"><span class="nav-number">11.</span> <span class="nav-text">11. 反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-删除链表中倒数第k个节点"><span class="nav-number">12.</span> <span class="nav-text">12. 删除链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-输出链表中倒数第k个节点"><span class="nav-number">13.</span> <span class="nav-text">13. 输出链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-求斐波纳切数列的第n个数-爬楼梯"><span class="nav-number">14.</span> <span class="nav-text">14. 求斐波纳切数列的第n个数/爬楼梯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-变态台阶问题"><span class="nav-number">15.</span> <span class="nav-text">15. 变态台阶问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-二维数组查找"><span class="nav-number">16.</span> <span class="nav-text">16. 二维数组查找</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-按奇偶排序数组"><span class="nav-number">17.</span> <span class="nav-text">17. 按奇偶排序数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-TOP-K-问题"><span class="nav-number">18.</span> <span class="nav-text">18. TOP K 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排"><span class="nav-number">18.1.</span> <span class="nav-text">堆排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快排方式"><span class="nav-number">18.2.</span> <span class="nav-text">快排方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间换时间：bitmap方式-海量数据排序也可以用"><span class="nav-number">18.3.</span> <span class="nav-text">空间换时间：bitmap方式(海量数据排序也可以用)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-1亿个-IPV-地址找相同"><span class="nav-number">19.</span> <span class="nav-text">19. 1亿个 IPV 地址找相同</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法一：hash取模"><span class="nav-number">19.1.</span> <span class="nav-text">方法一：hash取模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法二：bitmap"><span class="nav-number">19.2.</span> <span class="nav-text">方法二：bitmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-两个栈实现队列"><span class="nav-number">20.</span> <span class="nav-text">20. 两个栈实现队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-字典树（trie）实现敏感词汇过滤"><span class="nav-number">21.</span> <span class="nav-text">21. 字典树（trie）实现敏感词汇过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思路总结："><span class="nav-number">21.1.</span> <span class="nav-text">算法思路总结：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具体过程"><span class="nav-number">21.2.</span> <span class="nav-text">具体过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法代码实现"><span class="nav-number">21.3.</span> <span class="nav-text">算法代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间空间复杂度"><span class="nav-number">21.4.</span> <span class="nav-text">时间空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-给定已有硬币面值，计算需要的最少硬币数目？"><span class="nav-number">22.</span> <span class="nav-text">22. 给定已有硬币面值，计算需要的最少硬币数目？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-动态规划01背包问题"><span class="nav-number">23.</span> <span class="nav-text">23. 动态规划01背包问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-最长不重复子串"><span class="nav-number">24.</span> <span class="nav-text">24. 最长不重复子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-数据求交集"><span class="nav-number">25.</span> <span class="nav-text">25. 数据求交集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂度分析"><span class="nav-number">25.1.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-如何判断单链表是否有环？如何确定环的入口？"><span class="nav-number">26.</span> <span class="nav-text">26. 如何判断单链表是否有环？如何确定环的入口？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法一：hash-表"><span class="nav-number">26.1.</span> <span class="nav-text">方法一：hash 表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法二：双指针（快慢指针）"><span class="nav-number">26.2.</span> <span class="nav-text">方法二：双指针（快慢指针）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-找两条链表公共节点"><span class="nav-number">27.</span> <span class="nav-text">27. 找两条链表公共节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-100G-的文件，只有-100M-内存，对文件进行排序"><span class="nav-number">28.</span> <span class="nav-text">28. 100G 的文件，只有 100M 内存，对文件进行排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#外部排序-多路归并"><span class="nav-number">28.1.</span> <span class="nav-text">外部排序 + 多路归并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位图法"><span class="nav-number">28.2.</span> <span class="nav-text">位图法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-100亿个整型数据，乱序，100M内存，求中位数"><span class="nav-number">29.</span> <span class="nav-text">29. 100亿个整型数据，乱序，100M内存，求中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><span class="nav-number">30.</span> <span class="nav-text">30. 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-二叉树中和为某一值的路径"><span class="nav-number">31.</span> <span class="nav-text">31. 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-两个字符串A-B，将所有同时存在于A-B中的字母从A中剔除"><span class="nav-number">32.</span> <span class="nav-text">32. 两个字符串A,B，将所有同时存在于A,B中的字母从A中剔除</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-二叉搜索树转双向链表"><span class="nav-number">33.</span> <span class="nav-text">33. 二叉搜索树转双向链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-有序链表转换二叉搜索树"><span class="nav-number">34.</span> <span class="nav-text">34. 有序链表转换二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？"><span class="nav-number">35.</span> <span class="nav-text">35. 一颗完全二叉树共有1699个结点，则该二叉树中叶子结点数（度为0）为？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-m-n-的格子，部分格子有障碍物，从左上角到右下角有多少条路径"><span class="nav-number">36.</span> <span class="nav-text">36. m * n 的格子，部分格子有障碍物，从左上角到右下角有多少条路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-二叉树的最近公共祖先"><span class="nav-number">37.</span> <span class="nav-text">37. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-分5个线程计算1-10000的和，要求全部计算完了再汇总"><span class="nav-number">38.</span> <span class="nav-text">38. 分5个线程计算1-10000的和，要求全部计算完了再汇总</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-1-N-这些数中1出现的次数"><span class="nav-number">39.</span> <span class="nav-text">39. 1-N 这些数中1出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：暴力破解"><span class="nav-number">39.1.</span> <span class="nav-text">解法一：暴力破解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学法"><span class="nav-number">39.2.</span> <span class="nav-text">数学法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-合并区间"><span class="nav-number">40.</span> <span class="nav-text">40. 合并区间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-股票的最大利润"><span class="nav-number">41.</span> <span class="nav-text">41. 股票的最大利润</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-顺时针打印矩阵"><span class="nav-number">42.</span> <span class="nav-text">42. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-滑动窗口的最大值"><span class="nav-number">43.</span> <span class="nav-text">43. 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-从前序与中序遍历序列构造二叉树"><span class="nav-number">44.</span> <span class="nav-text">44. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂度分析-1"><span class="nav-number">44.1.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-矩阵中的路径"><span class="nav-number">45.</span> <span class="nav-text">45. 矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路"><span class="nav-number">45.1.</span> <span class="nav-text">解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理："><span class="nav-number">45.1.1.</span> <span class="nav-text">算法原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法剖析："><span class="nav-number">45.1.2.</span> <span class="nav-text">算法剖析：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">45.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
