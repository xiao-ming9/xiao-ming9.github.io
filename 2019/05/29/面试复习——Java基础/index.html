<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. &#x3D;&#x3D;和equals的区别 对于基本数据类型，“&#x3D;&#x3D;”比较的是值是否相等；对于引用数据类型，“&#x3D;&#x3D;”比较的是内存地址是否相等 equals本质上来说是使用了&#x3D;&#x3D;作为其底层的实现，但是java中很多类都对equals做了重写，使其对值进行判断  重写equals可以通过判断以下几点实现：  检查是否为同一个对象的引用，如果是直接返回tr">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="http://yoursite.com/2019/05/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="1. &#x3D;&#x3D;和equals的区别 对于基本数据类型，“&#x3D;&#x3D;”比较的是值是否相等；对于引用数据类型，“&#x3D;&#x3D;”比较的是内存地址是否相等 equals本质上来说是使用了&#x3D;&#x3D;作为其底层的实现，但是java中很多类都对equals做了重写，使其对值进行判断  重写equals可以通过判断以下几点实现：  检查是否为同一个对象的引用，如果是直接返回tr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/df1c3077b929873727c9970e3a48c0ef14fd094d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f7075742545362539362542392545362542332539352e706e67">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/1.7%E7%9A%84ConcurrentHashMap.jpeg">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20180925/308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F">
<meta property="og:image" content="https://camo.githubusercontent.com/b823c5f2cf18e7e27da70409d2b5e18fed820364/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e382d436f6e63757272656e74486173684d61702d5374727563747572652e6a7067">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8invoke%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/UTF-8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E5%90%84%E4%B8%AA%E7%BC%96%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB.jpg">
<meta property="article:published_time" content="2019-05-29T00:30:11.000Z">
<meta property="article:modified_time" content="2020-12-01T10:35:02.185Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67">


<link rel="canonical" href="http://yoursite.com/2019/05/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2019/05/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/","path":"2019/05/29/面试复习——Java基础/","title":"java基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java基础 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1. &#x3D;&#x3D;和equals的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">例子：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E4%B8%ADequals%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-jdk11-%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">String中equals底层实现(jdk11)：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8equals%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">使用equals方法注意事项：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2. 为什么重写equals时必须重写hashCode方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-List-Set-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">3. List,Set,Map三者的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">4. ArrayList源码分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-LinkList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">5. LinkList源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkList%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">LinkList中获取指定位置节点的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkList%E5%B0%86%E9%9B%86%E5%90%88%E6%8F%92%E5%85%A5%E5%88%B0%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">LinkList将集合插入到链表尾部：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList%E8%8E%B7%E5%8F%96%E5%A4%B4%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">5.3.</span> <span class="nav-text">LinkedList获取头节点数据的方法：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">6. String，StringBuffer和StringBuilder的区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-String%E4%B8%A4%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">7. String两种赋值方式比较：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">8. String创建对象五种情况分析：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%85%E5%86%B51"><span class="nav-number">8.1.</span> <span class="nav-text">情况1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%85%E5%86%B52"><span class="nav-number">8.2.</span> <span class="nav-text">情况2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%85%E5%86%B53"><span class="nav-number">8.3.</span> <span class="nav-text">情况3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%85%E5%86%B54"><span class="nav-number">8.4.</span> <span class="nav-text">情况4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%85%E5%86%B55"><span class="nav-number">8.5.</span> <span class="nav-text">情况5</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">9. 接口与抽象类区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">9.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">10. 重写和重载的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E6%B5%85%E5%85%8B%E9%9A%86%E5%92%8C%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="nav-number">11.</span> <span class="nav-text">11. 浅克隆和深克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#clone%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">11.1.</span> <span class="nav-text">clone替代方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">12.</span> <span class="nav-text">12. 类加载时的初始化顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">13. 构造器Constructor是否可以被重写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">14. 对象实例与对象引用有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E4%B8%BA%E4%BB%80%E4%B9%88java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">15. 为什么java只有值传递？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">16. 程序、进程、线程的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-java%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="nav-number">17.</span> <span class="nav-text">17. java线程有哪些基本状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">18.</span> <span class="nav-text">18. java中的异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ERROR"><span class="nav-number">18.1.</span> <span class="nav-text">ERROR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXCEPTION"><span class="nav-number">18.2.</span> <span class="nav-text">EXCEPTION</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Throwable%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">18.3.</span> <span class="nav-text">Throwable类常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93"><span class="nav-number">18.4.</span> <span class="nav-text">异常处理总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#finally%E5%9D%97%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">18.4.1.</span> <span class="nav-text">finally块不会被执行的四种情况：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9FBIO%EF%BC%8CNIO%EF%BC%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">19. Java中的IO流分为几种？BIO，NIO，AIO的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E4%B8%ADIO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="nav-number">19.1.</span> <span class="nav-text">JAVA中IO流分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%9A"><span class="nav-number">19.1.1.</span> <span class="nav-text">按照操作方式分类的结构图：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%9A"><span class="nav-number">19.1.2.</span> <span class="nav-text">按照操作对象分类结构图：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIO-NIO-AIO%E5%8C%BA%E5%88%AB"><span class="nav-number">19.2.</span> <span class="nav-text">BIO,NIO,AIO区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">20.</span> <span class="nav-text">20. 获取键盘输入常用的两种方法：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-BigDecimal%E7%94%A8%E5%A4%84"><span class="nav-number">21.</span> <span class="nav-text">21. BigDecimal用处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BigDecimal%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="nav-number">21.1.</span> <span class="nav-text">BigDecimal的大小比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BigDecimal%E4%BF%9D%E7%95%99%E5%87%A0%E4%BD%8D%E5%B0%8F%E6%95%B0"><span class="nav-number">21.2.</span> <span class="nav-text">BigDecimal保留几位小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BigDecimal%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">21.3.</span> <span class="nav-text">BigDecimal使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Arrays-asList-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="nav-number">22.</span> <span class="nav-text">22. Arrays.asList()使用指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E5%AF%B9%E5%85%B6%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="nav-number">22.1.</span> <span class="nav-text">《阿里巴巴Java开发手册》对其的描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93"><span class="nav-number">22.2.</span> <span class="nav-text">使用时注意事项总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList%EF%BC%9F"><span class="nav-number">22.3.</span> <span class="nav-text">如何正确的将数组转化为ArrayList？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Collection-toArray-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">23.</span> <span class="nav-text">23. Collection.toArray()方法的使用以及如何反转数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8foreach%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84remove-x2F-add%E6%93%8D%E4%BD%9C"><span class="nav-number">24.</span> <span class="nav-text">24. 为什么不要在foreach循环里进行元素的remove&#x2F;add操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">24.1.</span> <span class="nav-text">源码解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-Servlet%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8AServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">25.</span> <span class="nav-text">25. Servlet接口中有哪些方法以及Servlet的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Servlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">26.</span> <span class="nav-text">26. Servlet线程安全问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">27.</span> <span class="nav-text">27. HashMap源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">27.1.</span> <span class="nav-text">HashMap类中的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E8%8E%B7%E5%BE%97hash%E5%80%BC%E6%96%B9%E6%B3%95"><span class="nav-number">27.2.</span> <span class="nav-text">HashMap获得hash值方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%8A%82%E7%82%B9%E7%B1%BB%E5%88%86%E6%9E%90"><span class="nav-number">27.3.</span> <span class="nav-text">内部节点类分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node%E8%8A%82%E7%82%B9"><span class="nav-number">27.3.1.</span> <span class="nav-text">Node节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%BB%93%E7%82%B9%E7%B1%BB"><span class="nav-number">27.3.2.</span> <span class="nav-text">树结点类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">27.4.</span> <span class="nav-text">常用方法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">27.4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#putMapEntries%E6%96%B9%E6%B3%95"><span class="nav-number">27.4.2.</span> <span class="nav-text">putMapEntries方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Put%E6%96%B9%E6%B3%95"><span class="nav-number">27.4.3.</span> <span class="nav-text">Put方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get%E6%96%B9%E6%B3%95"><span class="nav-number">27.4.4.</span> <span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="nav-number">27.4.5.</span> <span class="nav-text">resize扩容方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">28. ArrayList和LinkedList区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RandomAccess%E6%8E%A5%E5%8F%A3"><span class="nav-number">28.1.</span> <span class="nav-text">RandomAccess接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list%E7%9A%84%E9%81%8D%E5%8E%86%E9%80%89%E6%8B%A9%EF%BC%9A"><span class="nav-number">28.2.</span> <span class="nav-text">list的遍历选择：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">29. HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-HashSet%EF%BC%88HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="nav-number">30.</span> <span class="nav-text">30. HashSet（HashMap和HashSet区别）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">30.1.</span> <span class="nav-text">HashSet检查重复的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">31. HashMap 为什么线程不安全？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#put%E7%9A%84%E6%97%B6%E5%80%99%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E3%80%82"><span class="nav-number">31.1.</span> <span class="nav-text">put的时候导致的多线程数据不一致。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B-Rehash-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="nav-number">31.2.</span> <span class="nav-text">多线程下 Rehash 导致的死循环问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-ConcurrentHashMap"><span class="nav-number">32.</span> <span class="nav-text">32. ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#get-%E6%96%B9%E6%B3%95"><span class="nav-number">32.1.</span> <span class="nav-text">get 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">32.2.</span> <span class="nav-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%E5%90%97%EF%BC%9F"><span class="nav-number">32.3.</span> <span class="nav-text">ConcurrentHashMap有什么缺陷吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-Comparable%E5%92%8CComparator%E5%8C%BA%E5%88%AB"><span class="nav-number">33.</span> <span class="nav-text">33. Comparable和Comparator区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">34.</span> <span class="nav-text">34. 容器中用到的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">34.1.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">34.2.</span> <span class="nav-text">适配器模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-Vector%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90"><span class="nav-number">35.</span> <span class="nav-text">35. Vector相关分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">35.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9"><span class="nav-number">35.2.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8EArrayList%E5%8C%BA%E5%88%AB"><span class="nav-number">35.3.</span> <span class="nav-text">与ArrayList区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">35.4.</span> <span class="nav-text">替代方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-CopyOnWriteArrayList"><span class="nav-number">36.</span> <span class="nav-text">36. CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-LinkedHashMap%E5%88%86%E6%9E%90"><span class="nav-number">37.</span> <span class="nav-text">37. LinkedHashMap分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">37.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98"><span class="nav-number">37.2.</span> <span class="nav-text">使用LinkedHashMap实现LRU缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-WeakHashMap"><span class="nav-number">38.</span> <span class="nav-text">38. WeakHashMap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-TreeSet"><span class="nav-number">39.</span> <span class="nav-text">39. TreeSet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">39.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F"><span class="nav-number">39.2.</span> <span class="nav-text">元素排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">40. Java中是如何支持正则表达式操作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">41. Java中如何跳出嵌套循环？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">42. &amp; 和 &amp;&amp; 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-Java%E9%87%8C%E9%9D%A2final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">43. Java里面final关键字的使用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-number">44.</span> <span class="nav-text">44. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%9E%8B%EF%BC%9F%E8%A7%A3%E9%87%8A-extends-%E5%92%8C-super-%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">45. 什么是范型？解释 extends 和 super 泛型限定符？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">46. String 为什么是不可变的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-Object-%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="nav-number">47.</span> <span class="nav-text">47. Object 类中有哪些方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#getClass"><span class="nav-number">47.1.</span> <span class="nav-text">getClass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode"><span class="nav-number">47.2.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">47.3.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone"><span class="nav-number">47.4.</span> <span class="nav-text">clone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">47.5.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-notifyAll"><span class="nav-number">47.6.</span> <span class="nav-text">wait(),notify(),notifyAll()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finalize"><span class="nav-number">47.7.</span> <span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-List%E3%80%81Set%E3%80%81Map%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AACollection%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">48. List、Set、Map是否继承自Collection接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-Collection-%E5%92%8C-Collections-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">49. Collection 和 Collections 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">50.</span> <span class="nav-text">50. 与快速失败机制对应的安全失败机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-Iterator-%E5%92%8C-ListIterator-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">51. Iterator 和 ListIterator 区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">52. 运行时异常和受检异常有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-JDBC-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">53.</span> <span class="nav-text">53. JDBC 使用流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-Java%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">54. Java提供的排序算法是怎么实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays-sort-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">54.1.</span> <span class="nav-text">Arrays.sort()的排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections-sort-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">54.2.</span> <span class="nav-text">Collections.sort()的排序算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-Collections-synchronizedMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">55.</span> <span class="nav-text">55. Collections.synchronizedMap()与 ConcurrentHashMap 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-JAVA-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">56.</span> <span class="nav-text">56. JAVA 反射的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E6%98%AF-forName-%E6%96%B9%E6%B3%95"><span class="nav-number">56.1.</span> <span class="nav-text">首先是 forName 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%98%AF-newInstance-%E6%96%B9%E6%B3%95"><span class="nav-number">56.2.</span> <span class="nav-text">接下来是 newInstance 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-getMethod-%E2%80%9CmyMethod%E2%80%9D-%E8%8E%B7%E5%BE%97-Method-%E5%AF%B9%E8%B1%A1"><span class="nav-number">56.3.</span> <span class="nav-text">反射获取方法 getMethod(“myMethod”) 获得 Method 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-invoke-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">56.4.</span> <span class="nav-text">Method.invoke() 反射调用方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-JVM%E3%80%81JRE%E3%80%81JDK-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">57. JVM、JRE、JDK 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-JAVA%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">58.</span> <span class="nav-text">58. JAVA的简单数据类型和复合数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">59.</span> <span class="nav-text">59. 字符编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ASCII-%E7%A0%81"><span class="nav-number">59.1.</span> <span class="nav-text">ASCII 码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode"><span class="nav-number">59.2.</span> <span class="nav-text">Unicode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">59.2.1.</span> <span class="nav-text">Unicode 的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-8"><span class="nav-number">59.3.</span> <span class="nav-text">UTF-8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Little-endian-%E5%92%8C-Big-endian"><span class="nav-number">59.4.</span> <span class="nav-text">Little endian 和 Big endian</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GB%E7%B3%BB%E5%88%97%E5%AD%97%E7%AC%A6%E9%9B%86-amp-%E7%BC%96%E7%A0%81"><span class="nav-number">59.5.</span> <span class="nav-text">GB系列字符集&amp;编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">60.</span> <span class="nav-text">60. Lambda 表达式实现原理</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java基础 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-29 08:30:11" itemprop="dateCreated datePublished" datetime="2019-05-29T08:30:11+08:00">2019-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-12-01 18:35:02" itemprop="dateModified" datetime="2020-12-01T18:35:02+08:00">2020-12-01</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>72k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:05</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-x3D-x3D-和equals的区别"><a href="#1-x3D-x3D-和equals的区别" class="headerlink" title="1. &#x3D;&#x3D;和equals的区别"></a>1. &#x3D;&#x3D;和equals的区别</h1><ol>
<li>对于基本数据类型，“=&#x3D;”比较的是值是否相等；对于引用数据类型，“=&#x3D;”比较的是内存地址是否相等</li>
<li>equals本质上来说是使用了&#x3D;&#x3D;作为其底层的实现，但是java中很多类都对equals做了重写，使其对值进行判断</li>
</ol>
<p>重写<code>equals</code>可以通过判断以下几点实现：</p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回true</li>
<li>检查是否是同一类型，不是直接返回false</li>
<li>将Object进行转型</li>
<li>判断每个关键域是否相等</li>
</ul>
<span id="more"></span>

<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>String类中对equals方法进行了重写，使其判断String类型的数据的值是否相等，相等则返回true</p>
<h3 id="String中equals底层实现-jdk11-："><a href="#String中equals底层实现-jdk11-：" class="headerlink" title="String中equals底层实现(jdk11)："></a>String中equals底层实现(jdk11)：</h3><ol>
<li>首先判断两个对象的地址是否相等，如果相等直接返回true，否则则进行下一步判断</li>
<li>接着判断对象实例是否是String类，如果不是直接返回false</li>
<li>判断两者的字符编码是否相同<blockquote>
<p>String类中定义了 <code>COMPACT_STRINGS</code> 表示是否开启字符串压缩，如果关闭则都使用UTF16编码</p>
</blockquote>
</li>
<li>根据字符编码不同分别调用不同的字符类中的equals方法判断<blockquote>
<p>有两个字符编码类：<code>Latin1(ISO-8859-1)</code> 和 <code>UTF16</code></p>
</blockquote>
</li>
</ol>
<pre><code class="java">public boolean equals(Object anObject) &#123;
    if (this == anObject) &#123;
        return true;
    &#125;
    if (anObject instanceof String) &#123;
        String aString = (String)anObject;
        if (coder() == aString.coder()) &#123;
            return isLatin1() ? StringLatin1.equals(value, aString.value)
                              : StringUTF16.equals(value, aString.value);
        &#125;
    &#125;
    return false;
&#125;
</code></pre>
<p><strong>两个字符类中equals的实现：</strong></p>
<pre><code class="java">/* StringLatin*/
public static boolean equals(byte[] value, byte[] other) &#123;
    if (value.length == other.length) &#123;
        for (int i = 0; i &lt; value.length; i++) &#123;
            if (value[i] != other[i]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
    return false;
&#125;

/* StringUTF16 */
public static boolean equals(byte[] value, byte[] other) &#123;
    if (value.length == other.length) &#123;
        //UTF16类型的数据，一个字符会占据两个byte数组位，所以计算长度时需要将byte数组长度缩小2倍
        int len = value.length &gt;&gt; 1;
        for (int i = 0; i &lt; len; i++) &#123;
            if (getChar(value, i) != getChar(other, i)) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<ul>
<li>说明：<blockquote>
<p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>
</blockquote>
</li>
</ul>
<h2 id="使用equals方法注意事项："><a href="#使用equals方法注意事项：" class="headerlink" title="使用equals方法注意事项："></a>使用equals方法注意事项：</h2><ol>
<li>Object的<code>equals</code>方法容易抛空指针异常，应使用常量或确定有值的对象来调用<code>equals</code>。</li>
<li>更推荐使用<code>java.util.Object.equals</code>（JDK7引入的工具类）</li>
</ol>
<pre><code class="java">public static boolean equals(Object a, Object b) &#123;
        // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。
        return (a == b) || (a != null &amp;&amp; a.equals(b));
    &#125;
</code></pre>
<ol start="3">
<li>所有整形包装类对象值的比较都必须使用<code>equals</code>方法</li>
</ol>
<pre><code class="java">Integer x = 3;//将3自动装箱成Integer
Integer y = 3;
System.out.println(x == y);// true
Integer a = new Integer(3);
Integer b = new Integer(3);
int c = 3;
System.out.println(a == b);//false
System.out.println(a.equals(b));//true
System.out.println(a == x);//false
System.out.println(a == c);//true,将a自动拆箱成int再比较
</code></pre>
<h1 id="2-为什么重写equals时必须重写hashCode方法？"><a href="#2-为什么重写equals时必须重写hashCode方法？" class="headerlink" title="2. 为什么重写equals时必须重写hashCode方法？"></a>2. 为什么重写equals时必须重写hashCode方法？</h1><blockquote>
<p>默认情况下，Object 的 <code>hashcode</code> 方法是本地方法，也就是用 C 或者 C++ 语言实现的，该方法直接返回对象的内存地址。</p>
</blockquote>
<ol>
<li>hashcode 获取得到的是该对象在哈希表中的索引位置，是一个 int 类型的数据，称为哈希码，也叫<strong>散列码</strong></li>
<li>hashcode 只有在需要用到<strong>散列表</strong>(HashSet, Hashtable, HashMap)的情况下才需要，不然没有任何关系</li>
<li>hashcode使用情况实例：<blockquote>
<p>当在hashset中加入新对象时，hashset 首先会先计算 hashcode 来判断对象加入的位置，同时将该 hashcode 与其他已经在 hashset 中的对象的 hashcode 做比较，如果 hashcode 不相同，则认为对象不相同。如果存在 hashcode 相同的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
</blockquote>
</li>
</ol>
<ul>
<li>hashCode（）与equals（）的相关规定:</li>
</ul>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回true</li>
<li><strong>两个对象有相同的hashcode 值，它们也不一定是相等</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>因此，要判断两个对象的值是否相等，除了重写equals 方法，hashCode方法也必须被覆盖</p>
<p>重写 hashcode 的思路：<br>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。<strong>R一般取31</strong>，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出时，信息就会丢失，因为与2相乘相当于左移一位。</p>
<blockquote>
<p>一个数与31相乘可以转换成移位和减法:<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
</blockquote>
<pre><code class="java">//例如一个类中有x，y，z三个整数类型的属性：
@Override
public int hashCode() &#123;
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
&#125;
</code></pre>
<h1 id="3-List-Set-Map三者的区别"><a href="#3-List-Set-Map三者的区别" class="headerlink" title="3. List,Set,Map三者的区别"></a>3. List,Set,Map三者的区别</h1><ol>
<li>List是有序列表，其存放内容是可以重复的，其实现接口有：<strong>ArrayList</strong>，<strong>LinkedList</strong>，<strong>Vector</strong></li>
<li>Set是无序的集合，其内部存放的内容不可以重复，实现接口有<strong>HashSet</strong>，<strong>TreeSet</strong>，<strong>LinkedHashSet</strong></li>
<li>Map存的是键值对（key-value），key值不允许有重复，value内容可以相同，但对应不同的key，实现接口有<strong>HashMap</strong>，<strong>TreeMap</strong>,<strong>LinkedHashMap</strong></li>
</ol>
<h1 id="4-ArrayList源码分析"><a href="#4-ArrayList源码分析" class="headerlink" title="4. ArrayList源码分析"></a>4. ArrayList源码分析</h1><ol>
<li>在使用默认构造方法（无参构造）时，创建的是一个空数组，只有当第一次插入数据时，才会将数组容量初始化为10</li>
</ol>
<pre><code class="java">//private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;

public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;
</code></pre>
<ol start="2">
<li>ArrayList的扩容机制：</li>
</ol>
<pre><code class="java"> //扩容方法：
 private Object[] grow(int minCapacity) &#123;
        return elementData = Arrays.copyOf(elementData,newCapacity(minCapacity));
 &#125;
    
 //扩容核心方法：  
 private int newCapacity(int minCapacity) &#123;
 
        int oldCapacity = elementData.length;
        //右移一位相当于除以2，即新的容量为原来容量的1.5倍
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //比较新容量跟指定容量大小
        if (newCapacity - minCapacity &lt;= 0) &#123;
            //如果minCapacity比较大
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                //返回默认容量和minCapacity中较大的
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity &lt; 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        &#125;
        //如果newCapacity比较大
        //如果小于MAX_ARRRY_SIZE，则返回newCapacity，否则返回Integer最大值
        return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    &#125;

    private static int hugeCapacity(int minCapacity) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE)
            ? Integer.MAX_VALUE
            : MAX_ARRAY_SIZE;
    &#125;
</code></pre>
<ol start="3">
<li>ArrayList复制的方式<br>ArrayList源码中用到的复制方法有两个：<code>System.arraycopy</code>，<code>Arrays.copyOf</code></li>
</ol>
<p><strong>两者的区别：</strong></p>
<ul>
<li>Arrays.copyOf本质上是调用了System.arraycopy方法</li>
<li>arraycopy需要传入目标数组，将复制后的数据放到目标数组中，而copyOf是在方法内部创建一个数组，将内容复制到这个数组然后返回该数组</li>
</ul>
<p>copyOf的一个方法的源码：</p>
<pre><code> public static byte[] copyOf(byte[] original, int newLength) &#123;
        byte[] copy = new byte[newLength];
        //本质上调用了arraycopy
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;
</code></pre>
<p>arraycopy的源码：</p>
<pre><code>/**
  * @param      src      源数组
  * @param      srcPos   要复制的源数组的起始位置
  * @param      dest     目标数组
  * @param      destPos  目标数组起始位置
  * @param      length   复制的长度.
  */
public static native void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);
</code></pre>
<p>ArrayList中add方法通过arraycopy方法复制自身数组，并将后面数组右移实现在指定位置插入内容</p>
<pre><code class="java">public void add(int index, E element) &#123;
        rangeCheckForAdd(index);
        modCount++;
        final int s;
        Object[] elementData;
        if ((s = size) == (elementData = this.elementData).length)
            elementData = grow();
        //复制自身数组，将index位置的数据后移
        System.arraycopy(elementData, index,
                         elementData, index + 1,
                         s - index);
        //index位置放入数据
        elementData[index] = element;
        size = s + 1;
    &#125;
</code></pre>
<ol start="4">
<li>序列化</li>
</ol>
<p><code>ArrayList</code>基于数组实现，并且具有动态扩容的特性，因此保存元素的数组不一定都会被使用到，所以没必要全部进行序列化。</p>
<pre><code class="java">transient Object[] elementData; // non-private to simplify nested class access
</code></pre>
<p><code>ArrayList</code>实现了<code>writeObject()</code>和<code>readObject</code>来控制只序列化数组中有元素填充的那部分内容。</p>
<pre><code class="java">//序列化
 private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException &#123;
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;//用于快速失败机制检测
    s.defaultWriteObject();

    // Write out size as capacity for behavioral compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) &#123;
        s.writeObject(elementData[i]);
    &#125;

    if (modCount != expectedModCount) &#123;
        throw new ConcurrentModificationException();
    &#125;
&#125;
</code></pre>
<pre><code class="java">//反序列化
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException &#123;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) &#123;
        // like clone(), allocate array based upon size not capacity
        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
        Object[] elements = new Object[size];

        // Read in all elements in the proper order.
        for (int i = 0; i &lt; size; i++) &#123;
            elements[i] = s.readObject();
        &#125;

        elementData = elements;
    &#125; else if (size == 0) &#123;
        elementData = EMPTY_ELEMENTDATA;
    &#125; else &#123;
        throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size);
    &#125;
&#125;
</code></pre>
<p>序列化和反序列化需要使用<code>ObjectOutputStream</code>中的<code>writeObject</code>和<code>ObjectInputStream</code>中的<code>readObject</code>方法，这两种方法在传入对象的内存存在<code>writeObject</code>和<code>readObject</code>时，会反射调用该对象的内部序列化方法。</p>
<h1 id="5-LinkList源码分析"><a href="#5-LinkList源码分析" class="headerlink" title="5. LinkList源码分析"></a>5. LinkList源码分析</h1><p><code>LinkedList</code>是一个实现了<code>List</code>接口和<code>Deque</code>接口的双向链表。<br><code>LinkedList</code>底层的链表结构使它支持高效的插入和删除操作，另外它实现了<code>Deque</code>接口，使得<code>LinkedList</code>类也具有队列的特性;<code>LinkedList</code>不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p>
<pre><code class="java">List list=Collections.synchronizedList(new LinkedList(...));
</code></pre>
<h2 id="LinkList中获取指定位置节点的方法"><a href="#LinkList中获取指定位置节点的方法" class="headerlink" title="LinkList中获取指定位置节点的方法"></a>LinkList中获取指定位置节点的方法</h2><pre><code class="java">/**
 * Returns the (non-null) Node at the specified element index.
 */
Node&lt;E&gt; node(int index) &#123;
    // assert isElementIndex(index);

    if (index &lt; (size &gt;&gt; 1)) &#123;//折半查找
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    &#125; else &#123;
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    &#125;
&#125;
</code></pre>
<h2 id="LinkList将集合插入到链表尾部："><a href="#LinkList将集合插入到链表尾部：" class="headerlink" title="LinkList将集合插入到链表尾部："></a>LinkList将集合插入到链表尾部：</h2><pre><code class="java">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
    return addAll(size, c);
&#125;
</code></pre>
<p><code>addAll(int Index,Collection c)</code>:将集合从指定位置开始插入具体实现：</p>
<pre><code class="java">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
    //1. 检查index是否在size范围内
    checkPositionIndex(index);

    //2. 把集合的数据存到对象数组中
    Object[] a = c.toArray();
    int numNew = a.length;
    if (numNew == 0)
        return false;

    Node&lt;E&gt; pred, succ;
    //3. 得到插入位置的前驱节点和后继节点
    //如果插入位置是尾部，前驱节点是last，后继节点是null
    if (index == size) &#123;
        succ = null;
        pred = last;
    &#125; else &#123;
        //否则，调用node()方法得到后继节点，再得到前驱节点
        succ = node(index);
        pred = succ.prev;
    &#125;

    //4. 遍历数组将数据插入
    for (Object o : a) &#123;
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
        //创建新节点，同时指定前驱节点
        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
        //如果插入位置是首节点
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;//双向链表，前驱节点的指针指向当前节点
        pred = newNode;//节点后移
    &#125;

    //如果插入位置是在尾部，重置last节点
    if (succ == null) &#123;
        last = pred;
    &#125; else &#123;
        //否则，将插入链表与原链表的后半部分连接起来
        pred.next = succ;
        succ.prev = pred;
    &#125;

    size += numNew;
    modCount++;
    return true;
&#125;
</code></pre>
<p>由以上可以总结出addAll方法的步骤：</p>
<ol>
<li>检查<code>index</code>范围是否在size范围内</li>
<li><code>toArray</code>方法把集合的数据存到对象数组中</li>
<li>得到插入位置的前驱和后继节点</li>
<li>遍历数据插入</li>
<li>将插入后的链表与后半部分链接</li>
</ol>
<h2 id="LinkedList获取头节点数据的方法："><a href="#LinkedList获取头节点数据的方法：" class="headerlink" title="LinkedList获取头节点数据的方法："></a>LinkedList获取头节点数据的方法：</h2><pre><code class="java">public E getFirst() &#123;
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
&#125;
public E element() &#123;
    return getFirst();
&#125;
public E peek() &#123;
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item;
&#125;
public E peekFirst() &#123;
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item;
&#125;
</code></pre>
<p><strong>区别</strong>：<code>getFirst</code>和<code>element</code>方法在链表为空时会抛出异常<code>NoSuchElementException</code>，而<code>peek</code>和<code>peekFirst</code>会直接返回null。</p>
<h1 id="6-String，StringBuffer和StringBuilder的区别："><a href="#6-String，StringBuffer和StringBuilder的区别：" class="headerlink" title="6. String，StringBuffer和StringBuilder的区别："></a>6. String，StringBuffer和StringBuilder的区别：</h1><ul>
<li><code>String</code>被声明为final，不可以被继承，在java8中，String使用<code>char</code>数组存储数据，jave9之后使用<code>byte</code>数组存储字符串，同时使用<code>coder</code>标识使用了哪种编码。</li>
<li><code>StringBuffer</code>和<code>StringBuilder</code>可变</li>
<li><code>String</code>不可变，线程安全；</li>
<li><code>StringBuilder</code>线程不安全，但性能高，字符串相加在编译后会使用该类优化代码实现拼接</li>
<li><code>StringBuffer</code>线程安全，性能低，内部使用<code>synchronized</code>进行同步。<blockquote>
<p>字符串如果使用“+”拼接，每使用一次，就会产生一个对象，<code>StringBuffer</code>可以解决此类问题产生的性能问题。默认初始化的数组长度是16，超过时采用<strong>原长x2+2</strong>扩容。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>单线程下，StringBuilder 和 StringBuffer 的性能其实相差不大，原因是 synchronized 引入了偏向锁。</p>
</blockquote>
<h1 id="7-String两种赋值方式比较："><a href="#7-String两种赋值方式比较：" class="headerlink" title="7. String两种赋值方式比较："></a>7. String两种赋值方式比较：</h1><pre><code class="java">String name1 = &quot;xiaoming&quot;;
Stirng name2 = new String(&quot;xiaoming&quot;);

name1 == name2;//false
</code></pre>
<p>方式1会自动地将字符串放到<strong>字符串常量池</strong>之中，同时在栈内存会有指向堆内存的字符串常量池的指针。</p>
<p>方式2首先会寻找常量池中是否存在该常量，若存在则只在堆内存创建一个对象；否则，会首先在堆内存创建一个对象，然后在常量池创建一个字符串常量，<strong>name指向堆内存对象，而堆内存存储指向常量池的地址</strong></p>
<h1 id="8-String创建对象五种情况分析："><a href="#8-String创建对象五种情况分析：" class="headerlink" title="8. String创建对象五种情况分析："></a>8. String创建对象五种情况分析：</h1><ul>
<li>变量的值只有在运行期才会被确定</li>
<li>如果在编译期可以确定，那么使用已有的对象，否则创建新的对象</li>
</ul>
<h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><pre><code class="java">String a = &quot;a&quot;;//常量池编译器确定
Strnig a1 = a+&quot;1&quot;;//运行期确定（a1）
String a2 = &quot;a1&quot;;//常量池编译器确定

a1 == a2;//false
</code></pre>
<h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><pre><code class="java">final String b = &quot;b&quot;;//final修饰的变量为静态，编译器确定
String b1 = b+&quot;1&quot;;//编译器可以读取静态变量，编译器确定，放入常量池
String b2 = &quot;b1&quot;;//获取常量池的值，编译器确定

b1 == b2;//true
</code></pre>
<h2 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h2><pre><code class="java">String c = getString();//通过方法取值,只能在运行期确定
String c1 = c+1;//运行期确定
String c2 = &quot;c1&quot;;//编译期确定

c1==c2;//false

private static String getString()&#123;
    return &quot;c&quot;;
&#125;
</code></pre>
<h2 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h2><pre><code class="java">final String d = getString();//虽然是个final常量,但是方法还是在运行期才确定
String d1 = d+1;
String d2 = &quot;d1&quot;;

d1==d2;//false

private static String getString()&#123;
    return &quot;d&quot;;
&#125;
</code></pre>
<h2 id="情况5"><a href="#情况5" class="headerlink" title="情况5"></a>情况5</h2><pre><code class="java">String a = &quot;a&quot;;
String b = &quot;b&quot;;
String c = a+b+1;//运行时先产生a+b对象,再产生a+b+1对象
String d = &quot;a&quot;+&quot;b&quot;+1;//常量相加,只产生一个对象

c==d;//false
</code></pre>
<h1 id="9-接口与抽象类区别"><a href="#9-接口与抽象类区别" class="headerlink" title="9. 接口与抽象类区别"></a>9. 接口与抽象类区别</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol>
<li>抽象类和抽象方法都使用<code>abstract</code>修饰</li>
<li>一个类中如果包含抽象方法，那么这个类必须声明为抽象类。</li>
<li>抽象类不能被实例化，需要继承抽象类才能实例化其子类。</li>
<li>抽象类不能使用final修饰</li>
<li>抽象类可以有实现方法和属性、构造方法</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol>
<li>使用<code>interface</code>关键字</li>
<li>接口中可以定义常量，抽象方法，jdk8之后可以有默认实现方法和静态方法</li>
<li>可以继承多个接口</li>
<li>接口中的方法和字段默认是public，不允许定义为private和protect</li>
<li>接口不能有构造方法</li>
<li><strong>接口的字段默认是 <code>static</code>和 <code>final</code></strong></li>
</ol>
<h1 id="10-重写和重载的区别"><a href="#10-重写和重载的区别" class="headerlink" title="10. 重写和重载的区别"></a>10. 重写和重载的区别</h1><p>重写存在于继承体系之中，指子类实现了一个与父类在方法声明上完全相同的方法。</p>
<p>为了满足里式替换原则，重写必须满足以下三个原则：</p>
<ul>
<li>子类的访问权限不能低于父类的访问权限</li>
<li>子类方法返回类型必须是父类方法返回类型或其子类</li>
<li>子类方法抛出的异常必须是父类方法抛出的异常或其子类</li>
</ul>
<blockquote>
<p>里式替换原则：里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。</p>
</blockquote>
<p>在调用一个方法时，先从本类中查找是否有相应的方法，如果没有就到父类中查找。如果没有就对参数进行转型，然后查看本类是否有相应的方法，没有就在父类中找，顺序如下：</p>
<ul>
<li><code>this.func(this)</code></li>
<li><code>super.func(this)</code></li>
<li><code>this.func(super)</code></li>
<li><code>super.func(super)</code></li>
</ul>
<p>重载存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>,与返回值无关</p>
<h1 id="11-浅克隆和深克隆"><a href="#11-浅克隆和深克隆" class="headerlink" title="11. 浅克隆和深克隆"></a>11. 浅克隆和深克隆</h1><p><code>clone</code>是<code>Object</code>的<code>protected</code>方法，因此其他类不能直接去调用该类实例的<code>clone</code>方法,需要对clone进行重写，重写时需要继承<code>Cloneable</code>标记接口，否则会报<code>CloneNotSupportedException</code>。</p>
<p><strong>浅克隆</strong>：当对象的属性中有引用变量时，实际上克隆后的对象跟原有对象所指向的是同一地址，如果此时修改引用变量的值，会使两个对象的引用变量都发生改变。</p>
<p><strong>深克隆</strong>：将引用对象也做一份拷贝</p>
<pre><code class="java">public class Sheep implements Cloneable&#123;
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Object obj = super.clone();
        //深克隆添加如下代码：
        Sheep sheep = (Sheep)obj;
        sheep.birthday = (Date) this.birthday.clone();//把属性也进行克隆
        return sheep;
    &#125;

    public Sheep(String name, Date birthday) &#123;
        this.name = name;
        this.birthday = birthday;
    &#125;
      
      //省略getter，setter和toString方法
&#125;


//客户端操作
public class Client &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;
        Date date = new Date(System.currentTimeMillis());
        Sheep sheep1 = new Sheep(&quot;多莉&quot;,date);
        Sheep sheep2 = (Sheep) sheep1.clone();

        date.setTime(23490738574947548L);//改变时间值，如果是浅克隆，两个都会改变

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep1 == sheep2);
    &#125;
&#125;
</code></pre>
<h2 id="clone替代方案"><a href="#clone替代方案" class="headerlink" title="clone替代方案"></a><code>clone</code>替代方案</h2><p>使用<code>clone()</code>方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。<code>Effective Java</code>书上讲到，最好不要去使用<code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。(深拷贝)</p>
<pre><code class="java">public class CloneConstructorExample &#123;

    private int[] arr;

    public CloneConstructorExample() &#123;
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) &#123;
            arr[i] = i;
        &#125;
    &#125;

    public CloneConstructorExample(CloneConstructorExample original) &#123;
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) &#123;
            arr[i] = original.arr[i];
        &#125;
    &#125;

    public void set(int index, int value) &#123;
        arr[index] = value;
    &#125;

    public int get(int index) &#123;
        return arr[index];
    &#125;
&#125;
</code></pre>
<h1 id="12-类加载时的初始化顺序"><a href="#12-类加载时的初始化顺序" class="headerlink" title="12. 类加载时的初始化顺序"></a>12. 类加载时的初始化顺序</h1><ol>
<li>静态变量和静态代码块（两者谁先取决于代码顺序）</li>
<li>实例变量</li>
<li>普通语句快（构造代码块）</li>
<li>构造函数的初始化</li>
</ol>
<p>如果存在继承的情况，初始化顺序如下：</p>
<ul>
<li>父类（静态变量，静态代码块）</li>
<li>子类（静态变量，静态代码块）</li>
<li>父类（实例变量，普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量，普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="13-构造器Constructor是否可以被重写？"><a href="#13-构造器Constructor是否可以被重写？" class="headerlink" title="13. 构造器Constructor是否可以被重写？"></a>13. 构造器Constructor是否可以被重写？</h1><p><strong>父类的私有属性和构造方法不能被继承</strong>，所以<code>Constructor</code>不能被重写，但是可以重载。</p>
<h1 id="14-对象实例与对象引用有什么不同？"><a href="#14-对象实例与对象引用有什么不同？" class="headerlink" title="14. 对象实例与对象引用有什么不同？"></a>14. 对象实例与对象引用有什么不同？</h1><p>对象实例在堆内存中，一个对象引用指向对象实例（对象引用在栈内存中）。一个对象引用可以指向0个或1个对象实例；一个对象实例可以有n个引用指向它。</p>
<h1 id="15-为什么java只有值传递？"><a href="#15-为什么java只有值传递？" class="headerlink" title="15. 为什么java只有值传递？"></a>15. 为什么java只有值传递？</h1><p>对于基本数据类型，java参数传递的是值的复制；对于引用数据类型，java参数传递的是指向地址的指针的拷贝。</p>
<blockquote>
<p>引用传递一般是对于对象型变量而言，传递的是该对象地址的一个副本，并不是原对象本身。所以对引用对象进行操作会同时改变原有对象。</p>
</blockquote>
<h1 id="16-程序、进程、线程的区别"><a href="#16-程序、进程、线程的区别" class="headerlink" title="16. 程序、进程、线程的区别"></a>16. 程序、进程、线程的区别</h1><p><strong>程序</strong>是含有指令和数据的文件，被存在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p><strong>线程</strong>与进程相似。但是线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与线程不同的的是<strong>同类的多个线程共享同一块内存空间和一组系统资源（共享进程的堆和方法区资源）</strong>，但是每个线程有自己的<strong>程序计数器、虚拟机栈和本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小。</p>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<p>在 java 中：</p>
<p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="java运行时内存区域"></p>
<p>从上图可以看出，一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源（<strong>JDK1.8之后使用元空间</strong>），但是每个线程有自己的<strong>程序计数器，虚拟机栈和本地方法栈</strong>。</p>
<blockquote>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<p>线程是进程划分成更小的运行单位。线程和进程最大的不同在于基本上各个进程都是独立的，而线程则不一定。同一进程中的不同线程极有可能相互影响。线程执行开销小，但不利于资源的管理和保护；进程则相反。</p>
<h1 id="17-java线程有哪些基本状态"><a href="#17-java线程有哪些基本状态" class="headerlink" title="17. java线程有哪些基本状态"></a>17. java线程有哪些基本状态</h1><table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用<code>start</code>方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，java线程将操作系统中的就绪和运行两种状态笼统的称作“运作中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<h1 id="18-java中的异常处理"><a href="#18-java中的异常处理" class="headerlink" title="18. java中的异常处理"></a>18. java中的异常处理</h1><p><img src="http://qiniu.xiaoming.net.cn/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="java异常类层次结构图"></p>
<p>在java中，所有的异常都有一个共同的祖先<code>java.lang</code>包中的的<code>Throwable类</code>。它有两个重要的子类：<code>Exception(异常)</code>和<code>Error(错误)</code>,二者都是java处理异常的重要子类。</p>
<h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><p><code>Error(错误)</code>:<strong>是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（<code>VirtualMachineError</code>），当JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（<code>Virtual MachineError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通过Error的子类描述。</p>
<h2 id="EXCEPTION"><a href="#EXCEPTION" class="headerlink" title="EXCEPTION"></a>EXCEPTION</h2><p><code>Exception(异常)</code>:<strong>是程序本身可以处理的异常</strong>，<code>Exception</code>类有一个重要的子类<code>RuntimeException</code>。该异常由Java虚拟机抛出。</p>
<ul>
<li><code>ArrithmeticException</code>：算术运算异常，一个整数除以0时，会抛出该异常。</li>
<li><code>MissingResourceException</code></li>
<li><code>ClassNotFoundException</code></li>
<li><code>NullPointerException</code>：要访问的变量没有引用任何对象时抛出该异常。</li>
<li><code>IllegalArgumentException</code>：非法参数异常</li>
<li><code>ArrayIndexOutOfBoundsException</code>：下标越界异常</li>
<li><code>UnkownTypeException</code></li>
</ul>
<blockquote>
<p>异常和错误的区别：异常能被程序本身处理，错误无法处理</p>
</blockquote>
<h2 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h2><ul>
<li><code>public String getMessage()</code>:返回异常发生时的详细信息</li>
<li><code>public string toString()</code>:返回异常发生时的简要描述</li>
<li><code>public string getLocalizedMessage()</code>:返回异常对象的本地化信息。使用<code>Throwable</code>的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与<code>getMessage()</code>返回的结果相同</li>
<li><code>public void printStackTrace()</code>:在控制台上打印<code>Throwable</code>对象封装的异常信息</li>
</ul>
<h2 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h2><ul>
<li><p><code>try块</code>： 用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有catch块，则必须跟一个<code>finally</code>块。</p>
</li>
<li><p><code>catch块</code>：用于处理<code>try</code>捕获到的异常</p>
</li>
<li><p><code>finally块</code>：无论是否捕获或处理异常，<code>finally</code>中的语句都会被执行。</p>
<blockquote>
<p>当try和finaly语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。</p>
</blockquote>
</li>
<li><p><code>throw</code>：用于在代码中明确的排除一个异常</p>
</li>
<li><p><code>throws</code>：用在方法声明上标明函数可能抛出的各种异常。</p>
</li>
</ul>
<h3 id="finally块不会被执行的四种情况："><a href="#finally块不会被执行的四种情况：" class="headerlink" title="finally块不会被执行的四种情况："></a>finally块不会被执行的四种情况：</h3><ol>
<li>在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行</li>
<li>在前面的代码中用了<code>System.exit(int)</code>已退出程序。 exit是带参函数；若该语句在异常语句之后，finally会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ol>
<h1 id="19-Java中的IO流分为几种？BIO，NIO，AIO的区别？"><a href="#19-Java中的IO流分为几种？BIO，NIO，AIO的区别？" class="headerlink" title="19. Java中的IO流分为几种？BIO，NIO，AIO的区别？"></a>19. Java中的IO流分为几种？BIO，NIO，AIO的区别？</h1><h2 id="JAVA中IO流分类"><a href="#JAVA中IO流分类" class="headerlink" title="JAVA中IO流分类"></a>JAVA中IO流分类</h2><ul>
<li>按照流的流向，分为<strong>输入流</strong>和<strong>输出流</strong></li>
<li>按照操作单元划分，分为<strong>字节流</strong>和<strong>字符流</strong></li>
<li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li>
</ul>
<h3 id="按照操作方式分类的结构图："><a href="#按照操作方式分类的结构图：" class="headerlink" title="按照操作方式分类的结构图："></a>按照操作方式分类的结构图：</h3><p><img src="http://qiniu.xiaoming.net.cn/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="按照操作方式分类结构图"></p>
<h3 id="按照操作对象分类结构图："><a href="#按照操作对象分类结构图：" class="headerlink" title="按照操作对象分类结构图："></a>按照操作对象分类结构图：</h3><p><img src="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" alt="按照操作对象分类结构图"></p>
<h2 id="BIO-NIO-AIO区别"><a href="#BIO-NIO-AIO区别" class="headerlink" title="BIO,NIO,AIO区别"></a>BIO,NIO,AIO区别</h2><ul>
<li><strong>BIO（Blocking I&#x2F;O）</strong>：同步阻塞I&#x2F;O，数据的读取和写入都必须阻塞在一个进程内等待完成。这种方式在连接数不是特别高（小于单机1000）的情况下，这种模型比较不错，可以让每一个连接都专注于自己的I&#x2F;O，并且编程模型简单，也不用过多的考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，需要一种更高效的I&#x2F;O处理模型来应对更高的并发量。</li>
<li><strong>NIO（New I&#x2F;O）</strong>：NIO是一种同步非阻塞的I&#x2F;O模型，它是支持面向缓冲的，基于通道的I&#x2F;O操作方法。但是其I&#x2F;O行为还是同步的，对于NIO来说，业务线程是在IO操作准备好时，才得到通知，接着就由这个线程自行完成IO操作，IO操作本身是同步的。</li>
<li><strong>AIO（Asynchronous I&#x2F;O）</strong>：AIO也就是NIO2，是异步非阻塞模式。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
<h1 id="20-获取键盘输入常用的两种方法："><a href="#20-获取键盘输入常用的两种方法：" class="headerlink" title="20. 获取键盘输入常用的两种方法："></a>20. 获取键盘输入常用的两种方法：</h1><ol>
<li>通过<code>Scanner</code></li>
</ol>
<pre><code class="java">Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
</code></pre>
<ol start="2">
<li>通过<code>BufferedReader</code></li>
</ol>
<pre><code class="java">BufferedReader input = new BufferedReader(new InputStreamReader(System.in)）;
String s = input.readLine();
</code></pre>
<h1 id="21-BigDecimal用处"><a href="#21-BigDecimal用处" class="headerlink" title="21. BigDecimal用处"></a>21. BigDecimal用处</h1><blockquote>
<p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用equals来判断</strong>。具体原理和浮点数的编码方式有关</p>
</blockquote>
<pre><code class="java">float a = 1.0f-0.9f;
float b = 0.9f-0.8f;
System.out.println(a);//0.100000024
System.out.println(b);//0.099999964
System.out.println(a ==b);//false
</code></pre>
<p>上面代码会出现false的原因是因为float数据存在<strong>精度丢失</strong>的情况。<strong>二进制的小数无法精确的表达十进制小数，所以计算法在计算十进制小数的过程中要先转化为二进制进行计算，这个过程就会出现精度丢失的情况</strong>。</p>
<p>如何解决这个问题？一种常用的方法是：<strong>使用<code>BigDecimal</code>来定义浮点数的值，再进行浮点数的运算操作</strong>。</p>
<pre><code class="java">BigDecimal a = new BigDecimal(&quot;1.0&quot;);
BigDecimal b = new BigDecimal(&quot;0.9&quot;);
BigDecimal c = new BigDecimal(&quot;0.8&quot;);
BigDecimal x = a.substract(b);//0.1
BigDecimal y = b.substract(c);//0.1
System.out.println(x.equals(y));//true;
</code></pre>
<h2 id="BigDecimal的大小比较"><a href="#BigDecimal的大小比较" class="headerlink" title="BigDecimal的大小比较"></a>BigDecimal的大小比较</h2><p><code>a.compareTo(b)</code>:返回-1表示小于，返回0表示等于，返回1表示大于</p>
<h2 id="BigDecimal保留几位小数"><a href="#BigDecimal保留几位小数" class="headerlink" title="BigDecimal保留几位小数"></a>BigDecimal保留几位小数</h2><p>通过<code>setScale</code>方法设置保留几位小数以及保留规则。</p>
<pre><code class="java">BigDecimal m = new BigDecimal(&quot;1.255433&quot;);
BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);
System.out.println(n);// 1.255
</code></pre>
<h2 id="BigDecimal使用注意事项"><a href="#BigDecimal使用注意事项" class="headerlink" title="BigDecimal使用注意事项"></a>BigDecimal使用注意事项</h2><blockquote>
<p>《阿里巴巴Java开发手册》提到：<strong>为了防止精度损失，禁止使用构造方法<code>BigDecimal(double)</code>的方式把double值转化为BigDecimal对象</strong>。该方法存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。优先推荐使用参数为<code>String</code>的构造方法，或者 BigDecimal 的<code>valueOf</code>方法，此方法内存其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p>
</blockquote>
<h1 id="22-Arrays-asList-使用指南"><a href="#22-Arrays-asList-使用指南" class="headerlink" title="22. Arrays.asList()使用指南"></a>22. Arrays.asList()使用指南</h1><p>JDK中对于这个方法的源码：</p>
<pre><code class="java">/**
 *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。
 */ 
public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;
    return new ArrayList&lt;&gt;(a);
&#125;
</code></pre>
<h2 id="《阿里巴巴Java开发手册》对其的描述："><a href="#《阿里巴巴Java开发手册》对其的描述：" class="headerlink" title="《阿里巴巴Java开发手册》对其的描述："></a>《阿里巴巴Java开发手册》对其的描述：</h2><p><img src="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" alt="《阿里巴巴Java 开发手册》对其的描述"></p>
<h2 id="使用时注意事项总结"><a href="#使用时注意事项总结" class="headerlink" title="使用时注意事项总结"></a>使用时注意事项总结</h2><ol>
<li><strong>传递的数组必须是对象数组，而不是基本类型</strong></li>
</ol>
<pre><code class="java">int[] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int [] array=(int[]) myList.get(0);
System.out.println(array[0]);//1
</code></pre>
<blockquote>
<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code>真正得到的参数就不是数组中的元素，而是数组对象本身！此时List的唯一元素就是这个数组，这也就解释了上面的代码。</p>
</blockquote>
<p>使用包装类就可以解决这个问题</p>
<pre><code class="java">Integer[] myArray = &#123; 1, 2, 3 &#125;;
</code></pre>
<ol start="2">
<li><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong></li>
</ol>
<pre><code class="java">List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
</code></pre>
<blockquote>
<p><code>Arrays.asList()</code>方法返回的并不是<code>java.util.ArrayList</code>，而是<code>java.util.Arrays</code>的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
</blockquote>
<pre><code class="java">List myList = Arrays.asList(1, 2, 3);
System.out.println(myList.getClass());//class java.util.Arrays$ArrayList
</code></pre>
<p>该<code>ArrayList</code>继承了<code>AbstractList</code>，而在<code>AbstractList</code>中，这几个方法的实现就是抛出<code>UnsupportedOperationException</code>异常，该<code>ArrayList</code>并没有对这些方法进行重写。</p>
<h2 id="如何正确的将数组转化为ArrayList？"><a href="#如何正确的将数组转化为ArrayList？" class="headerlink" title="如何正确的将数组转化为ArrayList？"></a>如何正确的将数组转化为ArrayList？</h2><ol>
<li>自己动手实现</li>
</ol>
<pre><code class="java">static &lt;T&gt; List&lt;T&gt; arrayToList(final T[] array) &#123;
    final List&lt;T&gt; l = new ArrayList&lt;T&gt;(array.length);
    
    for(final T s : array)&#123;
        l.add(s);
    &#125;
    return l;
&#125;
</code></pre>
<ol start="2">
<li>最简便的方法（推荐）</li>
</ol>
<pre><code class="java">List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));
</code></pre>
<ol start="3">
<li>使用java8的Stream（推荐）</li>
</ol>
<pre><code class="java">Integer [] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
</code></pre>
<h1 id="23-Collection-toArray-方法的使用以及如何反转数组"><a href="#23-Collection-toArray-方法的使用以及如何反转数组" class="headerlink" title="23. Collection.toArray()方法的使用以及如何反转数组"></a>23. Collection.toArray()方法的使用以及如何反转数组</h1><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a)</code>; 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<pre><code class="java">String [] s= new String[]&#123;
    &quot;dog&quot;, &quot;lazy&quot;, &quot;a&quot;, &quot;over&quot;, &quot;jumps&quot;, &quot;fox&quot;, &quot;brown&quot;, &quot;quick&quot;, &quot;A&quot;
&#125;;
List&lt;String&gt; list = Arrays.asList(s);
Collections.reverse(list);
s=list.toArray(new String[0]);//没有指定类型的话会报错
</code></pre>
<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。</p>
<h1 id="24-为什么不要在foreach循环里进行元素的remove-x2F-add操作"><a href="#24-为什么不要在foreach循环里进行元素的remove-x2F-add操作" class="headerlink" title="24. 为什么不要在foreach循环里进行元素的remove&#x2F;add操作"></a>24. 为什么不要在foreach循环里进行元素的remove&#x2F;add操作</h1><p><img src="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" alt="《阿里巴巴Java开发手册》"></p>
<p>如果要进行remove操作，可以调用迭代器的<code>remove</code>方法而不是集合类的<code>remove</code>方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的<code>fail-fast</code>机制。</p>
<blockquote>
<p>fail-fast，即快速失败，它是Java集合的一种错误检测机制。当多个线程对集合（非fail-safe的集合类）进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException（ 当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。需要注意，即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。</p>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>对上述代码进行反编译后，得到</p>
<pre><code class="java">List a = new ArrayList();
a.add(&quot;1&quot;);
a.add(&quot;2&quot;);
Iterator i$ = a.iterator();
do &#123;
    if (!i$.hasNext())
        break;
    String temp = (String) i$.next();
    if (&quot;2&quot;.equals(temp))
        a.remove(temp);
&#125; while (true);
</code></pre>
<p>首先需要注意的几个点是：</p>
<ul>
<li>foreach循环内部其实使用的是Iterator迭代器</li>
<li>代码首先判断是否<code>hasNext</code>，然后再去调用<code>next</code>。</li>
<li>这里的<code>remove</code>还是list的<code>remove</code>方法。</li>
</ul>
<p><strong>list中的remove源码</strong>：</p>
<pre><code class="java">public boolean remove(Object o) &#123;
    final Object[] es = elementData;
    final int size = this.size;
    int i = 0;
    //寻找目标位置
    found: &#123;
        if (o == null) &#123;
            for (; i &lt; size; i++)
                if (es[i] == null)
                    break found;
        &#125; else &#123;
            for (; i &lt; size; i++)
                if (o.equals(es[i]))
                    break found;
        &#125;
        return false;
    &#125;
    fastRemove(es, i);//删除的关键方法
    return true;
&#125;
</code></pre>
<p><strong>fastRemove源码</strong>：</p>
<pre><code class="java">private void fastRemove(Object[] es, int i) &#123;
    modCount++;//此处都修改次数计数+1，是关键
    final int newSize;
    if ((newSize = size - 1) &gt; i)
        System.arraycopy(es, i + 1, es, i, newSize - i);
    es[size = newSize] = null;
&#125;
</code></pre>
<p><strong>add方法源码</strong></p>
<pre><code class="java">public boolean add(E e) &#123;
    modCount++;//同样有该操作
    add(e, elementData, size);
    return true;
&#125;
</code></pre>
<p><strong>iterator源码</strong>：</p>
<pre><code class="java">public Iterator&lt;E&gt; iterator() &#123;
    return new Itr();
&#125;
</code></pre>
<pre><code class="java">private class Itr implements Iterator&lt;E&gt; &#123;
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    // prevent creating a synthetic constructor
    Itr() &#123;&#125;

    public boolean hasNext() &#123;
        return cursor != size;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() &#123;
        //此方法是抛出ConcurrentModificationException异常的根本原因，具体实现看该类最后
        checkForComodification();
        int i = cursor;
        if (i &gt;= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    &#125;

    public void remove() &#123;
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try &#123;
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        &#125; catch (IndexOutOfBoundsException ex) &#123;
            throw new ConcurrentModificationException();
        &#125;
    &#125;

    @Override
    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
        Objects.requireNonNull(action);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i &lt; size) &#123;
            final Object[] es = elementData;
            if (i &gt;= es.length)
                throw new ConcurrentModificationException();
            for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)
                action.accept(elementAt(es, i));
            // update once at end to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        &#125;
    &#125;

    final void checkForComodification() &#123;
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    &#125;
&#125;
</code></pre>
<p>通过源码可以看到，每一次对集合进行添加或者删除，都会对数组标记<code>modCount++</code>，在iterator中进行迭代时，在进行<code>next</code>判断时，会用iterator中的<code>expectedModCount</code>与<code>modCount</code>进行比较，如果不一样就会抛出<code>ConcurrentModificationException</code>。这也就是<code>fail-fast</code>快速失败机制。</p>
<p>在上面的例子中：<br>第一个例子执行完第一次循环后，<code>mod = 3</code> <code>expectedModCount =2</code> <code>cursor = 1</code> <code>size = 1</code>,所以程序在执行hasNext()的时候判断会返回false，所以程序不会报错。</p>
<p>第二个例子执行完第二次循环后,<code>mod = 3</code> <code>expectdModCount = 2</code> <code>cursor = 2</code> <code>size = 1</code> 此时<code>cursor != size</code>,程序认定还有元素，继续执行循环，调用<code>next</code>方法但是此时<code>mod != expectedModCount</code>所以此时会报错。</p>
<p>只有调用iterator中的remove方法，才会对<code>expectedModCount</code>进行更新，此时才不会报错。</p>
<h1 id="25-Servlet接口中有哪些方法以及Servlet的生命周期"><a href="#25-Servlet接口中有哪些方法以及Servlet的生命周期" class="headerlink" title="25. Servlet接口中有哪些方法以及Servlet的生命周期"></a>25. Servlet接口中有哪些方法以及Servlet的生命周期</h1><p>Servlet中定义了5个方法，其中前三个方法与Servlet生命周期有关：</p>
<ul>
<li><code>void init(ServletConfig config) throws ServletException</code></li>
<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>
<li><code>void destroy()</code></li>
<li><code>java.lang.String getServletInfo()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
</ul>
<p><strong>生命周期</strong>：Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其<code>init()</code>方法进行Servlet的初始化；请求到达时调用Servlet的<code>service()</code>方法，<code>service()</code>方法会根据需要调用与请求对应的<code>doGet</code>或<code>doPost</code>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<code>destroy()</code>方法。**<code>init</code>方法和<code>destroy</code>方法只会执行一次，service方法客户端每次请求Servlet都会执行<strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。（</strong>单例**）</p>
<h1 id="26-Servlet线程安全问题"><a href="#26-Servlet线程安全问题" class="headerlink" title="26. Servlet线程安全问题"></a>26. Servlet线程安全问题</h1><p>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。解决的办法是尽量不要在Servlet类中定义<code>name</code>属性（成员变量），而是要把<code>name</code>变量分别定义在<code>doGet()</code>和<code>doPost()</code>方法内。虽然使用<code>synchronized(name)&#123;&#125;</code>语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
<p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此<strong>Servlet里的只读属性最好定义为<code>final</code>类型的。</strong></p>
<h1 id="27-HashMap源码分析"><a href="#27-HashMap源码分析" class="headerlink" title="27. HashMap源码分析"></a>27. HashMap源码分析</h1><p>JDK1.8之前HashMap由<strong>数组+链表</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>
<h2 id="HashMap类中的属性"><a href="#HashMap类中的属性" class="headerlink" title="HashMap类中的属性"></a>HashMap类中的属性</h2><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;

    //序列号
    private static final long serialVersionUID = 362498820763181265L;
    //默认初始化容量，16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
    //允许的最大容量
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
    //默认的加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    //当桶（bucket）上的结点数大于这个值时会转化成红黑树
    static final int TREEIFY_THRESHOLD = 8;
    //当桶（bucket）上的结点数小于这个值时转化成链表
    static final int UNTREEIFY_THRESHOLD = 6;
    //桶中结构转换成红黑树对应table的最大大小
    static final int MIN_TREEIFY_CAPACITY = 64;
    //存储元素的数组，总是2的幂次倍
    transient Node&lt;K,V&gt;[] table;
    //存放具体元素的集
    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
    //存放元素的个数
    transient int size;
    //每次扩容和更改map的计数器
    transient int modCount;
    //临界值，当实际大小（容量*加载因子）超过临界值时，会进行扩容
    int threshold;
    //加载因子
    final float loadFactor;
</code></pre>
<ul>
<li><code>loadFactor</code>：加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</li>
</ul>
<blockquote>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</blockquote>
<ul>
<li><code>threshold</code>：<code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是衡量数组是否需要扩增的一个标准。</li>
</ul>
<h2 id="HashMap获得hash值方法"><a href="#HashMap获得hash值方法" class="headerlink" title="HashMap获得hash值方法"></a>HashMap获得hash值方法</h2><p>HashMap通过<code>key</code>的<code>hashCode</code>经过扰动函数处理过后得到<code>hash</code>值，然后通过<code>(n - 1) &amp; hash</code>判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的<code>hash</code>值以及<code>key</code>是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用<code>hash</code>方法也就是扰动函数是为了防止一些实现比较差的<code>hashCode()</code>方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<pre><code class="java">static final int hash(Object key) &#123;
    int h;
    // ^:按位异或
    // &gt;&gt;&gt;：无符号右移，忽略符号位，空位以0补齐
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
<h2 id="内部节点类分析"><a href="#内部节点类分析" class="headerlink" title="内部节点类分析"></a>内部节点类分析</h2><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;//哈希值，存放元素到hashmap中时用来与其他元素hash值比较
    final K key;//键
    V value;//值
    Node&lt;K,V&gt; next;//下一个结点

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    &#125;

    public final K getKey()        &#123; return key; &#125;
    public final V getValue()      &#123; return value; &#125;
    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;

    //重写hashcode方法
    public final int hashCode() &#123;
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    &#125;

    public final V setValue(V newValue) &#123;
        V oldValue = value;
        value = newValue;
        return oldValue;
    &#125;

    //重写equals方法
    public final boolean equals(Object o) &#123;
        if (o == this)
            return true;
        if (o instanceof Map.Entry) &#123;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="树结点类"><a href="#树结点类" class="headerlink" title="树结点类"></a>树结点类</h3><pre><code class="java">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;//判断颜色
    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;
        super(hash, key, val, next);
    &#125;

    //返回根结点
    final TreeNode&lt;K,V&gt; root() &#123;
        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;
            if ((p = r.parent) == null)
                return r;
            r = p;
        &#125;
    &#125;
    //后面的省略，在下面分析...
</code></pre>
<h2 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap中有四个构造方法：</p>
<pre><code class="java">//默认构造方法
public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
&#125;

//包含一个Map的构造方法
public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
&#125;

//指定初始容量的构造函数
public HashMap(int initialCapacity) &#123;
    this(initialCapacity,DEFAULT_LOAD_FACTOR);
&#125;
    
//指定初始容量和加载因子的构造函数
public HashMap(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);//保证容量会是2的幂次方大小
&#125;
</code></pre>
<h3 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a><code>putMapEntries</code>方法</h3><p>用于将一个Map集合放入HashMap中</p>
<pre><code class="java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;
    int s = m.size();
    if (s &gt; 0) &#123;
        //如果此时table还没有初始化
        if (table == null) &#123; // pre-size
            float ft = ((float)s / loadFactor) + 1.0F;//设置初始化的容量为当前map大小除以加载因子再加1
            //判断t有没有超过允许的最大大小
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            //如果t&gt;阈值，初始化阈值
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        &#125;
        //如果table已经初始化，而且m的个数大于阈值，则进行扩容
        else if (s &gt; threshold)
            resize();
        //将m中的所有元素放到hashMap中
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a><code>Put</code>方法</h3><p>HashMap只提供了<code>put</code>用于添加元素，<code>putVal</code>方法只是给put方法调用的一个方法，<strong>并没有提供给用户使用。</strong></p>
<p>对putVal方法添加元素的分析如下：</p>
<p>①如果定位到的数组位置没有元素就直接插入。</p>
<p>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。<br><img src="https://camo.githubusercontent.com/df1c3077b929873727c9970e3a48c0ef14fd094d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f7075742545362539362542392545362542332539352e706e67" alt="插入数据流程图"></p>
<p><strong>时间复杂度</strong>：理想情况下，不会出现 hash 冲突，此时时间复杂度是 O(1)；如果桶里有元素，并且元素个数小于8，则需要进行遍历链表，此时时间复杂度为 O(n)；如果桶里有元素并且个数大于8，此时转换为红黑树，时间复杂度为 O(logn)；因此最理想状态是 O(1),最差是O(n).</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

/**
 * @param onlyIfAbsent 表示是否对旧值进行替换，为true时表示不替换
 * @param evict 表示table是否处于创建状态，false表示处于
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
            boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    //table为初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    //此时该位置已经有元素
    else &#123;
        Node&lt;K,V&gt; e; K k;
        //比较当前桶的第一个元素的hash值相等，key也相等
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;//记录此时原有旧元素，后面会将新的值放入
        //如果hash值不相等且为红黑树结点
        else if (p instanceof TreeNode)
            //放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        //为链表结点
        else &#123;
            //循环在链表末端插入结点
            for (int binCount = 0; ; ++binCount) &#123;
                if ((e = p.next) == null) &#123;
                    p.next = newNode(hash, key, value, null);
                    //如果结点数量达到阈值，转化成红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                //判断链表结点中的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    //相等就跳出循环
                    break;
                //用于遍历链表
                p = e;
            &#125;
        &#125;
        //表示前面在桶中找到key，hash值与插入元素相等的结点
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;
            //根据所传参数决定是否替换旧值
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);//插入后回调
            return oldValue;
        &#125;
    &#125;
    ++modCount;//修改此处+1
    //如果大小大于阈值就扩容
    if (++size &gt; threshold)
        resize();
    //回调（主要是在子类LinkedHashMap中使用）
    afterNodeInsertion(evict);
    return null;
&#125;
</code></pre>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a><code>get</code>方法</h3><p>最优情况，hash不碰撞，O(1)，典型情况，近似是O(1)，因为几乎没有碰撞，最坏情况，O(N)，也就是所有的hash都一样，那么退化为线性查找。</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            if (first instanceof TreeNode)
                //在树中寻找
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do &#123; //在链表中循环查找
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<h3 id="resize扩容方法"><a href="#resize扩容方法" class="headerlink" title="resize扩容方法"></a><code>resize</code>扩容方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        //超过最大值就不再扩容了，随你去碰撞
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        //新容量为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    //没有初始化数组
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else &#123;               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    //设置新的resize上限（阈值）
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                 (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        //把每个bucket都移到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                //当前位置只有一个结点
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                //如果是红黑树，则转到红黑树中进行迁移
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; // preserve order
                    //当前结点是一个链表
                    Node&lt;K,V&gt; loHead = null, loTail = null;//散列后是原索引的链表
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;//散列后是新索引的链表
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        //与原数组容量与运算，相当于在最高位再取一个位
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            //如果是0，不变，使用原索引
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            //等于1就重新散列
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    //新的位置为原索引+旧容量（原因是在更高一位添加一个1相当于原有加上2的n次方（n表示位数），正好相当于原数组容量+当前位置散列（原数组容量本身就是2的n次方）
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<p><strong>以下对重新散列做一些说明</strong>：</p>
<p>假如现在容量为初始容量16，再假如5，21，37，53的hash自己（二进制），所以在oldTab中的存储位置就都是<code>hash &amp; （16 - 1）</code>【16-1就是二进制1111，就是取最后四位】，</p>
<ul>
<li>5  ：00000101</li>
<li>21：00010101</li>
<li>37：00100101</li>
<li>53：00110101</li>
</ul>
<p>四个数与（16-1）相与后都是0101,即原始链为：<code>5---&gt;21---&gt;37---&gt;53----&gt;null</code></p>
<p>此时进入代码中<code>do-while</code>循环，对链表节点进行遍历，判断是留下还是去新的链表：</p>
<ul>
<li><code>lo</code>就是扩容后仍然在原地的元素链表</li>
<li><code>hi</code>就是扩容后下标为<strong>原位置+原数组容量</strong>的元素链表，从而不需要重新计算hash。</li>
</ul>
<p>因为扩容后计算存储位置就是<code>hash &amp; （32 - 1)</code>【取后5位】，但是并不需要再计算一次位置，<br>此处<strong>只需要判断左边新增的那一位（右数第5位）是否为1即可判断此节点是留在原地lo还是移动去高位hi</strong>：</p>
<p><code>(e.hash &amp; oldCap) == 0</code> （oldCap是16也就是10000，相与即取新的那一位）</p>
<ul>
<li>5  ：00000101——————》0留在原地  lo链表</li>
<li>21：00010101——————》1移向高位  hi链表</li>
<li>37：00100101——————》0留在原地  lo链表</li>
<li>53：00110101——————》1移向高位  hi链表</li>
</ul>
<p>为什么为0就放在原位置，为1就要放到原位置+原数组容量位置呢</p>
<p>因为上面进行resize的时候，是将数组容量扩大了一倍，原计算位置取模的时候是通过length-1，那么现在与oldCap相与后，如果右边第5位是1，那就是增加了一个原数组的长度(因为原取模的时候是取4位)，所以如果右边第5位要是1的话，那新的位置就是原位置+原数组容量。</p>
<p>所以在1.8的情况下，resize 是不需要对原数组链表中的所有节点都进行再次hash，移动之后的节点也的顺序也不会改变，而且在一定程度上也避免了1.7中死锁的发生。</p>
<h1 id="28-ArrayList和LinkedList区别？"><a href="#28-ArrayList和LinkedList区别？" class="headerlink" title="28. ArrayList和LinkedList区别？"></a>28. ArrayList和LinkedList区别？</h1><ol>
<li><code>ArrayList</code>和<code>LinkedList</code>都是不同步的，也就是都是线程不安全的</li>
<li><code>ArrayList</code>底层使用的是<code>Object</code>数组，<code>LinkedList</code>底层使用的是<strong>双向链表</strong>的数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环）</li>
<li>插入和删除受元素位置的影响：</li>
</ol>
<ul>
<li><code>ArrayList</code>采用数组存储，所以插入和删除的时间复杂度受元素位置的影响。比如执行<code>add(E e)</code>,<code>ArrayList</code>会默认将指定元素追加到列表的末尾，这时时间复杂度为<code>O(1)</code>；但是如果要在指定位置i插入和删除元素的话（<code>add(int index,E element)</code>），时间复杂度为<code>O(n-i)</code>。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 </li>
<li><code>LinkedList</code>采用链表存储，所以插入，删除元素的时间复杂度不受元素位置的影响，都是近似<code>O(1)</code>,而数组近似<code>O(n)</code></li>
</ul>
<ol start="4">
<li><code>LinkedList</code>不支持高效随机访问元素，而<code>ArrayList</code>支持。快速随机访问就是通过元素的序号快速获取元素对象。</li>
<li><code>ArrayList</code>的空间浪费主要体现在 list 列表的结尾会预留一定的容量空间，而<code>LinkedList</code>的空间花费则体现在它的每一个元素都需要消耗比<code>ArrayList</code>更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h2 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h2><p><code>ArrayList</code>继承了一个<code>RandomAccess</code>接口，这个接口在源码中并没有什么定义（相当于一个标识接口），用于标识这个接口的类具有随机访问的功能。<br>在<code>Collections</code>工具类（提供大量针对<code>Collection</code>的操作）的<code>binarySearch()</code>中，它要判断传入的 list 是否<code>RamdomAccess</code>的实例，如果是，调用<code>indexedBinarySearch（）</code>方法，如果不是，那么调用<code>iteratorBinarySearch（）</code>方法。</p>
<h2 id="list的遍历选择："><a href="#list的遍历选择：" class="headerlink" title="list的遍历选择："></a>list的遍历选择：</h2><ul>
<li>实现了<code>RandomAccess</code>接口的list（表明支持快速随机访问），优先使用普通for循环，其次使用foreach</li>
<li>未实现<code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环。</li>
</ul>
<h1 id="29-HashMap和Hashtable的区别"><a href="#29-HashMap和Hashtable的区别" class="headerlink" title="29. HashMap和Hashtable的区别"></a>29. HashMap和Hashtable的区别</h1><ol>
<li><p><strong>线程是否安全</strong>：<code>HashMap</code>是非线程安全的，<code>HashTable</code>是线程安全；<code>HashTable</code>内部的方法基本都经过<code>synchronized</code>修饰。（要保证线程安全使用<code>ConcurrentHashMap</code>）</p>
</li>
<li><p><strong>效率</strong>：因为线程安全问题，<code>HashMap</code>要比<code>HashTable</code>效率高一点。</p>
<blockquote>
<p><code>HashTable</code>基本被淘汰，不要在代码中使用它</p>
</blockquote>
</li>
<li><p><strong>对Null key和Null value的支持</strong>：<code>HashMap</code>中，<code>null</code>可以作为键，这样的键只能有一个，可以有一个或多个键所对应的值为<code>null</code>。但是在<code>HashTable</code>中<code>put</code>键值只要有一个<code>null</code>,直接抛出<code>NullPointException</code></p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同</strong>：</p>
</li>
</ol>
<ul>
<li>创建时如果不指定容量初始值，<code>Hashtable</code>默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<code>2n+1</code>。<code>HashMap</code>默认初始化大小为16，之后每次扩容，容量变为原来的2倍。</li>
<li>创建时如果给定了容量初始值，<code>HashTable</code>会直接使用给定的大小，而<code>HashMap</code>会将其扩充为2的幂次方大小：</li>
</ul>
<pre><code class="java">static final int tableSizeFor(int cap) &#123;
    int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
&#125;
</code></pre>
<ol start="5">
<li><strong>底层数据结构</strong>： JDK1.8 以后的<code>HashMap</code>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。<code>Hashtable</code>没有这样的机制。</li>
</ol>
<h1 id="30-HashSet（HashMap和HashSet区别）"><a href="#30-HashSet（HashMap和HashSet区别）" class="headerlink" title="30. HashSet（HashMap和HashSet区别）"></a>30. HashSet（HashMap和HashSet区别）</h1><p><code>HashSet</code>是基于<code>HashMap</code>实现的，在<code>HashSet</code>源码中，除了<code>clone()</code>,<code>writeObject()</code>,<code>readObject()</code>是<code>HashSet</code>自己实现的以外，其他的基本是调用<code>HashMap</code>中的方法。</p>
<h2 id="HashSet检查重复的方式"><a href="#HashSet检查重复的方式" class="headerlink" title="HashSet检查重复的方式"></a>HashSet检查重复的方式</h2><p><code>HashSet</code>的<code>add</code>方法实际上是调用了<code>HashMap</code>的<code>put</code>方法，将<code>HashSet</code>的值作为<code>Map</code>中的键存储，利用了<code>HasnMap</code>中<strong>键不能重复的特点</strong>。而在<code>HashMap</code>中，对键的重复检测，首先会计算<code>hashcode</code>值是否相等,如果不相等就加入；如果相等则使用<code>equals()</code>方法检查<code>hashcode</code>相等的对象是否真的相同。</p>
<pre><code class="java">//作为统一的value,是连接HashMap的桥梁
private static final Object PRESENT = new Object();

//添加方法
public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;
</code></pre>
<p><code>HashSet</code>集合中并没有提供<code>get()</code>方法，当需要获取<code>HashSet</code>中某个元素时，只能通过遍历集合的方式进行<code>equals()</code>来比较实现：</p>
<pre><code class="java">for(String str:hashSet)&#123;
    if(&quot;xiaoming&quot;.equals(str))&#123;
        System.out.println(&quot;匹配到了&quot;+str);
    &#125;
&#125;
</code></pre>
<h1 id="31-HashMap-为什么线程不安全？"><a href="#31-HashMap-为什么线程不安全？" class="headerlink" title="31. HashMap 为什么线程不安全？"></a>31. HashMap 为什么线程不安全？</h1><p>主要有两个场景：</p>
<h2 id="put的时候导致的多线程数据不一致。"><a href="#put的时候导致的多线程数据不一致。" class="headerlink" title="put的时候导致的多线程数据不一致。"></a>put的时候导致的多线程数据不一致。</h2><p>这个问题比较好想象，比如有两个线程 A 和 B，首先 A 希望插入一个 key-value 对到 HashMap 中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程 B 被调度得以执行，和线程 A 一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程 B 成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程 B 插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<h2 id="多线程下-Rehash-导致的死循环问题"><a href="#多线程下-Rehash-导致的死循环问题" class="headerlink" title="多线程下 Rehash 导致的死循环问题"></a>多线程下 Rehash 导致的死循环问题</h2><p>主要原因在于并发下的<code>Rehash</code>会造成元素之间会形成一个<strong>循环链表</strong>。不过，jdk 1.8 后解决了这个问题，在 1.8 的情况下，resize 是不需要对原数组链表中的所有节点都进行再次 hash，<strong>移动之后的节点也的顺序也不会改变，而且在一定程度上也避免了1.7中死锁的发生</strong></p>
<p>并发环境下推荐使用 <code>ConcurrentHashMap</code>。</p>
<h1 id="32-ConcurrentHashMap"><a href="#32-ConcurrentHashMap" class="headerlink" title="32. ConcurrentHashMap"></a>32. ConcurrentHashMap</h1><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>源码如下：</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode()); //计算hash
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;//读取首节点的Node元素,底层调用 unsafe 类的 CAS 操作
        if ((eh = e.hash) == h) &#123; //如果该节点就是首节点就返回
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        &#125;
        //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来
        //eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。
        //eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。
        //eh&gt;=0，说明该节点下挂的是一个链表，直接遍历该链表即可。
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) &#123;//既不是首节点也不是ForwardingNode，那就往下遍历
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>ConcurrentHashMap 的读操作并不需要加锁，但是通过使用 <code>volatile</code> 关键字修饰 <code>Node</code> 节点的 <code>val</code> 和指针 <code>next</code>，在多线程环境下线程A修改因为hash冲突修改结点的 val 或者新增节点的时候是对线程 B 可见的。</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    //可以看到这些都用了volatile修饰
    volatile V val;
    volatile Node&lt;K,V&gt; next;
    
    //...
&#125;
</code></pre>
<blockquote>
<p> ConcurrentHashMap 在其数组上也用了 volatile 修饰，其目的是为了使得 Node 数组在扩容的时候对其他线程具有可见性  </p>
</blockquote>
<pre><code class="java">/**
 * 垃圾箱数组。 第一次插入时延迟进行初始化。
 * 大小始终是2的幂。 由迭代器直接访问。
 */
transient volatile Node&lt;K,V&gt;[] table;
</code></pre>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>区别主要体现在实现线程安全方式上不同。</p>
<ul>
<li><strong>底层数据结构</strong>：JDK1.7的<code>ConcurrentHashMap</code>底层采用<strong>分段的数组+链表</strong>实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>。<code>Hashtable</code>和 JDK1.8 之前的<code>HashMap</code>的底层数据结构类似都是采用<strong>数组+链表</strong>的形式，数组是<code>HashMap</code>的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式</strong>：</li>
</ul>
<ol>
<li>在JDK1.7的时候，<code>ConcurrentHashMap</code>采用的是<strong>分段锁</strong>的形式对整个桶数组进行了分割分段（Segment），每一把锁只锁容器其中的一部分数据，多线程访问容器里的不同数据段的数据，就不会存在锁竞争，提高并发效率。JDK1.8之后，摒弃了Segment的概念，而是直接用<strong>Node数组+链表+红黑树</strong>的数据结构来实现，并发控制使用<code>synchronized</code>和<code>CAS</code>(乐观锁)来操作。</li>
<li><code>HashTable</code>采用同一把锁的形式，使用<code>synchronized</code>来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用<code>put</code>添加元素，另一个线程不能使用<code>put</code>添加元素，也不能使用<code>get</code>，竞争会越来越激烈效率越低。</li>
</ol>
<p><strong>两者对比图</strong>：</p>
<p><code>HashTable</code>: </p>
<p><img src="http://qiniu.xiaoming.net.cn/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable安全锁"></p>
<p><code>1.7的ConcurrentHashMap</code>:</p>
<p><img src="http://qiniu.xiaoming.net.cn/1.7%E7%9A%84ConcurrentHashMap.jpeg" alt="1.7ConcurrentHashMap"></p>
<p>一个 ConcurrentHashMap 里包含两个静态内部类 <code>HashEntry</code> 和 <code>Segment</code> 。HashEntry用来封装散列到映射表中的键值对，Segment  的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p>在 HashEntry 类中，<code>key</code>，<code>hash</code> 和 <code>next</code> 域都被声明为 <code>final</code> 型，<code>value</code> 域被声明为 <code>volatile</code> 型。</p>
<pre><code class="java">static final class HashEntry&lt;K,V&gt; &#123;
       final K key;                      // 声明 key 为 final 型
       final int hash;                   // 声明 hash 值为 final 型
       volatile V value;                 // 声明 value 为 volatile 型
       final HashEntry&lt;K,V&gt; next;        // 声明 next 为 final 型
  
       HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) &#123;
           this.key = key;
           this.hash = hash;
           this.next = next;
           this.value = value;
       &#125;
&#125;
</code></pre>
<p>由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F" alt="ConcurrentHashMap1.7插入"></p>
<p>由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。</p>
<p><code>1.8的ConcurrentHashMap</code></p>
<p><img src="https://camo.githubusercontent.com/b823c5f2cf18e7e27da70409d2b5e18fed820364/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e382d436f6e63757272656e74486173684d61702d5374727563747572652e6a7067" alt="1.8ConcurrentHashMap"></p>
<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表&#x2F;红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）  </p>
<blockquote>
<p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
</blockquote>
<h2 id="ConcurrentHashMap有什么缺陷吗？"><a href="#ConcurrentHashMap有什么缺陷吗？" class="headerlink" title="ConcurrentHashMap有什么缺陷吗？"></a>ConcurrentHashMap有什么缺陷吗？</h2><p>ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。</p>
<h1 id="33-Comparable和Comparator区别"><a href="#33-Comparable和Comparator区别" class="headerlink" title="33. Comparable和Comparator区别"></a>33. Comparable和Comparator区别</h1><ul>
<li><code>comparable</code>接口实际上是出自<code>java.lang</code>包,它有一个<code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自<code>java.util</code>包,它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以<strong>重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法</strong>或者<strong>以两个Comparator来实现歌名排序和歌星名排序</strong>，第二种代表我们只能使用两个参数版的<code>Collections.sort()</code>。</p>
<p>Comparator定制排序：</p>
<pre><code class="java">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();
        arrayList.add(-1);
        arrayList.add(3);
        arrayList.add(3);
        arrayList.add(-5);
        arrayList.add(7);
        arrayList.add(4);
        arrayList.add(-9);
        arrayList.add(-7);
        System.out.println(&quot;原始数组:&quot;);
        System.out.println(arrayList);
        // void reverse(List list)：反转
        Collections.reverse(arrayList);
        System.out.println(&quot;Collections.reverse(arrayList):&quot;);
        System.out.println(arrayList);

        // void sort(List list),按自然排序的升序排序
        Collections.sort(arrayList);
        System.out.println(&quot;Collections.sort(arrayList):&quot;);
        System.out.println(arrayList);
        // 定制排序的用法
        Collections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123;

            @Override
            public int compare(Integer o1, Integer o2) &#123;
                return o2.compareTo(o1);
            &#125;
        &#125;);
        System.out.println(&quot;定制排序后：&quot;);
        System.out.println(arrayList);
</code></pre>
<p>输出如下：</p>
<pre><code>原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
</code></pre>
<p>对于普通的类，当类对象里有多个变量时,无法比较,此时需要使用让类继承<code>Comparable</code>或<code>Comparator</code>接口进行指定</p>
<pre><code class="java">//Comparable是泛型,可以指定类
class Cat implements Comparable&lt;Cat&gt;&#123;
    
    private String name;
    private int age;

    //省略构造方法

    //实现接口中的方法
    public int compareTo(Cat o)&#123;
        //该方法用于比较此对象与指定对象的顺序,如果该对象小于,等于,大于指定对象,则分别返回负整数,零或正整数
        return this.age-o.age;
    &#125;
&#125;

Cat[] cats = &#123;new Cat(&quot;小a&quot;,2),new Cat(&quot;小b&quot;,1),new Cat(&quot;小c&quot;,6)&#125;;
//此时可以进行比较
Arrays.sort(cats);
</code></pre>
<p>对于已经创建好的类,按照oo原则,对修改关闭,对扩展开放,所以可以使用Comparator接口重新定义一个新类来实现比较(该接口同样是泛型),该接口内有compare方法</p>
<pre><code class="java">public class CatComparator implements Comparator&lt;Cat&gt;&#123;
    public int compare(Cat o1,Cat o2)&#123;
        return o1.getAge()-o2.getAge();
    &#125;
&#125;
//第一个参数是要比较的类,第二个是使用的比较器
Arrays.sort(cats,new CatComparator());
</code></pre>
<h1 id="34-容器中用到的设计模式"><a href="#34-容器中用到的设计模式" class="headerlink" title="34. 容器中用到的设计模式"></a>34. 容器中用到的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>Collection继承了<code>Iterable</code>接口，其中<code>iterator()</code>方法能够产生一个<code>Iterator</code>对象，通过这个对象就可以迭代遍历<code>Collection</code>中的元素。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><code>java.util.Arrays.asList()</code>可以把数组类型转化为<code>List</code>类型。</p>
<blockquote>
<p>关于其内容见22题</p>
</blockquote>
<h1 id="35-Vector相关分析"><a href="#35-Vector相关分析" class="headerlink" title="35. Vector相关分析"></a>35. Vector相关分析</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>Vector的实现与ArrayList相似，但是使用了<code>synchronized</code>进行同步。</p>
<pre><code class="java">public synchronized boolean add(E e) &#123;
    modCount++;
    add(e, elementData, elementCount);
    return true;
&#125;

public synchronized E remove(int index) &#123;
    modCount++;
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    E oldValue = elementData(index);

    int numMoved = elementCount - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                        numMoved);
    elementData[--elementCount] = null; // Let gc do its work

    return oldValue;
&#125;

public synchronized E get(int index) &#123;
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
&#125;
</code></pre>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>Vector可以通过构造函数传入<code>capacityIncrement</code>参数指定每次扩容时容量的增长数。默认情况下每次扩容会扩容为原来的两倍。</p>
<pre><code class="java">public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                            initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement capacityIncrement;
&#125;
</code></pre>
<pre><code class="java">private int newCapacity(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt;= 0) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return minCapacity;
    &#125;
    return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)
        ? newCapacity
        : hugeCapacity(minCapacity);
&#125;
</code></pre>
<h2 id="与ArrayList区别"><a href="#与ArrayList区别" class="headerlink" title="与ArrayList区别"></a>与ArrayList区别</h2><ol>
<li><code>ArrayList</code>是线程不安全的，而<code>Vector</code>是线程安全的，因此开销比<code>ArrayList</code>大，访问速度较慢。最好使用<code>ArrayList</code>，因为同步操作完全可以由程序员自己来控制。</li>
<li><code>Vector</code>每次扩容是默认容量为原来2倍（可以自行指定增长数量），<code>ArrayList</code>为1.5倍。</li>
</ol>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>可以使用<code>Collections.synchronizedList()</code>得到一个线程安全的<code>ArrayList</code></p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);
</code></pre>
<p>也可以使用<code>concurrent</code>并发包下的<code>CopyOnWriteArrayList</code>类。</p>
<pre><code class="java">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h1 id="36-CopyOnWriteArrayList"><a href="#36-CopyOnWriteArrayList" class="headerlink" title="36. CopyOnWriteArrayList"></a>36. CopyOnWriteArrayList</h1><p>用于创建一个适用于并发的<code>ArrayList</code>，其主要实现原理是<strong>读写分离</strong>。</p>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失以及多线程写的时候会copy出多个副本出来。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre><code class="java">public boolean add(E e) &#123;
    synchronized (lock) &#123;
        Object[] es = getArray();
        int len = es.length;
        es = Arrays.copyOf(es, len + 1);
        es[len] = e;
        setArray(es);
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">static &lt;E&gt; E elementAt(Object[] a, int index) &#123;
    return (E) a[index];
&#125;
</code></pre>
<p><strong>适用场景</strong></p>
<p><code>CopyOnWriteArrayList</code>在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是<code>CopyOnWriteArrayList</code>有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以<code>CopyOnWriteArrayList</code>不适合内存敏感以及对实时性要求很高的场景。</p>
<h1 id="37-LinkedHashMap分析"><a href="#37-LinkedHashMap分析" class="headerlink" title="37. LinkedHashMap分析"></a>37. LinkedHashMap分析</h1><p><code>LinkedHashMap</code>继承自<code>HashMap</code>,因此具有和<code>HashMap</code>一样快速查找的特性。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><code>LinkedHashMap</code>内部维护了一个双向链表，用来维护插入顺序或者LRU顺序（最少使用淘汰算法）</p>
<pre><code class="java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p><code>accessOrder</code>决定了顺序，默认为<code>false</code>,此时维护的是插入顺序。</p>
<p><code>LinkedHashMap</code>最重要的是以下用于维护顺序的函数：<code>afterNodeAccess()</code>,<code>afterNodeInsertion()</code></p>
<p><strong>afterNodeAccess()</strong>:当一个节点被访问时，如果<code>accessOrder</code>为<code>true</code>，则会将该节点移到链表尾部。也就是说指定为<code>LRU</code>顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="java">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) &#123;
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else &#123;
            p.before = last;
            last.after = p;
        &#125;
        tail = p;
        ++modCount;
    &#125;
&#125;
</code></pre>
<p><strong>afterNodeInsertion()</strong>:在<code>put</code>等操作之后执行，当<code>removeEldestEntry()</code>方法返回<code>true</code>时会移除最晚的节点，也就是链表首部节点<code>first</code></p>
<p><code>evict</code>只有在构建<code>Map</code>的时候才为<code>false</code>，在这里为<code>true</code>。</p>
<pre><code class="java">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    &#125;
&#125;
</code></pre>
<p><code>removeEldestEntry()</code>默认为<code>false</code>，如果需要让它为<code>true</code>，需要继承 <code>LinkedHashMap</code>并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;
    return false;
&#125;
</code></pre>
<h2 id="使用LinkedHashMap实现LRU缓存"><a href="#使用LinkedHashMap实现LRU缓存" class="headerlink" title="使用LinkedHashMap实现LRU缓存"></a>使用LinkedHashMap实现LRU缓存</h2><p>思路如下：</p>
<ul>
<li>设定最大缓存空间<code>MAX_ENTRIES</code></li>
<li>使用<code>LinkedHashMap</code>的构造函数将<code>accessOrder</code>设置为<code>true</code>,开启URL顺序</li>
<li>覆盖<code>removeEldestEntry</code>方法，在结点多于最大缓存空间的时候将最久未使用数据移除。</li>
</ul>
<pre><code class="java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) &#123;
        return size() &gt; MAX_ENTRIES;
    &#125;

    LRUCache() &#123;
        super(MAX_ENTRIES, 0.75f, true);
    &#125;
&#125;
</code></pre>
<h1 id="38-WeakHashMap"><a href="#38-WeakHashMap" class="headerlink" title="38. WeakHashMap"></a>38. WeakHashMap</h1><p><code>WeakHashMap</code>的<code>Entry</code>继承自<code>WeakReference</code>，被<code>WeakReference</code>关联的对象在下一次垃圾回收时会被回收。</p>
<p><code>WeakHashMap</code>主要用来实现缓存，通过使用<code>WeakHashMap</code>来引用缓存对象，由JVM对这部分缓存进行回收。</p>
<p><code>Tomcat</code>中的<code>ConcurrentCache</code>使用了<code>WeakHashMap</code>来实现缓存功能。</p>
<p><code>ConcurrentCache</code>采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入<code>eden</code>中，<code>eden</code>使用<code>ConcurrentHashMap</code>实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入<code>longterm</code>，<code>longterm</code>使用<code>WeakHashMap</code>实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用<code>get()</code>方法时，会先从<code>eden</code>区获取，如果没有找到的话再到<code>longterm</code>获取，当从<code>longterm</code>获取到就把对象放入<code>eden</code>中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用<code>put()</code>方法时，如果<code>eden</code>的大小超过了 <code>size</code>，那么就将<code>eden</code>中的所有对象都放入<code>longterm</code>中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<pre><code class="java">public final class ConcurrentCache&lt;K, V&gt; &#123;

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) &#123;
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    &#125;

    public V get(K k) &#123;
        V v = this.eden.get(k);
        if (v == null) &#123;
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        &#125;
        return v;
    &#125;

    public void put(K k, V v) &#123;
        if (this.eden.size() &gt;= size) &#123;
            this.longterm.putAll(this.eden);
            this.eden.clear();
        &#125;
        this.eden.put(k, v);
    &#125;
&#125;
</code></pre>
<h1 id="39-TreeSet"><a href="#39-TreeSet" class="headerlink" title="39. TreeSet"></a>39. TreeSet</h1><p>TreeSet也是基于Map来实现，具体实现是TreeMap，底层数据结构为红黑树。</p>
<p>与HashSet不同的是，TreeSet具有排序功能，分为<strong>自然排序</strong>(123456)和<strong>自定义排序</strong>两类，默认是<strong>自然排序</strong>；在程序中，可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序；</p>
<p>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。</p>
<ul>
<li>与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</li>
<li>TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。<strong>这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数</strong>；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；</li>
<li>TreeSet实现Cloneable接口，意味着它也可以被克隆；</li>
<li>TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</li>
</ul>
<p>TreeSet具有如下特点：</p>
<ul>
<li>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</li>
<li>底层使用红黑树结构，而不是哈希表结构；</li>
<li>允许插入Null值；</li>
<li>不允许插入重复元素；</li>
<li>线程不安全；</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code class="java">public class TreeSetTest &#123;
    public static void main(String[] agrs)&#123;
        TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;();
        System.out.println(&quot;TreeSet初始化容量大小：&quot;+treeSet.size());

        //元素添加：
        treeSet.add(&quot;my&quot;);
        treeSet.add(&quot;name&quot;);
        treeSet.add(&quot;jiaboyan&quot;);
        treeSet.add(&quot;hello&quot;);
        treeSet.add(&quot;world&quot;);
        treeSet.add(&quot;1&quot;);
        treeSet.add(&quot;2&quot;);
        treeSet.add(&quot;3&quot;);
        System.out.println(&quot;TreeSet容量大小：&quot; + treeSet.size());
        System.out.println(&quot;TreeSet元素顺序为：&quot; + treeSet.toString());

        //增加for循环遍历：
        for(String str:treeSet)&#123;
            System.out.println(&quot;遍历元素：&quot;+str);
        &#125;

        //迭代器遍历：升序
        Iterator&lt;String&gt; iteratorAesc = treeSet.iterator();
        while(iteratorAesc.hasNext())&#123;
            String str = iteratorAesc.next();
            System.out.println(&quot;遍历元素升序：&quot;+str);
        &#125;

        //迭代器遍历：降序
        Iterator&lt;String&gt; iteratorDesc = treeSet.descendingIterator();
        while(iteratorDesc.hasNext())&#123;
            String str = iteratorDesc.next();
            System.out.println(&quot;遍历元素降序：&quot;+str);
        &#125;

        //元素获取:实现NavigableSet接口
        String firstEle = treeSet.first();//获取TreeSet头节点：
        System.out.println(&quot;TreeSet头节点为：&quot; + firstEle);

        // 获取指定元素之前的所有元素集合：(不包含指定元素)
        SortedSet&lt;String&gt; headSet = treeSet.headSet(&quot;jiaboyan&quot;);
        System.out.println(&quot;jiaboyan节点之前的元素为：&quot;+headSet.toString());

        //获取给定元素之间的集合：（包含头，不包含尾）
        SortedSet subSet = treeSet.subSet(&quot;1&quot;,&quot;world&quot;);
        System.out.println(&quot;1--jiaboan之间节点元素为：&quot;+subSet.toString());

        //集合判断：
        boolean isEmpty = treeSet.isEmpty();
        System.out.println(&quot;TreeSet是否为空：&quot;+isEmpty);
        boolean isContain = treeSet.contains(&quot;who&quot;);
        System.out.println(&quot;TreeSet是否包含who元素：&quot;+isContain);

        //元素删除：
        boolean jiaboyanRemove = treeSet.remove(&quot;jiaboyan&quot;);
        System.out.println(&quot;jiaboyan元素是否被删除&quot;+jiaboyanRemove);
        
        //集合中不存在的元素，删除返回false
        boolean whoRemove = treeSet.remove(&quot;who&quot;);
        System.out.println(&quot;who元素是否被删除&quot;+whoRemove);

       //删除并返回第一个元素：如果set集合不存在元素，则返回null
        String pollFirst = treeSet.pollFirst();
        System.out.println(&quot;删除的第一个元素：&quot;+pollFirst);
        
        //删除并返回最后一个元素：如果set集合不存在元素，则返回null
        String pollLast = treeSet.pollLast();
        System.out.println(&quot;删除的最后一个元素：&quot;+pollLast);


        treeSet.clear();//清空集合:
    &#125;
&#125;
</code></pre>
<h2 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h2><p>在TreeSet调用<code>add</code>方法时，会调用到底层TreeMap的<code>put</code>方法，在<code>put</code>方法中会调用到<code>compare(key, key)</code>方法，进行<code>key</code>大小的比较</p>
<h1 id="40-Java中是如何支持正则表达式操作的？"><a href="#40-Java中是如何支持正则表达式操作的？" class="headerlink" title="40. Java中是如何支持正则表达式操作的？"></a>40. Java中是如何支持正则表达式操作的？</h1><p>Java 的 String 类中提供了支持正则表达式的操作，包括：<code>matches()</code>,<code>replaceAll()</code>,<code>replaceFirst()</code>,<code>split()</code>。此外，Java 中还可以使用 <code>Pattern</code> 和 <code>Macher</code>类进行正则表达式操作。</p>
<pre><code class="java">String str = &quot;aaaaabbb&quot;;
str.matches(&quot;a*b&quot;);

Pattern p = Pattern.compile(&quot;a*b&quot;);//将正则表达式编译成Pattern类在内存中保存
Matcher m = p.matcher(str);//将执行匹配所涉及的状态保留再Matcher类中
boolean b = m.matches();//执行Matcher类的matches方法进行比较
</code></pre>
<h1 id="41-Java中如何跳出嵌套循环？"><a href="#41-Java中如何跳出嵌套循环？" class="headerlink" title="41. Java中如何跳出嵌套循环？"></a>41. Java中如何跳出嵌套循环？</h1><p>在最外层循环前加一个标记如 A，然后用 <code>break A</code> ;可以跳出多重循环。（Java中支持带标签的 <code>break</code> 和 <code>continue</code> 语句，作用有点类似于C和C++中的 <code>goto</code>语句，但是就像要避免使用 <code>goto</code> 一样，应该避免使用带标签的 <code>break</code> 和 <code>continue</code>，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好），根本不能进行字符串的 <code>equals</code> 比较，否则会产生 <code>NullPointerException</code> 异常。</p>
<h1 id="42-amp-和-amp-amp-的区别？"><a href="#42-amp-和-amp-amp-的区别？" class="headerlink" title="42. &amp; 和 &amp;&amp; 的区别？"></a>42. &amp; 和 &amp;&amp; 的区别？</h1><p><code>&amp;</code> 运算符有两种用法：</p>
<ul>
<li>按位与；</li>
<li>逻辑与。</li>
</ul>
<p><code>&amp;&amp;</code> 运算符是<strong>短路与运算</strong>。</p>
<p>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true 。<code>&amp;&amp;</code> 之所以称为短路运算是因为，如果 <code>&amp;&amp;</code> 左边的表达式的值是 <code>false</code>，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code>，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用 <code>&amp;</code> 运算符，因为第一个条件如果不成立，根本不能进行字符串的 <code>equals</code> 比较，否则会产生 <code>NullPointerException</code> 异常。</p>
<h1 id="43-Java里面final关键字的使用？"><a href="#43-Java里面final关键字的使用？" class="headerlink" title="43. Java里面final关键字的使用？"></a>43. Java里面final关键字的使用？</h1><p>当用 <code>final</code> 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类永远不会让他被继承，就可以用 <code>final</code> 进行修饰。<code>final</code> 类中的成员变量可以根据需要设为 <code>final</code>，但是要注意 <strong><code>final</code> 类中的所有成员方法都会被隐式地指定为 <code>final</code> 方法</strong>。</p>
<p>使用 <code>final</code> 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用 <code>final</code> 方法进行这些优化了。</p>
<p>对于一个 <code>final</code> 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
<h1 id="44-如何通过反射创建对象以及获取和设置对象私有属性字段的值？"><a href="#44-如何通过反射创建对象以及获取和设置对象私有属性字段的值？" class="headerlink" title="44. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？"></a>44. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？</h1><p>对象通过 <code>getClass()</code> 方法可以获得其 <code>Class</code> 对象，之后可以通过该 <code>Class</code> 对象的 <code>getDeclaredFields()</code> 方法获取包括 <code>private</code> 在内所有的属性；通过 <code>getDeclaredMethods()</code> 方法可以获取当前类包括 <code>private</code> 在内所有方法，但是不包括父类。之后通过<code>setAccesssible(true)</code>将其设置成可以访问（去除访问修饰符的检查）。</p>
<pre><code class="java">package reflection;

import java.lang.reflect.*;

public class ReflectionDemo &#123;

    public static void main(String[] args) &#123;
        Dog dog = new Dog(&quot;dabao&quot;,5,&quot;白色&quot;,&quot;藏獒&quot;);
        Class dogClass = dog.getClass();
        //通过反射实例化对象
        try &#123;
            //Dog inflectDog = (Dog)dogClass.newInstance(&quot;dwr&quot;);//jdk1.9之后不推荐使用
            Dog inflectDog = (Dog)dogClass.getDeclaredConstructor(String.class, int.class, String.class, String.class).newInstance(&quot;xiaobai&quot;,3,&quot;黑色&quot;,&quot;咖啡毛&quot;);
        &#125; catch (InstantiationException e) &#123;
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            e.printStackTrace();
        &#125; catch (NoSuchMethodException e) &#123;
            e.printStackTrace();
        &#125; catch (InvocationTargetException e) &#123;
            e.printStackTrace();
        &#125;

        //获取构造方法
        Constructor[] constructors = dogClass.getConstructors();//获取所有构造方法
        for (int i = 0; i &lt; constructors.length; i++) &#123;
            System.out.println(constructors[i].getName());//构造参数名
            System.out.println(constructors[i].getParameterCount());//参数数目
        &#125;
        try &#123;
            Constructor constructor = dogClass.getConstructor(String.class, int.class, String.class, String.class);//根据变量类型获取指定的构造方法
            //之后就可以调用上面的newInstance方法实例化一个对象
        &#125; catch (NoSuchMethodException e) &#123;
            e.printStackTrace();
        &#125;

        //获取类中的所有属性
        Field[] fields = dogClass.getFields();//获取所有非private的属性
        System.out.println(fields.length);
        Field[] declaredFields = dogClass.getDeclaredFields();//获取所有属性
        System.out.println(declaredFields.length);
        for (int i = 0; i &lt; declaredFields.length; i++) &#123;
            int modifiers = declaredFields[i].getModifiers();
            System.out.println(Modifier.toString(modifiers)+&quot; &quot;+declaredFields[i].getType()+&quot; &quot;+declaredFields[i].getName());
        &#125;

        //获取包对象的包信息
        Package aPackage = dogClass.getPackage();
        System.out.println(aPackage.getName());

        //获取方法
        //获取所有非private方法，包括父类的方法
        Method[] methods = dogClass.getMethods();
        for (int i = 0; i &lt; methods.length; i++) &#123;
            System.out.println(methods[i]);
            if(methods[i].getName().equals(&quot;toString&quot;))&#123;
                try &#123;
                    String s = (String)methods[i].invoke(dog);//调用方法
                    System.out.println(s);
                &#125; catch (IllegalAccessException e) &#123;
                    e.printStackTrace();
                &#125; catch (InvocationTargetException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;-------------&quot;);
        //获取当前类的所有方法（包括private），不包括父类
        Method[] methods1 = dogClass.getDeclaredMethods();
        for (int i = 0; i &lt; methods1.length; i++) &#123;
            System.out.println(methods1[i]);
            if(methods1[i].getName().equals(&quot;set&quot;))&#123;
                //设置私有方法可以被访问（去除访问修饰符的检查）
                methods1[i].setAccessible(true);
                try &#123;
                    methods1[i].invoke(dog);
                &#125; catch (IllegalAccessException e) &#123;
                    e.printStackTrace();
                &#125; catch (InvocationTargetException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="45-什么是范型？解释-extends-和-super-泛型限定符？"><a href="#45-什么是范型？解释-extends-和-super-泛型限定符？" class="headerlink" title="45. 什么是范型？解释 extends 和 super 泛型限定符？"></a>45. 什么是范型？解释 extends 和 super 泛型限定符？</h1><p>范型相当于将数据类型参数化，泛型只作用于编译期,在编译后会被所指定的具体类型代替。</p>
<ul>
<li>范型上限 <code>&lt; ? extends Fruit &gt;</code>：表示所能接收类型必须是指定类或者其子类。</li>
<li>范型下限 <code>&lt; ? super Apple &gt;</code>：表示所能接收类型必须是指定类或者其父类。</li>
</ul>
<p><strong>注意点</strong>：</p>
<p>上界的 <code>list</code> 只能使用 <code>get</code> 方法，而不能使用 <code>add</code> 方法（确切的说是不能 <code>add</code> 除 <code>null</code> 之外的对象，包括 <code>Object</code>）。</p>
<ul>
<li>原因：上界 <code>&lt;? extends Fruit&gt;</code>表示所有继承 <code>Fruit</code> 的子类，但是具体事哪个子类，无法确定，所以在调用 <code>add</code> 方法的时候，需要 <code>add</code> 什么类型是无法确定的。但是在 <code>get</code> 的时候，由于不管是什么子类，都能够通过向上转型使用 <code>Fruit</code> 作为接收对象。</li>
</ul>
<p>下界的 <code>list</code> 只能 <code>add</code>，不能<code>get</code>。</p>
<ul>
<li>原因：下界 <code>&lt;? super Apple&gt;</code> 表示 Apple 的所有父类，包括 <code>Fruit</code>，一直可以追溯到 <code>Object</code>。那么当使用 <code>add</code> 的时候，不能 <code>add</code> Apple 的父类，因为不能确定 <code>List</code> 中存放的到底是哪个父类，但是可以 <code>add</code> Apple 及其子类，因为他们都可以通过向上转型为 <code>Apple</code> 甚至是 <code>Object</code>。但是当使用 <code>get</code> 的时候，由于 <code>Apple</code> 有很多父类，并不知道要用什么类型接收返回值，所以无法使用。</li>
</ul>
<h1 id="46-String-为什么是不可变的？"><a href="#46-String-为什么是不可变的？" class="headerlink" title="46. String 为什么是不可变的？"></a>46. String 为什么是不可变的？</h1><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<p>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 <code>value</code> 字节数组也是 final 的，<strong>只有当字符串是不可变时字符串池才有可能实现</strong>，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；<strong>如果字符串是可变的则会引起很严重的安全问题</strong>，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；<strong>因为字符串是不可变的，所以是多线程安全的</strong>，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，<strong>不变性也保证了 hash 码的唯一性</strong>，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p>
<h1 id="47-Object-类中有哪些方法"><a href="#47-Object-类中有哪些方法" class="headerlink" title="47. Object 类中有哪些方法"></a>47. Object 类中有哪些方法</h1><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><pre><code class="java">public final native Class&lt;?&gt; getClass();
</code></pre>
<p>getClass 方法用于获取对象的运行时类,在反射的时候用的比较多。</p>
<p>注意到这个方法被 final 和 native 修饰，说明</p>
<ul>
<li>不能覆写</li>
<li>实现在C&#x2F;C++层</li>
</ul>
<p>返回的 Class 对象就是表示类静态同步方法锁定的对象。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><pre><code class="java">public native int hashCode();
</code></pre>
<p>hashCode 方法用于获取对象的 hash 值。</p>
<p>在强烈依赖 hashCode 的地方是必须的。比如 HashMap 中对 key 进行 hash 计算，其实是利用 key 的 hashCode。</p>
<p>这个方法的实现依然在native层。</p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><pre><code class="java">public boolean equals(Object obj) &#123;
    return (this == obj);
&#125;
</code></pre>
<p>equals 方法用于比较两个对象是否相等。</p>
<p>默认的实现就是通过比较引用来判断是不是相等。</p>
<p>这种实现比较简单粗暴，首先引用相等就是同一个对象，肯定是相等的。但是在实际应用中引用不等，对象未必不相等。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><pre><code class="java">protected native Object clone() throws CloneNotSupportedException;
</code></pre>
<p>这个方法就是创建并返回一个对象的拷贝。<br>这个方法有三个值得注意的点：</p>
<ul>
<li>方式是 native 实现信息的拷贝。</li>
<li>方法是 protected，外部没法调用。</li>
<li>如果没有实现 Cloneable 接口，调用 的时候会抛出 CloneNotSupportedException 异常。</li>
</ul>
<p>如果外部需要调用 clone 方法，要么通过反射，要么将它覆写成 public 方法。</p>
<p>这个 Cloneable 接口中没有定义任何方法，所以实现 Cloneable 接口没有别的作用，就代表具备了使用 clone 方法的权利。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><pre><code class="java">public String toString() &#123;
    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
&#125;
</code></pre>
<p>toString 方法就是把对象用字符串的形式表示，这个在日志中使用较多，当然也可以是类型转换，比如Integer 类。</p>
<p>默认的实现其实没有什么用，”类名@hashCode”，直接打印对象输出就是这样的格式。</p>
<p>官方文档建议最好覆写这个方法，返回一些有价值的、可读性强的信息。</p>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(),notify(),notifyAll()"></a>wait(),notify(),notifyAll()</h2><p>wait() 方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用 notify() 或者 notifyAll() 方法。</p>
<p>只能用在同步方法或者同步控制块中使用，获得当前对象的锁资源，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<pre><code class="java">public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123;
    if (timeoutMillis &lt; 0) &#123;
        throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;);
    &#125;

    if (nanos &lt; 0 || nanos &gt; 999999) &#123;
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    &#125;

    if (nanos &gt; 0) &#123;
        timeoutMillis++;
    &#125;

    wait(timeoutMillis);
&#125;
</code></pre>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><pre><code class="java">protected void finalize() throws Throwable &#123; &#125;
</code></pre>
<p>finalize 是 GC 准备回收对象的时候调用来执行清理工作的。(JVM 14题)</p>
<p>总结：</p>
<ul>
<li><code>Object()</code> 默认构造方法。</li>
<li><code>clone()</code> 创建并返回此对象的一个副本。</li>
<li><code>equals(Object obj)</code> 指示某个其他对象是否与此对象“相等”。</li>
<li><code>finalize()</code> 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</li>
<li><code>getClass()</code> 返回一个对象的运行时类。</li>
<li><code>hashCode()</code> 返回该对象的哈希码值。 </li>
<li><code>notify()</code> 唤醒在此对象监视器上等待的单个线程。</li>
<li><code>notifyAll()</code> 唤醒在此对象监视器上等待的所有线程。</li>
<li><code>toString()</code> 返回该对象的字符串表示。</li>
<li><code>wait()</code>导致当前的线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法。</li>
<li><code>wait(long timeout)</code> 导致当前的线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法，或者超过指定的时间量。<code>wait(long timeout, int nanos)</code> 导致当前的线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</li>
</ul>
<h1 id="48-List、Set、Map是否继承自Collection接口？"><a href="#48-List、Set、Map是否继承自Collection接口？" class="headerlink" title="48. List、Set、Map是否继承自Collection接口？"></a>48. List、Set、Map是否继承自Collection接口？</h1><p>只有 List 和 Set 继承了 Collection 接口，Map 是键值对映射容器，不同于 Set 和 List 只存储元素。</p>
<h1 id="49-Collection-和-Collections-的区别？"><a href="#49-Collection-和-Collections-的区别？" class="headerlink" title="49. Collection 和 Collections 的区别？"></a>49. Collection 和 Collections 的区别？</h1><ul>
<li>Collection 是集合类的上级接口，继承与他的接口主要有Set 和List。</li>
<li>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h1 id="50-与快速失败机制对应的安全失败机制"><a href="#50-与快速失败机制对应的安全失败机制" class="headerlink" title="50. 与快速失败机制对应的安全失败机制"></a>50. 与快速失败机制对应的安全失败机制</h1><p>安全失败（<code>fail-safe</code>）采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<strong>先复制原有集合内容，在拷贝的集合上进行遍历</strong>。</p>
<p><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 <code>Concurrent Modification Exception</code>，例如 <code>CopyOnWriteArrayList</code>。</p>
<p><strong>缺点</strong>：基于拷贝内容的优点是避免了 <code>Concurrent Modification Exception</code>，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p><strong>场景</strong>：<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<p>快速失败和安全失败是对迭代器而言的。 </p>
<ul>
<li>快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出 <code>ConcurrentModification异常</code>，<code>java.util</code> 下都是快速失败。 </li>
<li>安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在 <code>java.util.concurrent</code> 下都是安全失败</li>
</ul>
<h1 id="51-Iterator-和-ListIterator-区别？"><a href="#51-Iterator-和-ListIterator-区别？" class="headerlink" title="51. Iterator 和 ListIterator 区别？"></a>51. Iterator 和 ListIterator 区别？</h1><p><code>Iterator</code> 可用来遍历 <code>Set</code> 和 <code>List</code> 集合，但是 <code>ListIterator</code> 只能用来遍历 <code>List</code>。</p>
<p><code>Iterator</code> 对集合只能是前向遍历，<code>ListIterator</code> 既可以前向也可以后向。</p>
<p><code>ListIterator</code> 实现了 <code>Iterator</code> 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<p><code>Iterator</code> 提供了统一遍历操作集合元素的统一接口, <code>Collection</code> 接口实现 <code>Iterable</code> 接口,<br>每个集合都通过实现 <code>Iterable</code> 接口中 <code>iterator()</code> 方法返回 <code>Iterator</code> 接口的实例, 然后对集合的元素进行迭代操作。</p>
<p>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出 <code>ConcurrentModificationException</code> 异常. 但是可以通过 <code>Iterator</code> 接口中的 <code>remove()</code> 方法进行删除。（详见24题）。</p>
<h1 id="52-运行时异常和受检异常有什么区别？"><a href="#52-运行时异常和受检异常有什么区别？" class="headerlink" title="52. 运行时异常和受检异常有什么区别？"></a>52. 运行时异常和受检异常有什么区别？</h1><p>运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误，只要程序设计得当通常就不会发生。当出现这样的异常，可以不处理，总是由虚拟机接管。<code>RuntimeException</code>下的类便都是运行时异常。</p>
<p>受检异常跟程序的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而导致异常。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h1 id="53-JDBC-使用流程"><a href="#53-JDBC-使用流程" class="headerlink" title="53. JDBC 使用流程"></a>53. JDBC 使用流程</h1><ol>
<li>注册 JDBC 驱动（<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）</li>
<li>打开连接（<code>DriverManager.getConnection(&quot;url&quot;,&quot;name&quot;,&quot;password&quot;)</code>）</li>
<li>根据连接，创建 Statement（<code>conn.prepareStatement(sql)</code>）</li>
<li>设置参数（<code>stmt.setString(1, &quot;wyf&quot;);</code>）</li>
<li>执行查询（<code>stmt.executeQuery();</code>）</li>
<li>处理结果，结果集映射（<code>resultSet.next()</code>）</li>
<li>关闭资源（<code>finally</code>）</li>
</ol>
<h1 id="54-Java提供的排序算法是怎么实现的？"><a href="#54-Java提供的排序算法是怎么实现的？" class="headerlink" title="54. Java提供的排序算法是怎么实现的？"></a>54. Java提供的排序算法是怎么实现的？</h1><h2 id="Arrays-sort-的排序算法"><a href="#Arrays-sort-的排序算法" class="headerlink" title="Arrays.sort()的排序算法"></a>Arrays.sort()的排序算法</h2><p>如果数组长度大于等于286且连续性好的话，就用归并排序，如果大于等于286且连续性不好的话就用双轴快速排序。如果长度小于286且大于等于47的话就用双轴快速排序，如果长度小于47的话就用插入排序。</p>
<h2 id="Collections-sort-的排序算法"><a href="#Collections-sort-的排序算法" class="headerlink" title="Collections.sort()的排序算法"></a>Collections.sort()的排序算法</h2><p><code>LegacyMergeSort.userRequested</code>为 true 的话就会使用归并排序，可以通过下面代码设置为true：</p>
<pre><code class="java">System.setProperty(&quot;java.util.Arrays.useLegacyMergeSort&quot;,&quot;true&quot;);
</code></pre>
<p>不为 true 的话就会用一个叫 TimSort 的排序算法。</p>
<h1 id="55-Collections-synchronizedMap-与-ConcurrentHashMap-的区别"><a href="#55-Collections-synchronizedMap-与-ConcurrentHashMap-的区别" class="headerlink" title="55. Collections.synchronizedMap()与 ConcurrentHashMap 的区别"></a>55. Collections.synchronizedMap()与 ConcurrentHashMap 的区别</h1><p>SynchronizedMap 是一个实现了 Map 接口的代理类，该类中对 Map 接口中的方法使用 synchronized 同步关键字来保证对 Map 的操作是线程安全的。</p>
<p>Collections.synchronizedMap() 与 ConcurrentHashMap 主要区别是：</p>
<p>Collections.synchronizedMap() 和 Hashtable 一样，实现上在调用 map 所有方法时，都对整个 map 进行同步，会抛出 <code>java.util.ConcurrentModificationException</code> 异常，而 ConcurrentHashMap 的实现却更加精细，在 ConcurrentHashMap中，每个桶都有一个自己对应的锁。</p>
<p>所以，只要有一个线程访问 synchronizedMap，其他线程就无法进入 map，而如果一个线程在访问 ConcurrentHashMap 某个桶时，其他线程，仍然可以对 map 执行某些操作。这样，ConcurrentHashMap 在性能以及安全性方面，明显比 Collections.synchronizedMap() 更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历 map 时，其他线程试图对 map 进行数据修改，也不会抛出 ConcurrentModificationException。</p>
<p>不论 Collections.synchronizedMap() 还是 ConcurrentHashMap 对 map 同步的原子操作都是作用的 map 的方法上，map 在读取与清空之间，线程间是不同步的。</p>
<p>还有一个区别是：ConcurrentHashMap 从类的命名就能看出，它必然是个 HashMap。而Collections.synchronizedMap() 可以接收任意Map实例，实现Map的同步。</p>
<h1 id="56-JAVA-反射的原理"><a href="#56-JAVA-反射的原理" class="headerlink" title="56. JAVA 反射的原理"></a>56. JAVA 反射的原理</h1><p>反射调用过程如下：</p>
<pre><code class="java">Class actionClass=Class.forName(&quot;MyClass&quot;);
Object action=actionClass.newInstance();
Method method = actionClass.getMethod(&quot;myMethod&quot;,null);
method.invoke(action,null);
</code></pre>
<h2 id="首先是-forName-方法"><a href="#首先是-forName-方法" class="headerlink" title="首先是 forName 方法"></a>首先是 forName 方法</h2><pre><code class="java">@CallerSensitive
public static Class&lt;?&gt; forName(String className)
        throws ClassNotFoundException &#123;
    // 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader            
    Class&lt;?&gt; caller = Reflection.getCallerClass();
    // 调用native方法进行获取class信息
    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
&#125;
</code></pre>
<p><code>forName()</code>反射获取类信息，并没有将实现留给了 java,而是交给了 jvm 去加载。主要是先获取 <code>ClassLoader</code>, 然后调用 <code>native</code> 方法，获取信息，加载类则是回调 <code>java.lang.ClassLoader</code>。最后，jvm 又会回调 <code>ClassLoader</code> 进行类加载过程。</p>
<h2 id="接下来是-newInstance-方法"><a href="#接下来是-newInstance-方法" class="headerlink" title="接下来是 newInstance 方法"></a>接下来是 newInstance 方法</h2><p><code>newInstance()</code> 主要做了三件事：</p>
<ol>
<li>权限检测，如果不通过直接抛出异常；</li>
<li>查找无参构造器，并将其缓存起来，这个过程分三步：</li>
<li>调用具体方法的无参构造方法，生成实例并返回</li>
</ol>
<p>在查询无参构造器的时候，使用 <code>getConstructor0()</code> 为获取匹配的构造方器，分三步；</p>
<ol>
<li>先获取所有的 constructors, 然后通过进行参数类型比较；</li>
<li>找到匹配后，通过 ReflectionFactory copy一份 constructor 返回；</li>
<li>否则抛出 NoSuchMethodException;</li>
</ol>
<p>而获取所有的构造器主要步骤，都在 <code>privateGetDeclaredConstructors()</code> 方法里：</p>
<ol>
<li>先尝试从缓存中获取；</li>
<li>如果缓存没有，则从 jvm 中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ol>
<h2 id="反射获取方法-getMethod-“myMethod”-获得-Method-对象"><a href="#反射获取方法-getMethod-“myMethod”-获得-Method-对象" class="headerlink" title="反射获取方法 getMethod(“myMethod”) 获得 Method 对象"></a>反射获取方法 getMethod(“myMethod”) 获得 Method 对象</h2><ol>
<li>获取所有方法列表；</li>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ol>
<p>在获取所有方法列表的过程中，首先会从缓存中去寻找。</p>
<p>匹配到方法名后，进行参数类型匹配，但是，匹配到一个方法，并没有退出 for 循环，而是继续进行匹配。这是因为进行最优匹配，匹配最精确的子类进行返回。最后，通过 <code>ReflectionFactory</code> 的 <code>copy</code> 方法后返回！</p>
<p><img src="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="Method 对象生成过程"></p>
<p>每个类都会有一个与之对应的 Class 实例，JVM 管理着这个 Class 实例，这个实例里维护着该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。每次 getMethod 获取到的 Method 对象都持有对根对象的引用，因为一些重量级的 Method 的成员变量（主要是 MethodAccessor），我们不希望每次创建 Method 对象都要重新初始化，于是所有代表同一个方法的 Method 对象都共享着根对象的 MethodAccessor，每一次创建都会调用根对象的 copy 方法复制一份</p>
<h2 id="Method-invoke-反射调用方法"><a href="#Method-invoke-反射调用方法" class="headerlink" title="Method.invoke() 反射调用方法"></a>Method.invoke() 反射调用方法</h2><p><img src="http://qiniu.xiaoming.net.cn/%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8invoke%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.png" alt="反射调用 invoke 方法流程"></p>
<p>调用 <code>Method.invoke</code> 之后，会直接去调 <code>MethodAccessor.invoke</code>,最终是由 jvm 执行 <code>invoke0()</code> 执行。<code>MethodAccessor</code> 就是上面提到的所有同名 <code>method</code> 共享的一个实例，由 <code>ReflectionFactory</code> 创建。</p>
<p>创建机制采用了一种名为 <code>inflation</code> 的方式（JDK1.4之后）：如果该方法的累计调用次数 <code>&lt;=15</code>，会创建出<code>NativeMethodAccessorImpl</code>，它的实现就是直接调用 <code>native</code> 方法实现反射；如果该方法的累计调用次数 <code>&gt;15</code>，会由 java 代码创建出字节码组装而成的 <code>MethodAccessorImpl</code>。（是否采用 inflation 和 15 这个数字都可以在 jvm 参数中调整）</p>
<h1 id="57-JVM、JRE、JDK-的区别？"><a href="#57-JVM、JRE、JDK-的区别？" class="headerlink" title="57. JVM、JRE、JDK 的区别？"></a>57. JVM、JRE、JDK 的区别？</h1><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p>什么是字节码?采用字节码的好处是什么?</p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h1 id="58-JAVA的简单数据类型和复合数据类型"><a href="#58-JAVA的简单数据类型和复合数据类型" class="headerlink" title="58. JAVA的简单数据类型和复合数据类型"></a>58. JAVA的简单数据类型和复合数据类型</h1><p>基本数据类型：</p>
<ul>
<li>byte&#x2F;8(1个字节)</li>
<li>char&#x2F;16（2个字节）</li>
<li>short&#x2F;16（2个字节）</li>
<li>int&#x2F;32（4个字节）</li>
<li>float&#x2F;32（4个字节）</li>
<li>long&#x2F;64（8个字节）</li>
<li>double&#x2F;64（8个字节）</li>
<li>boolean&#x2F;1（1位）</li>
</ul>
<p>复合数据类型：</p>
<p>Java 虚拟机（JVM）还定义了索引（reference）这种数据类型。索引类型可以“引用”变量，由于 Java 没有明确地定义指针类型，所以索引类型可以被认为就是指向实际值或者指向变量所代表的实际值的指针。一个对象可以被多于一个以上的索引所“指”。JVM从不直接对对象寻址而是操作对象的索引。</p>
<p>索引类型分成三种，它们是：类（class）、接口（interface）和数组（array）。索引类型可以引用动态创建的类实例、普通实例和数组。索引还可以包含特殊的值，这就是 null 索引。null 索引在运行时上并没有对应的类型，但它可以被转换为任何类型。索引类型的默认值就是 null。</p>
<h1 id="59-字符编码"><a href="#59-字符编码" class="headerlink" title="59. 字符编码"></a>59. 字符编码</h1><p><strong>字符集</strong>（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>
<p><strong>字符编码</strong>（Character Encoding）：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p>
<p>常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
<h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><p>在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</p>
<h3 id="Unicode-的问题"><a href="#Unicode-的问题" class="headerlink" title="Unicode 的问题"></a>Unicode 的问题</h3><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？</p>
<p>第二个问题是，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：</p>
<ul>
<li>出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。</li>
<li>Unicode 在很长一段时间内无法推广，直到互联网的出现。</li>
</ul>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</strong>。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<blockquote>
<p>1）对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；<br>2）对于n字节的符号（n &gt; 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
</blockquote>
<p>下表总结了编码规则，字母x表示可用编码的位：</p>
<p><img src="http://qiniu.xiaoming.net.cn/UTF-8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99.jpg" alt="UTF-8编码规则"></p>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字严为例，演示如何实现 UTF-8 编码。</p>
<p>严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，向右对齐依次填入格式中的x，左边多出的x位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</p>
<h2 id="Little-endian-和-Big-endian"><a href="#Little-endian-和-Big-endian" class="headerlink" title="Little endian 和 Big endian"></a>Little endian 和 Big endian</h2><p>window 中的应用 notepad.exe 有一个 UCS-2 编码方式：即直接用两个字节存入字符的 Unicode 码</p>
<p>UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p>
<p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>
<h2 id="GB系列字符集-amp-编码"><a href="#GB系列字符集-amp-编码" class="headerlink" title="GB系列字符集&amp;编码"></a>GB系列字符集&amp;编码</h2><p>计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。但是当天朝也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。</p>
<p>天朝专家把那些 127 号之后的奇异符号们（即EASCII）取消掉，规定：一个小于 127 的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样就可以组合出大约 7000 多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在 127 号以下的那些就叫”半角”字符了。</p>
<p>上述编码规则就是GB2312。</p>
<blockquote>
<p>GB2312或GB2312-80 是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</p>
</blockquote>
<p>由于 GB 2312-80 只收录 6763 个汉字，有不少汉字，如部分在 GB 2312-80 推出以后才简化的汉字（如”啰”），部分人名用字（如中国前总理朱镕基的”镕”字），台湾及香港使用的繁体字，日语及朝鲜语汉字等，并未有收录在内。于是厂商微软利用 GB 2312-80 未使用的编码空间，收录 GB 13000.1-93 全部字符制定了 GBK 编码。根据微软资料，GBK 是对 GB2312-80 的扩展，也就是 CP936 字码表 (Code Page 936)的扩展（之前CP936和GB 2312-80一模一样），最早实现 于Windows 95 简体中文版。虽然 GBK 收录GB 13000.1-93 的全部字符，但编码方式并不相同。GBK 自身并非国家标准，只是曾由国家技术监督局标准化司、电子工业部科技与质量监督司公布为”技术规范指导性文件”。原始 GB13000 一直未被业界采用，后续国家标准 GB18030 技术上兼容 GBK 而非 GB13000。</p>
<blockquote>
<p>GB 18030，全称：国家标准GB 18030-2005《信息技术 中文编码字符集》，是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术 信息交换用汉字编码字符集 基本集的扩充》的修订版。与GB 2312-1980完全兼容，与GBK基本兼容，支持GB 13000及Unicode的全部统一汉字，共收录汉字70244个。</p>
</blockquote>
<p>GB 18030主要有以下特点：</p>
<ul>
<li>与UTF-8相同，采用多字节编码，每个字可以由1个、2个或4个字节组成；</li>
<li>编码空间庞大，最多可定义161万个字符；</li>
<li>支持中国国内少数民族的文字，不需要动用造字区；</li>
<li>汉字收录范围包含繁体汉字以及日韩汉字。</li>
</ul>
<p>各个编码之间的兼容关系如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%84%E4%B8%AA%E7%BC%96%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB.jpg" alt="各个编码之间的兼容关系"></p>
<h1 id="60-Lambda-表达式实现原理"><a href="#60-Lambda-表达式实现原理" class="headerlink" title="60. Lambda 表达式实现原理"></a>60. Lambda 表达式实现原理</h1><p>针对如下代码：</p>
<pre><code class="java">public class LambdaTest &#123;
    public static void printString(String s, Print&lt;String&gt; print) &#123;
        print.print(s);
    &#125;
    public static void main(String[] args) &#123;
        printString(&quot;test&quot;, (x) -&gt; System.out.println(x));
    &#125;
&#125;

@FunctionalInterface
interface Print&lt;T&gt; &#123;
    public void print(T x);
&#125;
</code></pre>
<p>使用 <code>javac</code> 编译之后再用 <code>javap -p</code> 进行反编译，可以得到如下代码：</p>
<pre><code class="java">C:\Users\Code\Java\study&gt;javap -p LambdaTest.class
Compiled from &quot;LambdaTest.java&quot;
public class LambdaTest &#123;
  public LambdaTest();
  public static void printString(java.lang.String, Print&lt;java.lang.String&gt;);
  public static void main(java.lang.String[]);
  //生成的私有静态方法
  private static void lambda$main$0(java.lang.String);
&#125;
</code></pre>
<p>由上面的代码可以看出编译器会根据Lambda表达式生成一个私有的静态函数：</p>
<pre><code class="java">private static void lambda$main$0(java.lang.String);
</code></pre>
<p>由此可以直到 Lambda 表达式在 Java 9 中首先会生成一个私有的静态函数，这个私有的静态函数干的就是 Lambda 表达式里面的内容，那么又是如何调用的生成的私有静态函数（lambda$main$0(String s)）呢？</p>
<p>通过 <code>javap -p -v -c LambdaTest.class</code> 查看完整的反编译结果，比较重要的有以下几段：</p>
<p>反编译后的 main 方法：</p>
<pre><code class="java"> public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         // ldc 这个操作码用来将常量从运行时常量池压栈到操作数栈
         0: ldc           #3                  // String test
         // 注意下面两句：通过实例调用 print
         2: invokedynamic #4,  0              // InvokeDynamic #0:print:()LPrint;        
         //调用静态方法 printString
         7: invokestatic  #5                  // Method printString:(Ljava/lang/String;LPrint;)V
        10: return
</code></pre>
<p><code>invokeddynamic</code> 指令表示动态调用指令，动态类型只有在运行期才能确定接收者类型。每一个 <code>invokedynamic</code> 指令的实例叫做一个动态调用点(dynamic call site), 动态调用点最开始是未链接状态(unlinked:表示还未指定该调用点要调用的方法), 动态调用点依靠引导方法来链接到具体的方法。引导方法是由编译器生成, 在运行期当 JVM 第一次遇到 <code>invokedynamic</code> 指令时, 会调用引导方法来将 <code>invokedynamic</code> 指令所指定的名字(方法名,方法签名)和具体的执行代码(目标方法)链接起来, 引导方法的返回值永久的决定了调用点的行为.引导方法的返回值类型是 <code>java.lang.invoke.CallSite</code>, 一个 <code>invokedynamic</code> 指令关联一个 CallSite, 将所有的调用委托到 CallSite 当前的 target(MethodHandle)</p>
<p>上面涉及到通过实例调用，而实例如下：</p>
<pre><code class="java">InnerClasses:
     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles
BootstrapMethods:
  0: #29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:
  (Ljava/lang/invoke/MethodHandles$Lookup;
  Ljava/lang/String;Ljava/lang/invoke/MethodType;
  Ljava/lang/invoke/MethodType;
  Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)
  Ljava/lang/invoke/CallSite;
  Method arguments:
      //对象类型终结符为 L 和 ;
      //Object V
      #30 (Ljava/lang/Object;)V
      #31 invokestatic LambdaTest.lambda$main$0:(Ljava/lang/String;)V
      #32 (Ljava/lang/String;)V
</code></pre>
<p>会看到生成这个实例的内部类，可以通过以下指令运行，运行时，会将生成的内部类 class 码输出到一个文件中</p>
<pre><code>java -Djdk.internal.lambda.dumpProxyClasses LambdaTest
</code></pre>
<p>再通过通过 jad 反编译 <code>LambdaTest$$Lambda$1.class</code> 文件，内容如下：</p>
<pre><code class="java">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
final class LambdaTest$$Lambda$1 implements Print &#123;
    private LambdaTest$$Lambda$1() &#123;
    &#125;

    public void print(Object obj) &#123;
        LambdaTest.lambda$main$0((String) obj);
    &#125;
&#125;
</code></pre>
<p>可以看到，最终使用 Lambda 表达式的代码最终的执行代码如下：</p>
<pre><code class="java">public class LambdaTest &#123;
    public static void PrintString(String s, Print&lt;String&gt; print) &#123;
        print.print(s);
    &#125;

    public static void main(String[] args) &#123;
        PrintString(&quot;test&quot;, new LambdaTest$$Lambda$1());
    &#125;

    private static void lambda$main$0(String x) &#123;
        System.out.println(x);
    &#125;

    static final class LambdaTest$$Lambda$1 implements Print &#123;
        public void print(Object obj) &#123;
            LambdaTest.lambda$main$0((String) obj);
        &#125;
        private LambdaTest$$Lambda$1() &#123;
        &#125;
    &#125;

&#125;

@FunctionalInterface
interface Print&lt;T&gt; &#123;
    public void print(T x);
&#125;
</code></pre>
<p>所以，其实现原理如下：</p>
<ol>
<li>在类编译时，虚拟机通过 <code>invokedynamic</code> 指令动态创建相应的实现类</li>
<li>会生成一个私有静态方法和一个内部类</li>
<li>在使用 lambda 表达式的地方，通过传递内部类实例，来调用私有静态方法。</li>
</ol>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yougewe/p/10125073.html">深入理解java反射原理</a><br><a target="_blank" rel="noopener" href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/">Java反射原理简析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">为什么HashMap线程不安全</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5a9e9cb751882577b45e863e">深入解读Object类</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b98b89bf265da0abd35034c">为什么ConcurrentHashMap的读操作不需要加锁？</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104515829">一文读懂Java ConcurrentHashMap原理与实现</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyp798752401/article/details/8872884">JAVA的简单数据类型和复合数据类型</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chunzhiyan/article/details/38759973">小结-JAVA中的复合数据类型</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的7种中文字符编码</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38333902">字符编码那点事：快速理解ASCII、Unicode、GBK和UTF-8</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/raintungli/article/details/54910152">Java 8 动态类型语言Lambda表达式实现原理分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiankunking/article/details/79825928">Java Lambda表达式 实现原理分析</a>  </p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/23/MyBaits%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/" rel="prev" title="MyBatis连接查询">
                  <i class="fa fa-chevron-left"></i> MyBatis连接查询
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/06/01/SpringMVC/" rel="next" title="SpringMVC">
                  SpringMVC <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">37:40</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
