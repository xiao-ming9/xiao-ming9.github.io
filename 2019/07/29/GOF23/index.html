<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概览23种设计模式主要可以分为三种类型：  创建型模式：用来创建对象   单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。  结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。（关注对象和类的组成关系）  适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。  行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通">
<meta property="og:type" content="article">
<meta property="og:title" content="GOF23">
<meta property="og:url" content="http://yoursite.com/2019/07/29/GOF23/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="概览23种设计模式主要可以分为三种类型：  创建型模式：用来创建对象   单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。  结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。（关注对象和类的组成关系）  适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。  行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/Go%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg">
<meta property="article:published_time" content="2019-07-29T00:58:56.000Z">
<meta property="article:modified_time" content="2022-12-03T14:25:10.238Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta property="article:tag" content="java">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/Go%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg">


<link rel="canonical" href="http://yoursite.com/2019/07/29/GOF23/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2019/07/29/GOF23/","path":"2019/07/29/GOF23/","title":"GOF23"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>GOF23 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">常见的五种单例模式实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">饿汉式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">懒汉式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">双重检测锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">静态内部类的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.5.</span> <span class="nav-text">使用枚举的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E7%A0%B4%E8%A7%A3%E5%8D%95%E4%BE%8B%EF%BC%88%E9%92%88%E5%AF%B9%E6%9E%9A%E4%B8%BE%E4%B9%8B%E5%A4%96%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">利用反射破解单例（针对枚举之外）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E8%A7%A3%E5%8D%95%E4%BE%8B%EF%BC%88%E9%92%88%E5%AF%B9%E6%9E%9A%E4%B8%BE%E4%B9%8B%E5%A4%96%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">利用序列化破解单例（针对枚举之外）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="nav-number">2.4.</span> <span class="nav-text">利用多线程测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.5.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.6.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.6.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">2.6.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.7.</span> <span class="nav-text">与其他设计模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-x2F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.</span> <span class="nav-text">简单工厂&#x2F;工厂方法模式的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.4.</span> <span class="nav-text">工厂模式的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="nav-number">3.5.</span> <span class="nav-text">与其他设计模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">抽象工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.</span> <span class="nav-text">抽象工厂模式适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">抽象工厂的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">4.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.3.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%88%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">建造者（生成器）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">5.2.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">5.3.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-3"><span class="nav-number">5.3.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">5.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="nav-number">5.4.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88prototype%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">原型模式（prototype）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E5%85%8B%E9%9A%86%E5%92%8C%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="nav-number">6.1.</span> <span class="nav-text">浅克隆和深克隆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="nav-number">6.2.</span> <span class="nav-text">利用序列化和反序列化技术实现深克隆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95"><span class="nav-number">6.3.</span> <span class="nav-text">效率测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.4.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">6.5.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">6.6.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-4"><span class="nav-number">6.6.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="nav-number">6.6.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-2"><span class="nav-number">6.7.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">7.1.</span> <span class="nav-text">适配器模式中的角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">7.3.</span> <span class="nav-text">go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">7.4.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="nav-number">7.5.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-5"><span class="nav-number">7.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="nav-number">7.5.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-3"><span class="nav-number">7.6.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="nav-number">8.1.</span> <span class="nav-text">代理模式中的核心角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A%E4%BB%A3%E7%90%86%E7%B1%BB%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA"><span class="nav-number">8.2.1.</span> <span class="nav-text">静态代理：代理类需要自己创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A%E4%BB%A3%E7%90%86%E7%B1%BB%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90"><span class="nav-number">8.2.2.</span> <span class="nav-text">动态代理：代理类动态生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">8.3.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">8.4.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="nav-number">8.5.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-6"><span class="nav-number">8.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="nav-number">8.5.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-4"><span class="nav-number">8.6.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">桥接模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">9.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">9.2.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">9.3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="nav-number">9.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-7"><span class="nav-number">9.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="nav-number">9.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-5"><span class="nav-number">9.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83"><span class="nav-number">10.1.</span> <span class="nav-text">核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">10.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.</span> <span class="nav-text">Go版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">10.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="nav-number">10.5.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-8"><span class="nav-number">10.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-8"><span class="nav-number">10.5.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-6"><span class="nav-number">10.6.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">装饰器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">11.1.</span> <span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">11.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">11.3.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">11.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-7"><span class="nav-number">11.5.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-9"><span class="nav-number">11.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-9"><span class="nav-number">11.5.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-7"><span class="nav-number">11.6.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">外观模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">12.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">12.2.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">12.3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-8"><span class="nav-number">12.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-10"><span class="nav-number">12.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-10"><span class="nav-number">12.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-8"><span class="nav-number">12.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">13.1.</span> <span class="nav-text">享元模式的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">13.2.</span> <span class="nav-text">Go 代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">13.3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-9"><span class="nav-number">13.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-11"><span class="nav-number">13.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-11"><span class="nav-number">13.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-9"><span class="nav-number">13.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.</span> <span class="nav-text">责任链模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">14.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">14.2.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">14.3.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-10"><span class="nav-number">14.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-12"><span class="nav-number">14.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-12"><span class="nav-number">14.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-10"><span class="nav-number">14.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">15.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">15.2.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="nav-number">15.3.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-11"><span class="nav-number">15.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-13"><span class="nav-number">15.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-13"><span class="nav-number">15.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-11"><span class="nav-number">15.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">中介者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">16.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">16.2.</span> <span class="nav-text">Go 代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="nav-number">16.3.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-12"><span class="nav-number">16.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-14"><span class="nav-number">16.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-14"><span class="nav-number">16.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-12"><span class="nav-number">16.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">17.1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0-7"><span class="nav-number">17.2.</span> <span class="nav-text">Go 版本实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="nav-number">17.3.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-13"><span class="nav-number">17.4.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-15"><span class="nav-number">17.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-15"><span class="nav-number">17.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-13"><span class="nav-number">17.5.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">19.</span> <span class="nav-text">访问者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">20.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">模版方法模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">22.</span> <span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-1"><span class="nav-number">22.1.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">24.</span> <span class="nav-text">备忘录模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-2"><span class="nav-number">24.1.</span> <span class="nav-text">结构</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/GOF23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="GOF23 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GOF23
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-29 08:58:56" itemprop="dateCreated datePublished" datetime="2019-07-29T08:58:56+08:00">2019-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-03 22:25:10" itemprop="dateModified" datetime="2022-12-03T22:25:10+08:00">2022-12-03</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>84k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:16</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>23种设计模式主要可以分为三种类型：</p>
<ol>
<li><p>创建型模式：用来创建对象 </p>
<p> 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</p>
</li>
<li><p>结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。（关注对象和类的组成关系）</p>
<p> 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>
</li>
<li><p>行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责</p>
<p> 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p>
</li>
</ol>
<span id="more"></span>

<p><img src="https://qiniu.xiaoming.net.cn/Go%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" alt="Go常用设计模式"></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<p>单例模式同时解决了两个问题， 所以违反了<em>单一职责原则</em></p>
<ol>
<li><p><strong>保证一个类只有一个实例</strong>。 为什么会想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。它的运作方式是这样的： 如果创建了一个对象， 同时过一会儿后决定再创建一个新对象， 此时会获得之前已创建的对象， 而不是一个新对象。</p>
<p> 注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</p>
</li>
<li><p><strong>为该实例提供一个全局访问节点</strong>。 全局变量在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p>
<p> 和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p> 还有一点： 我们不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p>
</li>
</ol>
<h2 id="常见的五种单例模式实现方式"><a href="#常见的五种单例模式实现方式" class="headerlink" title="常见的五种单例模式实现方式"></a>常见的五种单例模式实现方式</h2><ul>
<li>饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li>懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
<li>双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）</li>
<li>静态内部类式(线程安全，调用效率高。 但是，可以延时加载) </li>
<li>枚举单例(线程安全，调用效率高，不能延时加载)</li>
</ul>
<h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><p>类初始化时立即加载这个对象</p>
<pre><code class="java">public class SingletonDemo1 &#123;
      //类初始化时，立即加载这个对象。
      //加载类时，天然是线程安全的
    private static SingletonDemo1 instance = new SingletonDemo1();
      //私有化构造器
    private SingletonDemo1()&#123;
    &#125;
      //方法没有同步，调用效率高
    public static SingletonDemo1 getInstance()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略<code>synchronized</code>关键字。<br>如果只是加载本类，而不是要调用<code>getInstance()</code>，甚至永远没有调用，则会造成资源浪费！</p>
<h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><p>单例对象延迟加载（懒加载），真正需要使用的时候才加载</p>
<pre><code class="java">package com.xm.singleton;

/**
 * 懒汉式延迟加载
 */
public class SingletonDemo2 &#123;
    private static SingletonDemo2 instance;
    private SingletonDemo2()&#123;&#125;
    
    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance()&#123;
        if(instance==null)&#123;
            instance = new SingletonDemo2();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>资源利用率高，但是，每次调用<code>getInstance()</code>方法都要<strong>同步</strong>，并发效率较低。</p>
<h3 id="双重检测锁实现"><a href="#双重检测锁实现" class="headerlink" title="双重检测锁实现"></a>双重检测锁实现</h3><p>这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了。</p>
<pre><code class="java">public class SingletonDemo3 &#123;
    private static SingletonDemo3 instance=null;
    private SingletonDemo3()&#123;&#125;
    public static SingletonDemo3 getInstance()&#123;
        if(instance==null)&#123;
            SingletonDemo3 singleton;
            synchronized (SingletonDemo3.class)&#123;
                singleton=instance;
                if(singleton == null)&#123;
                    synchronized (SingletonDemo3.class)&#123;
                        if(singleton == null)&#123;
                            singleton = new SingletonDemo3();
                        &#125;
                    &#125;
                    instance = singleton;
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>由于编译器优化原因和 JVM 底层内部模型原因， 偶尔会出问题。不建议使用。</p>
<p>Go 版本的实现：</p>
<pre><code class="go">package singleton

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var lock = &amp;sync.Mutex&#123;&#125;

type single struct&#123;&#125;

var singleInstance *single

func getInstance() *single &#123;
    if singleInstance == nil &#123;
        lock.Lock()
        defer lock.Unlock()
        if singleInstance == nil &#123;
            fmt.Println(&quot;Creating single instance now.&quot;)
            singleInstance = &amp;single&#123;&#125;
            return singleInstance
        &#125;
        fmt.Println(&quot;Single instance already created.&quot;)
        return singleInstance
    &#125;
    fmt.Println(&quot;Single instance already created.&quot;)
    return singleInstance
&#125;
</code></pre>
<p>线程安全版本（基于 sync.Once）的 Go 实现：</p>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var once sync.Once

type single2 struct &#123;
&#125;

var singleInstance2 *single2

func getInstance2() *single2 &#123;
    if singleInstance == nil &#123;
        once.Do(func() &#123;
            fmt.Println(&quot;Creating single instance now.&quot;)
            singleInstance2 = &amp;single2&#123;&#125;
        &#125;)
        return singleInstance2
    &#125;

    fmt.Println(&quot;Single instance already created.&quot;)
    return singleInstance2
&#125;
</code></pre>
<h3 id="静态内部类的实现"><a href="#静态内部类的实现" class="headerlink" title="静态内部类的实现"></a>静态内部类的实现</h3><p>静态内部类实现也是一种懒加载的方式</p>
<pre><code class="java">public class SingletonDemo4 &#123;
    
    //静态内部类
    private static class SingletonClassInstance&#123;
        private static final SingletonDemo4 instance = new SingletonDemo4();
    &#125;
    
    public static SingletonDemo4 getInstance()&#123;
        return SingletonClassInstance.instance;
    &#125;
    
    private SingletonDemo4()&#123;&#125;
&#125;
</code></pre>
<p>优点：</p>
<ul>
<li>外部类没有<code>static</code>属性，则不会像饿汉式那样立即加载对象。</li>
<li>只有真正调用<code>getInstance()</code>,才会加载静态内部类。<strong>加载类时是线程安全的</strong>。 <code>instance</code>是<code>static final</code>类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.</li>
<li>兼备了并发高效调用和延迟加载的优势</li>
</ul>
<h3 id="使用枚举的实现"><a href="#使用枚举的实现" class="headerlink" title="使用枚举的实现"></a>使用枚举的实现</h3><pre><code class="java">public enum SingletonDemoe5 &#123;
    //这个枚举元素，本身就是单例对象
    INSTANCE;

    //添加自己需要的操作
    public void singletonOperation()&#123;

    &#125;
&#125;
</code></pre>
<ul>
<li>实现简单 </li>
<li>枚举本身就是单例模式。由JVM从根本上提供保障，避免通过反射和反序列化的漏洞！ </li>
<li>缺点：无延迟加载</li>
</ul>
<h2 id="利用反射破解单例（针对枚举之外）"><a href="#利用反射破解单例（针对枚举之外）" class="headerlink" title="利用反射破解单例（针对枚举之外）"></a>利用反射破解单例（针对枚举之外）</h2><pre><code class="java">/**
 * 懒汉式反射反序列化破解
 */
public class Client &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;
        SingletonDemo2 s1 = SingletonDemo2.getInstance();
        SingletonDemo2 s2 = SingletonDemo2.getInstance();

        System.out.println(s1);
        System.out.println(s2);

        Class&lt;SingletonDemo2&gt; singletonDemo2Class = (Class&lt;SingletonDemo2&gt;) Class.forName(&quot;com.xm.singleton.SingletonDemo2&quot;);
        //获取无参构造方法
        Constructor&lt;SingletonDemo2&gt; constructor = singletonDemo2Class.getDeclaredConstructor(null);
        constructor.setAccessible(true);//忽略权限修饰符
        SingletonDemo2 s3 = constructor.newInstance();//通过newInstance创建对象
        SingletonDemo2 s4 = constructor.newInstance();//通过newInstance创建对象

        System.out.println(s3);
        System.out.println(s4);
    &#125;
&#125;
</code></pre>
<p><strong>解决方案</strong>：在调用构造方法时，如果实例已经存在则抛出异常</p>
<pre><code class="java">/**
 * 懒汉式延迟加载
 */
public class SingletonDemo2 &#123;
    private static SingletonDemo2 instance;
    private SingletonDemo2()&#123;
          //避免反射破解
        if(instance != null)&#123;
            throw new RuntimeException();
        &#125;
    &#125;

    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance()&#123;
        if(instance==null)&#123;
            instance = new SingletonDemo2();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h2 id="利用序列化破解单例（针对枚举之外）"><a href="#利用序列化破解单例（针对枚举之外）" class="headerlink" title="利用序列化破解单例（针对枚举之外）"></a>利用序列化破解单例（针对枚举之外）</h2><pre><code class="java">public class Client2 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        SingletonDemo2 s1 = SingletonDemo2.getInstance();
        System.out.println(s1);

        //通过反序列化的方式构造多个对象
        //序列化
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);
        oos.close();
        fos.close();

        //反序列化
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;));
        SingletonDemo2 s2 = (SingletonDemo2)ois.readObject();
        System.out.println(s2);
    &#125;
&#125;
</code></pre>
<p><strong>解决方案</strong>：在类中定义<code>readResolve()</code>方法，反序列化时，如果定义了该方法，则直接返回此方法指定的对象，不需要再单独创建新对象</p>
<pre><code class="java">public class SingletonDemo2 implements Serializable &#123;
    private static SingletonDemo2 instance;
    private SingletonDemo2()&#123;
        if(instance != null)&#123;
            throw new RuntimeException();
        &#125;
    &#125;

    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance()&#123;
        if(instance==null)&#123;
            instance = new SingletonDemo2();
        &#125;
        return instance;
    &#125;

    private Object readResolve()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h2 id="利用多线程测试"><a href="#利用多线程测试" class="headerlink" title="利用多线程测试"></a>利用多线程测试</h2><p>借助同步辅助类<code>CountDownLatch</code>,在完成一组正在其他线程中执行的操作之前，它允许一 个或多个线程一直等待。</p>
<ul>
<li><code>countDown()</code> 当前线程调此方法，则计数减一(建议放在 finally里执行)</li>
<li><code>await()</code>， 调用此方法会一直阻塞当前线程，直到计时器的值为0</li>
</ul>
<pre><code class="java">public class Client3 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        long start = System.currentTimeMillis();
        int threadNum = 10;
          //初始计数器为10
        CountDownLatch countDownLatch = new CountDownLatch(threadNum);

        for(int i=0;i&lt;threadNum;i++)&#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    for(int i=0;i&lt;10000000;i++)&#123;
//                        Object o = SingletonDemo4.getInstance();
                        Object o = SingletonDemo5.INSTANCE;
                    &#125;
                    countDownLatch.countDown();
                &#125;
            &#125;).start();
        &#125;
        countDownLatch.await();

        long end = System.currentTimeMillis();
        System.out.println(end-start);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果不使用CountDownLatch工具类，main进程在创建出子进程后，会继续往下执行，不会等待子进程执行结束，会造成<code>end</code>记录的时间不是正确的结束时间，而是main进程执行到这里的时间  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</li>
</ol>
<p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p>
<ol start="2">
<li>如果需要更加严格地控制全局变量， 可以使用单例模式。</li>
</ol>
<p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<p>请注意， 可以随时调整限制并设定生成单例实例的数量， 只需修改获取实例方法。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
<li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>违反了单一职责原则。 该模式同时解决了两个问题。</li>
<li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ol>
<h2 id="与其他设计模式的关系"><a href="#与其他设计模式的关系" class="headerlink" title="与其他设计模式的关系"></a>与其他设计模式的关系</h2><ul>
<li>外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。<ol>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
<li>抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。</li>
</ul>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式实现了创建者和调用者分离，本质上是实例化对象，用工厂方法代替 new 操作。 同时，将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</p>
<p>工厂模式可以分为三类：</p>
<ul>
<li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法， 通过接收的参数的不同来返回不同的对象实例。 其缺陷是对于增加新产品无能为力，不修改代码的话，是无法扩展的。</p>
<pre><code class="java">//汽车接口
public interface Car &#123;
    void run();
&#125;

//汽车接口的实现类
public class Audi implements Car &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;奥迪汽车&quot;);
    &#125;
&#125;
public class Byd implements Car &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;比亚迪汽车&quot;);
    &#125;
&#125;

//简单工厂
public class CarFactory &#123;
    public static Car createCar(String type)&#123;
        if(&quot;奥迪&quot;.equals(type))&#123;
            return new Audi();
        &#125;else if(&quot;比亚迪&quot;.equals(type))&#123;
            return new Byd();
        &#125;else&#123;
            return null;
        &#125;
    &#125;
&#125;
public class CarFactory2 &#123;
    public static Car createAudi()&#123;
        return new Audi();
    &#125;

    public static Car createByd()&#123;
        return new Byd();
    &#125;
&#125;

/**
 * 简单工厂调用
 */
public class Client &#123;
    public static void main(String[] args) &#123;
        Car car1 = CarFactory.createCar(&quot;奥迪&quot;);
        Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);

        car1.run();
        car2.run();
    &#125;
&#125;
</code></pre>
<p>go 代码实现：</p>
<pre><code class="go">package factory

import &quot;fmt&quot;

// IGun 枪支接口
type IGun interface &#123;
    setName(name string)
    setPower(power int)
    getName() string
    getPower() int
&#125;

// AK47 具体品牌的枪支 AK47
type AK47 struct &#123;
    name  string
    power int
&#125;

func newAK47() IGun &#123;
    return &amp;AK47&#123;&#125;
&#125;

func (a *AK47) setName(name string) &#123;
    a.name = name
&#125;

func (a *AK47) setPower(power int) &#123;
    a.power = power
&#125;

func (a *AK47) getName() string &#123;
    return a.name
&#125;

func (a *AK47) getPower() int &#123;
    return a.power
&#125;

// Musket 具体产品 Musket
type Musket struct &#123;
    name  string
    power int
&#125;

func newMusket() IGun &#123;
    return &amp;Musket&#123;&#125;
&#125;

func (m *Musket) setName(name string) &#123;
    m.name = name
&#125;

func (m *Musket) setPower(power int) &#123;
    m.power = power
&#125;

func (m *Musket) getName() string &#123;
    return m.name
&#125;

func (m *Musket) getPower() int &#123;
    return m.power
&#125;

// getGun 具体工厂
func getGun(gunType string) (IGun, error) &#123;
    if gunType == &quot;ak47&quot; &#123;
        return newAK47(), nil
    &#125;
    if gunType == &quot;musket&quot; &#123;
        return newMusket(), nil
    &#125;
    return nil, fmt.Errorf(&quot;unsupported gun type&quot;)
&#125;
</code></pre>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。</p>
<pre><code class="java">//统一工厂接口
public interface CarFactory &#123;
    Car createCar();
&#125;

//不同的汽车创建不同的工厂实现类
public class AudiFactory implements CarFactory &#123;
    @Override
    public Car createCar() &#123;
        return new Audi();
    &#125;
&#125;
public class BydFactory implements CarFactory &#123;
    @Override
    public Car createCar() &#123;
        return new Byd();
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        Car car1 = new AudiFactory().createCar();
        Car car2 = new BydFactory().createCar();

        car1.run();
        car2.run();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。  </p>
</blockquote>
<h2 id="简单工厂-x2F-工厂方法模式的应用场景"><a href="#简单工厂-x2F-工厂方法模式的应用场景" class="headerlink" title="简单工厂&#x2F;工厂方法模式的应用场景"></a>简单工厂&#x2F;工厂方法模式的应用场景</h2><ol>
<li><p><strong>当在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法</strong>。</p>
<p> 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>
<p> 例如， 如果需要向应用中添加一种新产品， 只需要开发新的创建者子类， 然后重写其工厂方法即可。</p>
</li>
<li><p><strong>如果希望用户能扩展软件库或框架的内部组件， 可使用工厂方法</strong>。</p>
<p> 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当使用子类替代标准组件时， 框架如何辨识出该子类？</p>
<p> 解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</p>
<p> 假设使用开源 UI 框架编写自己的应用，并希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 此时可以使用圆形按钮 RoundButton 子类来继承标准的按钮 Button 类。 但是， 还需要告诉 UI框架 UIFramework 类使用新的子类按钮代替默认按钮。</p>
<p> 为了实现这个功能， 可以根据基础框架类开发子类圆形按钮 UI UIWithRoundButtons ， 并且重写其 createButton 创建按钮方法。 基类中的该方法返回按钮对象， 而开发的子类返回圆形按钮对象。 现在， 就可以使用圆形按钮 UI 类代替 UI 框架类。</p>
</li>
</ol>
<h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以避免创建者和具体产品之间的紧密耦合。</li>
<li>单一职责原则。 可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li>开闭原则。 无需更改现有客户端代码， 就可以在程序中引入新的产品类型。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ul>
<h2 id="与其他设计模式的关系-1"><a href="#与其他设计模式的关系-1" class="headerlink" title="与其他设计模式的关系"></a>与其他设计模式的关系</h2><ul>
<li>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制），随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</li>
<li>可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>
<li>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</li>
<li>工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</li>
</ul>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p><strong>抽象工厂模式针对的是产品族，用来生产不同产品族的全部产品</strong>。（对于增加新的产品，无能为力； 支持增加产品族）。在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p>
<pre><code class="java">//产品群接口
public interface Engine &#123;
    void run();
    void start();
&#125;
public interface Seat &#123;
    void message();
&#125;
public interface Tyre &#123;
    void revolve();
&#125;


//产品群接口实现类
public class LuxuryEngine implements Engine &#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;高端发动机run&quot;);
    &#125;

    @Override
    public void start() &#123;
        System.out.println(&quot;高端发动机start&quot;);
    &#125;
&#125;
public class LowEngine implements Engine &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;低端发动机run&quot;);
    &#125;

    @Override
    public void start() &#123;
        System.out.println(&quot;低端发动机start&quot;);
    &#125;
&#125;

public class LuxurySeat implements Seat &#123;
    @Override
    public void message() &#123;
        System.out.println(&quot;高端椅子&quot;);
    &#125;
&#125;
public class LowSeat implements Seat &#123;
    @Override
    public void message() &#123;
        System.out.println(&quot;低端椅子&quot;);
    &#125;
&#125;

public class LuxuryTyre implements Tyre &#123;
    @Override
    public void revolve() &#123;
        System.out.println(&quot;高端轮胎&quot;);
    &#125;
&#125;
public class LowTyre implements Tyre &#123;
    @Override
    public void revolve() &#123;
        System.out.println(&quot;低端轮胎&quot;);
    &#125;
&#125;


//工厂接口
public class LowTyre implements Tyre &#123;
    @Override
    public void revolve() &#123;
        System.out.println(&quot;低端轮胎&quot;);
    &#125;
&#125;

//工厂接口的实现：针对不同产品组合
public class LuxuryCarFactory implements CarFactory &#123;
    @Override
    public Engine createEngine() &#123;
        return new LuxuryEngine();
    &#125;

    @Override
    public Seat createSeat() &#123;
        return new LuxurySeat();
    &#125;

    @Override
    public Tyre createTyre() &#123;
        return new LuxuryTyre();
    &#125;
&#125;

public class LowCarFactory implements CarFactory &#123;
    @Override
    public Engine createEngine() &#123;
        return new LowEngine();
    &#125;

    @Override
    public Seat createSeat() &#123;
        return new LowSeat();
    &#125;

    @Override
    public Tyre createTyre() &#123;
        return new LowTyre();
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        CarFactory factory = new LuxuryCarFactory();
        Engine engine = factory.createEngine();
        engine.run();
        engine.start();
    &#125;
&#125;
</code></pre>
<p>go 版本实现：</p>
<pre><code class="go">package factory

import &quot;fmt&quot;

// IShoe 抽象产品群-1 鞋子
type IShoe interface &#123;
    setLogo(logo string)
    setSize(size int)
    getLogo() string
    getSize() int
&#125;

// IShirt 抽象产品群-2 衬衫
type IShirt interface &#123;
    setLogo(logo string)
    setSize(size int)
    getLogo() string
    getSize() int
&#125;

type Shoe struct &#123;
    logo string
    size int
&#125;

func (s *Shoe) setLogo(logo string) &#123;
    s.logo = logo
&#125;

func (s *Shoe) getLogo() string &#123;
    return s.logo
&#125;

func (s *Shoe) setSize(size int) &#123;
    s.size = size
&#125;

func (s *Shoe) getSize() int &#123;
    return s.size
&#125;

type Shirt struct &#123;
    logo string
    size int
&#125;

func (s *Shirt) setLogo(logo string) &#123;
    s.logo = logo
&#125;

func (s *Shirt) getLogo() string &#123;
    return s.logo
&#125;

func (s *Shirt) setSize(size int) &#123;
    s.size = size
&#125;

func (s *Shirt) getSize() int &#123;
    return s.size
&#125;

// AdidasShoe 鞋子具体产品-1
type AdidasShoe struct&#123; Shoe &#125;

// NikeShoe 鞋子具体产品-2
type NikeShoe struct&#123; Shoe &#125;

// AdidasShirt 衬衫具体产品-1
type AdidasShirt struct&#123; Shirt &#125;

// NikeShirt 衬衫具体产品-2
type NikeShirt struct&#123; Shirt &#125;

// Adidas adidas 具体工厂
type Adidas struct &#123;
&#125;

func (a *Adidas) makeShoe() IShoe &#123;
    return &amp;AdidasShoe&#123;
        Shoe: Shoe&#123;
            logo: &quot;adidas&quot;,
            size: 14,
        &#125;,
    &#125;
&#125;

func (a *Adidas) makeShirt() IShirt &#123;
    return &amp;AdidasShirt&#123;
        Shirt: Shirt&#123;
            logo: &quot;adidas&quot;,
            size: 14,
        &#125;,
    &#125;
&#125;

// Nike nike 具体工厂
type Nike struct &#123;
&#125;

func (n *Nike) makeShoe() IShoe &#123;
    return &amp;NikeShoe&#123;
        Shoe: Shoe&#123;
            logo: &quot;nike&quot;,
            size: 14,
        &#125;,
    &#125;
&#125;

func (n *Nike) makeShirt() IShirt &#123;
    return &amp;NikeShirt&#123;
        Shirt: Shirt&#123;
            logo: &quot;nike&quot;,
            size: 14,
        &#125;,
    &#125;
&#125;

// ISportsFactory 抽象工厂
type ISportsFactory interface &#123;
    makeShoe() IShoe
    makeShirt() IShirt
&#125;

func GetSportsFactory(brand string) (ISportsFactory, error) &#123;
    if brand == &quot;adidas&quot; &#123;
        return &amp;Adidas&#123;&#125;, nil
    &#125;

    if brand == &quot;nike&quot; &#123;
        return &amp;Nike&#123;&#125;, nil
    &#125;

    return nil, fmt.Errorf(&quot;wrong brand type passed&quot;)
&#125;

// 具体使用
func main() &#123;
    factory, _ := GetSportsFactory(&quot;adidas&quot;)
    adidasShoe := factory.makeShoe()
    adidasShirt := factory.makeShirt()
    adidasShoe.getLogo()
    adidasShirt.getSize()
&#125;
</code></pre>
<h2 id="抽象工厂模式适用场景"><a href="#抽象工厂模式适用场景" class="headerlink" title="抽象工厂模式适用场景"></a>抽象工厂模式适用场景</h2><ol>
<li>如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 不希望代码基于产品的具体类进行构建， 在这种情况下， 可以使用抽象工厂。</li>
<li>抽象工厂提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么就不会生成与应用程序已生成的产品类型不一致的产品。</li>
</ol>
<ul>
<li>如果有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</li>
<li>在设计良好的程序中， 每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</li>
</ul>
<h2 id="抽象工厂的优缺点"><a href="#抽象工厂的优缺点" class="headerlink" title="抽象工厂的优缺点"></a>抽象工厂的优缺点</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>可以确保同一工厂生成的产品相互匹配。</p>
</li>
<li><p>可以避免客户端和具体产品代码的耦合。</p>
</li>
<li><p>单一职责原则。 可以将产品生成代码抽取到同一位置， 使得代码易于维护。</p>
</li>
<li><p>开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</p>
</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li>
</ul>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、原型模式或生成器模式](更灵活但更加复杂）。</li>
<li>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许在获取产品前执行一些额外构造步骤。</li>
<li>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 可以使用抽象工厂来代替外观模式。</li>
<li>可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
<li>抽象工厂、 生成器和原型都可以用单例模式来实现。</li>
</ul>
<h1 id="建造者（生成器）模式"><a href="#建造者（生成器）模式" class="headerlink" title="建造者（生成器）模式"></a>建造者（生成器）模式</h1><p>当某个类的创建需要很多的其他类组成时，可以使用建造者模式，它可以分步骤的创建复杂对象，该模式允许使用相同的创建代码生成不同类型和形式的对象。</p>
<p><strong>建造者模式的本质</strong>：</p>
<ul>
<li>分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象； 相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
</ul>
<pre><code class="java">/**
 * 建造飞船
 */
public class AirShip &#123;
    private Engine engine;//发动机
    private OrbitalModule orbitalModule;//轨道舱
    private ExcapeTower excapeTower;//逃逸塔

    //一下省略getter，setter和toString方法
&#125;

class Engine&#123;
    private String name;

    public Engine(String name) &#123;
        this.name = name;
    &#125;
&#125;
class OrbitalModule&#123;
    private String name;

    public OrbitalModule(String name) &#123;
        this.name = name;
    &#125;
&#125;
class ExcapeTower&#123;
    private String name;

    public ExcapeTower(String name) &#123;
        this.name = name;
    &#125;
&#125;


//构建组件
public interface AirShipBuilder &#123;
    Engine builderEngine();
    OrbitalModule builderOrbitalModule();
    ExcapeTower builderExcapeTower();
&#125;

//对组件进行组装
public interface AirShipDirector &#123;
    AirShip directAirShip();
&#125;


//创建具体需要的组件（实现类）
public class XMAirShipBuilder implements AirShipBuilder &#123;

    @Override
    public Engine builderEngine() &#123;
        System.out.println(&quot;构造小铭发动机&quot;);
        return new Engine(&quot;小铭发动机&quot;);
    &#125;

    @Override
    public OrbitalModule builderOrbitalModule() &#123;
        System.out.println(&quot;构造小铭轨道舱&quot;);
        return new OrbitalModule(&quot;小铭轨道舱&quot;);
    &#125;

    @Override
    public ExcapeTower builderExcapeTower() &#123;
        System.out.println(&quot;构造小铭逃逸塔&quot;);
        return new ExcapeTower(&quot;小铭逃逸塔&quot;);
    &#125;
&#125;


//对组件进行组装
public class XMAirShipDirector implements AirShipDirector &#123;

    private XMAirShipBuilder builder;

    public XMAirShipDirector(XMAirShipBuilder builder) &#123;
        this.builder = builder;
    &#125;

    @Override
    public AirShip directAirShip() &#123;
        //通过使用builder来获取子组件
        Engine engine = builder.builderEngine();
        OrbitalModule orbitalModule = builder.builderOrbitalModule();
        ExcapeTower excapeTower = builder.builderExcapeTower();

        //对组件进行组装
        AirShip airShip = new AirShip();
        airShip.setEngine(engine);
        airShip.setOrbitalModule(orbitalModule);
        airShip.setExcapeTower(excapeTower);

        return airShip;
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        XMAirShipDirector director = new XMAirShipDirector(new XMAirShipBuilder());
        AirShip airShip = director.directAirShip();
        System.out.println(airShip);
    &#125;
&#125;
</code></pre>
<h2 id="go-版本实现"><a href="#go-版本实现" class="headerlink" title="go 版本实现"></a>go 版本实现</h2><pre><code class="go">// Package builder 生成器模式，也叫建造者模式
package builder

import &quot;fmt&quot;

// House 具体的产品
type House struct &#123;
    windowType string
    doorType   string
    floor      int
&#125;

// IBuilder 生成器接口
type IBuilder interface &#123;
    setWindowType()
    setDoorType()
    setNumFloor()
    getHouse() House
&#125;

func getBuilder(builderType string) IBuilder &#123;
    if builderType == &quot;normal&quot; &#123;
        return newNormalBuilder()
    &#125;

    if builderType == &quot;igloo&quot; &#123;
        return newIglooBuilder()
    &#125;
    return nil
&#125;

// NormalBuilder 生成器-1
type NormalBuilder struct &#123;
    windowType string
    doorType   string
    floor      int
&#125;

func newNormalBuilder() *NormalBuilder &#123;
    return &amp;NormalBuilder&#123;&#125;
&#125;

func (b *NormalBuilder) setWindowType() &#123;
    b.windowType = &quot;Wooden Window&quot;
&#125;

func (b *NormalBuilder) setDoorType() &#123;
    b.doorType = &quot;Wooden Door&quot;
&#125;

func (b *NormalBuilder) setNumFloor() &#123;
    b.floor = 2
&#125;

func (b *NormalBuilder) getHouse() House &#123;
    return House&#123;
        doorType:   b.doorType,
        windowType: b.windowType,
        floor:      b.floor,
    &#125;
&#125;

// IglooBuilder 生成器-2
type IglooBuilder struct &#123;
    windowType string
    doorType   string
    floor      int
&#125;

func newIglooBuilder() *IglooBuilder &#123;
    return &amp;IglooBuilder&#123;&#125;
&#125;

func (b *IglooBuilder) setWindowType() &#123;
    b.windowType = &quot;Snow Window&quot;
&#125;

func (b *IglooBuilder) setDoorType() &#123;
    b.doorType = &quot;Snow Door&quot;
&#125;

func (b *IglooBuilder) setNumFloor() &#123;
    b.floor = 1
&#125;

func (b *IglooBuilder) getHouse() House &#123;
    return House&#123;
        doorType:   b.doorType,
        windowType: b.windowType,
        floor:      b.floor,
    &#125;
&#125;

// Director 主管类
type Director struct &#123;
    builder IBuilder
&#125;

func newDirector(b IBuilder) *Director &#123;
    return &amp;Director&#123;
        builder: b,
    &#125;
&#125;

func (d *Director) setBuilder(b IBuilder) &#123;
    d.builder = b
&#125;

func (d *Director) buildHouse() House &#123;
    d.builder.setDoorType()
    d.builder.setWindowType()
    d.builder.setNumFloor()
    return d.builder.getHouse()
&#125;

func main() &#123;
    normalBuilder := getBuilder(&quot;normal&quot;)
    iglooBuilder := getBuilder(&quot;igloo&quot;)

    director := newDirector(normalBuilder)
    normalHouse := director.buildHouse()

    director.setBuilder(iglooBuilder)
    iglooHouse := director.buildHouse()

    fmt.Printf(&quot;normal house: %+v, igloo house: %+v\n&quot;, normalHouse, iglooHouse)
&#125;
</code></pre>
<h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>使用生成器模式可避免 “重叠构造函数 （tele­scop­ing con­struc­tor）” 的出现。</p>
<p> 假设构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。</p>
<pre><code class="java">class Pizza &#123;
Pizza(int size) &#123; ... &#125;
Pizza(int size, boolean cheese) &#123; ... &#125;
Pizza(int size, boolean cheese, boolean pepperoni) &#123; ... &#125;
// ...
</code></pre>
<p> 只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。</p>
<p> 生成器模式可以分步骤生成对象， 而且允许仅使用必须的步骤。 应用该模式后， 再也不需要将几十个参数塞进构造函数里了。</p>
</li>
<li><p>当希望使用代码创建不同形式的产品 （例如石头房屋或木头房屋） 时， 可使用生成器模式。</p>
<p> 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</p>
<p> 基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p>
</li>
<li><p>使用生成器构造组合树或其他复杂对象。</p>
<p> 生成器模式能分步骤构造产品。 可以延迟执行某些步骤而不会影响最终产品。 甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</p>
<p> 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</p>
</li>
</ol>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时， 可以复用相同的制造代码。</li>
<li>单一职责原则。 可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</p>
<h2 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</li>
<li>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许在获取产品前执行一些额外构造步骤。</li>
<li>可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</li>
<li>可以结合使用生成器和桥接模式： <em>主管</em>类负责抽象工作， 各种不同的<em>生成器</em>负责<em>实现</em>工作。</li>
<li>抽象工厂、 生成器和原型都可以用单例模式来实现。</li>
</ul>
<h1 id="原型模式（prototype）"><a href="#原型模式（prototype）" class="headerlink" title="原型模式（prototype）"></a>原型模式（prototype）</h1><p>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</p>
<p>实际上原型模式就是 java 中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 。其优势为：效率高(直接克隆，避免了重新执行构造过程步骤) 。</p>
<p>克隆类似于new，但是不同于 new。new 创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后， 再修改克隆对象的值。</p>
<blockquote>
<p>克隆产生的是一个新对象  </p>
</blockquote>
<p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个克隆方法。</p>
<p>所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。 当对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么只需克隆原型即可， 无需新建一个对象。</p>
<h2 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h2><p>当对象的属性中有引用变量时，实际上克隆后的对象跟原对象所指向的是同一个地址，如果此时修改引用变量的值，会使两个对象的引用变量都发生改变，这就是浅克隆；可以将引用变量也做一份克隆，这就是深克隆（也叫深复制）。</p>
<pre><code class="java">public class Sheep implements Cloneable&#123;
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Object obj = super.clone();
        //深克隆添加如下代码：
        Sheep sheep = (Sheep)obj;
        sheep.birthday = (Date) this.birthday.clone();//把属性也进行克隆
        return sheep;
    &#125;

    public Sheep(String name, Date birthday) &#123;
        this.name = name;
        this.birthday = birthday;
    &#125;
      
      //省略getter，setter和toString方法
&#125;


//客户端操作
public class Client &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;
        Date date = new Date(System.currentTimeMillis());
        Sheep sheep1 = new Sheep(&quot;多莉&quot;,date);
        Sheep sheep2 = (Sheep) sheep1.clone();

        date.setTime(23490738574947548L);//改变时间值，如果是浅克隆，两个都会改变

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep1 == sheep2);
    &#125;
&#125;
</code></pre>
<h2 id="利用序列化和反序列化技术实现深克隆"><a href="#利用序列化和反序列化技术实现深克隆" class="headerlink" title="利用序列化和反序列化技术实现深克隆"></a>利用序列化和反序列化技术实现深克隆</h2><p>不使用java的clone技术，而使用序列化和反序列化</p>
<pre><code class="java">package com.xm.prototype;

import java.io.*;
import java.util.Date;

public class Client2 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        Date date = new Date(System.currentTimeMillis());
        Sheep sheep1 = new Sheep(&quot;多莉&quot;,date);

        //序列化sheep1
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(sheep1);//把sheep1写入baos
        byte[] bytes = baos.toByteArray();

        //反序列化创建出克隆对象
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bais);
        Sheep sheep2 = (Sheep) ois.readObject();

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep1==sheep2);

        date.setTime(485974938756438L);
        System.out.println(&quot;————————————更改时间——————————&quot;);
        System.out.println(sheep1);
        System.out.println(sheep2);
    &#125;
&#125;
</code></pre>
<h2 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h2><pre><code class="java">public class Client3 &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;
        testNew(1000);
        testClone(1000);
    &#125;

    public static void testNew(int size)&#123;
        long start = System.currentTimeMillis();
        for(int i=0;i&lt;size;i++)&#123;
            new Laptop();
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;new方式耗时：&quot;+ (end-start));
    &#125;

    public static void testClone(int size) throws CloneNotSupportedException &#123;
        long start = System.currentTimeMillis();
        Laptop l = new Laptop();
        for(int i=0;i&lt;size;i++)&#123;
            Laptop laptop = (Laptop) l.clone();
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;clone方式耗时：&quot;+(end-start));
    &#125;
&#125;

class Laptop implements Cloneable&#123;
    public Laptop()&#123;
        try &#123;
            Thread.sleep(10);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现"><a href="#Go-版本实现" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">package prototype

import &quot;fmt&quot;

// Inode 原型接口
type Inode interface &#123;
    print(string)
    clone() Inode
&#125;

// File 具体原型1：文件
type File struct &#123;
    name string
&#125;

func (f *File) print(s string) &#123;
    fmt.Println(s + f.name)
&#125;

func (f *File) clone() Inode &#123;
    return &amp;File&#123;name: f.name + &quot;_clone&quot;&#125;
&#125;

// Folder 具体原型2：文件夹
type Folder struct &#123;
    children []Inode
    name     string
&#125;

func (f *Folder) print(s string) &#123;
    fmt.Println(s + f.name)
    for i := range f.children &#123;
        f.children[i].print(s)
    &#125;
&#125;

func (f *Folder) clone() Inode &#123;
    cloneFolder := &amp;Folder&#123;name: f.name + &quot;_clone&quot;&#125;
    var tempChildren []Inode
    for i := range f.children &#123;
        cloneChildren := f.children[i].clone()
        tempChildren = append(tempChildren, cloneChildren)
    &#125;
    cloneFolder.children = tempChildren
    return cloneFolder
&#125;

func main() &#123;
    file1 := &amp;File&#123;name: &quot;File1&quot;&#125;
    file2 := &amp;File&#123;name: &quot;File2&quot;&#125;
    file3 := &amp;File&#123;name: &quot;File3&quot;&#125;

    folder1 := &amp;Folder&#123;
        children: []Inode&#123;file1&#125;,
        name:     &quot;Folder1&quot;,
    &#125;

    folder2 := &amp;Folder&#123;
        children: []Inode&#123;folder1, file2, file3&#125;,
        name:     &quot;Folder2&quot;,
    &#125;
    fmt.Println(&quot;\nPrinting hierarchy for Folder2&quot;)
    folder2.print(&quot;  &quot;)

    cloneFolder := folder2.clone()
    fmt.Println(&quot;\nPrinting hierarchy for clone Folder&quot;)
    cloneFolder.print(&quot;  &quot;)
&#125;
</code></pre>
<h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>如果需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</p>
<p> 这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。</p>
<p> 原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。</p>
</li>
<li><p>如果子类的区别仅在于其对象的初始化方式， 那么可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</p>
<p> 在原型模式中， 可以使用一系列预生成的、 各种类型的对象作为原型。</p>
<p> 客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</p>
</li>
</ol>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>可以克隆对象， 而无需与它们所属的具体类相耦合。</p>
</li>
<li><p>可以克隆预生成原型， 避免反复运行初始化代码。</p>
</li>
<li><p>可以更方便地生成复杂对象。</p>
</li>
<li><p>可以用继承以外的方式来处理复杂对象的不同配置。</p>
</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦</li>
</ul>
<h2 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</li>
<li>原型可用于保存命令模式的历史记录。</li>
<li>大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li>原型并不基于继承， 因此没有继承的缺点。 另一方面， <em>原型</em>需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</li>
<li>有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li>
<li>抽象工厂、 生成器和原型都可以用单例模式来实现。</li>
</ul>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<h2 id="适配器模式中的角色"><a href="#适配器模式中的角色" class="headerlink" title="适配器模式中的角色"></a>适配器模式中的角色</h2><ul>
<li>目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</li>
<li>需要适配的类（Adaptee）：需要适配的类或适配者类，客户端需要调用该类，但是没有接口可以调用，需要被适配。</li>
<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>适配器模式的实现有<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器的局限是只能使用适配一个类，对象适配器可以适配多个</p>
<pre><code class="java">/**
 * 需要被适配的类
 */
public class Adaptee &#123;
    public void request()&#123;
        System.out.println(&quot;可以完成客户请求所需要的功能&quot;);
    &#125;
&#125;

/**
 * 客户端所期待的接口
 */
public interface Target &#123;
    void handleReq();
&#125;

/**
 * 适配器：类适配器
 */
public class Adapter extends Adaptee implements Target &#123;

    @Override
    public void handleReq() &#123;
        super.request();
    &#125;
&#125;

/**
 * 适配器：对象适配器
 */
public class Adapter2 implements Target &#123;
   
    private  Adaptee adaptee;

    public Adapter2(Adaptee adaptee) &#123;
        this.adaptee = adaptee;
    &#125;

    @Override
    public void handleReq() &#123;
        adaptee.request();
    &#125;
&#125;

/**
 * 客户端类
 */
public class Client &#123;
    public void test(Target target)&#123;
        target.handleReq();
    &#125;

    public static void main(String[] args) &#123;
        Client client = new Client();
        Adaptee adaptee = new Adaptee();
        Target target1 = new Adapter();
        Target target2 = new Adapter2(adaptee);
        client.test(target1);
        client.test(target2);
    &#125;
&#125;
</code></pre>
<h2 id="go-版本实现-1"><a href="#go-版本实现-1" class="headerlink" title="go 版本实现"></a>go 版本实现</h2><pre><code class="go">package adapter

import &quot;fmt&quot;

// Window 提供 usb 插口
type Window struct&#123;&#125;

func (w *Window) InsertUSBPort() &#123;
    fmt.Println(&quot;use usb port&quot;)
&#125;

// Lightning 接口
type Lightning interface &#123;
    InsertLightingPort()
&#125;

// Mac 电脑，提供了 lightning 接口
type Mac struct&#123;&#125;

func (m *Mac) InsertLightingPort() &#123;
    fmt.Println(&quot;use lightning port&quot;)
&#125;

// Client 客户端使用 Lightning 接口
type Client struct&#123;&#125;

func (c *Client) UserLightningPort(lightning Lightning) &#123;
    lightning.InsertLightingPort()
&#125;

// USB2LightningAdapter use 转 lightning 适配器
type USB2LightningAdapter struct &#123;
    windowMachine *Window
&#125;

func (a *USB2LightningAdapter) InsertLightingPort() &#123;
    a.windowMachine.InsertUSBPort()
&#125;

func main() &#123;
    client := &amp;Client&#123;&#125;
    mac := &amp;Mac&#123;&#125;
    client.UserLightningPort(mac) // mac 提供了 lightning 接口

    // window 没有 lightning 接口，使用适配器
    win := &amp;Window&#123;&#125;
    adapter := &amp;USB2LightningAdapter&#123;windowMachine: win&#125;
    client.UserLightningPort(adapter)
&#125;
</code></pre>
<h2 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>当希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p>
<p> 适配器模式允许创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p>
</li>
<li><p>如果需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</p>
<p> 可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。</p>
<p> 将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</p>
</li>
</ol>
<h2 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul>
<li>单一职责原则，可以将接口或数据转换代码从程序主要业务逻辑中分离。</li>
<li>开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ul>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代码整体复杂度增加， 因为需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ul>
<h2 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>桥接模式通常会于开发前期进行设计， 能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li>
<li>适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</li>
<li>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</li>
<li>外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</li>
<li>桥接、 状态模式和策略模式（在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>通过代理，控制对对象的访问，可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现）。</p>
<p>代理模式可以分为静态代理和动态代理。</p>
<p>AOP(Aspect Oriented Programming面向切面编程)的核心实现机制。</p>
<h2 id="代理模式中的核心角色"><a href="#代理模式中的核心角色" class="headerlink" title="代理模式中的核心角色"></a>代理模式中的核心角色</h2><ul>
<li>抽象角色：定义代理角色和真实角色的公共对外方法</li>
<li>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。（关注真正的业务逻辑）</li>
<li>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。（将统一的流程控制放到代理角色中处理！）</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="静态代理：代理类需要自己创建"><a href="#静态代理：代理类需要自己创建" class="headerlink" title="静态代理：代理类需要自己创建"></a>静态代理：代理类需要自己创建</h3><pre><code class="java">//抽象角色
public interface Star &#123;
    void confer();//面谈
    void signContract();//签合同
    void bookTicket();//订票
    void sing();//唱歌
    void collectMoney();//收钱
&#125;

//真实角色
public class RealStar implements Star &#123;
    @Override
    public void confer() &#123;
        System.out.println(&quot;realstar.confer()&quot;);
    &#125;

    @Override
    public void signContract() &#123;
        System.out.println(&quot;realstar.signContract()&quot;);
    &#125;

    @Override
    public void bookTicket() &#123;
        System.out.println(&quot;realstar.bookTicker()&quot;);
    &#125;

    @Override
    public void sing() &#123;
        System.out.println(&quot;realstar.sing()&quot;);
    &#125;

    @Override
    public void collectMoney() &#123;
        System.out.println(&quot;realstar.collectMoney()&quot;);
    &#125;
&#125;

//代理角色
public class ProxyStar implements Star &#123;

    private Star star;//代理的对象

    public ProxyStar(Star star) &#123;
        this.star = star;
    &#125;

    @Override
    public void confer() &#123;
        System.out.println(&quot;ProxyStar.confer&quot;);
    &#125;

    @Override
    public void signContract() &#123;
        System.out.println(&quot;ProxyStar.signContract&quot;);
    &#125;

    @Override
    public void bookTicket() &#123;
        System.out.println(&quot;ProxyStar.bookTicket&quot;);
    &#125;

    @Override
    public void sing() &#123;
        //这里需要真实角色的功能
        star.sing();
    &#125;

    @Override
    public void collectMoney() &#123;
        System.out.println(&quot;ProxyStar.collectMoney&quot;);
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        Star realStar = new RealStar();
        Star proxyStar = new ProxyStar(realStar);

        proxyStar.confer();
        proxyStar.signContract();
        proxyStar.bookTicket();
        proxyStar.sing();//此时调用真实角色
        proxyStar.collectMoney();
    &#125;
&#125;
</code></pre>
<h3 id="动态代理：代理类动态生成"><a href="#动态代理：代理类动态生成" class="headerlink" title="动态代理：代理类动态生成"></a>动态代理：代理类动态生成</h3><p>实现的方式有以下几种：</p>
<ul>
<li>JDK自带的动态代理</li>
<li>javaassist字节码操作库实现</li>
<li>CGLIB </li>
<li>ASM(底层使用指令，可维护性较差)</li>
</ul>
<p><strong>JDK实现动态代理</strong></p>
<pre><code class="java">//抽象角色
public interface Star &#123;
    void confer();//面谈
    void signContract();//签合同
    void bookTicket();//订票
    void sing();//唱歌
    void collectMoney();//收钱
&#125;

//真实角色
public class RealStar implements Star &#123;
    @Override
    public void confer() &#123;
        System.out.println(&quot;realstar.confer()&quot;);
    &#125;

    @Override
    public void signContract() &#123;
        System.out.println(&quot;realstar.signContract()&quot;);
    &#125;

    @Override
    public void bookTicket() &#123;
        System.out.println(&quot;realstar.bookTicker()&quot;);
    &#125;

    @Override
    public void sing() &#123;
        System.out.println(&quot;realstar.sing()&quot;);
    &#125;

    @Override
    public void collectMoney() &#123;
        System.out.println(&quot;realstar.collectMoney()&quot;);
    &#125;
&#125;

//动态代理处理器
public class StarHandler implements InvocationHandler &#123;

    Star realStar;

    public StarHandler(Star realStar) &#123;
        this.realStar = realStar;
    &#125;

    @Override
    /**
     *
     * @param proxy 代理类对象
     * @param method 被代理对象的方法
     * @param args 方法的参数
     * @return
     * @throws Throwable
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        Object object = null;
        System.out.println(&quot;真正的方法执行前。。。&quot;);
        System.out.println(&quot;面谈，签合同，预付款，订票&quot;);
        if(method.getName().equals(&quot;sing&quot;))&#123;
            object = method.invoke(realStar, args);//激活调用方法
        &#125;
        System.out.println(&quot;真正的方法执行后&quot;);
        System.out.println(&quot;收尾款&quot;);
        return object;
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);

        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Star.class&#125;,handler);

        //会调用invoke方法
        proxy.bookTicket();
        proxy.sing();

    &#125;
&#125;
</code></pre>
<blockquote>
<p>通过Proxy生成的代理类内部会有一个<code>handler</code>属性，调用方法时，实际上都会传到使用<code>handler</code>中的<code>invoke</code>方法，将当前类，当前方法和变量传入到<code>invoke</code>中  </p>
</blockquote>
<h2 id="Go-版本实现-1"><a href="#Go-版本实现-1" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package proxy 代理模式
// 例子：Nginx 服务器充当应用程序服务器的代理
package proxy

import &quot;fmt&quot;

// server 服务主题接口
type server interface &#123;
    handleRequest(string, string) (int, string)
&#125;

// Application 真实应用程序
type Application struct&#123;&#125;

func (a *Application) handleRequest(url, method string) (int, string) &#123;
    if url == &quot;/app/status&quot; &amp;&amp; method == &quot;GET&quot; &#123;
        return 200, &quot;Ok&quot;
    &#125;

    if url == &quot;/create/user&quot; &amp;&amp; method == &quot;POST&quot; &#123;
        return 201, &quot;User Created&quot;
    &#125;
    return 404, &quot;Not Ok&quot;
&#125;

// Nginx 应用程序代理
type Nginx struct &#123;
    application       *Application
    maxAllowedRequest int
    rateLimiter       map[string]int
&#125;

func newNginxServer() *Nginx &#123;
    return &amp;Nginx&#123;
        application:       &amp;Application&#123;&#125;,
        maxAllowedRequest: 2,
        rateLimiter:       map[string]int&#123;&#125;,
    &#125;
&#125;

func (n *Nginx) handleRequest(url, method string) (int, string) &#123;
    allowed := n.checkRateLimiting(url)
    if !allowed &#123;
        return 403, &quot;Not Allowed&quot;
    &#125;
    return n.application.handleRequest(url, method)
&#125;

func (n *Nginx) checkRateLimiting(url string) bool &#123;
    if n.rateLimiter[url] == 0 &#123;
        n.rateLimiter[url] = 1
    &#125;
    if n.rateLimiter[url] &gt; n.maxAllowedRequest &#123;
        return false
    &#125;
    n.rateLimiter[url] = n.rateLimiter[url] + 1
    return true
&#125;

func main() &#123;
    nginxServer := newNginxServer()
    appStatusURL := &quot;/app/status&quot;
    createuserURL := &quot;/create/user&quot;

    httpCode, body := nginxServer.handleRequest(appStatusURL, &quot;GET&quot;)
    fmt.Printf(&quot;\nUrl: %s\nHttpCode: %d\nBody: %s\n&quot;, appStatusURL, httpCode, body)

    httpCode, body = nginxServer.handleRequest(appStatusURL, &quot;GET&quot;)
    fmt.Printf(&quot;\nUrl: %s\nHttpCode: %d\nBody: %s\n&quot;, appStatusURL, httpCode, body)

    httpCode, body = nginxServer.handleRequest(appStatusURL, &quot;GET&quot;)
    fmt.Printf(&quot;\nUrl: %s\nHttpCode: %d\nBody: %s\n&quot;, appStatusURL, httpCode, body)

    httpCode, body = nginxServer.handleRequest(createuserURL, &quot;POST&quot;)
    fmt.Printf(&quot;\nUrl: %s\nHttpCode: %d\nBody: %s\n&quot;, appStatusURL, httpCode, body)

    httpCode, body = nginxServer.handleRequest(createuserURL, &quot;GET&quot;)
    fmt.Printf(&quot;\nUrl: %s\nHttpCode: %d\nBody: %s\n&quot;, appStatusURL, httpCode, body)
&#125;
</code></pre>
<h2 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>延迟初始化 （虚拟代理）。 如果有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p> 无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li><p>访问控制 （保护代理）。 如果只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</p>
<p> 代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p>
</li>
<li><p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</p>
<p> 在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p>
</li>
<li><p>记录日志请求 （日志记录代理）。 适用于当需要保存对于服务对象的请求历史记录时。</p>
<p> 代理可以在向服务传递请求前进行记录。</p>
</li>
<li><p>缓存请求结果 （缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p>
<p> 代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p>
</li>
<li><p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p>
<p> 代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p>
<p> 代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</p>
</li>
</ol>
<h2 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以在客户端毫无察觉的情况下控制服务对象。</li>
<li>如果客户端对服务对象的生命周期没有特殊要求， 可以对生命周期进行管理。</li>
<li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li>
<li>开闭原则。 可以在不对服务或客户端做出修改的情况下创建新代理。</li>
</ul>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代码可能会变得复杂， 因为需要新建许多类。</li>
<li>服务响应可能会延迟。</li>
</ul>
<h2 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。</li>
<li>外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</li>
<li>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</li>
</ul>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>用于处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</p>
<p>桥接模式可以取代多层继承的方案。</p>
<p>多层继承违背了单一职责原则， 复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个 数，从而降低管理和维护的成本。极大的提高了系统可扩展性，在两个变化维度中任意扩展一 个维度，都不需要修改原有的系统，符合开闭原则。</p>
<p>桥接模式将实现的功能分为抽象部分和实现部分。</p>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 <strong>该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层 （也被称为平台）</strong>。</p>
<p>例如，在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p>一般来说， 可以在两个独立方向上扩展这种应用：</p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li>
<li>支持多个不同的 API （例如， 能够在 Windows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>其实现核心是在主类中将其中一个或多个维度作为自身属性。</p>
<p>例如电脑可以分为笔记本，台式，平板，又可以有多个牌子，如果采用多层继承，如果增加一个牌子，需要分别增加对应不同笔记本类型的类</p>
<pre><code class="java">//牌子接口
public interface Brand &#123;
    void sale();
&#125;
//不同的牌子
public class Mac implements Brand &#123;
    @Override
    public void sale() &#123;
        System.out.println(&quot;苹果电脑&quot;);
    &#125;
&#125;
public class Dell implements Brand &#123;
    @Override
    public void sale() &#123;
        System.out.println(&quot;戴尔电脑&quot;);
    &#125;
&#125;

//电脑类型父类
public class Computer &#123;
     protected Brand brand;//引入品牌变量作为桥梁

    public Computer(Brand brand) &#123;
        this.brand = brand;
    &#125;

    public void sale()&#123;
         brand.sale();
     &#125;
&#125;
//不同的电脑类型
public class Desktop extends Computer &#123;

    public Desktop(Brand brand) &#123;
        super(brand);
    &#125;

    @Override
    public void sale() &#123;
        super.sale();
        System.out.println(&quot;台式机&quot;);
    &#125;
&#125;
public class Laptop extends Computer &#123;

    public Laptop(Brand brand) &#123;
        super(brand);
    &#125;

    @Override
    public void sale() &#123;
        super.sale();
        System.out.println(&quot;笔记本&quot;);
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Laptop(new Mac());
        computer.sale();
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-2"><a href="#Go-版本实现-2" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package bridge 桥接模式
// 使用任意计算机连接任意的打印机来完成打印操作
// 抽象层：计算机
// 实施层：打印机
package bridge

import &quot;fmt&quot;

// Printer 打印机实施类
type Printer interface &#123;
    PrintFile()
&#125;

// Computer 电脑抽象类
type Computer interface &#123;
    Print()
    SetPrinter(Printer)
&#125;

// Mac 具体抽象层 1
type Mac struct &#123;
    printer Printer // 抽象层引用实施层
&#125;

func (m *Mac) Print() &#123;
    fmt.Println(&quot;print by mac&quot;)
    m.printer.PrintFile()
&#125;

func (m *Mac) SetPrinter(printer Printer) &#123;
    m.printer = printer
&#125;

// Window 具体抽象层 2
type Window struct &#123;
    printer Printer
&#125;

func (w *Window) Print() &#123;
    fmt.Println(&quot;print by window&quot;)
    w.printer.PrintFile()
&#125;

func (w *Window) SetPrinter(printer Printer) &#123;
    w.printer = printer
&#125;

// Epson 具体实施层 1
type Epson struct&#123;&#125;

func (e *Epson) PrintFile() &#123;
    fmt.Println(&quot;print by Epson Printer&quot;)
&#125;

// Hp 具体实施层 2
type Hp struct&#123;&#125;

func (h *Hp) PrintFile() &#123;
    fmt.Println(&quot;print by Hp Printer&quot;)
&#125;

func main() &#123;
    hpPrinter := &amp;Hp&#123;&#125;
    epsonPrinter := &amp;Epson&#123;&#125;

    macComputer := &amp;Mac&#123;&#125;
    macComputer.SetPrinter(hpPrinter)
    macComputer.Print()
    macComputer.SetPrinter(epsonPrinter)
    macComputer.Print()

    windowComputer := &amp;Window&#123;&#125;
    windowComputer.SetPrinter(hpPrinter)
    windowComputer.Print()
    windowComputer.SetPrinter(epsonPrinter)
    windowComputer.Print()
&#125;
</code></pre>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>如果想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<p> 类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</p>
<p> 桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
</li>
<li><p>如果希望在几个独立维度上扩展一个类， 可使用该模式。</p>
<p> 桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
</li>
<li><p>如果需要在运行时切换不同实现方法， 可使用桥接模式。</p>
<p> 当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p>
<p> 顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p>
</li>
</ol>
<h2 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li>开闭原则。 可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ul>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h2 id="与其他模式的关系-5"><a href="#与其他模式的关系-5" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>桥接模式通常会于开发前期进行设计， 使能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li>
<li>桥接、 状态模式和策略模式（在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
<li>可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</li>
</ul>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式为处理<strong>树形结构</strong>提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员， 并调用执行。其中，使用了<strong>递归调用</strong>的机制对整个结构进行处理。适用于把部分和整体的关系能够用<strong>树形结构</strong>表示的情况，从而使客户端可以使用统一的方式处理部分对象和整体对象。 </p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>抽象构件(Component)角色: 定义了叶子和容器构件的共同点</li>
<li>叶子(Leaf)构件角色：无子节点</li>
<li>容器(Composite)构件角色： 有容器特征，可以包含子节点</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>模拟病毒文件和文件夹查杀：</p>
<pre><code class="java">/**
 * 抽象构建
 */
public interface AbstractFile &#123;
    void killVirus();
&#125;

/**
 * 相当于叶子构建角色
 */
public class ImageFile implements AbstractFile &#123;

    private String name;

    public ImageFile(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void killVirus() &#123;
        System.out.println(&quot;图像文件 &quot;+name+&quot;:开始查杀！&quot;);
    &#125;
&#125;
public class TextFile implements AbstractFile &#123;

    private String name;

    public TextFile(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void killVirus() &#123;
        System.out.println(&quot;文本文件 &quot;+name+&quot;:开始查杀！&quot;);
    &#125;
&#125;

/**
 * 相当于容器构建角色
 */
public class FolderFile implements AbstractFile &#123;

    private String name;
    List&lt;AbstractFile&gt; fileList = new ArrayList&lt;&gt;();//文件夹下的文件

    public FolderFile(String name) &#123;
        this.name = name;
    &#125;

    public void add(AbstractFile file)&#123;
        fileList.add(file);
    &#125;

    public void remove(AbstractFile file)&#123;
        fileList.remove(file);
    &#125;

    public AbstractFile getFile(int index)&#123;
        AbstractFile file = fileList.get(index);
        return file;
    &#125;

    @Override
    public void killVirus() &#123;
        System.out.println(&quot;文件夹 &quot;+name+&quot;:开始查杀！&quot;);
        for (AbstractFile file : fileList) &#123;
            file.killVirus();//天然递归
        &#125;
    &#125;
&#125;

//客户端调用
public class Client &#123;
    public static void main(String[] args) &#123;
        AbstractFile f1,f2;
        f1 = new ImageFile(&quot;照片.jpg&quot;);
        f2 = new TextFile(&quot;文本.txt&quot;);
        FolderFile f3 = new FolderFile(&quot;文件夹&quot;);
        FolderFile f4 = new FolderFile(&quot;文件夹2&quot;);

        f3.add(f1);
        f3.add(f2);

        f4.add(f1);
        f4.add(f2);
        f4.add(f3);

        f1.killVirus();
        f4.killVirus();
    &#125;
&#125;
</code></pre>
<h2 id="Go版本实现"><a href="#Go版本实现" class="headerlink" title="Go版本实现"></a>Go版本实现</h2><pre><code class="go">// Package composite 组合模式
// 模拟文件和文件夹的搜索
package composite

import &quot;fmt&quot;

// Component 定义抽象构建
type Component interface &#123;
    search(string)
&#125;

// File 文件
type File struct &#123;
    name string
&#125;

func (f *File) search(keyword string) &#123;
    fmt.Printf(&quot;Searching for keyword %s in file %s\n&quot;, keyword, f.name)
&#125;

func (f *File) getName() string &#123;
    return f.name
&#125;

// Folder 文件夹
type Folder struct &#123;
    components []Component
    name       string
&#125;

func (f *Folder) search(keyword string) &#123;
    fmt.Printf(&quot;Searching recursively for keyword %s in folder %s\n&quot;, keyword, f.name)
    for _, composite := range f.components &#123;
        composite.search(keyword)
    &#125;
&#125;

func (f *Folder) add(c Component) &#123;
    f.components = append(f.components, c)
&#125;

func main() &#123;
    file1 := &amp;File&#123;name: &quot;File1&quot;&#125;
    file2 := &amp;File&#123;name: &quot;File2&quot;&#125;
    file3 := &amp;File&#123;name: &quot;File3&quot;&#125;

    folder1 := &amp;Folder&#123;
        name: &quot;Folder1&quot;,
    &#125;

    folder1.add(file1)

    folder2 := &amp;Folder&#123;
        name: &quot;Folder2&quot;,
    &#125;
    folder2.add(file2)
    folder2.add(file3)
    folder2.add(folder1)

    folder2.search(&quot;rose&quot;)
&#125;
</code></pre>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>如果需要实现树状对象结构， 可以使用组合模式。</p>
<p> 组合模式提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得可以构建树状嵌套递归对象结构。</p>
</li>
<li><p>如果希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p> 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
</li>
</ol>
<h2 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>可以利用多态和递归机制更方便地使用复杂树结构。</p>
</li>
<li><p>开闭原则。 无需更改现有代码， 就可以在应用中添加新元素， 使其成为对象树的一部分。</p>
</li>
</ul>
<h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 需要过度一般化组件接口， 使其变得令人难以理解。</li>
</ul>
<h2 id="与其他模式的关系-6"><a href="#与其他模式的关系-6" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li><p>责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p>可以使用迭代器模式来遍历组合树。</p>
</li>
<li><p>可以使用访问者模式对整个组合树执行操作。</p>
</li>
<li><p>可以使用享元模式实现组合树的共享叶节点以节省内存。</p>
</li>
<li><p>组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>  装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>  但是， 模式也可以相互合作： 可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
</ul>
<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul>
<li>Component 抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。</li>
<li>ConcreteComponent具体构件角色(真实对象)</li>
<li>Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象 。这样，就能在真实对象调用前后增加新的功能。</li>
<li>ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。</li>
</ul>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><pre><code class="java">/**
 * 抽象构建
 */
public interface ICar &#123;
    void move();
&#125;

/**
 * 被装饰对象，具体构建角色，真实对象
 */
public class Car implements ICar &#123;
    @Override
    public void move() &#123;
        System.out.println(&quot;能够在陆地上跑。&quot;);
    &#125;
&#125;

/**
 * Decorator装饰角色，具体装饰者的基类
 */
public class SuperCar implements ICar &#123;

    protected ICar car;

    public SuperCar(ICar car) &#123;
        this.car = car;
    &#125;

    @Override
    public void move() &#123;
        car.move();
    &#125;
&#125;

/**
 * ConcreteDecorator具体装饰角色,需要继承装饰角色
 */
public class FlyCar extends SuperCar &#123;

    public FlyCar(ICar car) &#123;
        super(car);
    &#125;

    //新功能
    public void fly()&#123;
        System.out.println(&quot;能够在天上飞&quot;);
    &#125;

    @Override
    public void move() &#123;
        super.move();
        fly();
    &#125;
&#125;
public class WaterCar extends SuperCar &#123;

    public WaterCar(ICar car) &#123;
        super(car);
    &#125;

    public void swim()&#123;
        System.out.println(&quot;能够在水上游。&quot;);
    &#125;

    @Override
    public void move() &#123;
        super.move();
        swim();
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        ICar car  = new Car();
        car.move();

        ICar car1 = new FlyCar(car);
        car1.move();

        ICar car2 = new WaterCar(new FlyCar(new Car()));
        car2.move();
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-3"><a href="#Go-版本实现-3" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package decorator 装饰器模式
package decorator

import &quot;fmt&quot;

// ICar 抽象构建-汽车
type ICar interface &#123;
    move()
&#125;

// Car 具体被装饰的基类
type Car struct&#123;&#125;

func (c *Car) move() &#123;
    fmt.Println(&quot;car move&quot;)
&#125;

// FlyCar 具体装饰
type FlyCar struct &#123;
    car ICar
&#125;

func (c *FlyCar) move() &#123;
    c.car.move()
&#125;

// fly 新功能
func (c *FlyCar) fly() &#123;
    fmt.Println(&quot;car fly&quot;)
&#125;

func main() &#123;
    car := &amp;Car&#123;&#125;
    flyCar := &amp;FlyCar&#123;car: car&#125;
    flyCar.move()
    flyCar.fly()
&#125;
</code></pre>
<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>如果希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</p>
<p> 装饰能将业务逻辑组织为层次结构， 可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</p>
</li>
<li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 可以使用该模式。</p>
<p> 许多编程语言使用 <code>final</code>最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</p>
</li>
</ol>
<h2 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无需创建新子类即可扩展对象的行为，不会导致类个数急剧增加</li>
<li>可以在运行时添加或删除对象的功能。</li>
<li>可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象。</li>
<li>单一职责原则。 可以将实现了许多不同行为的一个大类拆分为多个较小的类。</li>
<li>具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加 新的具体构件子类和具体装饰子类。</li>
</ul>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在封装器栈中删除特定封装器比较困难。</li>
<li>实现行为不受装饰栈顺序影响的装饰比较困难。</li>
<li>各层的初始化配置代码看上去可能会很糟糕。</li>
<li>产生很多小对象。大量小对象占据内存，一定程度上影响性能。</li>
<li>装饰模式易于出错，调试排查比较麻烦。</li>
</ul>
<h2 id="与其他模式的关系-7"><a href="#与其他模式的关系-7" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p>
</li>
<li><p>责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p>  责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
<li><p>组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>  装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>  但是， 模式也可以相互合作： 可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
<li><p>装饰可更改对象的外表， 策略模式则能够改变其本质。</p>
</li>
<li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
<li><p><strong>装饰模式和桥接模式的区别</strong>：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。</p>
</li>
</ul>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式为子系统提供统一的入口（门面），封装子系统的复杂性，便于客户端调用。</p>
<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><pre><code class="java">public interface 工商局 &#123;
    void checkName();
&#125;
public class 揭阳工商局 implements 工商局 &#123;
    @Override
    public void checkName() &#123;
        System.out.println(&quot;在揭阳工商局检查名字是否有冲突！&quot;);
    &#125;
&#125;

public interface 质检局 &#123;
    void orgCodeCertificate();
&#125;
public class 揭阳质检局 implements 质检局 &#123;
    @Override
    public void orgCodeCertificate() &#123;
        System.out.println(&quot;在揭阳质检局办理组织机构代码证！&quot;);
    &#125;
&#125;

public interface 税务局 &#123;
    void taxCertificate();
&#125;
public class 揭阳税务局 implements 税务局 &#123;
    @Override
    public void taxCertificate() &#123;
        System.out.println(&quot;在揭阳税务局办理税务登记！&quot;);
    &#125;
&#125;

public interface 银行 &#123;
    void openAccount();
&#125;
public class 中国工商银行 implements 银行 &#123;
    @Override
    public void openAccount() &#123;
        System.out.println(&quot;在中国工商银行开户！&quot;);
    &#125;
&#125;

//门面
public class RegisterFacade &#123;
    public void register()&#123;
        工商局 a = new 揭阳工商局();
        质检局 b = new 揭阳质检局();
        税务局 c = new 揭阳税务局();
        银行 d = new 中国工商银行();

        a.checkName();
        b.orgCodeCertificate();
        c.taxCertificate();
        d.openAccount();
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        RegisterFacade facade = new RegisterFacade();
        facade.register();
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-4"><a href="#Go-版本实现-4" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package facade 外观模式
// 支付交易中，包含了以下流程；
// 检查账户
// 检查安全码
// 借记/贷记余额
// 账簿录入
// 发送消息通知
//
// 这里隐藏内部细节，对外暴露存钱和扣钱接口
package facade

import (
    &quot;fmt&quot;
    &quot;log&quot;
)

// Account 账户校验
type Account struct &#123;
    name string
&#125;

func newAccount(accountName string) *Account &#123;
    return &amp;Account&#123;
        name: accountName,
    &#125;
&#125;

func (a *Account) checkAccount(accountName string) error &#123;
    if a.name != accountName &#123;
        return fmt.Errorf(&quot;account name is incorrect&quot;)
    &#125;
    fmt.Println(&quot;Account Verified&quot;)
    return nil
&#125;

// SecurityCode 安全码校验
type SecurityCode struct &#123;
    code int
&#125;

func newSecurityCode(code int) *SecurityCode &#123;
    return &amp;SecurityCode&#123;
        code: code,
    &#125;
&#125;

func (s *SecurityCode) checkCode(incomingCode int) error &#123;
    if s.code != incomingCode &#123;
        return fmt.Errorf(&quot;security code is incorrect&quot;)
    &#125;
    fmt.Println(&quot;SecurityCode Verified&quot;)
    return nil
&#125;

// Wallet 借记/贷记余额
type Wallet struct &#123;
    balance int
&#125;

func newWallet() *Wallet &#123;
    return &amp;Wallet&#123;
        balance: 0,
    &#125;
&#125;

func (w *Wallet) creditBalance(amount int) &#123;
    w.balance += amount
    fmt.Println(&quot;Wallet balance added successfully&quot;)
    return
&#125;

func (w *Wallet) debitBalance(amount int) error &#123;
    if w.balance &lt; amount &#123;
        return fmt.Errorf(&quot;Balance is not sufficient&quot;)
    &#125;
    fmt.Println(&quot;Wallet balance is Sufficient&quot;)
    w.balance = w.balance - amount
    return nil
&#125;

// Ledger 账簿录入
type Ledger struct &#123;
&#125;

func (s *Ledger) makeEntry(accountID, txnType string, amount int) &#123;
    fmt.Printf(&quot;Make ledger entry for accountId %s with txnType %s for amount %d\n&quot;, accountID, txnType, amount)
    return
&#125;

// Notification 发送消息通知
type Notification struct &#123;
&#125;

func (n *Notification) sendWalletCreditNotification() &#123;
    fmt.Println(&quot;Sending wallet credit notification&quot;)
&#125;

func (n *Notification) sendWalletDebitNotification() &#123;
    fmt.Println(&quot;Sending wallet debit notification&quot;)
&#125;

// WalletFacade 封装对外接口
type WalletFacade struct &#123;
    account      *Account
    wallet       *Wallet
    securityCode *SecurityCode
    notification *Notification
    ledger       *Ledger
&#125;

func newWalletFacade(accountID string, code int) *WalletFacade &#123;
    fmt.Println(&quot;Starting create account&quot;)
    walletFacacde := &amp;WalletFacade&#123;
        account:      newAccount(accountID),
        securityCode: newSecurityCode(code),
        wallet:       newWallet(),
        notification: &amp;Notification&#123;&#125;,
        ledger:       &amp;Ledger&#123;&#125;,
    &#125;
    fmt.Println(&quot;Account created&quot;)
    return walletFacacde
&#125;

func (w *WalletFacade) addMoneyToWallet(accountID string, securityCode int, amount int) error &#123;
    fmt.Println(&quot;Starting add money to wallet&quot;)
    err := w.account.checkAccount(accountID)
    if err != nil &#123;
        return err
    &#125;
    err = w.securityCode.checkCode(securityCode)
    if err != nil &#123;
        return err
    &#125;
    w.wallet.creditBalance(amount)
    w.notification.sendWalletCreditNotification()
    w.ledger.makeEntry(accountID, &quot;credit&quot;, amount)
    return nil
&#125;

func (w *WalletFacade) deductMoneyFromWallet(accountID string, securityCode int, amount int) error &#123;
    fmt.Println(&quot;Starting debit money from wallet&quot;)
    err := w.account.checkAccount(accountID)
    if err != nil &#123;
        return err
    &#125;

    err = w.securityCode.checkCode(securityCode)
    if err != nil &#123;
        return err
    &#125;
    err = w.wallet.debitBalance(amount)
    if err != nil &#123;
        return err
    &#125;
    w.notification.sendWalletDebitNotification()
    w.ledger.makeEntry(accountID, &quot;credit&quot;, amount)
    return nil
&#125;

func main() &#123;
    fmt.Println()
    walletFacade := newWalletFacade(&quot;abc&quot;, 1234)
    fmt.Println()

    err := walletFacade.addMoneyToWallet(&quot;abc&quot;, 1234, 10)
    if err != nil &#123;
        log.Fatalf(&quot;Error: %s\n&quot;, err.Error())
    &#125;

    fmt.Println()
    err = walletFacade.deductMoneyFromWallet(&quot;abc&quot;, 1234, 5)
    if err != nil &#123;
        log.Fatalf(&quot;Error: %s\n&quot;, err.Error())
    &#125;
&#125;
</code></pre>
<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>如果需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p>
<p> 子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p>
</li>
<li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p>
<p> 创建外观来定义子系统中各层次的入口。 可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p>
</li>
</ol>
<h2 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><p>可以让自己的代码独立于复杂子系统。</p>
<h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><p>外观可能成为与程序中所有类都耦合的上帝对象。</p>
<h2 id="与其他模式的关系-8"><a href="#与其他模式的关系-8" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 可以使用抽象工厂模式来代替外观。</li>
<li>享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</li>
<li>外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。<ul>
<li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li>外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。<br>享元模式以共享的方式高效地支持大量细粒度对象的重用。享元对象能做到共享的关键是区分了<strong>内部状态</strong>和<strong>外部状态</strong>。</p>
<ul>
<li>内部状态：可以共享，不会随环境变化而改变</li>
<li>外部状态：不可以共享，会随环境变化而改变</li>
</ul>
<h2 id="享元模式的实现"><a href="#享元模式的实现" class="headerlink" title="享元模式的实现"></a>享元模式的实现</h2><ul>
<li><code>FlyweightFactory</code>享元工厂类:创建并管理享元对象，享元池一般设计成键值对</li>
<li><code>FlyWeight</code>抽象享元类:通常是一个接口或抽象类，声明公共方法，这些方法可以<strong>向外界提供对象的内部状态</strong>，同时可以<strong>设置外部状态</strong></li>
<li><code>ConcreteFlyWeight</code>具体享元类:为内部状态提供成员变量进行存储</li>
<li><code>UnsharedConcreteFlyWeight</code>非共享享元类:不能被共享的子类可以设计为非共享享元类</li>
</ul>
<pre><code class="java">/**
 * 外部状态，非共享享元类
 */
public class Coordinate &#123;
    private int x,y;

    public Coordinate(int x, int y) &#123;
        this.x = x;
        this.y = y;
    &#125;

    public int getX() &#123;
        return x;
    &#125;

    public void setX(int x) &#123;
        this.x = x;
    &#125;

    public int getY() &#123;
        return y;
    &#125;

    public void setY(int y) &#123;
        this.y = y;
    &#125;
&#125;

/**
 * 享元抽象类
 */
public interface ChessFlyWeight &#123;
    //向外提供访问内部状态
    void setColor(String color);
    String getColor();

    void display(Coordinate c);//设置外部状态
&#125;
/**
 * 具体享元类
 */
public class ChessConcreteFlyWeight implements ChessFlyWeight &#123;

    private String color;//为内部状态提供成员变量进行存储

    public ChessConcreteFlyWeight(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public void setColor(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public String getColor() &#123;
        return color;
    &#125;

    @Override
    public void display(Coordinate c) &#123;
        System.out.println(&quot;棋子颜色：&quot;+ color);
        System.out.println(&quot;棋子位置：&quot;+ c.getX() + &quot;:&quot; + c.getY());
    &#125;
&#125;

/**
 * 享元工厂
 */
public class ChessFlyWeightFactory &#123;
    //享元池对象
    private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;&gt;();

    public static ChessFlyWeight getChess(String color)&#123;
        if(map.get(color) != null)&#123;
            return  map.get(color);
        &#125;else&#123;
            ChessFlyWeight chess = new ChessConcreteFlyWeight(color);
            map.put(color,chess);
            return chess;
        &#125;
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        ChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;);
        ChessFlyWeight chess2 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;);
        System.out.println(chess1 == chess2);

        System.out.println(&quot;增加外部状态的处理--------&quot;);
        chess1.display(new Coordinate(10,12));
        chess2.display(new Coordinate(12,10));
    &#125;
&#125;
</code></pre>
<h2 id="Go-代码实现"><a href="#Go-代码实现" class="headerlink" title="Go 代码实现"></a>Go 代码实现</h2><pre><code class="go">// Package flyweight 享元模式
// 假设游戏里的玩家可以设置 2 种不同的服装，这里服装就可以提取成享元对象
package flyweight

import &quot;fmt&quot;

const (
    //TerroristDressType terrorist dress type
    TerroristDressType = &quot;tDress&quot;
    //CounterTerrroristDressType terrorist dress type
    CounterTerrroristDressType = &quot;ctDress&quot;
)

// Dress 服装，享元接口
type Dress interface &#123;
    getColor() string
&#125;

// TerroristDress 具体享元对象-服装1
type TerroristDress struct &#123;
    color string
&#125;

func (t *TerroristDress) getColor() string &#123;
    return t.color
&#125;

func newTerroristDress() *TerroristDress &#123;
    return &amp;TerroristDress&#123;color: &quot;red&quot;&#125;
&#125;

// CounterTerroristDress 具体享元对象-服装2
type CounterTerroristDress struct &#123;
    color string
&#125;

func (c *CounterTerroristDress) getColor() string &#123;
    return c.color
&#125;

func newCounterTerroristDress() *CounterTerroristDress &#123;
    return &amp;CounterTerroristDress&#123;color: &quot;green&quot;&#125;
&#125;

type DressFactory struct &#123;
    dressMap map[string]Dress
&#125;

// 享元池对象
var dressFactorySingleInstance = &amp;DressFactory&#123;dressMap: make(map[string]Dress)&#125;

func (d *DressFactory) getDressByType(dressType string) (Dress, error) &#123;
    if d.dressMap[dressType] != nil &#123;
        return d.dressMap[dressType], nil
    &#125;

    if dressType == TerroristDressType &#123;
        d.dressMap[dressType] = newTerroristDress()
        return d.dressMap[dressType], nil
    &#125;
    if dressType == CounterTerrroristDressType &#123;
        d.dressMap[dressType] = newCounterTerroristDress()
        return d.dressMap[dressType], nil
    &#125;

    return nil, fmt.Errorf(&quot;Wrong dress type passed&quot;)
&#125;

func getDressFactorySingleInstance() *DressFactory &#123;
    return dressFactorySingleInstance
&#125;

// Player 非共享享元类-玩家
type Player struct &#123;
    dress      Dress
    playerType string
    lat        int
    long       int
&#125;

func newPlayer(playerType, dressType string) *Player &#123;
    dress, _ := getDressFactorySingleInstance().getDressByType(dressType)
    return &amp;Player&#123;
        playerType: playerType,
        dress:      dress,
    &#125;
&#125;

func (p *Player) newLocation(lat, long int) &#123;
    p.lat = lat
    p.long = long
&#125;

// game 非共享享元类-游戏
type game struct &#123;
    terrorists        []*Player
    counterTerrorists []*Player
&#125;

func newGame() *game &#123;
    return &amp;game&#123;
        terrorists:        make([]*Player, 1),
        counterTerrorists: make([]*Player, 1),
    &#125;
&#125;

func (c *game) addTerrorist(dressType string) &#123;
    player := newPlayer(&quot;T&quot;, dressType)
    c.terrorists = append(c.terrorists, player)
    return
&#125;

func (c *game) addCounterTerrorist(dressType string) &#123;
    player := newPlayer(&quot;CT&quot;, dressType)
    c.counterTerrorists = append(c.counterTerrorists, player)
    return
&#125;

func main() &#123;
    game := newGame()

    //Add Terrorist
    game.addTerrorist(TerroristDressType)
    game.addTerrorist(TerroristDressType)
    game.addTerrorist(TerroristDressType)
    game.addTerrorist(TerroristDressType)

    //Add CounterTerrorist
    game.addCounterTerrorist(CounterTerrroristDressType)
    game.addCounterTerrorist(CounterTerrroristDressType)
    game.addCounterTerrorist(CounterTerrroristDressType)

    dressFactoryInstance := getDressFactorySingleInstance()

    for dressType, dress := range dressFactoryInstance.dressMap &#123;
        fmt.Printf(&quot;DressColorType: %s\nDressColor: %s\n&quot;, dressType, dress.getColor())
    &#125;
&#125;
</code></pre>
<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</p>
<p> 应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：</p>
</li>
</ol>
<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul>
<h2 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><ul>
<li>极大减少内存中对象的数量</li>
<li>相同或相似对象内存中只存一份，极大的节约资源，提高系统性能</li>
<li>外部状态相对独立，不影响内部状态</li>
</ul>
<h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>模式较复杂，使程序逻辑复杂化</li>
<li>为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间</li>
</ul>
<h2 id="与其他模式的关系-9"><a href="#与其他模式的关系-9" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>可以使用享元模式实现组合模式树的共享叶节点以节省内存。</li>
<li>享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。</li>
<li>如果能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。<ol>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
</ul>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>将能够处理同一类请求的对象练成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果有则处理，如果不能则传递给链上的下一个对象。</p>
<p>由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。 符合开闭原则。</p>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>责任链的实现方法有两种：</p>
<ul>
<li>链表方式定义职责链</li>
<li>非链表方式实现职责链：通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。</li>
</ul>
<pre><code class="java">
//要处理的请求
public class LeaveRequest &#123;
    private String empName;
    private int leaveDays;
    private String reason;

    public LeaveRequest(String empName, int leaveDays, String reason) &#123;
        this.empName = empName;
        this.leaveDays = leaveDays;
        this.reason = reason;
    &#125;

    public String getEmpName() &#123;
        return empName;
    &#125;

    public void setEmpName(String empName) &#123;
        this.empName = empName;
    &#125;

    public int getLeaveDays() &#123;
        return leaveDays;
    &#125;

    public void setLeaveDays(int leaveDays) &#123;
        this.leaveDays = leaveDays;
    &#125;

    public String getReason() &#123;
        return reason;
    &#125;

    public void setReason(String reason) &#123;
        this.reason = reason;
    &#125;
&#125;

//责任链上对象的基类
public abstract class Leader &#123;

    protected String name;
    protected Leader nextLeader;//责任链后继对象

    public Leader(String name) &#123;
        this.name = name;
    &#125;

    //设置责任链上的后继对象
    public void setNextLeader(Leader nextLeader) &#123;
        this.nextLeader = nextLeader;
    &#125;

    //处理请求的核心业务方法
    public abstract void handleRequest(LeaveRequest request);
&#125;

public class Director extends Leader &#123;

    public Director(String name) &#123;
        super(name);
    &#125;

    @Override
    public void handleRequest(LeaveRequest request) &#123;
        if(request.getLeaveDays()&lt;3)&#123;
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：主任&quot;+this.name+&quot;,审批通过！&quot;);
        &#125;else&#123;
            if(this.nextLeader!=null)&#123;
                this.nextLeader.handleRequest(request);
            &#125;
        &#125;
    &#125;
&#125;
public class Manager extends Leader &#123;

    public Manager(String name) &#123;
        super(name);
    &#125;

    @Override
    public void handleRequest(LeaveRequest request) &#123;
        if(request.getLeaveDays()&lt;10)&#123;
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：经理&quot;+this.name+&quot;,审批通过！&quot;);
        &#125;else&#123;
            if(this.nextLeader!=null)&#123;
                this.nextLeader.handleRequest(request);
            &#125;
        &#125;
    &#125;
&#125;
public class GeneralManager extends Leader &#123;

    public GeneralManager(String name) &#123;
        super(name);
    &#125;

    @Override
    public void handleRequest(LeaveRequest request) &#123;
        if(request.getLeaveDays()&lt;30)&#123;
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：总经理&quot;+this.name+&quot;,审批通过！&quot;);
        &#125;else&#123;
            System.out.println(&quot;请假&quot;+request.getLeaveDays()+&quot;天，直接辞职吧！&quot;);
        &#125;
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        Leader leader1 = new Director(&quot;张三&quot;);
        Leader leader2 = new Manager(&quot;李四&quot;);
        Leader leader3 = new GeneralManager(&quot;王五&quot;);

        //组织责任链对象的关系
        leader1.setNextLeader(leader2);
        leader2.setNextLeader(leader3);

        //开启请假处理
        LeaveRequest request = new LeaveRequest(&quot;小铭&quot;,90,&quot;想出去玩！！！&quot;);
        leader1.handleRequest(request);
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-5"><a href="#Go-版本实现-5" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package chain_of_responsibility 责任链模式
// 假设病人来访医院，他们首先都会去前台，然后是看医生，取药，最后结账。
// 也就是说，病人需要通过一条部门链，每个部门都在完成其职能后将病人进一步沿着链条输送。
package chain_of_responsibility

import &quot;fmt&quot;

// Patient 病人
type Patient struct &#123;
    name              string
    registrationDone  bool
    doctorCheckUpDone bool
    medicineDone      bool
    paymentDone       bool
&#125;

// Department 处理者接口
type Department interface &#123;
    execute(*Patient)
    setNext(Department)
&#125;

// Reception 处理者1-前台
type Reception struct &#123;
    next Department
&#125;

func (r *Reception) execute(p *Patient) &#123;
    if p.registrationDone &#123;
        fmt.Println(&quot;Patient registration already done&quot;)
        r.next.execute(p)
        return
    &#125;
    fmt.Println(&quot;Reception registering patient&quot;)
    p.registrationDone = true
    r.next.execute(p)
&#125;

func (r *Reception) setNext(next Department) &#123;
    r.next = next
&#125;

// Doctor 具体处理者2-医生
type Doctor struct &#123;
    next Department
&#125;

func (d *Doctor) execute(p *Patient) &#123;
    if p.doctorCheckUpDone &#123;
        fmt.Println(&quot;Doctor checkup already done&quot;)
        d.next.execute(p)
        return
    &#125;
    fmt.Println(&quot;Doctor checking patient&quot;)
    p.doctorCheckUpDone = true
    d.next.execute(p)
&#125;

func (d *Doctor) setNext(next Department) &#123;
    d.next = next
&#125;

// Medical 具体处理者3-取药
type Medical struct &#123;
    next Department
&#125;

func (m *Medical) execute(p *Patient) &#123;
    if p.medicineDone &#123;
        fmt.Println(&quot;Medicine already given to patient&quot;)
        m.next.execute(p)
        return
    &#125;
    fmt.Println(&quot;Medical giving medicine to patient&quot;)
    p.medicineDone = true
    m.next.execute(p)
&#125;

func (m *Medical) setNext(next Department) &#123;
    m.next = next
&#125;

// Cashier 具体处理者4-付款
type Cashier struct &#123;
    next Department
&#125;

func (c *Cashier) execute(p *Patient) &#123;
    if p.paymentDone &#123;
        fmt.Println(&quot;Payment Done&quot;)
    &#125;
    fmt.Println(&quot;Cashier getting money from patient patient&quot;)
&#125;

func (c *Cashier) setNext(next Department) &#123;
    c.next = next
&#125;


func main() &#123;

    cashier := &amp;Cashier&#123;&#125;

    //Set next for medical department
    medical := &amp;Medical&#123;&#125;
    medical.setNext(cashier)

    //Set next for doctor department
    doctor := &amp;Doctor&#123;&#125;
    doctor.setNext(medical)

    //Set next for reception department
    reception := &amp;Reception&#123;&#125;
    reception.setNext(doctor)

    patient := &amp;Patient&#123;name: &quot;abc&quot;&#125;
    //Patient visiting
    reception.execute(patient)
&#125;
</code></pre>
<h2 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。</p>
<p> 该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p>
</li>
<li><p>当必须按顺序执行多个处理者时， 可以使用该模式。</p>
<p> 无论以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p>
</li>
<li><p>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</p>
<p> 如果在处理者类中有对引用成员变量的设定方法， 将能动态地插入和移除处理者， 或者改变其顺序。</p>
</li>
</ol>
<h2 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以控制请求处理的顺序。</li>
<li>单一职责原则。 可对发起操作和执行操作的类进行解耦。</li>
<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>
</ul>
<h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>部分请求可能未被处理。</li>
</ul>
<h2 id="与其他模式的关系-10"><a href="#与其他模式的关系-10" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：</p>
</li>
<li><p>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</p>
</li>
<li><p>命令在发送者和请求者之间建立单向连接。</p>
</li>
<li><p>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</p>
</li>
<li><p>观察者允许接收者动态地订阅或取消接收请求。</p>
</li>
<li><p>责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p>责任链的管理者可使用命令模式实现。 在这种情况下， 可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>  还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li><p>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p>  责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
</ul>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式提供一种可以遍历聚合对象的方式。又称为：游标cursor模式。</p>
<p>迭代器模式能在不暴露复杂数据结构内部细节的情况下遍历其中所有的元素。</p>
<ul>
<li>聚合对象：存储数据</li>
<li>迭代器：遍历数据</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">/**
 * 自定义的迭代器接口
 */
public interface MyIterator &#123;
    void first();//将游标指向第一个元素
    void next();//将游标指向下一个元素
    boolean hasNext();//判断是否存在下一个元素
    boolean isFirst();//判断是否是第一个元素
    boolean isLast();//判断是否是最后一个元素
    Object getCurrentObj();//获得当前元素
&#125;

/**
 * 自定义聚合类
 */
public class ConcreteMyAggregate &#123;
    private List&lt;Object&gt; list = new ArrayList&lt;&gt;();

    public void addObject(Object o)&#123;
        list.add(o);
    &#125;

    public void removeObject(Object o)&#123;
        list.remove(o);
    &#125;

    public List&lt;Object&gt; getList() &#123;
        return list;
    &#125;

    public void setList(List&lt;Object&gt; list) &#123;
        this.list = list;
    &#125;

    public MyIterator createIterator()&#123;
        return new MyConcreteIterator();
    &#125;

    /**
     * 迭代器作为内部类
     */
    private class MyConcreteIterator implements MyIterator&#123;

        private int cursor;//游标

        @Override
        public void first() &#123;
            cursor = 0;
        &#125;

        @Override
        public void next() &#123;
            if(cursor &lt; list.size())&#123;
                cursor++;
            &#125;
        &#125;

        @Override
        public boolean hasNext() &#123;
            return cursor &lt; list.size();
        &#125;

        @Override
        public boolean isFirst() &#123;
            return cursor == 0;
        &#125;

        @Override
        public boolean isLast() &#123;
            return cursor == list.size()-1;
        &#125;

        @Override
        public Object getCurrentObj() &#123;
            return list.get(cursor);
        &#125;
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        ConcreteMyAggregate cma = new ConcreteMyAggregate();
        cma.addObject(&quot;abc&quot;);
        cma.addObject(&quot;123&quot;);
        cma.addObject(new ConcreteMyAggregate());

        MyIterator iterator = cma.createIterator();
        while (iterator.hasNext())&#123;
            System.out.println(iterator.getCurrentObj());
            iterator.next();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-6"><a href="#Go-版本实现-6" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package iterator 迭代器模式
package iterator

import &quot;fmt&quot;

// User 用户信息
type User struct &#123;
    name string
    age  int
&#125;

// Iterator 迭代器接口
type Iterator interface &#123;
    hasNext() bool
    getNext() *User
&#125;

// UserIterator 用户数据迭代器
type UserIterator struct &#123;
    index int
    users []*User
&#125;

func (u *UserIterator) hasNext() bool &#123;
    if u.index &lt; len(u.users) &#123;
        return true
    &#125;
    return false
&#125;

func (u *UserIterator) getNext() *User &#123;
    if u.hasNext() &#123;
        user := u.users[u.index]
        u.index++
        return user
    &#125;
    return nil
&#125;

// Collection 集合
type Collection interface &#123;
    createIterator() Iterator
&#125;

// UserCollection 具体集合
type UserCollection struct &#123;
    users []*User
&#125;

func (u *UserCollection) createIterator() Iterator &#123;
    return &amp;UserIterator&#123;
        users: u.users,
    &#125;
&#125;

func main() &#123;
    user1 := &amp;User&#123;
        name: &quot;a&quot;,
        age:  30,
    &#125;
    user2 := &amp;User&#123;
        name: &quot;b&quot;,
        age:  20,
    &#125;

    userCollection := &amp;UserCollection&#123;
        users: []*User&#123;user1, user2&#125;,
    &#125;

    iterator := userCollection.createIterator()

    for iterator.hasNext() &#123;
        user := iterator.getNext()
        fmt.Printf(&quot;User is %+v\n&quot;, user)
    &#125;
&#125;
</code></pre>
<h2 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>当集合背后为复杂的数据结构， 且希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</p>
<p> 迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p>
</li>
<li><p>使用该模式可以减少程序中重复的遍历代码。</p>
<p> 重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</li>
<li><p>如果希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</p>
<p> 该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。</p>
</li>
</ol>
<h2 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><ul>
<li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li>
<li>开闭原则。 可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</li>
<li>可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</li>
<li>相似的， 可以暂停遍历并在需要时继续。</li>
</ul>
<h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>如果程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</li>
<li>对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</li>
</ul>
<h2 id="与其他模式的关系-11"><a href="#与其他模式的关系-11" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>可以使用迭代器模式来遍历组合模式树。</li>
<li>可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>
<li>可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。</li>
<li>可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</li>
</ul>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系极其复杂，这些对象被称为<strong>同事对象</strong>，可以引入一个<strong>中介者对象</strong>，使各个同事只跟中介者对象打交道，将复杂的网络结构简单化。</p>
<p>中介者模式解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">/**
 * 抽象同事类
 */
public interface Department &#123;
    void selfAction();//本部门内部事务
    void outAction();//向总经理发出申请
&#125;

/**
 * 抽象中介者
 */
public interface Mediator &#123;
    void register(String dname,Department d);//管理的相关部门
    void command(String dname);//向有关部门发出命令
&#125;

//具体同事类
public class Development implements Department &#123;

    private Mediator mediator;//持有中介者的引用

    public Development(Mediator mediator) &#123;
        this.mediator = mediator;
        mediator.register(&quot;development&quot;,this);//使中介者拥有当前引用
    &#125;

    @Override
    public void selfAction() &#123;
        System.out.println(&quot;科研部内部事务&quot;);
    &#125;

    @Override
    public void outAction() &#123;
        System.out.println(&quot;科研部需要财务部拨钱&quot;);
        mediator.command(&quot;financial&quot;);
    &#125;
&#125;
public class Financial implements Department &#123;
    private Mediator mediator;//持有中介者的引用

    public Financial(Mediator mediator) &#123;
        this.mediator = mediator;
        mediator.register(&quot;financial&quot;,this);//使中介者拥有当前引用
    &#125;

    @Override
    public void selfAction() &#123;
        System.out.println(&quot;财务部内部事务&quot;);
    &#125;

    @Override
    public void outAction() &#123;
        System.out.println(&quot;财务部接收其他部门财务申请&quot;);
        mediator.command(&quot;development&quot;);
        mediator.command(&quot;market&quot;);
    &#125;
&#125;
public class Market implements Department &#123;

    private Mediator mediator;//持有中介者的引用

    public Market(Mediator mediator) &#123;
        this.mediator = mediator;
        mediator.register(&quot;market&quot;,this);//使中介者拥有当前引用
    &#125;

    @Override
    public void selfAction() &#123;
        System.out.println(&quot;市场部内部事务&quot;);
    &#125;

    @Override
    public void outAction() &#123;
        System.out.println(&quot;市场部需要财务部拨钱&quot;);
        mediator.command(&quot;financial&quot;);
    &#125;
&#125;

/**
 * 具体中介者对象（总经理）
 */
public class President implements Mediator &#123;

    private Map&lt;String,Department&gt; map = new HashMap&lt;&gt;();

    @Override
    public void register(String dname, Department d) &#123;
        map.put(dname, d);
    &#125;

    @Override
    public void command(String dname) &#123;
        map.get(dname).selfAction();
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        Mediator mediator = new President();//中介者对象

        Market market = new Market(mediator);
        Development development = new Development(mediator);
        Financial financial = new Financial(mediator);

        development.outAction();
        financial.outAction();
    &#125;
&#125;
</code></pre>
<h2 id="Go-代码实现-1"><a href="#Go-代码实现-1" class="headerlink" title="Go 代码实现"></a>Go 代码实现</h2><pre><code class="go">// Package mediator 中介者模式
// 模拟火车站交通系统，两列火车通过车站经历（中介者）来控制进出站
package mediator

import &quot;fmt&quot;

// Train 组件，火车接口
type Train interface &#123;
    arrive()
    depart()
    permitArrival()
&#125;

// Mediator 中介者接口
type Mediator interface &#123;
    canArrive(Train) bool
    notifyAboutDeparture()
&#125;

// StationManager 具体中介者
type StationManager struct &#123;
    isPlatformFree bool
    trainQueue     []Train
&#125;

func newStationManger() *StationManager &#123;
    return &amp;StationManager&#123;
        isPlatformFree: true,
    &#125;
&#125;

func (s *StationManager) canArrive(t Train) bool &#123;
    if s.isPlatformFree &#123;
        s.isPlatformFree = false
        return true
    &#125;
    s.trainQueue = append(s.trainQueue, t)
    return false
&#125;

func (s *StationManager) notifyAboutDeparture() &#123;
    if !s.isPlatformFree &#123;
        s.isPlatformFree = true
    &#125;
    if len(s.trainQueue) &gt; 0 &#123;
        firstTrainInQueue := s.trainQueue[0]
        s.trainQueue = s.trainQueue[1:]
        firstTrainInQueue.permitArrival()
    &#125;
&#125;

// PassengerTrain 具体火车1
type PassengerTrain struct &#123;
    mediator Mediator
&#125;

func (g *PassengerTrain) arrive() &#123;
    if !g.mediator.canArrive(g) &#123;
        fmt.Println(&quot;PassengerTrain: Arrival blocked, waiting&quot;)
        return
    &#125;
    fmt.Println(&quot;PassengerTrain: Arrived&quot;)
&#125;

func (g *PassengerTrain) depart() &#123;
    fmt.Println(&quot;PassengerTrain: Leaving&quot;)
    g.mediator.notifyAboutDeparture()
&#125;

func (g *PassengerTrain) permitArrival() &#123;
    fmt.Println(&quot;PassengerTrain: Arrival permitted, arriving&quot;)
    g.arrive()
&#125;

// FreightTrain 具体火车2
type FreightTrain struct &#123;
    mediator Mediator
&#125;

func (g *FreightTrain) arrive() &#123;
    if !g.mediator.canArrive(g) &#123;
        fmt.Println(&quot;FreightTrain: Arrival blocked, waiting&quot;)
        return
    &#125;
    fmt.Println(&quot;FreightTrain: Arrived&quot;)
&#125;

func (g *FreightTrain) depart() &#123;
    fmt.Println(&quot;FreightTrain: Leaving&quot;)
    g.mediator.notifyAboutDeparture()
&#125;

func (g *FreightTrain) permitArrival() &#123;
    fmt.Println(&quot;FreightTrain: Arrival permitted&quot;)
    g.arrive()
&#125;

func main() &#123;
    stationManager := newStationManger()

    passengerTrain := &amp;PassengerTrain&#123;
        mediator: stationManager,
    &#125;
    freightTrain := &amp;FreightTrain&#123;
        mediator: stationManager,
    &#125;

    passengerTrain.arrive()
    freightTrain.arrive()
    passengerTrain.depart()
&#125;
</code></pre>
<h2 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</p>
<p> 该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。</p>
</li>
<li><p>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</p>
<p> 应用中介者模式后， 每个组件不再知晓其他组件的情况。尽管这些组件无法直接交流，但它们仍可通过中介者对象进行间接交流。如果希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。</p>
</li>
<li><p>如果为了能在不同情景下复用一些基本行为，导致需要被迫创建大量组件子类时，可使用中介者模式。</p>
<p> 由于所有组件间关系都被包含在中介者中， 因此无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</p>
</li>
</ol>
<h2 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><ul>
<li>单一职责原则。 可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</li>
<li>开闭原则。 无需修改实际组件就能增加新的中介者。</li>
<li>可以减轻应用中多个组件间的耦合情况。</li>
<li>可以更方便地复用各个组件。</li>
</ul>
<h3 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>一段时间后， 中介者可能会演化成为上帝对象。</li>
</ul>
<h2 id="与其他模式的关系-12"><a href="#与其他模式的关系-12" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p>外观模式和中介者的职责类似：它们都尝试在大量紧密耦合的类中组织起合作。</p>
<ul>
<li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li><p>中介者和观察者之间的区别往往很难记住。在大部分情况下，可以使用其中一种模式，而有时可以同时使用。</p>
<p>  中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。观察者的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。</p>
<p>  有一种流行的中介者模式实现方式依赖于观察者。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时，它可能看上去与观察者非常相似。</p>
<p>  当你感到疑惑时，记住可以采用其他方式来实现中介者。 例如，可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和<em>观察者</em>并不相同，但这仍是一种中介者模式。</p>
<p>  假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。</p>
</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Command</code>抽象命令类</li>
<li><code>ConcreteCommand</code>具体命令类</li>
<li><code>Invoker</code>请求的调用者&#x2F;请求者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的<code>execute</code>方法，间接调用接受者的相关操作</li>
<li><code>Receiver</code>接收者：接收者执行与请求相关的操作，具体实现对请求的业务处理。（实际执行操作内容的对象）</li>
<li><code>Client</code>客户类，需要创建调用者对象，具体命令类对象，在创建具体命令类对象时指定对应的接受者。发送者和接收者之间没有直接关系，都通过命令对象间接调用</li>
</ul>
<pre><code class="java">/**
 * 真正的命令执行者
 */
public class Receiver &#123;
    public void action()&#123;
        System.out.println(&quot;真正的命令执行者！&quot;);
    &#125;
&#125;

/**
 * 命令抽象类
 */
public interface Command &#123;

    /**
     * 这个方法是一个返回结果为空的方法
     * 实际项目中，可以根据需求设计多个不同的方法
     */
    void execute();
&#125;

/**
 * 具体的命令类
 */
public class ConcreteCommand implements Command &#123;

    private Receiver receiver;

    public ConcreteCommand(Receiver receiver) &#123;
        this.receiver = receiver;
    &#125;

    @Override
    public void execute() &#123;
        System.out.println(&quot;命令类调用前处理&quot;);
        receiver.action();
        System.out.println(&quot;命令类调用后处理&quot;);
    &#125;
&#125;

/**
 * 命令发起者
 */
public class Invoker &#123;

    private Command command;//可以通过容器List容纳多个命令对象，进行批处理

    public Invoker(Command command) &#123;
        this.command = command;
    &#125;

    //调用命令类方法
    public void call()&#123;
        System.out.println(&quot;命令发起者调用前处理&quot;);
        command.execute();
        System.out.println(&quot;命令发起者调用后处理&quot;);
    &#125;
&#125;


public class Client &#123;
    public static void main(String[] args) &#123;
        Command command = new ConcreteCommand(new Receiver());
        Invoker invoker = new Invoker(command);
        invoker.call();
    &#125;
&#125;
</code></pre>
<h2 id="Go-版本实现-7"><a href="#Go-版本实现-7" class="headerlink" title="Go 版本实现"></a>Go 版本实现</h2><pre><code class="go">// Package command 命令模式
// 以电视机为接受者，对其发送打开和关闭命令
package command

import &quot;fmt&quot;

// Device 命令执行者接口
type Device interface &#123;
    on()
    off()
&#125;

// TV 具体命令接受者
type TV struct &#123;
    isRunning bool
&#125;

func (t *TV) on() &#123;
    t.isRunning = true
    fmt.Println(&quot;Turning tv on&quot;)
&#125;

func (t *TV) off() &#123;
    t.isRunning = false
    fmt.Println(&quot;Turning tv off&quot;)
&#125;

// Command 命令接口
type Command interface &#123;
    execute()
&#125;

// OnCommand 具体命令：打开
type OnCommand struct &#123;
    device Device
&#125;

func (c *OnCommand) execute() &#123;
    c.device.on()
&#125;

// OffCommand 具体命令：关闭
type OffCommand struct &#123;
    device Device
&#125;

func (c *OffCommand) execute() &#123;
    c.device.off()
&#125;

type Button struct &#123;
    command Command
&#125;

func (b *Button) press() &#123;
    b.command.execute()
&#125;

func main() &#123;
    tv := &amp;TV&#123;&#125;

    onCommand := &amp;OnCommand&#123;
        device: tv,
    &#125;

    offCommand := &amp;OffCommand&#123;
        device: tv,
    &#125;

    onButton := &amp;Button&#123;
        command: onCommand,
    &#125;
    onButton.press()

    offButton := &amp;Button&#123;
        command: offCommand,
    &#125;
    offButton.press()
&#125;
</code></pre>
<h2 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>如果需要通过操作来参数化对象， 可使用命令模式。</p>
<p> 命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p>
<p> 举个例子： 开发一个 GUI 组件 （例如上下文菜单）， 希望用户能够配置菜单项， 并在点击菜单项时触发操作。</p>
</li>
<li><p>如果想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p>
<p> 同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 还可以将命令放入队列、 记录命令或者通过网络发送命令。</p>
</li>
<li><p>如果想要实现操作回滚功能， 可使用命令模式。</p>
<p> 尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p>
<p> 为了能够回滚操作， 需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p>
<p> 这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p> 其次， 备份状态可能会占用大量内存。 因此， 有时需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</p>
</li>
</ol>
<h2 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><ul>
<li>单一职责原则。 可以解耦触发和执行操作的类。</li>
<li>开闭原则。 可以在不修改已有客户端代码的情况下在程序中创建新的命令。</li>
<li>可以实现撤销和恢复功能。</li>
<li>可以实现操作的延迟执行。</li>
<li>可以将一组简单命令组合成一个复杂命令。</li>
</ul>
<h3 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代码可能会变得更加复杂， 因为在发送者和接收者之间增加了一个全新的层次。</li>
</ul>
<h2 id="与其他模式的关系-13"><a href="#与其他模式的关系-13" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p>责任链的管理者可使用命令模式实现。 在这种情况下， 可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>  还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li><p>可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p>
</li>
<li><p>命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p>
<ul>
<li>可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</li>
<li>另一方面， 策略通常可用于描述完成某件事的不同方式， 能够在同一个上下文类中切换算法。</li>
</ul>
</li>
<li><p>原型模式可用于保存命令的历史记录。</p>
</li>
<li><p>可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。</p>
</li>
</ul>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>是一种不常用的设计模式，用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。当我们需要开发一种新的语言时，可以考虑使用解释器模式。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。访问者模式表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</p>
<pre><code class="java">//策略接口
public interface Strategy &#123;
    double getPrice(double standardPrice);
&#125;
//各种不同的策略
public class NewCustomerFewStrategy implements Strategy &#123;
    @Override
    public double getPrice(double standardPrice) &#123;
        System.out.println(&quot;普通用户小批量，不打折&quot;);
        return standardPrice;
    &#125;
&#125;
public class NewCustomerManyStrategy implements Strategy &#123;
    @Override
    public double getPrice(double standardPrice) &#123;
        System.out.println(&quot;普通用户da批量，打9折&quot;);
        return standardPrice*0.9;
    &#125;
&#125;
public class OldCustomerFewStrategy implements Strategy &#123;
    @Override
    public double getPrice(double standardPrice) &#123;
        System.out.println(&quot;老用户小批量，打85折&quot;);
        return standardPrice*0.85;
    &#125;
&#125;
public class OldCustromerManyStrategy implements Strategy &#123;
    @Override
    public double getPrice(double standardPrice) &#123;
        System.out.println(&quot;老用户大批量，打八折&quot;);
        return standardPrice*0.8;
    &#125;
&#125;

/**
 * 负责和具体的策略类交互，实现具体算法与客户端调用分离
 */
public class Context &#123;
    private Strategy strategy;//当前采用的算法

    public Context(Strategy strategy) &#123;
        this.strategy = strategy;
    &#125;

    public void setStrategy(Strategy strategy) &#123;
        this.strategy = strategy;
    &#125;

    public void printPrice(double price)&#123;
        double p = strategy.getPrice(price);
        System.out.println(&quot;最终价格：&quot;+p+&quot;元&quot;);
    &#125;
&#125;

//客户端
public class Client &#123;
    public static void main(String[] args) &#123;
        Strategy strategy = new OldCustomerFewStrategy();
        Context context = new Context(strategy);
        context.printPrice(2113211);
    &#125;
&#125;
</code></pre>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>模版方法定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。<br>通常处理步骤在父类中定义好，具体实现延迟到子类中定义。子类不能调用父类，而通过父类调用子类，这些步骤在父类中已经写好，完全由父类控制整个过程，这个过程又叫做<strong>方法回调</strong>（钩子方法）</p>
<pre><code class="java">public abstract class BankTemplateMethod &#123;

    public void takeNumber()&#123;
        System.out.println(&quot;取号&quot;);
    &#125;

    public abstract void transact();//办理具体的业务（钩子方法）

    public void evaluate()&#123;
        System.out.println(&quot;评价本次服务&quot;);
    &#125;

    /**
     * 模版方法，将基本操作组合在一起，子类一般不能重写
     */
    public final void process()&#123;
        this.takeNumber();
        this.transact();
        this.evaluate();
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        //可以采用匿名内部类的方式调用
        BankTemplateMethod btm = new BankTemplateMethod() &#123;
            @Override
            public void transact() &#123;
                System.out.println(&quot;取款&quot;);
            &#125;
        &#125;;
        btm.process();
    &#125;
&#125;
</code></pre>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题</p>
<h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Context</code>环境类：环境类中维护一个<code>State</code>对象，它定义了当前的状态。</li>
<li><code>State</code>抽象状态类</li>
<li><code>ConcreteState</code>具体状态类：每一个类封装了一个状态对应的行为</li>
</ul>
<pre><code class="java">/**
 * 状态抽象类
 */
public interface State &#123;
    void handle();
&#125;

public class FreeState implements State &#123;
    @Override
    public void handle() &#123;
        System.out.println(&quot;房间空闲，可预定！&quot;);
    &#125;
&#125;
public class BookedState implements State &#123;
    @Override
    public void handle() &#123;
        System.out.println(&quot;房间已经被预定！&quot;);
    &#125;
&#125;
public class CheckedState implements State &#123;
    @Override
    public void handle() &#123;
        System.out.println(&quot;房间已入驻，请勿打扰！&quot;);
    &#125;
&#125;

/**
 * 环境类:代表着当前的状态以及状态切换的核心方法
 */
public class HotelContext &#123;
    private State state;

    public void setState(State state) &#123;
        System.out.println(&quot;修改状态！&quot;);
        this.state = state;
        state.handle();
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        HotelContext context = new HotelContext();
        context.setState(new FreeState());
        context.setState(new CheckedState());
    &#125;
&#125;
</code></pre>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。<br>观察者模式主要用于1:N的通知。当一个对象（目标对象<code>Subject</code>或<code>Objservable</code>的状态变化时，它需要及时告知一系列对象（观察者对象<code>Observer</code>），令它们作出响应<br>通知观察者的方式有：</p>
<ul>
<li>推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收</li>
<li>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定</li>
</ul>
<pre><code class="java">/**
 * 目标类对象
 */
public class Subject &#123;
    //存储所有观察者的集合
    protected List&lt;Observer&gt; list = new ArrayList&lt;&gt;();

    public void register(Observer observer)&#123;
        list.add(observer);
    &#125;

    public void remove(Observer observer)&#123;
        list.remove(observer);
    &#125;

    //通知所有的观察者更新状态
    public void notifyAllObservers()&#123;
        for (Observer observer : list) &#123;
            observer.update(this);
        &#125;
    &#125;
&#125;

/**
 * 观察者
 */
public interface Observer &#123;
    void update(Subject subject);
&#125;

/**
 * 具体的目标类对象
 */
public class ConcreteSubject extends Subject &#123;
    private int state;

    public int getState() &#123;
        return state;
    &#125;

    public void setState(int state) &#123;
        this.state = state;
        //目标对象值发生变化，通知所有观察者
        this.notifyAllObservers();
    &#125;
&#125;

/**
 * 具体的观察者对象
 */
public class ObserverA implements Observer &#123;

    private int myState;//myState需要跟目标对象的state保持一致

    public int getMyState() &#123;
        return myState;
    &#125;

    public void setMyState(int myState) &#123;
        this.myState = myState;
    &#125;

    @Override
    public void update(Subject subject) &#123;
        myState = ((ConcreteSubject) subject).getState();
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        //目标对象
        ConcreteSubject subject = new ConcreteSubject();

        //创建多个观察者
        ObserverA observer1 = new ObserverA();
        ObserverA observer2 = new ObserverA();
        ObserverA observer3 = new ObserverA();

        //将三个观察者绑定到目标对象
        subject.register(observer1);
        subject.register(observer2);
        subject.register(observer3);

        //改变subject的状态
        subject.setState(10);

        System.out.println(observer1.getMyState());
        System.out.println(observer2.getMyState());
        System.out.println(observer3.getMyState());

        subject.setState(100);
        System.out.println(observer1.getMyState());
        System.out.println(observer2.getMyState());
        System.out.println(observer3.getMyState());
    &#125;
&#125;
</code></pre>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>用于保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</p>
<h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Originator</code>源发器类：要做备份的内容，其中有方法负责创建一个备忘录，用以记录当前时刻它的内部状态，并可以使用备忘录恢复到内部状态</li>
<li><code>Memonto</code>备忘录类，负责存储<code>Originator</code>对象的内部状态，并可防止<code>Originator</code>以外的其他对象访问</li>
<li><code>CareTaker</code>负责人类：负责保存好备忘录<code>Memento</code></li>
</ul>
<pre><code class="java">//源发器类
public class Emp &#123;
    private String name;
    private int age;
    private double salary;

    public Emp() &#123;
    &#125;

    public Emp(String name, int age, double salary) &#123;
        this.name = name;
        this.age = age;
        this.salary = salary;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public double getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;

    //进行备忘录操作
    public EmpMemento memento()&#123;
        return new EmpMemento(this);
    &#125;

    //进行恢复操作
    public void recovery(EmpMemento memento)&#123;
        name = memento.getName();
        age = memento.getAge();
        salary = memento.getSalary();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Emp&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;
&#125;

//备忘录类
public class EmpMemento &#123;
    private String name;
    private int age;
    private double salary;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public double getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;

    public EmpMemento(Emp emp) &#123;
        name = emp.getName();
        age = emp.getAge();
        salary = emp.getSalary();
    &#125;
&#125;


/**
 * 负责人类
 */
public class CareTaker &#123;
    private EmpMemento memento;

    //可以设置容器存储多个备份点
//    private List&lt;EmpMemento&gt; mementoList = new ArrayList&lt;&gt;();
      //还可以使用栈，同时还可以设置序列化和持久化

    public EmpMemento getMemento() &#123;
        return memento;
    &#125;

    public void setMemento(EmpMemento memento) &#123;
        this.memento = memento;
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        CareTaker careTaker = new CareTaker();
        Emp emp = new Emp(&quot;多多&quot;,2,1000.12);
        EmpMemento memento = emp.memento();//创建一个备忘录
        careTaker.setMemento(memento);//存储备忘录

        System.out.println(&quot;第一次打印：&quot;+emp);

        emp.setAge(1);
        emp.setSalary(2000);
        System.out.println(&quot;第二次打印：&quot;+emp);

        emp.recovery(careTaker.getMemento());
        System.out.println(&quot;第三次打印：&quot;+emp);
    &#125;
&#125;
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/07/24/Nginx%E6%9E%B6%E6%9E%84/" rel="prev" title="Nginx架构">
                  <i class="fa fa-chevron-left"></i> Nginx架构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/07/30/Docker/" rel="next" title="Docker">
                  Docker <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:50</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
