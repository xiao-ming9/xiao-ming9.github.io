<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="概览23种设计模式主要可以分为三种类型：  创建型模式：用来创建对象单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结 构，用来解决更大的问题。（关注对象和类的组成关系）适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模 式。 行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，">
<meta name="keywords" content="java,设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="GOF23">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;07&#x2F;29&#x2F;GOF23&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="概览23种设计模式主要可以分为三种类型：  创建型模式：用来创建对象单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结 构，用来解决更大的问题。（关注对象和类的组成关系）适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模 式。 行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-01T10:36:59.560Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/07/29/GOF23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>GOF23 | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/GOF23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GOF23
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-29 08:58:56" itemprop="dateCreated datePublished" datetime="2019-07-29T08:58:56+08:00">2019-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-01 18:36:59" itemprop="dateModified" datetime="2020-12-01T18:36:59+08:00">2020-12-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>35 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>23种设计模式主要可以分为三种类型：</p>
<ol>
<li>创建型模式：用来创建对象<br>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</li>
<li>结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结 构，用来解决更大的问题。（关注对象和类的组成关系）<br>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模 式。</li>
<li>行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责<br>模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模 式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。<a id="more"></a>

</li>
</ol>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ol>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要 比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动 时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
<li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计 一个单例类，负责所有数据表的映射处理<h2 id="常见的五种单例模式实现方式"><a href="#常见的五种单例模式实现方式" class="headerlink" title="常见的五种单例模式实现方式"></a>常见的五种单例模式实现方式</h2></li>
</ol>
<ul>
<li>饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li>懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
<li>双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）</li>
<li>静态内部类式(线程安全，调用效率高。 但是，可以延时加载) </li>
<li>枚举单例(线程安全，调用效率高，不能延时加载)</li>
</ul>
<h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><p>类初始化时立即加载这个对象</p>
<pre><code class="java">public class SingletonDemo1 {
      //类初始化时，立即加载这个对象。
      //加载类时，天然是线程安全的
    private static SingletonDemo1 instance = new SingletonDemo1();
      //私有化构造器
    private SingletonDemo1(){
    }
      //方法没有同步，调用效率高
    public static SingletonDemo1 getInstance(){
        return instance;
    }
}</code></pre>
<p>饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略<code>synchronized</code>关键字。<br>如果只是加载本类，而不是要调用<code>getInstance()</code>，甚至永远没有调用，则会造成资源浪费！</p>
<h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><p>单例对象延迟加载（懒加载），真正需要使用的时候才加载</p>
<pre><code class="java">package com.xm.singleton;

/**
 * 懒汉式延迟加载
 */
public class SingletonDemo2 {
    private static SingletonDemo2 instance;
    private SingletonDemo2(){}

    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance(){
        if(instance==null){
            instance = new SingletonDemo2();
        }
        return instance;
    }
}</code></pre>
<p>资源利用率高，但是，每次调用<code>getInstance()</code>方法都要<strong>同步</strong>，并发效率较低。</p>
<h3 id="双重检测锁实现"><a href="#双重检测锁实现" class="headerlink" title="双重检测锁实现"></a>双重检测锁实现</h3><p>这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了。</p>
<pre><code class="java">public class SingletonDemo3 {
    private static SingletonDemo3 instance=null;
    private SingletonDemo3(){}
    public static SingletonDemo3 getInstance(){
        if(instance==null){
            SingletonDemo3 singleton;
            synchronized (SingletonDemo3.class){
                singleton=instance;
                if(singleton == null){
                    synchronized (SingletonDemo3.class){
                        if(singleton == null){
                            singleton = new SingletonDemo3();
                        }
                    }
                    instance = singleton;
                }
            }
        }
        return instance;
    }
}</code></pre>
<p>由于编译器优化原因和JVM底层内部模型原因， 偶尔会出问题。不建议使用。</p>
<h3 id="静态内部类的实现"><a href="#静态内部类的实现" class="headerlink" title="静态内部类的实现"></a>静态内部类的实现</h3><p>静态内部类实现也是一种懒加载的方式</p>
<pre><code class="java">public class SingletonDemo4 {

    //静态内部类
    private static class SingletonClassInstance{
        private static final SingletonDemo4 instance = new SingletonDemo4();
    }

    public static SingletonDemo4 getInstance(){
        return SingletonClassInstance.instance;
    }

    private SingletonDemo4(){}
}</code></pre>
<p>优点：</p>
<ul>
<li>外部类没有<code>static</code>属性，则不会像饿汉式那样立即加载对象。</li>
<li>只有真正调用<code>getInstance()</code>,才会加载静态内部类。<strong>加载类时是线程安全的</strong>。 <code>instance</code>是<code>static final</code>类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.</li>
<li>兼备了并发高效调用和延迟加载的优势</li>
</ul>
<h3 id="使用枚举的实现"><a href="#使用枚举的实现" class="headerlink" title="使用枚举的实现"></a>使用枚举的实现</h3><pre><code class="java">public enum SingletonDemoe5 {
    //这个枚举元素，本身就是单例对象
    INSTANCE;

    //添加自己需要的操作
    public void singletonOperation(){

    }
}</code></pre>
<ul>
<li>实现简单 </li>
<li>枚举本身就是单例模式。由JVM从根本上提供保障，避免通过反射和反序列化的漏洞！ </li>
<li>缺点：无延迟加载</li>
</ul>
<h2 id="利用反射破解单例（针对枚举之外）"><a href="#利用反射破解单例（针对枚举之外）" class="headerlink" title="利用反射破解单例（针对枚举之外）"></a>利用反射破解单例（针对枚举之外）</h2><pre><code class="java">/**
 * 懒汉式反射反序列化破解
 */
public class Client {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        SingletonDemo2 s1 = SingletonDemo2.getInstance();
        SingletonDemo2 s2 = SingletonDemo2.getInstance();

        System.out.println(s1);
        System.out.println(s2);

        Class&lt;SingletonDemo2&gt; singletonDemo2Class = (Class&lt;SingletonDemo2&gt;) Class.forName(&quot;com.xm.singleton.SingletonDemo2&quot;);
        //获取无参构造方法
        Constructor&lt;SingletonDemo2&gt; constructor = singletonDemo2Class.getDeclaredConstructor(null);
        constructor.setAccessible(true);//忽略权限修饰符
        SingletonDemo2 s3 = constructor.newInstance();//通过newInstance创建对象
        SingletonDemo2 s4 = constructor.newInstance();//通过newInstance创建对象

        System.out.println(s3);
        System.out.println(s4);
    }
}</code></pre>
<p><strong>解决方案</strong>：在调用构造方法时，如果实例已经存在则抛出异常</p>
<pre><code class="java">/**
 * 懒汉式延迟加载
 */
public class SingletonDemo2 {
    private static SingletonDemo2 instance;
    private SingletonDemo2(){
          //避免反射破解
        if(instance != null){
            throw new RuntimeException();
        }
    }

    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance(){
        if(instance==null){
            instance = new SingletonDemo2();
        }
        return instance;
    }
}</code></pre>
<h2 id="利用序列化破解单例（针对枚举之外）"><a href="#利用序列化破解单例（针对枚举之外）" class="headerlink" title="利用序列化破解单例（针对枚举之外）"></a>利用序列化破解单例（针对枚举之外）</h2><pre><code class="java">public class Client2 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        SingletonDemo2 s1 = SingletonDemo2.getInstance();
        System.out.println(s1);

        //通过反序列化的方式构造多个对象
        //序列化
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);
        oos.close();
        fos.close();

        //反序列化
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;));
        SingletonDemo2 s2 = (SingletonDemo2)ois.readObject();
        System.out.println(s2);
    }
}</code></pre>
<p><strong>解决方案</strong>：在类中定义<code>readResolve()</code>方法，反序列化时，如果定义了该方法，则直接返回此方法指定的对象，不需要再单独创建新对象</p>
<pre><code class="java">public class SingletonDemo2 implements Serializable {
    private static SingletonDemo2 instance;
    private SingletonDemo2(){
        if(instance != null){
            throw new RuntimeException();
        }
    }

    //方法同步,调用效率低
    public static synchronized SingletonDemo2 getInstance(){
        if(instance==null){
            instance = new SingletonDemo2();
        }
        return instance;
    }

    private Object readResolve(){
        return instance;
    }
}</code></pre>
<h2 id="利用多线程测试"><a href="#利用多线程测试" class="headerlink" title="利用多线程测试"></a>利用多线程测试</h2><p>借助同步辅助类<code>CountDownLatch</code>,在完成一组正在其他线程中执行的操作之前，它允许一 个或多个线程一直等待。</p>
<ul>
<li><p><code>countDown()</code> 当前线程调此方法，则计数减一(建议放在 finally里执行)</p>
</li>
<li><p><code>await()</code>， 调用此方法会一直阻塞当前线程，直到计时器的值为0</p>
<pre><code class="java">public class Client3 {
  public static void main(String[] args) throws InterruptedException {
      long start = System.currentTimeMillis();
      int threadNum = 10;
        //初始计数器为10
      CountDownLatch countDownLatch = new CountDownLatch(threadNum);

      for(int i=0;i&lt;threadNum;i++){
          new Thread(new Runnable() {
              @Override
              public void run() {
                  for(int i=0;i&lt;10000000;i++){
//                        Object o = SingletonDemo4.getInstance();
                      Object o = SingletonDemo5.INSTANCE;
                  }
                  countDownLatch.countDown();
              }
          }).start();
      }
      countDownLatch.await();

      long end = System.currentTimeMillis();
      System.out.println(end-start);
  }
}</code></pre>
<blockquote>
<p>如果不使用CountDownLatch工具类，main进程在创建出子进程后，会继续往下执行，不会等待子进程执行结束，会造成<code>end</code>记录的时间不是正确的结束时间，而是main进程执行到这里的时间  </p>
</blockquote>
</li>
</ul>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式实现了创建者和调用者分离，本质上是实例化对象，用工厂方法代替new操作。 同时，将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦<br>工厂模式可以分为三类：</p>
<ul>
<li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法， 通过接收的参数的不同来返回不同的对象实例。 其缺陷是对于增加新产品无能为力，不修改代码的话，是无法扩展的。</p>
<pre><code class="java">//汽车接口
public interface Car {
    void run();
}

//汽车接口的实现类
public class Audi implements Car {
    @Override
    public void run() {
        System.out.println(&quot;奥迪汽车&quot;);
    }
}
public class Byd implements Car {
    @Override
    public void run() {
        System.out.println(&quot;比亚迪汽车&quot;);
    }
}

//简单工厂
public class CarFactory {
    public static Car createCar(String type){
        if(&quot;奥迪&quot;.equals(type)){
            return new Audi();
        }else if(&quot;比亚迪&quot;.equals(type)){
            return new Byd();
        }else{
            return null;
        }
    }
}
public class CarFactory2 {
    public static Car createAudi(){
        return new Audi();
    }

    public static Car createByd(){
        return new Byd();
    }
}

/**
 * 简单工厂调用
 */
public class Client {
    public static void main(String[] args) {
        Car car1 = CarFactory.createCar(&quot;奥迪&quot;);
        Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);

        car1.run();
        car2.run();
    }
}</code></pre>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。</p>
<pre><code class="java">//统一工厂接口
public interface CarFactory {
    Car createCar();
}

//不同的汽车创建不同的工厂实现类
public class AudiFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Audi();
    }
}
public class BydFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Byd();
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        Car car1 = new AudiFactory().createCar();
        Car car2 = new BydFactory().createCar();

        car1.run();
        car2.run();
    }
}</code></pre>
<blockquote>
<p>根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。  </p>
</blockquote>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>针对的是产品族，用来生产不同产品族的全部产品。（对于增加新的产品，无能为力； 支持增加产品族）。在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p>
<pre><code class="java">//产品群接口
public interface Engine {
    void run();
    void start();
}
public interface Seat {
    void message();
}
public interface Tyre {
    void revolve();
}


//产品群接口实现类
public class LuxuryEngine implements Engine {

    @Override
    public void run() {
        System.out.println(&quot;高端发动机run&quot;);
    }

    @Override
    public void start() {
        System.out.println(&quot;高端发动机start&quot;);
    }
}
public class LowEngine implements Engine {
    @Override
    public void run() {
        System.out.println(&quot;低端发动机run&quot;);
    }

    @Override
    public void start() {
        System.out.println(&quot;低端发动机start&quot;);
    }
}

public class LuxurySeat implements Seat {
    @Override
    public void message() {
        System.out.println(&quot;高端椅子&quot;);
    }
}
public class LowSeat implements Seat {
    @Override
    public void message() {
        System.out.println(&quot;低端椅子&quot;);
    }
}

public class LuxuryTyre implements Tyre {
    @Override
    public void revolve() {
        System.out.println(&quot;高端轮胎&quot;);
    }
}
public class LowTyre implements Tyre {
    @Override
    public void revolve() {
        System.out.println(&quot;低端轮胎&quot;);
    }
}


//工厂接口
public class LowTyre implements Tyre {
    @Override
    public void revolve() {
        System.out.println(&quot;低端轮胎&quot;);
    }
}

//工厂接口的实现：针对不同产品组合
public class LuxuryCarFactory implements CarFactory {
    @Override
    public Engine createEngine() {
        return new LuxuryEngine();
    }

    @Override
    public Seat createSeat() {
        return new LuxurySeat();
    }

    @Override
    public Tyre createTyre() {
        return new LuxuryTyre();
    }
}

public class LowCarFactory implements CarFactory {
    @Override
    public Engine createEngine() {
        return new LowEngine();
    }

    @Override
    public Seat createSeat() {
        return new LowSeat();
    }

    @Override
    public Tyre createTyre() {
        return new LowTyre();
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        CarFactory factory = new LuxuryCarFactory();
        Engine engine = factory.createEngine();
        engine.run();
        engine.start();
    }
}</code></pre>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>当某个类的创建需要很多的其他类组成时，可以使用建造者模式<br><strong>建造者模式的本质</strong>：</p>
<ul>
<li>分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象； 相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
</ul>
<pre><code class="java">/**
 * 建造飞船
 */
public class AirShip {
    private Engine engine;//发动机
    private OrbitalModule orbitalModule;//轨道舱
    private ExcapeTower excapeTower;//逃逸塔

    //一下省略getter，setter和toString方法
}

class Engine{
    private String name;

    public Engine(String name) {
        this.name = name;
    }
}
class OrbitalModule{
    private String name;

    public OrbitalModule(String name) {
        this.name = name;
    }
}
class ExcapeTower{
    private String name;

    public ExcapeTower(String name) {
        this.name = name;
    }
}


//构建组件
public interface AirShipBuilder {
    Engine builderEngine();
    OrbitalModule builderOrbitalModule();
    ExcapeTower builderExcapeTower();
}

//对组件进行组装
public interface AirShipDirector {
    AirShip directAirShip();
}


//创建具体需要的组件（实现类）
public class XMAirShipBuilder implements AirShipBuilder {

    @Override
    public Engine builderEngine() {
        System.out.println(&quot;构造小铭发动机&quot;);
        return new Engine(&quot;小铭发动机&quot;);
    }

    @Override
    public OrbitalModule builderOrbitalModule() {
        System.out.println(&quot;构造小铭轨道舱&quot;);
        return new OrbitalModule(&quot;小铭轨道舱&quot;);
    }

    @Override
    public ExcapeTower builderExcapeTower() {
        System.out.println(&quot;构造小铭逃逸塔&quot;);
        return new ExcapeTower(&quot;小铭逃逸塔&quot;);
    }
}


//对组件进行组装
public class XMAirShipDirector implements AirShipDirector {

    private XMAirShipBuilder builder;

    public XMAirShipDirector(XMAirShipBuilder builder) {
        this.builder = builder;
    }

    @Override
    public AirShip directAirShip() {
        //通过使用builder来获取子组件
        Engine engine = builder.builderEngine();
        OrbitalModule orbitalModule = builder.builderOrbitalModule();
        ExcapeTower excapeTower = builder.builderExcapeTower();

        //对组件进行组装
        AirShip airShip = new AirShip();
        airShip.setEngine(engine);
        airShip.setOrbitalModule(orbitalModule);
        airShip.setExcapeTower(excapeTower);

        return airShip;
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        XMAirShipDirector director = new XMAirShipDirector(new XMAirShipBuilder());
        AirShip airShip = director.directAirShip();
        System.out.println(airShip);
    }
}</code></pre>
<h1 id="原型模式（prototype）"><a href="#原型模式（prototype）" class="headerlink" title="原型模式（prototype）"></a>原型模式（prototype）</h1><p>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>实际上原型模式就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 。其优势为：效率高(直接克隆，避免了重新执行构造过程步骤) 。<br>克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后， 再修改克隆对象的值。</p>
<blockquote>
<p>克隆产生的是一个新对象  </p>
</blockquote>
<h2 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h2><p>当对象的属性中有引用变量时，实际上克隆后的对象跟原对象所指向的是同一个地址，如果此时修改引用变量的值，会使两个对象的引用变量都发生改变，这就是浅克隆；可以将引用变量也做一份克隆，这就是深克隆（也叫深复制）。</p>
<pre><code class="java">public class Sheep implements Cloneable{
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        //深克隆添加如下代码：
        Sheep sheep = (Sheep)obj;
        sheep.birthday = (Date) this.birthday.clone();//把属性也进行克隆
        return sheep;
    }

    public Sheep(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

      //省略getter，setter和toString方法
}


//客户端操作
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date(System.currentTimeMillis());
        Sheep sheep1 = new Sheep(&quot;多莉&quot;,date);
        Sheep sheep2 = (Sheep) sheep1.clone();

        date.setTime(23490738574947548L);//改变时间值，如果是浅克隆，两个都会改变

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep1 == sheep2);
    }
}</code></pre>
<h2 id="利用序列化和反序列化技术实现深克隆"><a href="#利用序列化和反序列化技术实现深克隆" class="headerlink" title="利用序列化和反序列化技术实现深克隆"></a>利用序列化和反序列化技术实现深克隆</h2><p>不使用java的clone技术，而使用序列化和反序列化</p>
<pre><code class="java">package com.xm.prototype;

import java.io.*;
import java.util.Date;

public class Client2 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Date date = new Date(System.currentTimeMillis());
        Sheep sheep1 = new Sheep(&quot;多莉&quot;,date);

        //序列化sheep1
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(sheep1);//把sheep1写入baos
        byte[] bytes = baos.toByteArray();

        //反序列化创建出克隆对象
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bais);
        Sheep sheep2 = (Sheep) ois.readObject();

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep1==sheep2);

        date.setTime(485974938756438L);
        System.out.println(&quot;————————————更改时间——————————&quot;);
        System.out.println(sheep1);
        System.out.println(sheep2);
    }
}</code></pre>
<h2 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h2><pre><code class="java">public class Client3 {
    public static void main(String[] args) throws CloneNotSupportedException {
        testNew(1000);
        testClone(1000);
    }

    public static void testNew(int size){
        long start = System.currentTimeMillis();
        for(int i=0;i&lt;size;i++){
            new Laptop();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;new方式耗时：&quot;+ (end-start));
    }

    public static void testClone(int size) throws CloneNotSupportedException {
        long start = System.currentTimeMillis();
        Laptop l = new Laptop();
        for(int i=0;i&lt;size;i++){
            Laptop laptop = (Laptop) l.clone();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;clone方式耗时：&quot;+(end-start));
    }
}

class Laptop implements Cloneable{
    public Laptop(){
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</code></pre>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原 本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<h2 id="适配器模式中的角色"><a href="#适配器模式中的角色" class="headerlink" title="适配器模式中的角色"></a>适配器模式中的角色</h2><ul>
<li>目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</li>
<li>需要适配的类（Adaptee）：需要适配的类或适配者类，客户端需要调用该类，但是没有接口可以调用，需要被适配。</li>
<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>适配器模式的实现有<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器的局限是只能使用适配一个类，对象适配器可以适配多个<pre><code class="java">/**
* 需要被适配的类
*/
public class Adaptee {
  public void request(){
      System.out.println(&quot;可以完成客户请求所需要的功能&quot;);
  }
}
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>客户端所期待的接口</li>
<li>/<br>public interface Target {<br>  void handleReq();<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><p>适配器：类适配器</p>
</li>
<li><p>/<br>public class Adapter extends Adaptee implements Target {</p>
<p>  @Override<br>  public void handleReq() {</p>
<pre><code>  super.request();</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>适配器：对象适配器</p>
</li>
<li><p>/<br>public class Adapter2 implements Target {</p>
<p>  private  Adaptee adaptee;</p>
<p>  public Adapter2(Adaptee adaptee) {</p>
<pre><code>  this.adaptee = adaptee;</code></pre><p>  }</p>
<p>  @Override<br>  public void handleReq() {</p>
<pre><code>  adaptee.request();</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>客户端类</p>
</li>
<li><p>/<br>public class Client {<br>  public void test(Target target){</p>
<pre><code>  target.handleReq();</code></pre><p>  }</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  Client client = new Client();
  Adaptee adaptee = new Adaptee();
  Target target1 = new Adapter();
  Target target2 = new Adapter2(adaptee);
  client.test(target1);
  client.test(target2);</code></pre><p>  }<br>}</p>
<pre><code># 代理模式
通过代理，控制对对象的访问！可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现！）代理模式可以分为静态代理和动态代理。
AOP(Aspect Oriented Programming面向切面编程)的核心实现机制！
## 代理模式中的核心角色
* 抽象角色：定义代理角色和真实角色的公共对外方法
* 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。（关注真正的业务逻辑）
* 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。（将统一的流程控制放到代理角色中处理！）
</code></pre></li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="静态代理：代理类需要自己创建"><a href="#静态代理：代理类需要自己创建" class="headerlink" title="静态代理：代理类需要自己创建"></a>静态代理：代理类需要自己创建</h3><pre><code class="java">//抽象角色
public interface Star {
    void confer();//面谈
    void signContract();//签合同
    void bookTicket();//订票
    void sing();//唱歌
    void collectMoney();//收钱
}

//真实角色
public class RealStar implements Star {
    @Override
    public void confer() {
        System.out.println(&quot;realstar.confer()&quot;);
    }

    @Override
    public void signContract() {
        System.out.println(&quot;realstar.signContract()&quot;);
    }

    @Override
    public void bookTicket() {
        System.out.println(&quot;realstar.bookTicker()&quot;);
    }

    @Override
    public void sing() {
        System.out.println(&quot;realstar.sing()&quot;);
    }

    @Override
    public void collectMoney() {
        System.out.println(&quot;realstar.collectMoney()&quot;);
    }
}

//代理角色
public class ProxyStar implements Star {

    private Star star;//代理的对象

    public ProxyStar(Star star) {
        this.star = star;
    }

    @Override
    public void confer() {
        System.out.println(&quot;ProxyStar.confer&quot;);
    }

    @Override
    public void signContract() {
        System.out.println(&quot;ProxyStar.signContract&quot;);
    }

    @Override
    public void bookTicket() {
        System.out.println(&quot;ProxyStar.bookTicket&quot;);
    }

    @Override
    public void sing() {
        //这里需要真实角色的功能
        star.sing();
    }

    @Override
    public void collectMoney() {
        System.out.println(&quot;ProxyStar.collectMoney&quot;);
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        Star realStar = new RealStar();
        Star proxyStar = new ProxyStar(realStar);

        proxyStar.confer();
        proxyStar.signContract();
        proxyStar.bookTicket();
        proxyStar.sing();//此时调用真实角色
        proxyStar.collectMoney();
    }
}</code></pre>
<h3 id="动态代理：代理类动态生成"><a href="#动态代理：代理类动态生成" class="headerlink" title="动态代理：代理类动态生成"></a>动态代理：代理类动态生成</h3><p>实现的方式有以下几种：</p>
<ul>
<li>JDK自带的动态代理</li>
<li>javaassist字节码操作库实现</li>
<li>CGLIB </li>
<li>ASM(底层使用指令，可维护性较差)</li>
</ul>
<p><strong>JDK实现动态代理</strong></p>
<pre><code class="java">//抽象角色
public interface Star {
    void confer();//面谈
    void signContract();//签合同
    void bookTicket();//订票
    void sing();//唱歌
    void collectMoney();//收钱
}

//真实角色
public class RealStar implements Star {
    @Override
    public void confer() {
        System.out.println(&quot;realstar.confer()&quot;);
    }

    @Override
    public void signContract() {
        System.out.println(&quot;realstar.signContract()&quot;);
    }

    @Override
    public void bookTicket() {
        System.out.println(&quot;realstar.bookTicker()&quot;);
    }

    @Override
    public void sing() {
        System.out.println(&quot;realstar.sing()&quot;);
    }

    @Override
    public void collectMoney() {
        System.out.println(&quot;realstar.collectMoney()&quot;);
    }
}

//动态代理处理器
public class StarHandler implements InvocationHandler {

    Star realStar;

    public StarHandler(Star realStar) {
        this.realStar = realStar;
    }

    @Override
    /**
     *
     * @param proxy 代理类对象
     * @param method 被代理对象的方法
     * @param args 方法的参数
     * @return
     * @throws Throwable
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object object = null;
        System.out.println(&quot;真正的方法执行前。。。&quot;);
        System.out.println(&quot;面谈，签合同，预付款，订票&quot;);
        if(method.getName().equals(&quot;sing&quot;)){
            object = method.invoke(realStar, args);//激活调用方法
        }
        System.out.println(&quot;真正的方法执行后&quot;);
        System.out.println(&quot;收尾款&quot;);
        return object;
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);

        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Star.class},handler);

        //会调用invoke方法
        proxy.bookTicket();
        proxy.sing();

    }
}</code></pre>
<blockquote>
<p>通过Proxy生成的代理类内部会有一个<code>handler</code>属性，调用方法时，实际上都会传到使用<code>handler</code>中的<code>invoke</code>方法，将当前类，当前方法和变量传入到<code>invoke</code>中  </p>
</blockquote>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>用于处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。<br>桥接模式可以取代多层继承的方案。 多层继承违背了单一职责原则， 复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个 数，从而降低管理和维护的成本。极大的提高了系统可扩展性，在两个变化维度中任意扩展一 个维度，都不需要修改原有的系统，符合开闭原则。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>其实现核心是在主类中将其中一个或多个维度作为自身属性<br>例如电脑可以分为笔记本，台式，平板，又可以有多个牌子，如果采用多层继承，如果增加一个牌子，需要分别增加对应不同笔记本类型的类</p>
<pre><code class="java">//牌子接口
public interface Brand {
    void sale();
}
//不同的牌子
public class Mac implements Brand {
    @Override
    public void sale() {
        System.out.println(&quot;苹果电脑&quot;);
    }
}
public class Dell implements Brand {
    @Override
    public void sale() {
        System.out.println(&quot;戴尔电脑&quot;);
    }
}

//电脑类型父类
public class Computer {
     protected Brand brand;//引入品牌变量作为桥梁

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void sale(){
         brand.sale();
     }
}
//不同的电脑类型
public class Desktop extends Computer {

    public Desktop(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println(&quot;台式机&quot;);
    }
}
public class Laptop extends Computer {

    public Laptop(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println(&quot;笔记本&quot;);
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        Computer computer = new Laptop(new Mac());
        computer.sale();
    }
}</code></pre>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式为处理<strong>树形结构</strong>提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员， 并调用执行。其中，使用了<strong>递归调用</strong>的机制对整个结构进行处理。适用于把部分和整体的关系能够用<strong>树形结构</strong>表示的情况，从而使客户端可以使用统一的方式处理部分对象和整体对象。 </p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>抽象构件(Component)角色: 定义了叶子和容器构件的共同点</li>
<li>叶子(Leaf)构件角色：无子节点</li>
<li>容器(Composite)构件角色： 有容器特征，可以包含子节点</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>模拟病毒文件和文件夹查杀：</p>
<pre><code class="java">/**
 * 抽象构建
 */
public interface AbstractFile {
    void killVirus();
}

/**
 * 相当于叶子构建角色
 */
public class ImageFile implements AbstractFile {

    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    @Override
    public void killVirus() {
        System.out.println(&quot;图像文件 &quot;+name+&quot;:开始查杀！&quot;);
    }
}
public class TextFile implements AbstractFile {

    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    @Override
    public void killVirus() {
        System.out.println(&quot;文本文件 &quot;+name+&quot;:开始查杀！&quot;);
    }
}

/**
 * 相当于容器构建角色
 */
public class FolderFile implements AbstractFile {

    private String name;
    List&lt;AbstractFile&gt; fileList = new ArrayList&lt;&gt;();//文件夹下的文件

    public FolderFile(String name) {
        this.name = name;
    }

    public void add(AbstractFile file){
        fileList.add(file);
    }

    public void remove(AbstractFile file){
        fileList.remove(file);
    }

    public AbstractFile getFile(int index){
        AbstractFile file = fileList.get(index);
        return file;
    }

    @Override
    public void killVirus() {
        System.out.println(&quot;文件夹 &quot;+name+&quot;:开始查杀！&quot;);
        for (AbstractFile file : fileList) {
            file.killVirus();//天然递归
        }
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        AbstractFile f1,f2;
        f1 = new ImageFile(&quot;照片.jpg&quot;);
        f2 = new TextFile(&quot;文本.txt&quot;);
        FolderFile f3 = new FolderFile(&quot;文件夹&quot;);
        FolderFile f4 = new FolderFile(&quot;文件夹2&quot;);

        f3.add(f1);
        f3.add(f2);

        f4.add(f1);
        f4.add(f2);
        f4.add(f3);

        f1.killVirus();
        f4.killVirus();
    }
}</code></pre>
<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p>
<ul>
<li>扩展对象功能，比继承灵活，不会导致类个数急剧增加</li>
<li>可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更 加强大的对象</li>
<li>具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加 新的具体构件子类和具体装饰子类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>产生很多小对象。大量小对象占据内存，一定程度上影响性能。</li>
<li>装饰模式易于出错，调试排查比较麻烦。<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2></li>
<li>Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。</li>
<li>ConcreteComponent具体构件角色(真实对象)</li>
<li>Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象 。这样，就能在真实对象调用前后增加新的功能。</li>
<li>ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。</li>
</ul>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><pre><code class="java">/**
 * 抽象构建
 */
public interface ICar {
    void move();
}

/**
 * 被装饰对象，具体构建角色，真实对象
 */
public class Car implements ICar {
    @Override
    public void move() {
        System.out.println(&quot;能够在陆地上跑。&quot;);
    }
}

/**
 * Decorator装饰角色，具体装饰者的基类
 */
public class SuperCar implements ICar {

    protected ICar car;

    public SuperCar(ICar car) {
        this.car = car;
    }

    @Override
    public void move() {
        car.move();
    }
}

/**
 * ConcreteDecorator具体装饰角色,需要继承装饰角色
 */
public class FlyCar extends SuperCar {

    public FlyCar(ICar car) {
        super(car);
    }

    //新功能
    public void fly(){
        System.out.println(&quot;能够在天上飞&quot;);
    }

    @Override
    public void move() {
        super.move();
        fly();
    }
}
public class WaterCar extends SuperCar {

    public WaterCar(ICar car) {
        super(car);
    }

    public void swim(){
        System.out.println(&quot;能够在水上游。&quot;);
    }

    @Override
    public void move() {
        super.move();
        swim();
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        ICar car  = new Car();
        car.move();

        ICar car1 = new FlyCar(car);
        car1.move();

        ICar car2 = new WaterCar(new FlyCar(new Car()));
        car2.move();
    }
}</code></pre>
<blockquote>
<p><strong>装饰模式和桥接模式的区别</strong>：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。  </p>
</blockquote>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为子系统提供统一的入口（门面），封装子系统的复杂性，便于客户端调用。</p>
<pre><code class="java">public interface 工商局 {
    void checkName();
}
public class 揭阳工商局 implements 工商局 {
    @Override
    public void checkName() {
        System.out.println(&quot;在揭阳工商局检查名字是否有冲突！&quot;);
    }
}

public interface 质检局 {
    void orgCodeCertificate();
}
public class 揭阳质检局 implements 质检局 {
    @Override
    public void orgCodeCertificate() {
        System.out.println(&quot;在揭阳质检局办理组织机构代码证！&quot;);
    }
}

public interface 税务局 {
    void taxCertificate();
}
public class 揭阳税务局 implements 税务局 {
    @Override
    public void taxCertificate() {
        System.out.println(&quot;在揭阳税务局办理税务登记！&quot;);
    }
}

public interface 银行 {
    void openAccount();
}
public class 中国工商银行 implements 银行 {
    @Override
    public void openAccount() {
        System.out.println(&quot;在中国工商银行开户！&quot;);
    }
}

//门面
public class RegisterFacade {
    public void register(){
        工商局 a = new 揭阳工商局();
        质检局 b = new 揭阳质检局();
        税务局 c = new 揭阳税务局();
        银行 d = new 中国工商银行();

        a.checkName();
        b.orgCodeCertificate();
        c.taxCertificate();
        d.openAccount();
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        RegisterFacade facade = new RegisterFacade();
        facade.register();
    }
}</code></pre>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。<br>享元模式以共享的方式高效地支持大量细粒度对象的重用。享元对象能做到共享的关键是区分了<strong>内部状态</strong>和<strong>外部状态</strong>。</p>
<ul>
<li>内部状态：可以共享，不会随环境变化而改变</li>
<li>外部状态：不可以共享，会随环境变化而改变</li>
</ul>
<h2 id="享元模式的实现"><a href="#享元模式的实现" class="headerlink" title="享元模式的实现"></a>享元模式的实现</h2><ul>
<li><code>FlyweightFactory</code>享元工厂类:创建并管理享元对象，享元池一般设计成键值对</li>
<li><code>FlyWeight</code>抽象享元类:通常是一个接口或抽象类，声明公共方法，这些方法可以<strong>向外界提供对象的内部状态</strong>，同时可以<strong>设置外部状态</strong></li>
<li><code>ConcreteFlyWeight</code>具体享元类:为内部状态提供成员变量进行存储</li>
<li><code>UnsharedConcreteFlyWeight</code>非共享享元类:不能被共享的子类可以设计为非共享享元类</li>
</ul>
<pre><code class="java">/**
 * 外部状态，非共享享元类
 */
public class Coordinate {
    private int x,y;

    public Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }
}

/**
 * 享元抽象类
 */
public interface ChessFlyWeight {
    //向外提供访问内部状态
    void setColor(String color);
    String getColor();

    void display(Coordinate c);//设置外部状态
}
/**
 * 具体享元类
 */
public class ChessConcreteFlyWeight implements ChessFlyWeight {

    private String color;//为内部状态提供成员变量进行存储

    public ChessConcreteFlyWeight(String color) {
        this.color = color;
    }

    @Override
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String getColor() {
        return color;
    }

    @Override
    public void display(Coordinate c) {
        System.out.println(&quot;棋子颜色：&quot;+ color);
        System.out.println(&quot;棋子位置：&quot;+ c.getX() + &quot;:&quot; + c.getY());
    }
}

/**
 * 享元工厂
 */
public class ChessFlyWeightFactory {
    //享元池对象
    private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;&gt;();

    public static ChessFlyWeight getChess(String color){
        if(map.get(color) != null){
            return  map.get(color);
        }else{
            ChessFlyWeight chess = new ChessConcreteFlyWeight(color);
            map.put(color,chess);
            return chess;
        }
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        ChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;);
        ChessFlyWeight chess2 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;);
        System.out.println(chess1 == chess2);

        System.out.println(&quot;增加外部状态的处理--------&quot;);
        chess1.display(new Coordinate(10,12));
        chess2.display(new Coordinate(12,10));
    }
}</code></pre>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>极大减少内存中对象的数量</li>
<li>相同或相似对象内存中只存一份，极大的节约资源，提高系统性能</li>
<li>外部状态相对独立，不影响内部状态</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>模式较复杂，使程序逻辑复杂化</li>
<li>为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间</li>
</ul>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>将能够处理同一类请求的对象练成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果有则处理，如果不能则传递给链上的下一个对象。<br>由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类 库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。 符合开闭原则。</p>
<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>责任链的实现方法有两种：</p>
<ul>
<li>链表方式定义职责链</li>
<li>非链表方式实现职责链：通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。</li>
</ul>
<pre><code class="java">
//要处理的请求
public class LeaveRequest {
    private String empName;
    private int leaveDays;
    private String reason;

    public LeaveRequest(String empName, int leaveDays, String reason) {
        this.empName = empName;
        this.leaveDays = leaveDays;
        this.reason = reason;
    }

    public String getEmpName() {
        return empName;
    }

    public void setEmpName(String empName) {
        this.empName = empName;
    }

    public int getLeaveDays() {
        return leaveDays;
    }

    public void setLeaveDays(int leaveDays) {
        this.leaveDays = leaveDays;
    }

    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}

//责任链上对象的基类
public abstract class Leader {

    protected String name;
    protected Leader nextLeader;//责任链后继对象

    public Leader(String name) {
        this.name = name;
    }

    //设置责任链上的后继对象
    public void setNextLeader(Leader nextLeader) {
        this.nextLeader = nextLeader;
    }

    //处理请求的核心业务方法
    public abstract void handleRequest(LeaveRequest request);
}

public class Director extends Leader {

    public Director(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {
        if(request.getLeaveDays()&lt;3){
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：主任&quot;+this.name+&quot;,审批通过！&quot;);
        }else{
            if(this.nextLeader!=null){
                this.nextLeader.handleRequest(request);
            }
        }
    }
}
public class Manager extends Leader {

    public Manager(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {
        if(request.getLeaveDays()&lt;10){
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：经理&quot;+this.name+&quot;,审批通过！&quot;);
        }else{
            if(this.nextLeader!=null){
                this.nextLeader.handleRequest(request);
            }
        }
    }
}
public class GeneralManager extends Leader {

    public GeneralManager(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {
        if(request.getLeaveDays()&lt;30){
            System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason());
            System.out.println(&quot;审批人：总经理&quot;+this.name+&quot;,审批通过！&quot;);
        }else{
            System.out.println(&quot;请假&quot;+request.getLeaveDays()+&quot;天，直接辞职吧！&quot;);
        }
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        Leader leader1 = new Director(&quot;张三&quot;);
        Leader leader2 = new Manager(&quot;李四&quot;);
        Leader leader3 = new GeneralManager(&quot;王五&quot;);

        //组织责任链对象的关系
        leader1.setNextLeader(leader2);
        leader2.setNextLeader(leader3);

        //开启请假处理
        LeaveRequest request = new LeaveRequest(&quot;小铭&quot;,90,&quot;想出去玩！！！&quot;);
        leader1.handleRequest(request);
    }
}</code></pre>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式提供一种可以遍历聚合对象的方式。又称为：游标cursor模式</p>
<ul>
<li>聚合对象：存储数据</li>
<li>迭代器：遍历数据</li>
</ul>
<pre><code class="java">/**
 * 自定义的迭代器接口
 */
public interface MyIterator {
    void first();//将游标指向第一个元素
    void next();//将游标指向下一个元素
    boolean hasNext();//判断是否存在下一个元素
    boolean isFirst();//判断是否是第一个元素
    boolean isLast();//判断是否是最后一个元素
    Object getCurrentObj();//获得当前元素
}

/**
 * 自定义聚合类
 */
public class ConcreteMyAggregate {
    private List&lt;Object&gt; list = new ArrayList&lt;&gt;();

    public void addObject(Object o){
        list.add(o);
    }

    public void removeObject(Object o){
        list.remove(o);
    }

    public List&lt;Object&gt; getList() {
        return list;
    }

    public void setList(List&lt;Object&gt; list) {
        this.list = list;
    }

    public MyIterator createIterator(){
        return new MyConcreteIterator();
    }

    /**
     * 迭代器作为内部类
     */
    private class MyConcreteIterator implements MyIterator{

        private int cursor;//游标

        @Override
        public void first() {
            cursor = 0;
        }

        @Override
        public void next() {
            if(cursor &lt; list.size()){
                cursor++;
            }
        }

        @Override
        public boolean hasNext() {
            return cursor &lt; list.size();
        }

        @Override
        public boolean isFirst() {
            return cursor == 0;
        }

        @Override
        public boolean isLast() {
            return cursor == list.size()-1;
        }

        @Override
        public Object getCurrentObj() {
            return list.get(cursor);
        }
    }
}

public class Client {
    public static void main(String[] args) {
        ConcreteMyAggregate cma = new ConcreteMyAggregate();
        cma.addObject(&quot;abc&quot;);
        cma.addObject(&quot;123&quot;);
        cma.addObject(new ConcreteMyAggregate());

        MyIterator iterator = cma.createIterator();
        while (iterator.hasNext()){
            System.out.println(iterator.getCurrentObj());
            iterator.next();
        }
    }
}</code></pre>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系极其复杂，这些对象被称为<strong>同事对象</strong>，可以引入一个<strong>中介者对象</strong>，使各个同事只跟中介者对象打交道，将复杂的网络结构简单化<br>中介者模式解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系</p>
<pre><code class="java">/**
 * 抽象同事类
 */
public interface Department {
    void selfAction();//本部门内部事务
    void outAction();//向总经理发出申请
}

/**
 * 抽象中介者
 */
public interface Mediator {
    void register(String dname,Department d);//管理的相关部门
    void command(String dname);//向有关部门发出命令
}

//具体同事类
public class Development implements Department {

    private Mediator mediator;//持有中介者的引用

    public Development(Mediator mediator) {
        this.mediator = mediator;
        mediator.register(&quot;development&quot;,this);//使中介者拥有当前引用
    }

    @Override
    public void selfAction() {
        System.out.println(&quot;科研部内部事务&quot;);
    }

    @Override
    public void outAction() {
        System.out.println(&quot;科研部需要财务部拨钱&quot;);
        mediator.command(&quot;financial&quot;);
    }
}
public class Financial implements Department {
    private Mediator mediator;//持有中介者的引用

    public Financial(Mediator mediator) {
        this.mediator = mediator;
        mediator.register(&quot;financial&quot;,this);//使中介者拥有当前引用
    }

    @Override
    public void selfAction() {
        System.out.println(&quot;财务部内部事务&quot;);
    }

    @Override
    public void outAction() {
        System.out.println(&quot;财务部接收其他部门财务申请&quot;);
        mediator.command(&quot;development&quot;);
        mediator.command(&quot;market&quot;);
    }
}
public class Market implements Department {

    private Mediator mediator;//持有中介者的引用

    public Market(Mediator mediator) {
        this.mediator = mediator;
        mediator.register(&quot;market&quot;,this);//使中介者拥有当前引用
    }

    @Override
    public void selfAction() {
        System.out.println(&quot;市场部内部事务&quot;);
    }

    @Override
    public void outAction() {
        System.out.println(&quot;市场部需要财务部拨钱&quot;);
        mediator.command(&quot;financial&quot;);
    }
}

/**
 * 具体中介者对象（总经理）
 */
public class President implements Mediator {

    private Map&lt;String,Department&gt; map = new HashMap&lt;&gt;();

    @Override
    public void register(String dname, Department d) {
        map.put(dname, d);
    }

    @Override
    public void command(String dname) {
        map.get(dname).selfAction();
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        Mediator mediator = new President();//中介者对象

        Market market = new Market(mediator);
        Development development = new Development(mediator);
        Financial financial = new Financial(mediator);

        development.outAction();
        financial.outAction();
    }
}</code></pre>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Command</code>抽象命令类</li>
<li><code>ConcreteCommand</code>具体命令类</li>
<li><code>Invoker</code>请求的调用者/请求者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的<code>execute</code>方法，间接调用接受者的相关操作</li>
<li><code>Receiver</code>接收者：接收者执行与请求相关的操作，具体实现对请求的业务处理。（实际执行操作内容的对象）</li>
<li><code>Client</code>客户类，需要创建调用者对象，具体命令类对象，在创建具体命令类对象时指定对应的接受者。发送者和接收者之间没有直接关系，都通过命令对象间接调用</li>
</ul>
<pre><code class="java">/**
 * 真正的命令执行者
 */
public class Receiver {
    public void action(){
        System.out.println(&quot;真正的命令执行者！&quot;);
    }
}

/**
 * 命令抽象类
 */
public interface Command {

    /**
     * 这个方法是一个返回结果为空的方法
     * 实际项目中，可以根据需求设计多个不同的方法
     */
    void execute();
}

/**
 * 具体的命令类
 */
public class ConcreteCommand implements Command {

    private Receiver receiver;

    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        System.out.println(&quot;命令类调用前处理&quot;);
        receiver.action();
        System.out.println(&quot;命令类调用后处理&quot;);
    }
}

/**
 * 命令发起者
 */
public class Invoker {

    private Command command;//可以通过容器List容纳多个命令对象，进行批处理

    public Invoker(Command command) {
        this.command = command;
    }

    //调用命令类方法
    public void call(){
        System.out.println(&quot;命令发起者调用前处理&quot;);
        command.execute();
        System.out.println(&quot;命令发起者调用后处理&quot;);
    }
}


public class Client {
    public static void main(String[] args) {
        Command command = new ConcreteCommand(new Receiver());
        Invoker invoker = new Invoker(command);
        invoker.call();
    }
}</code></pre>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>是一种不常用的设计模式，用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。当我们需要开发一种新的语言时，可以考虑使用解释器模式。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。访问者模式表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</p>
<pre><code class="java">//策略接口
public interface Strategy {
    double getPrice(double standardPrice);
}
//各种不同的策略
public class NewCustomerFewStrategy implements Strategy {
    @Override
    public double getPrice(double standardPrice) {
        System.out.println(&quot;普通用户小批量，不打折&quot;);
        return standardPrice;
    }
}
public class NewCustomerManyStrategy implements Strategy {
    @Override
    public double getPrice(double standardPrice) {
        System.out.println(&quot;普通用户da批量，打9折&quot;);
        return standardPrice*0.9;
    }
}
public class OldCustomerFewStrategy implements Strategy {
    @Override
    public double getPrice(double standardPrice) {
        System.out.println(&quot;老用户小批量，打85折&quot;);
        return standardPrice*0.85;
    }
}
public class OldCustromerManyStrategy implements Strategy {
    @Override
    public double getPrice(double standardPrice) {
        System.out.println(&quot;老用户大批量，打八折&quot;);
        return standardPrice*0.8;
    }
}

/**
 * 负责和具体的策略类交互，实现具体算法与客户端调用分离
 */
public class Context {
    private Strategy strategy;//当前采用的算法

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void printPrice(double price){
        double p = strategy.getPrice(price);
        System.out.println(&quot;最终价格：&quot;+p+&quot;元&quot;);
    }
}

//客户端
public class Client {
    public static void main(String[] args) {
        Strategy strategy = new OldCustomerFewStrategy();
        Context context = new Context(strategy);
        context.printPrice(2113211);
    }
}</code></pre>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>模版方法定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。<br>通常处理步骤在父类中定义好，具体实现延迟到子类中定义。子类不能调用父类，而通过父类调用子类，这些步骤在父类中已经写好，完全由父类控制整个过程，这个过程又叫做<strong>方法回调</strong>（钩子方法）</p>
<pre><code class="java">public abstract class BankTemplateMethod {

    public void takeNumber(){
        System.out.println(&quot;取号&quot;);
    }

    public abstract void transact();//办理具体的业务（钩子方法）

    public void evaluate(){
        System.out.println(&quot;评价本次服务&quot;);
    }

    /**
     * 模版方法，将基本操作组合在一起，子类一般不能重写
     */
    public final void process(){
        this.takeNumber();
        this.transact();
        this.evaluate();
    }
}

public class Client {
    public static void main(String[] args) {
        //可以采用匿名内部类的方式调用
        BankTemplateMethod btm = new BankTemplateMethod() {
            @Override
            public void transact() {
                System.out.println(&quot;取款&quot;);
            }
        };
        btm.process();
    }
}</code></pre>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题</p>
<h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Context</code>环境类：环境类中维护一个<code>State</code>对象，它定义了当前的状态。</li>
<li><code>State</code>抽象状态类</li>
<li><code>ConcreteState</code>具体状态类：每一个类封装了一个状态对应的行为</li>
</ul>
<pre><code class="java">/**
 * 状态抽象类
 */
public interface State {
    void handle();
}

public class FreeState implements State {
    @Override
    public void handle() {
        System.out.println(&quot;房间空闲，可预定！&quot;);
    }
}
public class BookedState implements State {
    @Override
    public void handle() {
        System.out.println(&quot;房间已经被预定！&quot;);
    }
}
public class CheckedState implements State {
    @Override
    public void handle() {
        System.out.println(&quot;房间已入驻，请勿打扰！&quot;);
    }
}

/**
 * 环境类:代表着当前的状态以及状态切换的核心方法
 */
public class HotelContext {
    private State state;

    public void setState(State state) {
        System.out.println(&quot;修改状态！&quot;);
        this.state = state;
        state.handle();
    }
}

public class Client {
    public static void main(String[] args) {
        HotelContext context = new HotelContext();
        context.setState(new FreeState());
        context.setState(new CheckedState());
    }
}</code></pre>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。<br>观察者模式主要用于1:N的通知。当一个对象（目标对象<code>Subject</code>或<code>Objservable</code>的状态变化时，它需要及时告知一系列对象（观察者对象<code>Observer</code>），令它们作出响应<br>通知观察者的方式有：</p>
<ul>
<li>推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收</li>
<li>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定</li>
</ul>
<pre><code class="java">/**
 * 目标类对象
 */
public class Subject {
    //存储所有观察者的集合
    protected List&lt;Observer&gt; list = new ArrayList&lt;&gt;();

    public void register(Observer observer){
        list.add(observer);
    }

    public void remove(Observer observer){
        list.remove(observer);
    }

    //通知所有的观察者更新状态
    public void notifyAllObservers(){
        for (Observer observer : list) {
            observer.update(this);
        }
    }
}

/**
 * 观察者
 */
public interface Observer {
    void update(Subject subject);
}

/**
 * 具体的目标类对象
 */
public class ConcreteSubject extends Subject {
    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        //目标对象值发生变化，通知所有观察者
        this.notifyAllObservers();
    }
}

/**
 * 具体的观察者对象
 */
public class ObserverA implements Observer {

    private int myState;//myState需要跟目标对象的state保持一致

    public int getMyState() {
        return myState;
    }

    public void setMyState(int myState) {
        this.myState = myState;
    }

    @Override
    public void update(Subject subject) {
        myState = ((ConcreteSubject) subject).getState();
    }
}

public class Client {
    public static void main(String[] args) {
        //目标对象
        ConcreteSubject subject = new ConcreteSubject();

        //创建多个观察者
        ObserverA observer1 = new ObserverA();
        ObserverA observer2 = new ObserverA();
        ObserverA observer3 = new ObserverA();

        //将三个观察者绑定到目标对象
        subject.register(observer1);
        subject.register(observer2);
        subject.register(observer3);

        //改变subject的状态
        subject.setState(10);

        System.out.println(observer1.getMyState());
        System.out.println(observer2.getMyState());
        System.out.println(observer3.getMyState());

        subject.setState(100);
        System.out.println(observer1.getMyState());
        System.out.println(observer2.getMyState());
        System.out.println(observer3.getMyState());
    }
}</code></pre>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>用于保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</p>
<h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><ul>
<li><code>Originator</code>源发器类：要做备份的内容，其中有方法负责创建一个备忘录，用以记录当前时刻它的内部状态，并可以使用备忘录恢复到内部状态</li>
<li><code>Memonto</code>备忘录类，负责存储<code>Originator</code>对象的内部状态，并可防止<code>Originator</code>以外的其他对象访问</li>
<li><code>CareTaker</code>负责人类：负责保存好备忘录<code>Memento</code></li>
</ul>
<pre><code class="java">//源发器类
public class Emp {
    private String name;
    private int age;
    private double salary;

    public Emp() {
    }

    public Emp(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    //进行备忘录操作
    public EmpMemento memento(){
        return new EmpMemento(this);
    }

    //进行恢复操作
    public void recovery(EmpMemento memento){
        name = memento.getName();
        age = memento.getAge();
        salary = memento.getSalary();
    }

    @Override
    public String toString() {
        return &quot;Emp{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;}&#39;;
    }
}

//备忘录类
public class EmpMemento {
    private String name;
    private int age;
    private double salary;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public EmpMemento(Emp emp) {
        name = emp.getName();
        age = emp.getAge();
        salary = emp.getSalary();
    }
}


/**
 * 负责人类
 */
public class CareTaker {
    private EmpMemento memento;

    //可以设置容器存储多个备份点
//    private List&lt;EmpMemento&gt; mementoList = new ArrayList&lt;&gt;();
      //还可以使用栈，同时还可以设置序列化和持久化

    public EmpMemento getMemento() {
        return memento;
    }

    public void setMemento(EmpMemento memento) {
        this.memento = memento;
    }
}

public class Client {
    public static void main(String[] args) {
        CareTaker careTaker = new CareTaker();
        Emp emp = new Emp(&quot;多多&quot;,2,1000.12);
        EmpMemento memento = emp.memento();//创建一个备忘录
        careTaker.setMemento(memento);//存储备忘录

        System.out.println(&quot;第一次打印：&quot;+emp);

        emp.setAge(1);
        emp.setSalary(2000);
        System.out.println(&quot;第二次打印：&quot;+emp);

        emp.recovery(careTaker.getMemento());
        System.out.println(&quot;第三次打印：&quot;+emp);
    }
}</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/24/Nginx%E6%9E%B6%E6%9E%84/" rel="prev" title="Nginx架构">
      <i class="fa fa-chevron-left"></i> Nginx架构
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/07/30/Docker/" rel="next" title="Docker">
      Docker <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例模式"><span class="nav-number">2.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#优点："><span class="nav-number">2.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的五种单例模式实现方式"><span class="nav-number">2.2.</span> <span class="nav-text">常见的五种单例模式实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#饿汉式实现"><span class="nav-number">2.2.1.</span> <span class="nav-text">饿汉式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#懒汉式实现"><span class="nav-number">2.2.2.</span> <span class="nav-text">懒汉式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双重检测锁实现"><span class="nav-number">2.2.3.</span> <span class="nav-text">双重检测锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态内部类的实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">静态内部类的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用枚举的实现"><span class="nav-number">2.2.5.</span> <span class="nav-text">使用枚举的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用反射破解单例（针对枚举之外）"><span class="nav-number">2.3.</span> <span class="nav-text">利用反射破解单例（针对枚举之外）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用序列化破解单例（针对枚举之外）"><span class="nav-number">2.4.</span> <span class="nav-text">利用序列化破解单例（针对枚举之外）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用多线程测试"><span class="nav-number">2.5.</span> <span class="nav-text">利用多线程测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#工厂模式"><span class="nav-number">3.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单工厂模式"><span class="nav-number">3.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂方法模式"><span class="nav-number">3.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">3.3.</span> <span class="nav-text">抽象工厂模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#建造者模式"><span class="nav-number">4.</span> <span class="nav-text">建造者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原型模式（prototype）"><span class="nav-number">5.</span> <span class="nav-text">原型模式（prototype）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浅克隆和深克隆"><span class="nav-number">5.1.</span> <span class="nav-text">浅克隆和深克隆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用序列化和反序列化技术实现深克隆"><span class="nav-number">5.2.</span> <span class="nav-text">利用序列化和反序列化技术实现深克隆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#效率测试"><span class="nav-number">5.3.</span> <span class="nav-text">效率测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#适配器模式"><span class="nav-number">6.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器模式中的角色"><span class="nav-number">6.1.</span> <span class="nav-text">适配器模式中的角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">6.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方式"><span class="nav-number">6.3.</span> <span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态代理：代理类需要自己创建"><span class="nav-number">6.3.1.</span> <span class="nav-text">静态代理：代理类需要自己创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理：代理类动态生成"><span class="nav-number">6.3.2.</span> <span class="nav-text">动态代理：代理类动态生成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#桥接模式"><span class="nav-number">7.</span> <span class="nav-text">桥接模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-1"><span class="nav-number">7.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合模式"><span class="nav-number">8.</span> <span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心"><span class="nav-number">8.1.</span> <span class="nav-text">核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-2"><span class="nav-number">8.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#装饰器模式"><span class="nav-number">9.</span> <span class="nav-text">装饰器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#优缺点"><span class="nav-number">9.1.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现细节"><span class="nav-number">9.2.</span> <span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-3"><span class="nav-number">9.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#外观模式"><span class="nav-number">10.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#享元模式"><span class="nav-number">11.</span> <span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#享元模式的实现"><span class="nav-number">11.1.</span> <span class="nav-text">享元模式的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优缺点-1"><span class="nav-number">11.2.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#责任链模式"><span class="nav-number">12.</span> <span class="nav-text">责任链模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-4"><span class="nav-number">12.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器模式"><span class="nav-number">13.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#中介者模式"><span class="nav-number">14.</span> <span class="nav-text">中介者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命令模式"><span class="nav-number">15.</span> <span class="nav-text">命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构"><span class="nav-number">15.1.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释器模式"><span class="nav-number">16.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问者模式"><span class="nav-number">17.</span> <span class="nav-text">访问者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#策略模式"><span class="nav-number">18.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模版方法模式"><span class="nav-number">19.</span> <span class="nav-text">模版方法模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态模式"><span class="nav-number">20.</span> <span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构-1"><span class="nav-number">20.1.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#观察者模式"><span class="nav-number">21.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#备忘录模式"><span class="nav-number">22.</span> <span class="nav-text">备忘录模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构-2"><span class="nav-number">22.1.</span> <span class="nav-text">结构</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34:37</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
