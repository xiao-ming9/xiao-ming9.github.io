

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="基本概念Docker包括三个基本概念：

镜像（Image）
容器（Container）
仓库（Repository）

镜像作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个root文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包">
  <meta name="author" content="Silverming">
  <meta name="keywords" content="">
  
  <title>Docker - Silverming</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"54ebb03ad7ad5b762ac8ff7958df6d3f","google":"G-M2RT7SDT3L","gtag":"G-M2RT7SDT3L","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tFHjJkaAYKqH8BIXKnJVurUc-MdYXbMMI","app_key":"1qR5F7XyydYd5YJtIpMJBFmP","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Silverming</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <!-- <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i -->
              <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
           <!-- <a class="nav-link" href="javascript:" target="_blank" rel="noopener">&nbsp;<i -->
             <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Docker">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-07-30 10:53" pubdate>
        2019年7月30日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2020年12月1日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个root文件系统。<br>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<br>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<a id="more"></a>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。<br>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a> 、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>类似于github，用于托管镜像。最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像。<br>仓库名经常以<em>两段式路径</em>形式出现，比如jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。</p>
<h1 id="macOS安装"><a href="#macOS安装" class="headerlink" title="macOS安装"></a>macOS安装</h1><p>使用<code>Homebrew</code>或者直接上官网下载.dmg文件</p>
<blockquote>
<p>brew cask install docker  </p>
</blockquote>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从Docker镜像仓库获取镜像的命令是<code>docker pull</code></p>
<figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">docker pull <span class="hljs-comment">[选项]</span> <span class="hljs-comment">[Docker Registry 地址<span class="hljs-comment">[:端口号]</span>/]</span>仓库名<span class="hljs-comment">[:标签]</span><br></code></pre></div></td></tr></table></figure>
<p>具体的选项可以通过<code>docker pull —help</code>命令看到</p>
<ul>
<li>Docker镜像仓库地址：格式一般为<code>&lt;域名/IP&gt;[:端口号]</code>,默认地址是Docker Hub</li>
<li>仓库名：两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>，对于Docker Hub，如果不给用户名，默认是<code>library</code>官方镜像</li>
</ul>
<p>示例：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">~ » docker pull <span class="hljs-string">ubuntu:</span><span class="hljs-number">18.04</span><br><span class="hljs-number">18.04</span>: Pulling from library/ubuntu<br><span class="hljs-number">7413</span><span class="hljs-string">c47ba209:</span> Pull complete <br><span class="hljs-number">0</span><span class="hljs-string">fe7e7cbb2e8:</span> Pull complete <br><span class="hljs-number">1</span><span class="hljs-string">d425c982345:</span> Pull complete <br><span class="hljs-number">344</span><span class="hljs-string">da5c95cec:</span> Pull complete <br><span class="hljs-string">Digest:</span> <span class="hljs-string">sha256:</span>c303f19cfe9ee92badbbbd7567bc1ca47789f79303ddcef56f77687d4744cd7a<br><span class="hljs-string">Status:</span> Downloaded newer image <span class="hljs-keyword">for</span> <span class="hljs-string">ubuntu:</span><span class="hljs-number">18.04</span><br></code></pre></div></td></tr></table></figure>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是<code>ubuntu:18.04</code>，因此将会获取官方镜像<code>library/ubuntu</code>仓库中标签为<code>18.04</code>的镜像。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">~ » docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--rm ubuntu:18.04 bash</span><br>root@<span class="hljs-number">52</span>c958411df6:/<span class="hljs-comment">#</span><br></code></pre></div></td></tr></table></figure>
<p>运行的命令是<code>docker run</code>,参数说明：</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是<code>-t</code>终端。这里打算进入bash执行一些命令并查看返回结果，因此需要交互式终端。</li>
<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动<code>docker rm</code>。这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用<code>—rm</code>可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>:这是指用<code>ubuntu:18.04</code>镜像为基础来启动容器。</li>
<li><code>bash</code>:放在镜像名后的是<strong>命令</strong>，这里希望有个交互式 Shell，因此用的是bash</li>
</ul>
<p>如果要退出该容器，可以使用<code>exit</code></p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>使用<code>docker image ls</code>命令可以列出已经下载的镜像</p>
<figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">~ » docker <span class="hljs-built_in">image</span> ls -a<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>nginx               latest              e445ab08b2be        <span class="hljs-number">19</span> hours ago        126MB<br>ubuntu              <span class="hljs-number">18.04</span>               <span class="hljs-number">3556258649b2</span>        <span class="hljs-number">24</span> hours ago        <span class="hljs-number">64.</span>2MB<br></code></pre></div></td></tr></table></figure>
<p>类别包含了<code>仓库名</code>，<code>标签</code>，<code>镜像ID</code>,<code>创建时间</code>以及<code>所占用的空间</code><br><strong>镜像 ID</strong>则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong>。<br>此处列出的体积是解压后展开后各层所占空间的综合。同时，列表中的镜像体积总和不一定是所有镜像实际消耗的硬盘，由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。<br>可以通过<code>docker system df</code>查看镜像，容器，数据卷所占用的空间</p>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>由于原本的镜像官方升级后，重新pull后镜像名会转移到新的镜像上，原有镜像就会成为虚悬镜像</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">&lt;none&gt;               &lt;none&gt;              <span class="hljs-number">00285</span>df0df87        <span class="hljs-number">5</span> days ago          <span class="hljs-number">342</span> MB<br></code></pre></div></td></tr></table></figure>
<p>可以通过<code>docker image ls -f dangling=true</code>专门显示这类镜像，这类镜像可以直接使用<code>docker image prune</code>删除掉</p>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用<strong>中间层镜像</strong>。可以加上<code>-a</code>参数显示<br>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。</p>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><ol>
<li>根据仓库名：<code>docker image ls ubuntu</code></li>
<li>列出特定的某个镜像，也就是说指定仓库名和标签：<code>docker image ls ubuntu:18.04</code></li>
<li>使用过滤器参数<code>--filter</code>或者简写<code>-f</code>,例如查看某个位置之前或者之后的镜像：<code>docker image ls -f since/before=mongo:3.2</code></li>
<li>以特定格式表示：</li>
</ol>
<ul>
<li><code>-q</code>：表示只列出ID</li>
</ul>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">docker image rm [选项] &lt;镜像<span class="hljs-number">1</span>&gt; [&lt;镜像<span class="hljs-number">2</span>&gt; ...]<br></code></pre></div></td></tr></table></figure>
<p>镜像可以是<code>长ID</code>，<code>短ID</code>，<code>镜像名</code>和<code>镜像摘要</code><br>默认显示的id是短ID，镜像名指的是<code>&lt;仓库名&gt;:&lt;标签&gt;</code>,<br>镜像摘要最为精确：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">~ » docker image ls --digests<br>REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE<br>ubuntu              <span class="hljs-number">18.04</span>               sha256:c303f19cfe9ee92badbbbd7567bc1ca47789f79303ddcef56f77687d4744cd7a   <span class="hljs-number">3556258649</span>b2        <span class="hljs-number">25</span> hours ago        <span class="hljs-number">64.2</span>MB<br><br>~ » docker image rm <span class="hljs-symbol">ubuntu@</span>sha256:c303f19cfe9ee92badbbbd7567bc1ca47789f79303ddcef56f77687d4744cd7a<br>Untagged: <span class="hljs-symbol">ubuntu@</span>sha256:c303f19cfe9ee92badbbbd7567bc1ca47789f79303ddcef56f77687d4744cd7a<br></code></pre></div></td></tr></table></figure>
<h3 id="Untagged和Deleted"><a href="#Untagged和Deleted" class="headerlink" title="Untagged和Deleted"></a>Untagged和Deleted</h3><p>当使用命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是我们看到的Untagged的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生。所以并非所有的<code>docker image rm</code>都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。<br>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。<br>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">docker image rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">image</span> <span class="hljs-params">ls</span> -<span class="hljs-params">q</span> <span class="hljs-params">redis</span>)</span><br>docker image rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">image</span> <span class="hljs-params">ls</span> -<span class="hljs-params">q</span> -<span class="hljs-params">f</span> <span class="hljs-params">before</span>=<span class="hljs-params">mongo</span>:3.2)</span><br></code></pre></div></td></tr></table></figure>

<h1 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<blockquote>
<p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。  </p>
</blockquote>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。<br>启动的命令是<code>docker run</code>，<code>-t</code>选项表示让Docker分配一个伪终端，并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开<br>当利用docker run来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><p>使用<code>docker container start</code>命令，直接将一个已经终止的容器启动运行</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>添加<code>-d</code>参数可以是容器以守护态在后台运行执行的命令，可以通过<code>docker container ls</code>命令来查看容器信息，如果要获取容器的输出信息，可以通过<code>docker container logs</code>命令</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>使用<code>docker container stop</code>可以终止一个运行的容器<br>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如在启动了一个终端的容器，当我们通过<code>exit</code>退出终端时，所创建的容器会立即终止。</p>
<figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> stop <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></div></td></tr></table></figure>
<p>处于终止状态的容器，可以通过<code>docker container start</code>命令重新启动，终止状态的容器可以通过<code>docker container ls -a</code>命令查看。<br><code>docker container restart</code>命令会将一个运行态的容器终止，然后在重新启动它</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>要进入在后台运行的容器，可以使用<code>docker attach</code>或者<code>docker exec</code>命令<br>区别：<code>attach</code>进入后exit，会导致容器停止，而<code>exec</code>不会<br>参数说明：<br><code>-i</code>:保持标准输入，即使没有分配伪终端，仍然可以对命令执行结果返回<br><code>-t</code>: 分配伪终端</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ docker run -dit ubuntu<br><span class="hljs-number">69</span>d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6<br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br><span class="hljs-number">69</span>d137adef7a        ubuntu:latest       <span class="hljs-string">"/bin/bash"</span>         <span class="hljs-number">18</span> seconds ago      Up <span class="hljs-number">17</span> seconds                           zealous_swirles<br><br>$ docker exec -i <span class="hljs-number">69</span>d1 bash<br>ls<br>bin<br>boot<br>dev<br>...<br><br>$ docker exec -it <span class="hljs-number">69</span>d1 bash<br><span class="hljs-symbol">root@</span><span class="hljs-number">69</span>d137adef7a:/#<br></code></pre></div></td></tr></table></figure>
<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><p>如果要导出某个容器快照文件到本地，可以使用<code>docker export</code>命令</p>
<figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">docker</span> ex<span class="hljs-keyword">port</span> CONTAINER ID &gt; xxx.tar<br></code></pre></div></td></tr></table></figure>
<p>使用<code>docker import</code>从容器快照文件中再导入为镜像</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">cat xxx.tar | docker <span class="hljs-keyword">import</span> - test/ubuntu:v1<span class="hljs-number">.0</span><br></code></pre></div></td></tr></table></figure>
<p>还可以通过指定URL或者某个目录来导入</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">docker <span class="hljs-keyword">import</span> <span class="hljs-string">http:</span><span class="hljs-comment">//example.com/exampleimage.tgz example/imagerepo</span><br></code></pre></div></td></tr></table></figure>
<p>注：<em>既可以使用<code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用<code>docker container rm</code>删除一个处于终止状态的容器</p>
<figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">docker <span class="hljs-keyword">container</span> rm containerName<br></code></pre></div></td></tr></table></figure>
<p><code>-f</code>参数可以删除运行中的容器，Docker会对其发送<code>SIGKILL</code>信号<br><code>dcoker container prune</code>可以删除所有处于终止状态的容器</p>
<h1 id="仓库-1"><a href="#仓库-1" class="headerlink" title="仓库"></a>仓库</h1><p>库（<code>Repository</code>）是集中存放镜像的地方。<br>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址<code>dl.dockerpool.com/ubuntu</code>来说，<code>dl.dockerpool.com</code>是注册服务器地址，<code>ubuntu</code>是仓库名。</p>
<blockquote>
<p>Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>  </p>
</blockquote>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>可以通过执行<code>doker login</code>命令交互式输入用户名及密码在命令行登录Docker Hub。使用<code>docker logout</code>退出登录</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker search</code>命令可以用来查找官方仓库中的镜像，并利用<code>docker pull</code>下载到本地</p>
<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p><code>docker push</code>命令可以将自己的镜像推送到Docker Hub</p>
<blockquote>
<p>docker push usrname/ubuntu:18.04   </p>
</blockquote>
<h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。<br>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。<br>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 或 <a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a> ）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。<br>要配置自动构建，包括如下的步骤：</p>
<ul>
<li>登录 Docker Hub；</li>
<li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li>
<li>在 Docker Hub 中新建或选择已有的仓库，在Builds选项卡中选择Configure Automated Builds；</li>
<li>选取一个目标网站中的项目（需要含Dockerfile）和分支；</li>
<li>指定Dockerfile的位置，并保存。</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的Timeline选项卡中查看每次构建的状态。</p>
<h1 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h1><h2 id="commit命令理解镜像构成"><a href="#commit命令理解镜像构成" class="headerlink" title="commit命令理解镜像构成"></a>commit命令理解镜像构成</h2><p>我们可以根据自己的需要对本地运行的容器进行修改，通过使用<code>docker exec</code>命令进入容器，修改容器文件（也就是<strong>容器的存储层</strong>）</p>
<figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-comment"># 表示以交互终端方式进入webserver容器，并进行bash命令，获得可以可操作的shell</span><br>docker exec -<span class="hljs-keyword">it</span> webserber bash<br></code></pre></div></td></tr></table></figure>
<p>修改之后可以通过<code>docker diff</code>命令查看具体的改动<br>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个<code>docker commit</code>命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">docker commit [选项] &lt;容器ID或容器名&gt; <span class="hljs-meta">[&lt;仓库名&gt;[:&lt;标签&gt;]</span>]<br></code></pre></div></td></tr></table></figure>
<p><code>--author</code>表示指定修改的作者，<code>--message</code>记录本次修改的内容，可以为空<br>可以用<code>docker history</code>具体查看镜像内的历史记录</p>
<h2 id="慎用docker-commit"><a href="#慎用docker-commit" class="headerlink" title="慎用docker commit"></a>慎用<code>docker commit</code></h2><p>使用<code>docker commit</code>命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。<br>首先，通过观察<code>docker diff webserver</code>的结果，会发现除了真正想要修改的文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。<br>此外，使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然<code>docker diff</code>或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。<br>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用<code>docker commit</code>制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p>我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。<br>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。<br>例如，在一个空白目录新建一个<code>Dockerfile</code>的文本文件，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></div></td></tr></table></figure>
<h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。<code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个Dockerfile中<code>FROM</code>是必备的指令，并且必须是第一条指令。<br>如果不以任何镜像为基础，则可以使用Docker中的特殊镜像：<code>scratch</code>，表示这是一个空白镜像，接下来所写的指令将作为镜像第一层开始存在。</p>
<h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><p><code>RUN</code>指令是用来执行命令行命令的，其形式有以下两种：</p>
<ul>
<li><code>shell</code>格式：<code>Run &lt;命令&gt;</code>,就像直接在命令行中输入的命令一样。</li>
<li><code>exec</code>格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>,，这更像是函数调用中的格式。</li>
</ul>
<p>DockerFile中，每一个Run行为，都会新建立一层，所以要尽可能的使用更少的Run，可以使用<code>&amp;&amp;</code>将各个所需命令串联起来。Dockerfile 还支持 Shell 类的行尾添加<code>\</code>的命令换行方式，以及行首<code>#</code>进行注释的格式。此外，在一组命令的最后添加清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了apt缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="bash"> buildDeps=<span class="hljs-string">'gcc libc6-dev make wget'</span> \<br>    &amp;&amp; apt-get update \<br>    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \<br>    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \<br>    &amp;&amp; mkdir -p /usr/src/redis \<br>    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \<br>    &amp;&amp; make -C /usr/src/redis \<br>    &amp;&amp; make -C /usr/src/redis install \<br>    &amp;&amp; rm -rf /var/lib/apt/lists/* \<br>    &amp;&amp; rm redis.tar.gz \<br>    &amp;&amp; rm -r /usr/src/redis \<br>    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></span><br></code></pre></div></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在dockerfile所在目录使用<code>docker build</code>命令进行镜像构建，格式如下：</p>
<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker builder [选项] &lt;上下文路径/URL/-&gt;<br></code></pre></div></td></tr></table></figure>
<p>其中，url可以是<code>Git repo</code>,<code>tar</code>包。<code>-</code>表示标准输入中读取，可以是：</p>
<ul>
<li>从标准输入中读取Dockerfile<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker build - &lt; Dockerfile<br>cat Dockerfile | docker build -<br></code></pre></div></td></tr></table></figure></li>
<li>从标准输入中读取上下文压缩包进行构建<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker build - &lt; context.tar.gz<br></code></pre></div></td></tr></table></figure>
例如：<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">» docker build -t nginx:v3 . <br>Sending build context to Docker daemon  <span class="hljs-number">2.048</span>kB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">2</span> : <span class="hljs-keyword">FROM</span> nginx<br> ---&gt; e445ab08b2be<br>Step <span class="hljs-number">2</span>/<span class="hljs-number">2</span> : <span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'&lt;h1&gt;Hello,Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br> ---&gt; Running in <span class="hljs-number">07</span>b98b86f9ff<br>Removing intermediate container <span class="hljs-number">07</span>b98b86f9ff<br> ---&gt; f9aad93f8f41<br>Successfully built f9aad93f8f41<br>Successfully tagged nginx:v3<br></code></pre></div></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>-t</code>指定了最终镜像的名称  </p>
</blockquote>
<blockquote>
<p><code>docker build</code>工作原理：Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a> ，而如docker命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种docker功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。  </p>
</blockquote>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>进行镜像构建的时候，并非所有定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY指令、ADD指令等。而docker build命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。当构建的时候，用户会指定构建镜像上下文的路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<h1 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h1><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷</li>
<li>挂载主机目录</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录,它拥有以下特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一致存在，即使容器被删除</li>
</ul>
<h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker"><span class="hljs-comment"># 创建一个数据卷</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> create my-vol</span><br><span class="hljs-comment"># 查看所有的数据卷</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> ls</span><br></code></pre></div></td></tr></table></figure>

<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用<code>docker run</code>命令的时候，使用<code>—mount</code>标记来将数据卷挂载到容器里。在一次<code>docker run</code>中可以挂载多个数据卷。<br>下面创建一个名为web的容器，并加载一个数据卷到容器的<code>/webapp</code>目录。</p>
<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="bash"> -d -P --name web --mount <span class="hljs-built_in">source</span>=my-val,target=/webapp training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>通过使用以下命令可以查看某一容器的信息，数据卷信息在”Mounts”下面</p>
<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker inspect web<br></code></pre></div></td></tr></table></figure>
<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker <span class="hljs-keyword">volume</span><span class="bash"> rm my-vol</span><br><br><span class="hljs-comment"># 删除无主的数据卷</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> prune</span><br></code></pre></div></td></tr></table></figure>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code>这个命令。</p>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用<code>—mount</code>标记可以指定挂载一个本地主机的目录到容器中去。<br>例如下面的命令加载主机的<code>/src/webapp</code>目录到容器的<code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径<br>Docker 挂载主机目录的默认权限是读写，用户也可以通过增加<code>readonly</code>指定为只读</p>
<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">$ docker <span class="hljs-keyword">run</span><span class="bash"> -d -P \<br>    --name web \<br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="hljs-built_in">readonly</span> \<br>    training/webapp \<br>    python app.py</span><br></code></pre></div></td></tr></table></figure>
<h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>—mount</code>标记也可以从主机挂载单个文件到容器中,这样就可以记录在容器输入过的命令了</p>
<figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">$ docker <span class="hljs-keyword">run</span><span class="bash"> --rm -it \<br>   <span class="hljs-comment"># -v $HOME/.bash_history:/root/.bash_history \</span><br>   --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-variable">$HOME</span>/.bash_history,target=/root/.bash_history \<br>   ubuntu:18.04 \<br>   bash</span><br><br>root@<span class="hljs-number">2</span>affd44b4667:/<span class="hljs-comment"># history</span><br><span class="hljs-number">1</span>  ls<br><span class="hljs-number">2</span>  diskutil list<br></code></pre></div></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Docker/">Docker</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/08/16/Linux/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/07/29/GOF23/">
                        <span class="hidden-mobile">GOF23</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.lazyComments('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'xiao-ming9/xiao-ming9.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备18114217号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=粤ICP备18114217号-1"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>粤ICP备18114217号-1</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?54ebb03ad7ad5b762ac8ff7958df6d3f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-M2RT7SDT3L', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M2RT7SDT3L"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-M2RT7SDT3L');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
