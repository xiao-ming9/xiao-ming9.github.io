<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Redis哨兵</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Redis哨兵</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-Sentinel的高可用性"><span class="toc-text">Redis Sentinel的高可用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#部署方式"><span class="toc-text">部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sentinel相关配置"><span class="toc-text">Sentinel相关配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态调整"><span class="toc-text">动态调整</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实现原理"><span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#三个定时监控任务"><span class="toc-text">三个定时监控任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主观下线和客观下线"><span class="toc-text">主观下线和客观下线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主观下线"><span class="toc-text">主观下线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客观下线"><span class="toc-text">客观下线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于sentinel-is-master-down-by-addr命令"><span class="toc-text">关于sentinel is-master-down-by-addr命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#领导者Sentinel节点的选取"><span class="toc-text">领导者Sentinel节点的选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#故障转移"><span class="toc-text">故障转移</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93"><i class="tag post-item-tag">数据库</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Redis哨兵</h1><time class="has-text-grey" datetime="2019-07-11T02:48:23.000Z">2019-07-11</time><article class="mt-2 post-content"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Redis哨兵（Sentinel）是Redis提供的一种高可用实现方案，Redis在主从复制下，一旦主节点出现问题，需要人工干预，手动将一个从节点更新为主节点（slaveof no one），同时还要通知应用方新的主节点，让其他从节点去复制新的从节点。这种方式存在弊端大，Redis Sentinel高可用方案就是为了解决这种问题</p>
<a id="more"></a>

<h1 id="Redis-Sentinel的高可用性"><a href="#Redis-Sentinel的高可用性" class="headerlink" title="Redis Sentinel的高可用性"></a>Redis Sentinel的高可用性</h1><p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。</p>
<h1 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h1><ul>
<li>首先部署主节点和从节点</li>
<li>部署sentinel节点<br>在Redis安装目录下有一个<strong>sentinel.conf</strong>的文件，是默认的sentinel节点配置文件，对其进行复制和修改</li>
<li>启动Sentinel节点<blockquote>
<p>Sentinel节点默认的端口是26379  </p>
</blockquote>
</li>
</ul>
<p>启动节点的方式有两种：</p>
<ol>
<li><p>使用redis-sentinel命令</p>
<blockquote>
<p>redis-sentinel sentinel配置文件.conf  </p>
</blockquote>
</li>
<li><p>使用redis-server命令加上<code>--sentinel</code>参数</p>
<blockquote>
<p>redis-server sentinel配置文件.conf —sentinel  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>每个sentinel节点会对主节点和所有从节点进行监控，同时Sentinel节点之间也会相互监控  </p>
</blockquote>
<h2 id="Sentinel相关配置"><a href="#Sentinel相关配置" class="headerlink" title="Sentinel相关配置"></a>Sentinel相关配置</h2><ul>
<li>port ：端口</li>
<li>dir：Sentinel工作目录</li>
<li>sentinel monitor：master-name是对要监控的节点起一个名字，quorum是用于判断主节点最终不可达需要的票数。<pre><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></pre><blockquote>
<p>领导者选举至少要有sentinel节点个数/2+1和quorum的较大值个节点，才能选举出领导者  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果一个Sentinel要监控多个主节点，只需要指定多个masterName来区分不同的主节点即可，即写两个sentinel monitor  </p>
</blockquote>
<h2 id="动态调整"><a href="#动态调整" class="headerlink" title="动态调整"></a>动态调整</h2><p>Sentinel提供了<code>sentinel set</code>命令用于动态设置参数</p>
<pre><code>sentinel set &lt;param&gt; &lt;value&gt;</code></pre><ol>
<li>sentinel set 命令只对当前Sentinel节点有效</li>
<li>sentinel set命令如果执行成功会立即刷新配置文件，和Redis普通数据节点需要执行config rewrite刷新配置文件不同</li>
</ol>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>Sentinel节点是一个特殊的Redis节点，有自己专属的API</p>
<ol>
<li>sentinel masters：展示所有被监控的主节点状态以及相关的统计信息</li>
<li>sentinel master  masterName：展示指定的主节点状态以及相关的统计信息</li>
<li>sentinel slaves masterName：展示指定主节点的从节点状态及相关统计信息</li>
<li>sentinel get-master-addr-by-name masterName：返回指定主节点的IP地址和端口</li>
<li>sentinel sentinels masterName：展示指定的Sentinel节点集合（不包含当前Sentinel节）</li>
<li>sentinel failover masterName：对指定主节点进行强制故障转移（没有和其他Sentinel节点“协商”），当故障转移完成后，其他Sentinel节点按照故障转移的结果更新自身配置</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h2><p>Redis Sentinel通过三个定时监控任务完成对每个节点发现和监控</p>
<ol>
<li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构，Sentinel节点可以通过info replication的结果进行解析找到相应的从节点。</li>
</ol>
<p><strong>该定时任务的作用：</strong></p>
<ul>
<li>通过向主节点执行info命令，获取从节点的信息，这也是为什么 Sentinel节点不需要显式配置监控从节点</li>
<li>当有新的从节点加入时都可以立刻感知出来。</li>
<li>节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。</li>
</ul>
<ol start="2">
<li>每隔2秒，每个Sentinel会向Redis数据节点的<code>__sentinel__:hello</code>频道发送该Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及他们对主节点的判断</li>
</ol>
<p><strong>该定时任务的作用</strong>：</p>
<ul>
<li>发现新的Sentinel节点：通过订阅主节点的<code>__sentinel__：hello</code>了解其他 的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接</li>
<li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</li>
</ul>
<ol start="3">
<li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来却仍这些节点当前是否可达。</li>
</ol>
<p><strong>该定时任务的作用：</strong><br>通过对上面的定时任务，Sentinel节点对主节点，从节点，其余Sentinel节点都建立起连接，实现对每个节点的监控，这个定时任务是节点失败判定的重要依据。</p>
<h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>每个Sentinel节点每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心脏检测，当这些节点超过<code>down-after-milliseconds</code>没有进行有效恢复时，Seintinel节点会对该节点做失败判定，这个行为称为主观下线。</p>
<h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p>当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过<code>sentinel is-master-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断。当超过quorum个数Sentinel节点认为主节点确实有问题，这时就会做出客观下线的决定</p>
<h2 id="关于sentinel-is-master-down-by-addr命令"><a href="#关于sentinel-is-master-down-by-addr命令" class="headerlink" title="关于sentinel is-master-down-by-addr命令"></a>关于sentinel is-master-down-by-addr命令</h2><pre><code>sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code></pre><ul>
<li>current_epoch:当前配置纪元</li>
<li>runid：此参数有两种类型：<ol>
<li>当runid等于<code>*</code>时，作用是Sentinel节点直接交换对主节点下线的判定。</li>
<li>当runid等于当前Sentinel节点的runid时，作用是当前Sentinel节点希望目 标Sentinel节点同意自己成为领导者的请求</li>
</ol>
</li>
</ul>
<p>此命令返回结果包含三个参数：</p>
<ul>
<li>down_state：目标Sentinel节点对于主节点的下线判断，1是下线，0是在线</li>
<li>leader_runid：当leader_runid等于“*”时，代表返回结果是用来做主节点是否不可达，当leader_runid等于具体的runid，代表目标节点同意runid成为领导者。</li>
<li>leader_epoch：领导者纪元。</li>
</ul>
<h2 id="领导者Sentinel节点的选取"><a href="#领导者Sentinel节点的选取" class="headerlink" title="领导者Sentinel节点的选取"></a>领导者Sentinel节点的选取</h2><pre><code>1. 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送`sentinel is-master-down-by-addr`命令， 要求将自己设置为领导者。
2. 收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。
3.  如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）/2+1），那么它将成为领导者。 
4. 如果此过程没有选举出领导者，将进入下一次选举。</code></pre><blockquote>
<p>事实上每个Sectinel只有一票，会最先给发起请求的节点。基本上谁先完成客观下线，就会成为领导者  </p>
</blockquote>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><ol>
<li>在从节点列表中选出一个节点作为新的主节点，选择方法如下： </li>
</ol>
<ul>
<li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。</li>
<li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li>
<li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li>
<li>选择runid最小的从节点。</li>
</ul>
<ol start="2">
<li>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点。</li>
<li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和parallel-syncs参数有关</li>
<li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/07/12/Redis%E9%9B%86%E7%BE%A4/" title="Redis集群"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Redis集群</span></a><a class="button is-default" href="/2019/07/08/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Redis主从复制"><span class="has-text-weight-semibold">下一页: Redis主从复制</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>&lt;a href=&quot;http://www.beian.miit.gov.cn/&quot;&gt;备案号&lt;/a&gt;</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>