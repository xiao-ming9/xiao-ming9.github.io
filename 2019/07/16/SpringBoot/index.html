<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Spring boot</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Spring boot</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#入门示例"><span class="toc-text">入门示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置maven依赖"><span class="toc-text">配置maven依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建运行程序"><span class="toc-text">创建运行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以父子模块的方式配置maven依赖的方式"><span class="toc-text">以父子模块的方式配置maven依赖的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注解"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnableAutoConfiguration"><span class="toc-text">@EnableAutoConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBootApplication"><span class="toc-text">@SpringBootApplication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestController"><span class="toc-text">@RestController</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局配置文件"><span class="toc-text">全局配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取自定义属性的值"><span class="toc-text">获取自定义属性的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型安全的配置"><span class="toc-text">类型安全的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile配置"><span class="toc-text">Profile配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot整合测试"><span class="toc-text">SpringBoot整合测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot日志管理"><span class="toc-text">SpringBoot日志管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义日志配置"><span class="toc-text">自定义日志配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义日志系统"><span class="toc-text">自定义日志系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置工程为开发模式"><span class="toc-text">配置工程为开发模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问静态资源"><span class="toc-text">访问静态资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义JSON转换"><span class="toc-text">自定义JSON转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义拦截器"><span class="toc-text">自定义拦截器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局异常处理器"><span class="toc-text">全局异常处理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步调用"><span class="toc-text">异步调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot整合QuartZ"><span class="toc-text">SpringBoot整合QuartZ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot整合Mybatis"><span class="toc-text">SpringBoot整合Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xml文件方式"><span class="toc-text">xml文件方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注解方式"><span class="toc-text">注解方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot整合多数据源"><span class="toc-text">SpringBoot整合多数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整合流程："><span class="toc-text">整合流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot事务管理"><span class="toc-text">SpringBoot事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot整合JPA"><span class="toc-text">SpringBoot整合JPA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#让控制器输出json字符串格式"><span class="toc-text">让控制器输出json字符串格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#带附件的邮件"><span class="toc-text">带附件的邮件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送模版邮件"><span class="toc-text">发送模版邮件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件操作"><span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot实现文件上传"><span class="toc-text">SpringBoot实现文件上传</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a><a href="/tags/spring"><i class="tag post-item-tag">spring</i></a><a href="/tags/spring%20boot"><i class="tag post-item-tag">spring boot</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Spring boot</h1><time class="has-text-grey" datetime="2019-07-16T07:36:31.000Z">2019-07-16</time><article class="mt-2 post-content"><h1 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h1><h2 id="配置maven依赖"><a href="#配置maven依赖" class="headerlink" title="配置maven依赖"></a>配置maven依赖</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;xm&lt;/groupId&gt;
    &lt;artifactId&gt;springbootTest&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;!-- 从Spring Boot继承默认值 --&gt;
    &lt;parent&gt;
        &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt;
        &lt;artifactId&gt; spring-boot-starter-parent &lt;/artifactId&gt;
        &lt;version&gt; 2.1.6.RELEASE &lt;/version&gt;
    &lt;/parent&gt;

    &lt;!--添加Web应用程序的典型依赖项 --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre>
<a id="more"></a>
<blockquote>
<p>springboot对多种框架提供构建支持，称为starter pom，其中对于SpringMVC的支持是<code>spring-boot-starter-web</code>包，此外还有其他Starter Pom，可以进入parent依赖中查看，也可以在官网文档中查看  </p>
</blockquote>
<h2 id="创建运行程序"><a href="#创建运行程序" class="headerlink" title="创建运行程序"></a>创建运行程序</h2><pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController //controller里面的方法都以json格式输出
@EnableAutoConfiguration//自动配置,不需要自己写xml文件
public class Example {

    @RequestMapping(&quot;/&quot;)
    String home(){
        return &quot;Hello World!&quot;;
    }

    //程序入口
    public static void main(String[] args) {
        SpringApplication.run(Example.class,args);
    }
}</code></pre>
<h2 id="以父子模块的方式配置maven依赖的方式"><a href="#以父子模块的方式配置maven依赖的方式" class="headerlink" title="以父子模块的方式配置maven依赖的方式"></a>以父子模块的方式配置maven依赖的方式</h2><p>首先需要创建父工程，通过父工程点击<code>new module</code>创建子工程，父工程的maven依赖如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;xm&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBoot_Parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;SpringBoot_Child1&lt;/module&gt;
    &lt;/modules&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- Override Spring Data release train provided by Spring Boot --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
                &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
                &lt;version&gt;Fowler-SR2&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

&lt;/project&gt;</code></pre>
<p>子工程需要依赖父工程，并添加自己所需要的依赖：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;SpringBoot_Parent&lt;/artifactId&gt;
        &lt;groupId&gt;xm&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;SpringBoot_Child1&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>该注解修饰的类将自动进行配置，不再需要xml配置文件，Spring-boot提供了多种自动配置的支持，可以在依赖包中的<code>spring-boot-autoconfigure</code>包中查看支持的所有依赖<br>如果要关闭某些自动配置，可以在注解中使用<code>exclude</code>属性，将不需要自动配置的类写上</p>
<pre><code class="java">//关闭Redis的自动配置
@EnableAutoConfiguration(exclude = RedisAutoConfiguration.class)</code></pre>
<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>SpringBoot程序启动需要有一个入口，如果在每个控制器写一个入口会显得很麻烦，可以专门写一个启动类用于Spring启动，需要加上<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>注解，SpringBoot提供<code>SpringBootApplication</code>注解实现上面两个功能</p>
<pre><code class="java">package com.xm.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

//默认扫描当前包及以下的子包
//@EnableAutoConfiguration //SpringBoot自动配置
//@ComponentScan(&quot;com.xm.controller&quot;)//自动扫描
@SpringBootApplication(scanBasePackages = {&quot;com.xm.controller&quot;})
public class SpringApplications {
    public static void main(String[] args) {
        SpringApplication.run(SpringApplications.class,args);
    }
} </code></pre>
<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>在控制器中，如果没有配置@ResponseBody注解，默认是进行跳转，如果一个控制器中的所有功能都是返回json，可以在类上加上<code>@RestController</code>注解，这样里面的所有方法就都是返回json格式，不再需要一个一个配置注解</p>
<blockquote>
<p>SpringBoot同样支持RestFul风格，方式与SpringMVC一样  </p>
</blockquote>
<h1 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h1><p>如果不希望使用SpringBoot默认的配置，可以自己创建配置文件，文件名必须是<strong>application</strong>，后缀名可以是properties或者yml,并将文件放置在<strong>resources</strong>目录下</p>
<pre><code class="yaml">server:
  port: 8088
  servlet:
    context-path: /xm</code></pre>
<p>这样重新启动时，端口号会改为8088，根目录会变成<code>/xm</code></p>
<h2 id="获取自定义属性的值"><a href="#获取自定义属性的值" class="headerlink" title="获取自定义属性的值"></a>获取自定义属性的值</h2><pre><code class="java">package com.xm.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@EnableAutoConfiguration
@Controller
public class BookController {

    @Value(&quot;${book.author}&quot;)//取值
    private String author;

    @Value(&quot;${book.name}&quot;)
    private String name;

    @RequestMapping(&quot;/bookInfo&quot;)
    @ResponseBody
    public String showInfo(){
        return author + &quot;:&quot; + name;
    }

    public static void main(String[] args) {
        SpringApplication.run(BookController.class,args);
    }
}</code></pre>
<h2 id="类型安全的配置"><a href="#类型安全的配置" class="headerlink" title="类型安全的配置"></a>类型安全的配置</h2><p>如果配置文件中有多个属性，每次取值都用value注解比较繁琐，SpringBoot提供基于类型安全的配置方式：<br>通过<code>@ConfigurationProperties</code>指定前缀名，将文件中的属性与Bean相关联，同时Bean中的变量名要跟配置文件中的变量名<strong>一致</strong>，同时提供变量的get和set方法</p>
<pre><code class="java">package com.xm.controller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@EnableAutoConfiguration
@Controller
@ConfigurationProperties(prefix = &quot;book&quot;)
public class BookController {

    private String author;

    private String name;

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @RequestMapping(&quot;/bookInfo&quot;)
    @ResponseBody
    public String showInfo(){
        return author + &quot;:&quot; + name;
    }

    public static void main(String[] args) {
        SpringApplication.run(BookController.class,args);
    }

}</code></pre>
<h2 id="Profile配置"><a href="#Profile配置" class="headerlink" title="Profile配置"></a>Profile配置</h2><p>当针对不同的环境需要使用不同的配置文件时，可以使用Profile配置，其格式为：<code>application-*.properties</code>(application-prod.properties（生产环境）,application-sit.properties（测试环境）,application-dev.properties（开发环境）)或者yml格式。然后需要在<strong>application.properties</strong>文件中通过<code>string.profiles.active=prod/dev/..</code>来指定使用哪一个配置文件</p>
<pre><code class="yaml"># application-dev.yml
server:
  port: 9999


# application.yml

book:
  author: Toms
  name: SpringBoots

spring:
  profiles:
    active: dev</code></pre>
<h1 id="SpringBoot整合测试"><a href="#SpringBoot整合测试" class="headerlink" title="SpringBoot整合测试"></a>SpringBoot整合测试</h1><p>首先需要导入测试依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.5.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>测试：</p>
<pre><code class="java">package com.xm.test;

import com.xm.controller.SpringController;
import junit.framework.TestCase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@SpringBootTest(classes = SpringController.class)//测试谁
@RunWith(SpringJUnit4ClassRunner.class)//用什么测试
@WebAppConfiguration
public class TestSpringController {
    @Autowired
    private SpringController springController;//注入

    @Test
    public void test1(){
        TestCase.assertEquals(this.springController.yes(),&quot;hello&quot;);
    }
}</code></pre>
<h1 id="SpringBoot日志管理"><a href="#SpringBoot日志管理" class="headerlink" title="SpringBoot日志管理"></a>SpringBoot日志管理</h1><p>SpringBoot的日志级别有7个，从低到高分别是：<br><strong>TRACE，DEBUG，INFO，WARN，ERROR，FATAL，OFF</strong>，如果设置了某个日志级别，低于该级别的日志不会输出。<br>SpringBoot默认配置ERROR，WARN和INFO级别的日志输出到控制台</p>
<p>默认情况下，SpringBoot将日志输出到控制台，不会写到日志文件。如果需要将日志写到文件中，需要在SprngBoot配置文件<code>application.properties</code>中设置<code>logging.file</code>或<code>logging.path</code>属性</p>
<ul>
<li>logging.file:设置文件，绝对路径或者相对路径。如：<pre><code class="properties">logging.file = log/my.log(相对）
logging.file = /log/my.log(绝对)</code></pre>
</li>
<li>logging.path:设置目录，会在该目录下创建spring.log文件，并写入日志内容<pre><code class="properties">logging.path = /var/log</code></pre>
<blockquote>
<p>两者不能同时使用，如同时使用，只有logging.file生效，默认日志文件的大小达到10MB会切分一次产生新的日志文件  </p>
</blockquote>
</li>
</ul>
<p>配置示例：</p>
<pre><code class="properties">logging.level.root = WARN
logging.level.org.springframework.web = DEBUG
logging.file = 路径
logging.pattern.console = %d{yyyy/MM/dd-HH:mm:ss}
[%thread] %-5level %logger- %msg%n
[%thread] %-5level %logger- %msg&amp;n</code></pre>
<h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><p>除了在Springboot中进行日志配置，还可以自己根据使用的日志系统写日志配置文件<br>文件命令建议加上<code>-spring</code>,这样spring boot可以为它添加一些spring boot特有的配置项，不加的情况下需要在全局配置文件中指定自己定义的文件名：</p>
<pre><code class="properties">logging.config = classpath:logging-config.xml</code></pre>
<h2 id="自定义日志系统"><a href="#自定义日志系统" class="headerlink" title="自定义日志系统"></a>自定义日志系统</h2><p>Spring默认使用的日志是Logback，如果要使用其他类型，需要先对Logback进行排除</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h1 id="配置工程为开发模式"><a href="#配置工程为开发模式" class="headerlink" title="配置工程为开发模式"></a>配置工程为开发模式</h1><p>在开发过程中，每次修改代码后需要重新启动，可以将工程设置为开发模式，代码修改不再需要重新运行，具体做法为导入以下依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
<h1 id="访问静态资源"><a href="#访问静态资源" class="headerlink" title="访问静态资源"></a>访问静态资源</h1><p>在SpringBoot中访问静态资源跟普通Web项目不太一样，Spring Boot默认的路径是在<code>resources/static</code>和<code>resources/public</code>,也可以自己在全局配置文件中进行配置：</p>
<pre><code class="properties">spring.resources.static-locations=classpath:/static/</code></pre>
<h1 id="自定义JSON转换"><a href="#自定义JSON转换" class="headerlink" title="自定义JSON转换"></a>自定义JSON转换</h1><p>SpringBoot默认使用Jackson进行json解析，如果希望自定义（如使用FastJson），可以通过以下方式更改：<br>首先导入FastJson包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.58&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>在启动类中注入新配置：</p>
<pre><code class="java">package com.xm.app;

import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.Bean;
import org.springframework.http.converter.HttpMessageConverter;

//默认扫描当前包及以下的子包
//@EnableAutoConfiguration //SpringBoot自动配置
//@ComponentScan(&quot;com.xm.controller&quot;)//自动扫描
@SpringBootApplication(scanBasePackages = &quot;com.xm.controller&quot;)
public class SpringApplications{
    @Bean//依赖注入
    public HttpMessageConverters fastJsonMessageConverter(){
        //创建FastJson的消息转换器
        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();
        //创建FastJson的配置对象
        FastJsonConfig config = new FastJsonConfig();
        //对json数据进行格式化
        config.setSerializerFeatures(SerializerFeature.PrettyFormat);

        converter.setFastJsonConfig(config);
        HttpMessageConverter&lt;?&gt;con = converter;
        return new HttpMessageConverters(con);
    }


    public static void main(String[] args) {
        SpringApplication.run(SpringApplications.class,args);
    }
}</code></pre>
<blockquote>
<p>对于中文，默认客户端接受不一定使用URTF-8编码，可以在全局配置文件加入如下配置使客户端使用UTF-8编码：<br><code>spring.http.encoding.force = true</code>  </p>
</blockquote>
<p>创建实体类进行验证：</p>
<pre><code class="java">package com.xm.com.xm.pojo;

import com.alibaba.fastjson.annotation.JSONField;

import java.util.Date;

public class Person {
    private Integer id;
    private String name;
    @JSONField(format = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date date;//日期格式化

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}</code></pre>
<pre><code class="java">package com.xm.controller;

import com.xm.com.xm.pojo.Person;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.Date;

@Controller
public class PersonController {

    @ResponseBody
    @RequestMapping(&quot;/show&quot;)
    public Object show(){
        Person person = new Person();
        person.setId(66);
        person.setName(&quot;小明&quot;);
        person.setDate(new Date());
        return person;
    }
}</code></pre>
<h1 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h1><p>通过继承<strong>WebMvcConfigurer</strong>接口，对里面的<code>addInterceptors</code>方法重写，根据自己需要实现的拦截功能进行定义：</p>
<pre><code class="java">package com.xm.interceptor;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Configuration//声明这是一个配置
public class MyInterceptor implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        HandlerInterceptor interceptor = new HandlerInterceptor() {
            @Override
            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
                System.out.println(&quot;自定义拦截器&quot;);
                return true;
            }
        };
        registry.addInterceptor(interceptor).addPathPatterns(&quot;/**&quot;);
    }
}</code></pre>
<blockquote>
<p>在启动项中扫描的包上需要加入当前包  </p>
</blockquote>
<h1 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h1><p>SpringBoot使用Aop的思想进行异常处理</p>
<pre><code class="java">package com.xm.exceptionHandler;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Map&lt;String,Object&gt; handleException(Exception exception){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;errorCode&quot;,500);
        map.put(&quot;errorMag&quot;,exception.toString());
        return map;
    }
}</code></pre>
<h1 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h1><p>在项目中当需要访问其他接口较慢或者做耗时工作时，如果不希望程序一直卡着而是能够并行处理，可以使用多线程来并行处理任务<br>SpringBoot提供了异步处理方式<code>@Async</code></p>
<ol>
<li>创建服务层接口及实现类<br>在相应需要开启子线程的方法上使用<code>@Async</code>注解<pre><code class="java">package com.xm.service;
</code></pre>
</li>
</ol>
<p>import java.util.concurrent.Future;</p>
<p>public interface AsyncService {<br>    Future<String> doTask1() throws Exception;<br>    Future<String> doTask2() throws Exception;<br>    Future<String> doTask3() throws Exception;<br>}</p>
<pre><code>```java
package com.xm.service;

import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Service;

import java.util.Random;
import java.util.concurrent.Future;

@Service
public class AsyncServiceImpl implements AsyncService {

    private static Random random = new Random();

    @Async//标示开启子进程异步调用
    @Override
    public Future&lt;String&gt; doTask1() throws Exception {
        System.out.println(&quot;任务一开始执行&quot;);
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务一结束，耗时：&quot;+(end-start)+&quot;毫秒&quot;);
        return new AsyncResult&lt;&gt;(&quot;任务一结束&quot;);
    }

    @Async
    @Override
    public Future&lt;String&gt; doTask2() throws Exception {
        System.out.println(&quot;任务二开始执行&quot;);
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务二结束，耗时：&quot;+(end-start)+&quot;毫秒&quot;);
        return new AsyncResult&lt;&gt;(&quot;任务二结束&quot;);
    }

    @Async
    @Override
    public Future&lt;String&gt; doTask3() throws Exception {
        System.out.println(&quot;任务三开始执行&quot;);
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务三结束，耗时：&quot;+(end-start)+&quot;毫秒&quot;);
        return new AsyncResult&lt;&gt;(&quot;任务三结束&quot;);
    }
}</code></pre><ol start="2">
<li>创建控制器调用服务层<pre><code class="java">package com.xm.controller;
</code></pre>
</li>
</ol>
<p>import com.xm.service.AsyncService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.ResponseBody;</p>
<p>import java.util.concurrent.Future;</p>
<p>@Controller<br>public class SyncController {</p>
<pre><code>@Autowired
private AsyncService asyncService;

@RequestMapping(&quot;/async&quot;)
@ResponseBody
public String asyncTest() throws Exception {

    long start = System.currentTimeMillis();

    Future&lt;String&gt; task1 = asyncService.doTask1();
    Future&lt;String&gt; task2 = asyncService.doTask2();
    Future&lt;String&gt; task3 = asyncService.doTask3();

    while (true){
        if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()){
            break;
        }
        Thread.sleep(1000);
    }

    long end = System.currentTimeMillis();
    return &quot;全部执行完成，总耗时：&quot;+(end-start)+&quot;毫秒&quot;;
}</code></pre><p>}</p>
<pre><code>3. 在启动类上添加`@EnableAsync`开启异步执行，同时扫描的包要加上service包

# 模版引擎
SpringBoot官方对于动态页面推荐使用模版引擎，动态引擎有：FreeMarker、Thymeleaf、 Mustache等
## SpringBoot中整合Freemarker
1. 首先导入freemarker依赖
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><ol start="2">
<li>创建<code>ftl</code>文件<br>SpringBoot默认会在<code>resources/templates</code>目录下获取后缀名为<code>.ftl</code>的模版引擎文件<pre><code class="html">&lt;html&gt;
&lt;head&gt; Freemarker模版引擎&lt;/head&gt;
&lt;body&gt;
 ${name}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
<li>创建控制器传值<pre><code class="java">package com.xm.controller;
</code></pre>
</li>
</ol>
<p>import org.springframework.stereotype.Controller;<br>import org.springframework.ui.Model;<br>import org.springframework.web.bind.annotation.RequestMapping;</p>
<p>@Controller<br>public class TemplatesController {<br>    @RequestMapping(“/index”)<br>    public String index(Model model){<br>        model.addAttribute(“name”,”小明”);<br>        return “show”;//会自动到resources/templates目录下找<br>    }<br>}</p>
<pre><code>
&gt; 如果要改变Freemarker的默认配置，可以在全局配置文件中做自定义配置  

## SpringBoot整合Thymeleaf
1. 导入`spring-boot-starter-thymeleaf`依赖
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><ol start="2">
<li>创建html文件<br>Thymeleaf默认的页面文件是html文件，同时其有自己的语法<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;Thymeleaf&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 th:text=&quot;${name}&quot;&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
剩下的跟上一种一样</li>
</ol>
<h1 id="SpringBoot整合QuartZ"><a href="#SpringBoot整合QuartZ" class="headerlink" title="SpringBoot整合QuartZ"></a>SpringBoot整合QuartZ</h1><p>QuartZ是一个用于任务调度的框架</p>
<ol>
<li>创建定时任务：<br>对需要定时执行的任务使用<code>@Scheduled</code>注解,同时需要将该类放入容器，使用<code>@Component</code><pre><code class="java">package com.xm.job;
</code></pre>
</li>
</ol>
<p>import org.springframework.scheduling.annotation.Scheduled;</p>
<p>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>public class MyJob {</p>
<pre><code>@Scheduled(fixedRate = 1000)//每隔多久执行一次任务，单位毫秒
public void run(){
    System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));
}</code></pre><p>}</p>
<pre><code>2. 在启动类中开启任务调度：使用`@EnableScheduling`,同时扫描包要指明

# 数据库相关操作
## SpringBoot整合JdbcTemplate
首先需要导入相关依赖：
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>创建相应的pojo，dao和service</p>
<pre><code class="java">package com.xm.pojo;

public class User {
    private Integer id;
    private String name;
    private Integer age;
      //省略get，set方法
}</code></pre>
<pre><code class="java">package com.xm.dao;

import com.xm.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void addUser(User user){
        jdbcTemplate.update(&quot;insert into users(name,age) values (?,?)&quot;, new Object[]{
                        user.getName(),
                        user.getAge()
                });
    }
}</code></pre>
<pre><code class="java">package com.xm.service;

import com.xm.dao.UserDao;
import com.xm.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserDao userDao;

    public void saveUser(User user){
        userDao.addUser(user);
    }
}</code></pre>
<p>创建控制器：</p>
<pre><code class="java">package com.xm.controller;


import com.xm.pojo.User;
import com.xm.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping(&quot;/savaUser&quot;)
    @ResponseBody
    public String save(){
        User user = new User();
        user.setName(&quot;潘多拉&quot;);
        user.setAge(666);

        userService.saveUser(user);

        return &quot;success&quot;;
    }
}</code></pre>
<p>在全局配置文件中设置连接数据库的相关信息：</p>
<pre><code class="properties">spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password= root
spring.datasource.url = jdbc:mysql://localhost:3306/spring</code></pre>
<h2 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h2><h3 id="xml文件方式"><a href="#xml文件方式" class="headerlink" title="xml文件方式"></a>xml文件方式</h3><ol>
<li><p>添加依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
     &lt;groupId&gt;mysql&lt;/groupId&gt;
     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
     &lt;version&gt;8.0.16&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
     &lt;version&gt;2.0.1&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;druid&lt;/artifactId&gt;
     &lt;version&gt;1.1.19&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;!-- 分页插件--&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
     &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
     &lt;version&gt;1.2.12&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;dependency&gt;
     &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
     &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
     &lt;version&gt;1.3.7&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>
</li>
</ol>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-maven-plugin</artifactId>
            <version>1.3.7</version>
            <dependencies>
                <dependency>
                    <groupId>mysql</groupId>
                    <artifactId>mysql-connector-java</artifactId>
                    <version>5.1.47</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```
2. 通过逆向工程创建pojo，mapper和dao,手动添加相应的注解
3. 将生成的`xxxMapper.xml`文件放到sources目录下
4. 在resources目录下创建mybatis配置文件，只需写入前提配置即可
5. 创建全局配置文件进行配置
```yaml
spring:
  datasource:
    name: test
    url: jdbc:mysql://localhost:3306/spring
    username: root
    password: root
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    dbcp2:
      initial-size: 1
      max-wait-millis: 60000
      min-idle: 1
      time-between-eviction-runs-millis: 60000
      min-evictable-idle-time-millis: 300000
      validation-query: select 'x'
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      pool-prepared-statements: true
      max-open-prepared-statements: 20

<p>mybatis:<br>  mapper-locations: classpath:mapper/UsersMapper.xml<br>  config-location: classpath:mybatis/mybatis-config.xml</p>
<p>pagehelper:<br>  reasonable: true<br>  support-methods-arguments: true<br>  params: count=countSql<br>  helper-dialect: mysql</p>
<pre><code>6. 开发服务层和控制器层
```java
package com.xm.service;

import com.github.pagehelper.PageHelper;
import com.xm.dao.UsersMapper;
import com.xm.pojo.Users;
import com.xm.pojo.UsersExample;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UsersServiceImpl implements UsersService {

    @Autowired
    private UsersMapper usersMapper;

    @Override
    public void addUser(Users users) {
        usersMapper.insert(users);
    }

    @Override
    public List&lt;Users&gt; findUsers(int page, int rows) {
        UsersExample example = new UsersExample();
        PageHelper.startPage(page,rows);//相当于拦截器
        List&lt;Users&gt; users = usersMapper.selectByExample(example);
        return users;
    }
}</code></pre><pre><code class="java">package com.xm.controller;

import com.xm.pojo.Users;
import com.xm.service.UsersService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class UsersController {

    @Autowired
    private UsersService usersService;

    @RequestMapping(&quot;/saveUser&quot;)
    @ResponseBody
    public String saveUsers(){
        Users users = new Users();
        users.setAge(12);
        users.setName(&quot;阿拉斯加&quot;);

        usersService.addUser(users);
        return &quot;success&quot;;
    }

    @RequestMapping(&quot;/findUsers/{page}/{rows}&quot;)
    @ResponseBody
    public List&lt;Users&gt; findUsers(@PathVariable int page,@PathVariable int rows){
        return usersService.findUsers(page,rows);
    }
}</code></pre>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>这种方式不需要mybatis配置文件和mapper的xml文件，主要修改的地方为映射类：<br>在对应的方法上使用相应的注解并自己写上sql语句，同时方法中的变量使用<code>@Param</code>使其对应上</p>
<pre><code class="java">package com.xm.dao;

import com.xm.pojo.Users;
import com.xm.pojo.UsersExample;
import java.util.List;

import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

@Repository
public interface UsersMapper {

    @Select(&quot;select * from users where name=#{name}&quot;)
    Users findUserByName(@Param(&quot;name&quot;) String name);

    @Insert(&quot;insert into users(name,age) values(#{name},#{age})&quot;)
    void addUser(@Param(&quot;name&quot;) String name,@Param(&quot;age&quot;) Integer age);
}
</code></pre>
<h2 id="SpringBoot整合多数据源"><a href="#SpringBoot整合多数据源" class="headerlink" title="SpringBoot整合多数据源"></a>SpringBoot整合多数据源</h2><p>在项目中通常会进行数据库拆分或者是引入其他数据库，从而需要配置多个数据源<br>区分多个数据源的方式：</p>
<ol>
<li>通过包来区分：com.db1.mapper,com.db2.mapper</li>
<li>使用注解区分:需要使用大量注解，一般不推荐使用</li>
</ol>
<h3 id="整合流程："><a href="#整合流程：" class="headerlink" title="整合流程："></a>整合流程：</h3><ol>
<li>在全局配置文件中配置多个数据源<pre><code class="properties">#配置两个数据源
spring.datasource.db1.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.db1.username=root
spring.datasource.db1.password=root
#2.0之后的版本需要使用jdbc-url
spring.datasource.db1.jdbc-url=jdbc:mysql://localhost:3306/spring
</code></pre>
</li>
</ol>
<p>spring.datasource.db2.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.db2.username=root<br>spring.datasource.db2.password=root<br>spring.datasource.db2.jdbc-url=jdbc:mysql://localhost:3306/sm</p>
<pre><code>
2. 对每个数据源进行配置
DataSource1.java:
```java
package com.xm.datasource;


import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;

@Configuration //注册到Spring容器中
//扫描对应的mapper的包还有对应sqlSessionFactory的引用
@MapperScan(basePackages=&quot;com.xm.db1.mapper&quot;,sqlSessionFactoryRef = &quot;db1SqlSessionFactory&quot;)
public class DataSource1 {

    /**
     * 配置db1数据库，生成数据源对象
     * @return
     */
    @Bean(name = &quot;db1Datasource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.db1&quot;)//对应全局配置文件前缀
    public DataSource testDataSource(){
        return DataSourceBuilder.create().build();
    }

    /**
     * 创建SqlSessionFactory
     * @param dataSource
     * @return
     * @throws Exception
     */
    @Bean(name=&quot;db1SqlSessionFactory&quot;)
    @Primary //自动装配时优先使用
    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;db1Datasource&quot;)DataSource dataSource)
            throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        return bean.getObject();
    }

    /**
     * 配置事务管理
     * @param dataSource
     * @return
     */
    @Bean(name=&quot;db1TransactionManager&quot;)
    public DataSourceTransactionManager testTransactionManager(
            @Qualifier(&quot;db1Datasource&quot;)DataSource dataSource){
        return new DataSourceTransactionManager(dataSource);
    }

    /**
     * 整合数据库和mybatis时用于实现数据库操作
     * @param sqlSessionFactory
     * @return
     */
    @Bean(name=&quot;db1SqlSessionTemplate&quot;)
    public SqlSessionTemplate testSqlSessionTemplate(
            @Qualifier(&quot;db1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory){
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}</code></pre><p>另一个数据源大致相同，只需要相应的改成2就可以了<br>3. 创建mapper文件，需要将两个数据源放在不用的包中<br>需要注意注解指定相应的数据源</p>
<pre><code class="java">package com.xm.db1.mapper;

import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Param;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Repository;

@Qualifier(&quot;db1SqlSessionFactory&quot;)
@Repository(&quot;db1UserMapper&quot;)
public interface UsersMapper {

    @Insert(&quot;insert into users(name,age) values(#{name},#{age})&quot;)
    void addUser(@Param(&quot;name&quot;)String name, @Param(&quot;age&quot;)Integer age);
}</code></pre>
<ol start="4">
<li>开发相应的service<pre><code class="java">package com.xm.db1.service;
</code></pre>
</li>
</ol>
<p>import com.xm.db1.mapper.UsersMapper;<br>import com.xm.db1.pojo.Users;<br>import org.springframework.stereotype.Service;</p>
<p>import javax.annotation.Resource;</p>
<p>@Service(“db1UsersService”)<br>public class UsersServiceImpl implements UsersService {</p>
<pre><code>@Resource(name = &quot;db1UserMapper&quot;)
private UsersMapper usersMapper;

@Override
public void saveUser(Users users) {
    usersMapper.addUser(users.getName(),users.getAge());
}</code></pre><p>}</p>
<pre><code>5. 创建控制器层
```java
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class IndexController {

    @Resource(name = &quot;db1UsersService&quot;)//对应不同的service
    private UsersService usersService1;

    @Resource(name = &quot;db2UsersService&quot;)
    private com.xm.db2.service.UsersService usersService2;

    @RequestMapping(&quot;/addUser&quot;)
    @ResponseBody
    public String addUser(){
        Users users1 = new Users();
        users1.setName(&quot;哈士奇&quot;);
        users1.setAge(111);

        usersService1.saveUser(users1);
        return &quot;OK&quot;;
    }
}</code></pre><h2 id="SpringBoot事务管理"><a href="#SpringBoot事务管理" class="headerlink" title="SpringBoot事务管理"></a>SpringBoot事务管理</h2><p>在SpringBoot中推荐使用<code>@Transactional</code>注解声明事务管理，只需要在需要开启事务的方法上加上即开启事务</p>
<h2 id="SpringBoot整合JPA"><a href="#SpringBoot整合JPA" class="headerlink" title="SpringBoot整合JPA"></a>SpringBoot整合JPA</h2><p>jpa是一种数据持久化的规范，其实现最受欢迎的有Hibernate，Springboot也针对jpa做了实现：其可以根据实体类自动生成数据库表</p>
<ol>
<li>导入依赖<pre><code class="xml">&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li>全局配置文件配置数据库连接和JPA<pre><code class="properties">spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password= root
spring.datasource.url = jdbc:mysql://localhost:3306/spring
</code></pre>
</li>
</ol>
<h1 id="让控制器输出json字符串格式"><a href="#让控制器输出json字符串格式" class="headerlink" title="让控制器输出json字符串格式"></a>让控制器输出json字符串格式</h1><p>spring.jackson.serialization.indent-output=true<br>spring.jpa.hibernate.ddl-auto=update<br>spring.jpa.show-sql=true<br>spring.jooq.sql-dialect=MySQL5Dialect</p>
<pre><code>3. 创建实体类，对实体类使用`Entity`注解表示自动生成表
生成的表的表名默认和实体类的类名相同，可以通过使用注解`@Table(name=&quot;xxx&quot;`指定表名
对于需要作为表中主键的属性，使用`@Id`注解，同时对于主键上的值的生成规则做指定：
使用`@GenerateValue(strategy=GenerationType.xxxx`注解
- AUTO表示自动生成
- IDENTITY表示自动增长
对于其他的属性，默认属性名跟字段名相同，可以使用`@Column(name=&quot;xx&quot;)`注解指明字段名，如果字段不允许为空，可以设置`@Column(nullable=false)`
```java
package com.xm.pojo;


import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name=&quot;t_user&quot;)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String name;
    private Integer age;
    private Date birthday;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}</code></pre><ol start="4">
<li>创建Dao层<br>只需要创建一个接口并且继承<code>JpaRepository</code>，这个子类提供了增删改查的功能，它有两个范型，第一个是实体类，第二个是实体类中主键属性的类型<pre><code class="java">package com.xm.dao;
</code></pre>
</li>
</ol>
<p>import com.xm.pojo.User;<br>import org.springframework.data.jpa.repository.JpaRepository;</p>
<p>public interface UserDao extends JpaRepository&lt;User, Integer&gt; {<br>}</p>
<pre><code>5. service层和controller层
```java
package com.xm.service;

import com.xm.dao.UserDao;
import com.xm.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Override
    public void addUser(User user) {
        userDao.save(user);
    }
}

@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping(&quot;/saveUser&quot;)
    public String saveUser(){
        User user = new User();
        user.setName(&quot;巴啦啦小魔仙&quot;);
        user.setAge(6);
        user.setBirthday(new Date());

        userService.addUser(user);
        return &quot;OK&quot;;
    }
}</code></pre><ol start="6">
<li>启动类需要使用相应的注解扫描<pre><code class="java">package com.xm.app;
</code></pre>
</li>
</ol>
<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br>import org.springframework.boot.autoconfigure.domain.EntityScan;<br>import org.springframework.data.jpa.repository.config.EnableJpaRepositories;</p>
<p>@SpringBootApplication(scanBasePackages = “com.xm”)<br>@EntityScan(“com.xm.pojo”)//扫描实体类从而生成表<br>@EnableJpaRepositories(“com.xm.dao”)//扫描dao<br>public class SpringBootApp {<br>    public static void main(String[] args) {<br>        SpringApplication.run(SpringBootApp.class,args);<br>    }<br>}</p>
<pre><code>
&gt; 未解决问题：启动后出现异常：java.lang.IllegalStateException: Error processing condition on org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration.pageableCustomizer  
&gt; 无法正常启动  

# SpringBoot整合Mail
## 发送普通邮件
导入`spring-boot-starter-mail`依赖
配置全局配置文件
```properties
spring.mail.host=smtp.qq.com
spring.mail.username=934933088@qq.com
# 授权码,在qq邮箱设置里获取
spring.mail.password=xxxxx
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true</code></pre><p>读取邮件发送者：</p>
<pre><code class="java">package com.xm.mail;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class EmailConfig {

    @Value(&quot;${spring.mail.username}&quot;)
    private String emailFrom;

    public String getEmailFrom(){
        return emailFrom;
    }

    public void setEmailFrom(String emailFrom){
        this.emailFrom = emailFrom;
    }
}</code></pre>
<p>服务层实现：</p>
<pre><code class="java">package com.xm.mail;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailServiceImpl implements EmailService {

    @Autowired
    private EmailConfig emailConfig;

    @Autowired
    private JavaMailSender mailSender;

    @Override
    public void sendSimpleMail(String sendTo, String title, String content) {
        //简单邮件的发送
        SimpleMailMessage message = new SimpleMailMessage();//构造邮件实体类
        message.setFrom(emailConfig.getEmailFrom());
        message.setTo(sendTo);
        message.setSubject(title);
        message.setText(content);

        mailSender.send(message);//发送邮件
    }
}</code></pre>
<h2 id="带附件的邮件"><a href="#带附件的邮件" class="headerlink" title="带附件的邮件"></a>带附件的邮件</h2><pre><code class="java">@Override
public void sendAttachmentMail(String sendTo, String title, String content, File file) {
    MimeMessage msg = mailSender.createMimeMessage();//将邮件封装成对象

    try {
        MimeMessageHelper helper = new MimeMessageHelper(msg,true);//设置为multipart格式
        helper.setFrom(emailConfig.getEmailFrom());
        helper.setTo(sendTo);
        helper.setSubject(title);
        helper.setText(content);

        FileSystemResource resource = new FileSystemResource(file);
        helper.addAttachment(&quot;附件&quot;,resource);
    } catch (MessagingException e) {
        e.printStackTrace();
    }
    mailSender.send(msg);
}</code></pre>
<pre><code class="java">@RequestMapping(&quot;/sendFileMail&quot;)
@ResponseBody
public String sendAttachmentEmail(){
    File file = new File(&quot;SpringBoot_Child5/src/main/resources/static/66.txt&quot;);
    emailService.sendAttachmentMail(&quot;934933088@qq.com&quot;,&quot;hello&quot;,&quot;看文件&quot;,file);
    return &quot;success&quot;;
}</code></pre>
<h2 id="发送模版邮件"><a href="#发送模版邮件" class="headerlink" title="发送模版邮件"></a>发送模版邮件</h2><p>需要导入模版引擎,同时在resources/templates目录下创建模版<br>service层：</p>
<pre><code class="java">@Service
public class EmailServiceImpl implements EmailService {

    @Autowired
    private EmailConfig emailConfig;

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private FreeMarkerConfigurer freeMarkerConfigurer;

      @Override
    public void sendTemplateMail(String sendTo, String title, String info) {
          //info为模版的文件名（包含后缀）
        MimeMessage message = mailSender.createMimeMessage();
        try {
            MimeMessageHelper helper = new MimeMessageHelper(message,true);
            helper.setFrom(emailConfig.getEmailFrom());
            helper.setTo(sendTo);
            helper.setSubject(title);

            //封装模版使用的数据
            Map&lt;String,Object&gt; model = new HashMap&lt;&gt;();
            model.put(&quot;username&quot;,&quot;小红&quot;);

            //得到模版
            Template template = freeMarkerConfigurer.getConfiguration().getTemplate(info);
            String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);

            helper.setText(html,true);
        } catch (Exception e) {
            e.printStackTrace();
        }
        mailSender.send(message);
    }
}</code></pre>
<p>控制器：</p>
<pre><code class="java">@RequestMapping(&quot;/sendTemplateEmail&quot;)
@ResponseBody
public String sendTemplateEmail(){
    emailService.sendTemplateMail(&quot;934933088@qq.com&quot;,&quot;模版邮箱&quot;,&quot;info.html&quot;);
    return &quot;success&quot;;
}</code></pre>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="SpringBoot实现文件上传"><a href="#SpringBoot实现文件上传" class="headerlink" title="SpringBoot实现文件上传"></a>SpringBoot实现文件上传</h2><p>依赖web包之后，文件上传的包就自动依赖上了<br>如果需要控制上传文件的大小，可以通过全局配置文件的设置</p>
<pre><code class="properties">#上传单个文件的大小
spring.servlet.multipart.max-file-size=500MB
#上传全部文件的总大小
spring.servlet.multipart.max-request-size= 500MB</code></pre>
<ol>
<li><p>使用模版引擎编写文件上传页面</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;文件上传&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;h2&gt;文件上传&lt;/h2&gt;
 &lt;hr/&gt;
 &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/upload&quot;&gt;
     &lt;p&gt;
         文件&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
     &lt;/p&gt;
     &lt;p&gt;
         &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;
     &lt;/p&gt;
 &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
<li><p>实现文件上传控制器</p>
<pre><code class="java">package com.xm.controller;
</code></pre>
</li>
</ol>
<p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RequestMethod;<br>import org.springframework.web.bind.annotation.ResponseBody;<br>import org.springframework.web.multipart.MultipartFile;</p>
<p>import javax.servlet.http.HttpServletRequest;<br>import java.io.File;<br>import java.io.IOException;<br>import java.util.UUID;</p>
<p>@Controller<br>public class UploadController {</p>
<pre><code>//页面不能直接访问，需要通过控制器跳转
@RequestMapping(&quot;/toUpload&quot;)
public String toUpload(){
    return &quot;upload&quot;;
}

@RequestMapping(value = &quot;/upload&quot;,method = RequestMethod.POST)
@ResponseBody
public String uploadFile(MultipartFile file, HttpServletRequest request){

    //创建文件在服务器端的存放路径
    String dir = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File fileDir = new File(dir);
    if(!fileDir.exists())
        fileDir.mkdirs();
    //生成文件在服务器端存放的名字
    String fileSuffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));
    String fileName = UUID.randomUUID().toString()+fileSuffix;
    File files = new File(fileDir+&quot;/&quot;+fileName);
    //上传
    try {
        file.transferTo(files);
    } catch (IOException e) {
        e.printStackTrace();
        return &quot;上传失败&quot;;
    }
    return &quot;success&quot;;
}</code></pre><p>}</p>
<pre><code>
## 批量文件上传
```java
@RequestMapping(value = &quot;/upload/batch&quot;,method = RequestMethod.POST)
@ResponseBody
public String uploadFiles(MultipartFile[] files,HttpServletRequest request){
    //创建文件在服务器端的存放路径
    String dir = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File fileDir = new File(dir);
    if(!fileDir.exists())
        fileDir.mkdirs();

    //遍历数组
    for(int i=0;i&lt;files.length;i++){
        String fileSuffix = files[i].getOriginalFilename().substring(files[i].getOriginalFilename().lastIndexOf(&quot;.&quot;));
        String fileName = UUID.randomUUID().toString()+fileSuffix;
        File file = new File(fileDir+&quot;/&quot;+fileName);
        //上传
        try {
            files[i].transferTo(file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return &quot;success&quot;;
}</code></pre></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/07/21/Nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%A8%A1%E5%9D%97/" title="Nginx基本配置和模块"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Nginx基本配置和模块</span></a><a class="button is-default" href="/2019/07/12/Redis%E9%9B%86%E7%BE%A4/" title="Redis集群"><span class="has-text-weight-semibold">下一页: Redis集群</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>&lt;a href=&quot;http://www.beian.miit.gov.cn/&quot;&gt;备案号&lt;/a&gt;</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>