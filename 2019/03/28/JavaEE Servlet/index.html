<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Java EE Servlet</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Java EE Servlet</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet的两种创建方式"><span class="toc-text">Servlet的两种创建方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置Servlet的两种方法"><span class="toc-text">配置Servlet的两种方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet生命周期"><span class="toc-text">Servlet生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet接收请求和响应"><span class="toc-text">Servlet接收请求和响应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet线程安全问题"><span class="toc-text">Servlet线程安全问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结合JDBC注册案例"><span class="toc-text">结合JDBC注册案例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#转发"><span class="toc-text">转发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于路径问题"><span class="toc-text">关于路径问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Response类"><span class="toc-text">Response类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Request类常用API"><span class="toc-text">Request类常用API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下载文件"><span class="toc-text">下载文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session"><span class="toc-text">Session</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#将表单数据封装成javaBean的三种方法"><span class="toc-text">将表单数据封装成javaBean的三种方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ServletContext"><span class="toc-text">ServletContext</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#过滤器Filter"><span class="toc-text">过滤器Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#过滤器处理浏览器缓存"><span class="toc-text">过滤器处理浏览器缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全站压缩功能"><span class="toc-text">全站压缩功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#监听器"><span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件上传"><span class="toc-text">文件上传</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Java EE Servlet</h1><time class="has-text-grey" datetime="2019-03-28T07:35:21.000Z">2019-03-28</time><article class="mt-2 post-content"><p><strong>Servlet</strong>是运行在服务器上的小程序，作为客户端与服务器的中间层</p>
<p><code>servlet</code>接口有四个方法</p>
<ul>
<li>init：第一次访问时创建servlet对象时调用</li>
<li>service：每次访问时调用</li>
<li>destroy：当服务器停止时释放servlet调用</li>
<li>getServletInfo：获取Servlet基本信息，版权，作者</li>
</ul>
<a id="more"></a>
<h1 id="Servlet的两种创建方式"><a href="#Servlet的两种创建方式" class="headerlink" title="Servlet的两种创建方式"></a>Servlet的两种创建方式</h1><ul>
<li>继承<code>HttpServlet</code>，重写<code>doPost</code>和<code>doGet</code>方法<pre><code class="java">package servlet;
</code></pre>
</li>
</ul>
<p>import javax.servlet.ServletException;<br>import javax.servlet.annotation.WebServlet;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p>
<p>@WebServlet(“/MyServlet1”)<br>public class MyServlet1 extends HttpServlet {</p>
<pre><code>public MyServlet1(){
    super();
}

//Post请求
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    doGet(request,response);
}

//get请求
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.getWriter().append(&quot;Served at:&quot;).append(request.getContextPath());
    response.getWriter().append(&quot;第一种方式&quot;);
}</code></pre><p>}</p>
<pre><code>- 实现Servlet接口
```java
package servlet;

import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import java.io.IOException;

@WebServlet(&quot;/MyServlet2&quot;)
public class MyServlet2 implements Servlet {
    @Override
    /**
     * 初始化
     */
    public void init(ServletConfig config) throws ServletException {

    }

    @Override
    /**
     * 读取配置
     */
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    /**
     *服务方法，当浏览器请求Servlet时执行提供服务
     */
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        res.getWriter().write(&quot;创建servlet的第二种方法&quot;);
    }

    @Override
    /**
     * 获取Servlet基本信息，版权，作者
     */
    public String getServletInfo() {
        return null;
    }

    @Override
    /**
     * 服务方法
     */
    public void destroy() {

    }
}</code></pre><h1 id="配置Servlet的两种方法"><a href="#配置Servlet的两种方法" class="headerlink" title="配置Servlet的两种方法"></a>配置Servlet的两种方法</h1><ol>
<li><p>使用注解</p>
<blockquote>
<p>@WebServlet(“/yourUrl”)</p>
</blockquote>
</li>
<li><p>配置xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
       http://java.sun.com/xml/ns/javaee/web-app_4_0.xsd&quot;
        version=&quot;4.0&quot;&gt;

 &lt;!--配置Servlet--&gt;

 &lt;!--1.配置servlet节点--&gt;
 &lt;servlet&gt;
     &lt;!--1.1.为Servlet创建一个名字--&gt;
     &lt;servlet-name&gt;MyServlet2&lt;/servlet-name&gt;
     &lt;!--1.2.配置类的全路径--&gt;
     &lt;servlet-class&gt;servlet.MyServlet2&lt;/servlet-class&gt;
 &lt;/servlet&gt;
 &lt;!--2.配置servlet-mapping节点--&gt;
 &lt;servlet-mapping&gt;
     &lt;!--2.1.引用上面定义的servlet的名字--&gt;
     &lt;servlet-name&gt;MyServlet2&lt;/servlet-name&gt;
     &lt;!--2.2.定义映射的路径--&gt;
     &lt;!--2.2.1.精确匹配--&gt;
     &lt;url-pattern&gt;/MyServlet2&lt;/url-pattern&gt;
     &lt;!--2.2.2.后缀匹配，*通配符,只需要满足后缀即可--&gt;
     &lt;url-pattern&gt;*.servlet&lt;/url-pattern&gt;
     &lt;!--2.2.3.通配符匹配--&gt;
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
<h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1></li>
<li><p>实例化  </p>
</li>
</ol>
<p>由Servlet容器（Tomcat服务器）调用Servlet的构造方法创建一个servlet对象，默认在收到请求之后才创建；也可以指定在服务器启动时创建<br>两种方法：</p>
<ul>
<li>使用注解</li>
</ul>
<blockquote>
<p>@WebServlet(value=”/yourUrl”,loadOnStartup=1)  </p>
</blockquote>
<ul>
<li>在xml的<code>Servlet</code>节点中加入</li>
</ul>
<blockquote>
<p>&#60;load-on-startup&#62;0&#60;load-on-startup&#62;  </p>
</blockquote>
<p>当其值为0或者大于0时表示在服务器启动时创建</p>
<ol start="2">
<li>初始化  </li>
</ol>
<p>调用<code>init</code>方法进行初始化</p>
<ol start="3">
<li>就绪/服务  </li>
</ol>
<p>对请求进行响应，底层调用<code>service</code>方法</p>
<ol start="4">
<li>销毁  </li>
</ol>
<p>服务器在销毁servlet时调用<code>destroy</code>释放资源，通常在服务器重启或关闭时会被执行</p>
<h1 id="Servlet接收请求和响应"><a href="#Servlet接收请求和响应" class="headerlink" title="Servlet接收请求和响应"></a>Servlet接收请求和响应</h1><p>html文件放在<code>web</code>目录下</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;基本信息&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;基本信息&lt;/h1&gt;
    &lt;!-- 注意action指定路径 --&gt;
    &lt;form action=&quot;InfoServlet&quot; method=&quot;post&quot;&gt;
        姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;
        年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="java">package servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet(&quot;/InfoServlet&quot;)
public class InfoServlet extends HttpServlet {

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //在接收前修改请求对象的编码,不然服务器默认使用ISO-8859-1，一个字节一个字符
        request.setCharacterEncoding(&quot;utf-8&quot;);

        //修改响应编码,默认响应类型也是ISO-8859-1，输入中文会出现乱码
        response.setCharacterEncoding(&quot;utf-8&quot;);//这种方法不会改变浏览器编码，浏览器使用gbk显示，可能会乱码
        response.setContentType(&quot;text/html;charset=utf-8&quot;);//在响应头添加编码

        //request封装请求数据，response封装响应数据

        //接收数据
        String username = request.getParameter(&quot;username&quot;);
        String age = request.getParameter(&quot;age&quot;);
        System.out.println(request.getRemoteAddr()+username+&quot;...&quot;+age);//返回发起请求的ip地址

        //响应数据
        //输出数据的两种方式：
        PrintWriter out = response.getWriter();//字符流
        out.write(&quot;获取数据成功&quot;);
        ServletOutputStream out = response.getOutPutStream()//字节流
        out.write(&quot;获取数据成功&quot;.getBytes());
    }
}</code></pre>
<h1 id="Servlet线程安全问题"><a href="#Servlet线程安全问题" class="headerlink" title="Servlet线程安全问题"></a>Servlet线程安全问题</h1><p>因为每次请求都会创建一个线程，如果多人同时请求，就会存在多个线程操作一个Servlet对象，如果在对应的方法中操作了成员变量，就有可能产生线程安全问题</p>
<p>保证线程安全：</p>
<ul>
<li>将存在线程安全问题的代码放到同步代码块中<code>synchronized</code></li>
<li>尽可能使用基本不变量，防止使用成员变量<h1 id="结合JDBC注册案例"><a href="#结合JDBC注册案例" class="headerlink" title="结合JDBC注册案例"></a>结合JDBC注册案例</h1></li>
</ul>
<blockquote>
<p>javaWeb使用JDBC时需要在web文件夹的<code>lib</code>文件下导入需要的包  </p>
</blockquote>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;用户注册&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;用户注册&lt;/h1&gt;
    &lt;form action=&quot;RegisterServlet&quot; method=&quot;post&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;用户名&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;密码&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;确认密码&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;password&quot; name=&quot;repwd&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;邮箱&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;性别&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked=&quot;checked&quot;&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot;&gt;女
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;
                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
                &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="java">package com.xm.utils;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;

public class ActiveCodeUtils {
    //创建随机激活码
    public static String createActiveCode(){
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;);
        String s1 = simpleDateFormat.format(date);
        String s2 = Integer.toHexString(new Random().nextInt(900)+100);
        return s1+s2;
    }
}

package com.xm.servlet;

import com.xm.utils.ActiveCodeUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

@WebServlet(&quot;/RegisterServlet&quot;)
public class RegisterServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //编码
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //获取数据
        String username = request.getParameter(&quot;username&quot;);
        String pwd = request.getParameter(&quot;pwd&quot;);
        String repwd = request.getParameter(&quot;repwd&quot;);
        String email = request.getParameter(&quot;email&quot;);
        String gender = request.getParameter(&quot;gender&quot;);

        //验证数据
        PrintWriter writer = response.getWriter();
        //用户名为空或者输入空格（trim表示去掉空格）
        if(username == null || username.trim().equals(&quot;&quot;)){
            writer.write(&quot;用户名不能为空&quot;);
        }
        if(!pwd.equals(repwd)){
            writer.write(&quot;两次密码输入不一致&quot;);
        }
        //使用JDBC
        Connection conn = null;
        PreparedStatement pstat = null;
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            conn = DriverManager.getConnection(
                    &quot;jdbc:mysql://127.0.0.1:3306/shop?useSSL=false&quot;,
                    &quot;root&quot;,
                    &quot;zm19980225&quot;);
            pstat = conn.prepareStatement(
                    &quot;insert into users(username,password,email,gender,flag,role,code) values (?,?,?,?,?,?,?)&quot;
            );
            pstat.setString(1,username);
            pstat.setString(2,pwd);
            pstat.setString(3,email);
            pstat.setString(4,gender);
            pstat.setInt(5,0);
            pstat.setInt(6,1);
            pstat.setString(7, ActiveCodeUtils.createActiveCode());//使用工具类生成随机激活码
            int res = pstat.executeUpdate();
            if(res&gt;0){
                writer.write(&quot;注册成功&quot;);
            }else{
                writer.write(&quot;注册失败&quot;);
            }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
            writer.write(&quot;注册失败&quot;);
        }finally {
            if(pstat!=null){
                try {
                    pstat.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(conn!=null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><pre><code class="java">package com.xm.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/LoginServlet&quot;)
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //编码
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //接受数据
        String username = request.getParameter(&quot;username&quot;);
        String pwd = request.getParameter(&quot;pwd&quot;);
        System.out.println(&quot;用户名：&quot;+username+&quot;密码：&quot;+pwd);
        //判断
        if(username.equals(&quot;join&quot;) &amp;&amp; pwd.equals(&quot;8888&quot;)){
            //重定向,指明地址为web目录下的路径
            response.sendRedirect(&quot;info.html&quot;);
            return;
        }else{
            response.sendRedirect(&quot;register.html&quot;);
        }
    }
}</code></pre>
<h1 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h1><p>只能转发到同一个服务器（web容器）下的另一个url，不能是其他网站</p>
<pre><code class="java">//转发，应该使用request，因为是在请求的时候进行转发
//获取转发器
RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/ListServlet&quot;);//在服务器端，/表示web目录
//转发
requestDispatcher.forward(request,response);//使用转发浏览器的url不会改变</code></pre>
<h1 id="关于路径问题"><a href="#关于路径问题" class="headerlink" title="关于路径问题"></a>关于路径问题</h1><ul>
<li>绝对路径：用在不同网站之间的跳转</li>
<li>相对路径：容易出现混乱</li>
<li>根路径：如果在浏览器中使用，<code>/</code>表示域名，如果在服务器中使用，<code>/</code>表示web项目</li>
</ul>
<h1 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h1><p>设置响应头的几种方法：</p>
<pre><code class="java">response.setCharacterEncoding();
//设置tomcat编码，将数据写在html中</code></pre>
<pre><code class="java">response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;)</code></pre>
<pre><code class="java">response.setContntType(&quot;text/html;charset=UTF-8&quot;)</code></pre>
<h1 id="Request类常用API"><a href="#Request类常用API" class="headerlink" title="Request类常用API"></a>Request类常用API</h1><p>获取请求路径相关参数：<br><code>getRequestURL</code>:返回客户端发出请求时的完整URL<br><code>getRequestURI</code>:返回请求行中的资源名部分<br><code>getQueryString</code>:返回请求行中的参数部分<br><code>getRmoteHost</code>:返回请求的客户机的完整主机名<br><code>getLocalAddr</code>:返回WEB服务器的IP地址<br><code>getLocaleName</code>:返回WEB服务的主机名<br><code>getMethod</code>:客户机请求方式<br>获取请求头信息：<br><code>getHead(name)</code><br><code>getHeaders(String name)</code><br><code>getHeaderNames</code><br>获取请求正文参数：<br><code>getParameter(name)</code><br><code>getParameterValues(String name)</code><br><code>getParameterNames</code><br><code>getParameterMap</code><br><code>getInputStream</code></p>
<h1 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h1><pre><code class="java">package com.xm.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URLEncoder;

@WebServlet(&quot;/downloadServlet&quot;)
public class DownloadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //request.setCharacterEncoding(&quot;utf-8&quot;);

        //这种相对路径方法不行
        //File file = new File(&quot;images/test.jpg&quot;);

        //使用类加载器，也不行
        //DownloadServlet.class.getClassLoader().getResourceAsStream(&quot;images/test.jpg&quot;);

        //使用绝对路径(可以)
        //File file = new File(&quot;/media/M_fM__VM__GM_fM_!M_#/编程语言/Java/JavaWebStudy/web/images/test.jpg&quot;);

        //一般使用这种方式
        ServletContext application = getServletContext();
        String realpath = application.getRealPath(&quot;images/图片.jpg&quot;);
        System.out.println(realpath);
        File file = new File(realpath);
        FileInputStream fis = new FileInputStream(realpath);

        //中文乱码：将文件名变成utf-8编码，再转换成iso-8859-1编码传给服务器，服务器读取后浏览器再用utf-8
        //两种方法：
        String fileName = new String(file.getName().getBytes(&quot;utf-8&quot;),&quot;iso-8859-1&quot;);
        //String fileName = URLEncoder.encode(file.getName(),&quot;utf-8&quot;);
        System.out.println(file.getName());
        System.out.println(fileName);
        //发送给服务器之前要设置请求头,不设置会有文件名问题
        response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+fileName);
        ServletOutputStream sos = response.getOutputStream();
        byte[] bytes = new byte[1024*4];
        int len=0;
        while ((len = fis.read(bytes))!=-1){
            sos.write(bytes,0,len);
        }
    }
}</code></pre>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><pre><code class="java">package com.xm.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.URLDecoder;
import java.net.URLEncoder;

@WebServlet(&quot;/cookieServlet&quot;)
public class CookieServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //设置cookie
        Cookie cookie = new Cookie(&quot;username&quot;,&quot;hongdou&quot;);
        //如果有中文需要设置编码
        Cookie cookie2 = new Cookie(&quot;username&quot;, URLEncoder.encode(&quot;红豆&quot;,&quot;utf-8&quot;));
        //设置cookie的有效期,负数表示文件存储在浏览器中，关闭浏览器时即被删除，默认是-1;0表示删除cookie;正数表示有效期，以秒为单位
        cookie.setMaxAge(10*60);
        //设置cookie路径：默认为当前程序指定url往上一级
        cookie.setPath(&quot;/xxxx&quot;);
        //获取cookie的路径
        System.out.println(cookie.getPath());
        //设置cookie只有http才能读取，默认脚本可读
        cookie.setHttpOnly(true);
        //将cookie添加到response发给浏览器（颁发cookie）
        response.addCookie(cookie);
        response.addCookie(cookie2);
        //读取浏览器发回来的cookie
        Cookie[] cookies = request.getCookies();
        if(cookies!=null){
            for(Cookie c:cookies){
                //对于中文需要转码
                System.out.println(c.getName()+&quot;:&quot;+ URLDecoder.decode(c.getValue(),&quot;utf-8&quot;));
            }
        }
    }
}</code></pre>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>session有效时间默认是无操作半小时</p>
<pre><code class="java">package com.xm.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

@WebServlet(&quot;/sessionServlet&quot;)
public class SessionServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //获取session,一旦获取session，服务器就会创建cookie JSESSIONID,其值是一个十六进制字符串
        HttpSession session =request.getSession();

        System.out.println(&quot;sessionId:&quot;+session.getId());
        System.out.println(&quot;session创建时间:&quot;+new SimpleDateFormat().format(new Date(session.getCreationTime())));
        System.out.println(&quot;最后一次访问时间:&quot;+new SimpleDateFormat().format(new Date(session.getLastAccessedTime())));
        System.out.println(&quot;session过时时间:&quot;+session.getMaxInactiveInterval());

        //向session中存放数据
        session.setAttribute(&quot;username&quot;,&quot;ormosia&quot;);

        //获取session数据
        System.out.println(session.getAttribute(&quot;username&quot;));

        //设置session无效
        session.invalidate();

        //修改过期时间
        session.setMaxInactiveInterval(20*60);
    }
}</code></pre>
<p>设置session过期的另一种方法是在xml文件中配置</p>
<pre><code class="xml">&lt;session-config&gt;
    &lt;!--单位为分钟--&gt;
    &lt;session-timeout&gt;20&lt;/session-timeout&gt;
&lt;session-confin&gt;</code></pre>
<p>cookie和session的创建都是在服务器，但是cookie其状态是保存在客户端中的，session是保存在服务器中的。创建session时，服务器会在浏览器上创建一个cookie存储sessionID，后面客户端请求时服务器将读取sessionId找到对应的session。当浏览器关闭时，cookie会被删除，所以下次再访问时无法根据sessionId找到session，就会导致失效（但是实际上session还在，只是找不到了）</p>
<h1 id="将表单数据封装成javaBean的三种方法"><a href="#将表单数据封装成javaBean的三种方法" class="headerlink" title="将表单数据封装成javaBean的三种方法"></a>将表单数据封装成javaBean的三种方法</h1><pre><code class="java">package com.xm.servlet;

import com.xm.domain.User;
import com.xm.utils.ActiveCodeUtils;
import org.apache.commons.beanutils.BeanUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;

/**
 * 封装从表单获取的javabean类
 */
@WebServlet(&quot;/beanServlet&quot;)
public class BeanServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //第一种方法
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String email = request.getParameter(&quot;email&quot;);
        String gender = request.getParameter(&quot;gender&quot;);

        User user = new User(1,username,password,email,gender,0,1, ActiveCodeUtils.createActiveCode());
        System.out.println(user.toString());

        第二种方法
        Map&lt;String, String[]&gt; paraMap = request.getParameterMap();
        User user = new User();
        for(Map.Entry&lt;String,String[]&gt; entry:paraMap.entrySet()){
            System.out.println(entry.getKey());
            System.out.println(entry.getValue().toString());
            System.out.println(entry.getValue().length);

            String key = entry.getKey();
            try {
                //属性描述符
                PropertyDescriptor pd = new PropertyDescriptor(key,User.class);//获取指定属性（key）的属性描述符
                if(pd != null){
                    Method method  = pd.getWriteMethod();//获取该属性的写方法
                    if(entry.getValue().length == 1){
                        method.invoke(user,entry.getValue()[0]);
                    }else{
                        method.invoke(user,entry.getValue());
                    }
                }
            } catch (IntrospectionException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            }
        }
        System.out.println(user.toString());

        //第三种方法：使用已经封装好的BeanUtils包
        /**
        * 需要三个包：
        * 1. commons-beanutils
        * 2. commons-collections
        * 3. commons-logging
        */
        User user  = new User();
        try {
            //d第一个参数是类对象，第二个是表单的所有内容，会自动把值赋给对象
            BeanUtils.populate(user,request.getParameterMap());
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(user.toString());

    }
}</code></pre>
<h1 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h1><p><code>ServletContext</code>又叫Servlet上下文，代表当前整个应用程序，web服务器启动时，会为每一个Web应用程序创建的一个<strong>共享</strong>的存储区域，在服务器启动时创建，关闭时销毁</p>
<p>ServletContext的获取：</p>
<pre><code class="java">//第一种方法：
ServletContext application = this.getServletContext();
//第二种方式：
ServletContext application2 = getServletConfig().getServletContext();
//第三种方法：通过session获取,常用
ServletContext application3 = request.getSession().getServletContext();
//第四种方式：通过Request，最常用
ServletContext application4 = request.getServletContext();</code></pre>
<p>获取信息</p>
<pre><code class="java">//获取资源路径
String path = application.getRealPath(&quot;&quot;);//代表应用程序所在目录,即服务器的web目录
String path2 = application.getRealPath(&quot;WEB-INF/classes/books.xml&quot;);//放在src下的文件，应该这样写
//获取路径信息(上下文路径）
String path3 = application.getContextPath();//项目根路径
//在上下文存储信息
application.setAttribute(&quot;welcome&quot;,&quot;在其他页面获取上下文也可以读到&quot;);
//读取上下文信息
Object attribute = application.getAttribute(&quot;welcome&quot;);</code></pre>
<h1 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h1><p>初始化Filter的两种方法：</p>
<p>使用注解</p>
<blockquote>
<p>@WebFilter(“/yourFilter”)</p>
</blockquote>
<p>使用xml文件</p>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;firstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.xm.filter.FirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;firstFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
<p>注解优先级别设定：<br>在xml中，排前面的<code>filter-mapping</code>优先执行<br>在注解中按照类名的字符串排序进行作用</p>
<h2 id="过滤器处理浏览器缓存"><a href="#过滤器处理浏览器缓存" class="headerlink" title="过滤器处理浏览器缓存"></a>过滤器处理浏览器缓存</h2><p>当向服务器请求html界面时，第一次服务器会创建一个缓存区，将资源放入缓存区，当客户端第二次进行访问时，服务器根据时间判断如果是同一个资源且没有更新，就直接返回缓存区资源并且返回304状态码，同时浏览器也会在本地缓存资源，当关闭浏览器重新打开或打开新页面时进行访问时，浏览器会从本地缓存查找，如果有就返回<code>200(from disk cache)</code>,再次刷新返回304</p>
<p>避免浏览器缓存的方法：浏览器还是会缓存，只是控制每次都是第一次访问</p>
<pre><code class="java">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
    System.out.println(&quot;开始执行过滤&quot;);
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) resp;
    response.setDateHeader(&quot;Expires&quot;,-1);
    response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
    chain.doFilter(req, resp);//资源放行，只有这句话执行才能继续访问

    System.out.println(&quot;过滤完成&quot;);
    }</code></pre>
<p>请求和响应都需要经过过滤器，请求经过的为<code>chain.daFilter</code>之前，其后为响应的过滤</p>
<h1 id="全站压缩功能"><a href="#全站压缩功能" class="headerlink" title="全站压缩功能"></a>全站压缩功能</h1><p>正常情况下调用httpResponse的write方法会直接将资源发给客户端，可以使用装饰者设计模式将write方法的写入内容先写进缓存，压缩后再进行发送</p>
<pre><code class="java">package com.xm.filter;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * 继承HttpServletResponseWrapper这个专门用来封装新功能的类
 */
public class GzipResponse extends HttpServletResponseWrapper {

    private ByteArrayOutputStream baos;//内存流
    private PrintWriter pw;
    /**
     * Constructs a response adaptor wrapping the given response.
     *
     * @param response The response to be wrapped
     * @throws IllegalArgumentException if the response is null
     */
    public GzipResponse(HttpServletResponse response) {
        super(response);
        baos = new ByteArrayOutputStream();
    }

    public ByteArrayOutputStream getBaos(){
        if(pw!=null){
            pw.flush();//将pw的缓存写入baos
        }
        return baos;
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        pw = new PrintWriter(baos,true);//获取一个写入内存流的打印流
        return pw;
    }

    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        return super.getOutputStream();
    }
}</code></pre>
<pre><code class="java">package com.xm.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.zip.GZIPOutputStream;

@WebFilter(&quot;/gzipServlet&quot;)
/**
 * 全站压缩
 */
public class GzipFilter implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        //压缩前进行处理
        HttpServletRequest request = (HttpServletRequest) req;
        GzipResponse response = new GzipResponse((HttpServletResponse)resp);

        //处理后发给目标地址
        chain.doFilter(request, response);

        //将目标地址操作后要发送的资源进行压缩
        ByteArrayOutputStream baos = response.getBaos();
        System.out.println(&quot;未压缩前的资源大小：&quot;+baos.size());
        ByteArrayOutputStream newbaos = new ByteArrayOutputStream();//保存压缩后的数据
        //压缩类
        GZIPOutputStream gzip = new GZIPOutputStream(newbaos);
        //压缩操作
        gzip.write(baos.toByteArray());
        gzip.flush();
        gzip.close();
        System.out.println(&quot;压缩后的数据大小：&quot;+newbaos.size());

        //把压缩后的数据发给浏览器
        response.setHeader(&quot;Content-Encoding&quot;,&quot;gzip&quot;);
        response.getOutputStream().write(newbaos.toByteArray());
    }

    public void init(FilterConfig config) throws ServletException {

    }
}</code></pre>
<pre><code class="java">package com.xm.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet(&quot;/gzipServlet&quot;)
public class GzipServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        PrintWriter writer = response.getWriter();//因为经过了过滤器，获取到的是自定义压缩里面的打印流
        writer.write(&quot;一二三四五六七八九十十一十二十三十四十五十六十七十八十九二十&quot;);
    }
}</code></pre>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器在服务器创建时启动，服务器关闭时销毁<br>监听器的两种配置方法：</p>
<ul>
<li>注解<code>@WebListener()</code></li>
<li>使用xml文件<pre><code class="xml">&lt;listener&gt;
      &lt;listener-class&gt;类所在的路径（com.xm.xxxx)&lt;/listener-class&gt;
  &lt;/listener&gt;</code></pre>
监听器主要有以下几种：</li>
<li><strong>ServletContextListener</strong>:监听Servlet上下文<pre><code class="java">package com.xm.listener;
</code></pre>
</li>
</ul>
<p>import javax.servlet.ServletContextEvent;<br>import javax.servlet.ServletContextListener;<br>import javax.servlet.annotation.WebListener;</p>
<p>@WebListener()<br>/**</p>
<ul>
<li><p>Servlet上下文监听器</p>
</li>
<li><p>事件源:ServletContext</p>
</li>
<li><p>监听器</p>
</li>
<li><p>/<br>public class MyServletContextListener implements ServletContextListener {</p>
<p>  // Public constructor is required by servlet spec<br>  public MyServletContextListener() {<br>  }</p>
<p>  // ——————————————————-<br>  // ServletContextListener implementation<br>  // ——————————————————-</p>
<p>  //初始化<br>  public void contextInitialized(ServletContextEvent sce) {</p>
<pre><code>/* This method is called when the servlet context is
   initialized(when the Web application is deployed). 
   You can initialize servlet context related data here.
*/
System.out.println(sce.getSource().hashCode());</code></pre><p>  }</p>
<p>  //销毁<br>  public void contextDestroyed(ServletContextEvent sce) {</p>
<pre><code>/* This method is invoked when the Servlet Context 
   (the Web application) is undeployed or 
   Application Server shuts down.
*/</code></pre><p>  }<br>}</p>
<pre><code>- **ServletContextAttributeListener**:监听ServletContext中变量的变化
```java
package com.xm.listener;
</code></pre></li>
</ul>
<p>import javax.servlet.ServletContextAttributeEvent;<br>import javax.servlet.ServletContextAttributeListener;<br>import javax.servlet.annotation.WebListener;</p>
<p>@WebListener()<br>public class MyServletContextAttributeListener implements ServletContextAttributeListener{</p>
<pre><code>// Public constructor is required by servlet spec
public MyServletContextAttributeListener() {
}

@Override
//添加了某个变量
public void attributeAdded(ServletContextAttributeEvent scae) {
    System.out.println(&quot;添加了某个变量&quot;+scae.getName()+&quot;:&quot;+scae.getValue());
}

@Override
//删除了某个变量
public void attributeRemoved(ServletContextAttributeEvent scae) {
    System.out.println(&quot;删除了某个变量&quot;+scae.getName()+&quot;:&quot;+scae.getValue());

}

@Override
//替换了某个变量
public void attributeReplaced(ServletContextAttributeEvent scae) {
    System.out.println(&quot;更新了某个变量&quot;+scae.getName()+&quot;:&quot;+scae.getValue());
}</code></pre><p>}</p>
<pre><code>- **HttpSessionListener**:session监听器
```java
package com.xm.listener;

import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import javax.servlet.http.HttpSessionAttributeListener;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

@WebListener()
public class MyHttpSessionListener implements ServletContextListener,
        HttpSessionListener, HttpSessionAttributeListener {

    // Public constructor is required by servlet spec
    public MyHttpSessionListener() {
    }

    // -------------------------------------------------------
    // HttpSessionListener implementation
    // -------------------------------------------------------
    public void sessionCreated(HttpSessionEvent se) {
        /* Session is created. */
        System.out.println(&quot;创建了session：&quot;+se.getSession());
    }

    public void sessionDestroyed(HttpSessionEvent se) {
        /* Session is destroyed. */
        //服务器关闭或者session过期
        System.out.println(&quot;销毁了session：&quot;+se.getSession());
    }
}</code></pre><ul>
<li><strong>HttpSessionAttributeListener</strong>:监听session的变量变化</li>
<li><strong>HttpSessionBindingListener</strong>:监听对象的添加和删除，该类不需要写监听器，将需要监听的对象继承该接口<pre><code class="java">package com.xm.domain;
</code></pre>
</li>
</ul>
<p>import javax.servlet.http.HttpSessionBindingEvent;<br>import javax.servlet.http.HttpSessionBindingListener;</p>
<p>public class User implements HttpSessionBindingListener {<br>    private String username;<br>    private String password;<br>    private String email;</p>
<pre><code>public User() {
}

public User(String username, String password, String email) {
    this.username = username;
    this.password = password;
    this.email = email;
}

public String getUsername() {
    return username;
}

public void setUsername(String username) {
    this.username = username;
}

public String getPassword() {
    return password;
}

public void setPassword(String password) {
    this.password = password;
}

public String getEmail() {
    return email;
}

public void setEmail(String email) {
    this.email = email;
}

@Override
public String toString() {
    return &quot;User{&quot; +
            &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +
            &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +
            &quot;, email=&#39;&quot; + email + &#39;\&#39;&#39; +
            &#39;}&#39;;
}

@Override
/**
 * 把user放入session时执行
 */
public void valueBound(HttpSessionBindingEvent event) {
    System.out.println(&quot;向session中添加对象：&quot;+event.getName()+&quot;:&quot;+event.getValue());
}

@Override
/**
 * 把user从session中移除时执行
 */
public void valueUnbound(HttpSessionBindingEvent event) {
    System.out.println(&quot;向session中删除对象：&quot;+event.getName()+&quot;:&quot;+event.getValue());
}</code></pre><p>}</p>
<pre><code>- **ServletRequestListener**：监听请求生命周期
- **ServletRequestAttributeListener**:监听请求中的变量属性
# 自定义session管理  

```java
package com.xm.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import java.util.*;

/**
 * session管理
 */
@WebListener
public class SessionManagerListener implements HttpSessionListener, ServletContextListener {
    private Timer timer;//计时器工具类
    private Object lock = new Object();//一把锁，防止同步问题
    private List&lt;HttpSession&gt; sessions = new LinkedList&lt;HttpSession&gt;();
    private class MyTimerTask extends TimerTask{
        @Override
        public void run() {
            Iterator&lt;HttpSession&gt; iterator = sessions.iterator();
            synchronized (lock){
                while (iterator.hasNext()) {
                    HttpSession session = iterator.next();
                    if(System.currentTimeMillis()-session.getLastAccessedTime()&gt;(60*1000)){
                        session.invalidate();//失效
                        iterator.remove();//把元素移除
                    }
                }
            }
        }
    }
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        timer = new Timer();
        timer.schedule(new MyTimerTask(),0,60*1000);//启动计时器
        sce.getServletContext().setAttribute(&quot;session&quot;,sessions);
        System.out.println(&quot;定时器执行了&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {

    }

    @Override
    public void sessionCreated(HttpSessionEvent se) {
        synchronized (lock){
            sessions.add(se.getSession());
            System.out.println(&quot;添加了一个session&quot;+se.getSession().hashCode());
        }
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent se) {
        System.out.println(&quot;session销毁了&quot;);
    }
}</code></pre><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><pre><code class="java">package com.xm.utils;

import java.io.File;
import java.util.UUID;

/**
 * 文件上传工具类
 */
public class FileUploadUtils {
    /**
     * 生成文件名
     * @param oldFileName
     * @return
     */
    public static String getNewFileName(String oldFileName){
        String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);//返回唯一通用识别码
        System.out.println(uuid);
        return uuid+&quot;_&quot;+oldFileName;
    }

    /**
     * 产生一个新的目录
     * @param basedir
     * @param oldFileName
     * @return
     */
    public static String getNewPath(String basedir,String oldFileName){
        int hashCode = oldFileName.hashCode();
        int dir1 = hashCode&amp;0xf;//与15与运算取后四位
        int dir2 = (hashCode&gt;&gt;4)&amp;0xf;//右移4位再取四位

        String path = basedir+&quot;\\&quot;+dir1+&quot;\\&quot;+dir2;
        File d = new File(path);
        if(!d.exists()){
            d.mkdirs();
        }
        return path;
    }
}


package com.xm.servlet;

import com.xm.utils.FileUploadUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Part;
import java.io.IOException;
import java.util.Collection;

@WebServlet(&quot;/uploadFile&quot;)
//location:存储临时文件的位置
//maxFileSize:上传文件允许的最大大小（以字节为单位）
//maxRequstSize:multipart/form-data允许的最大请求大小
//fileThreadThreshold：文件将写入磁盘的大小阈值，缓存，数据量大于该值时写入文件
@MultipartConfig(location = &quot;&quot;,maxFileSize = 1024*1024*2,maxRequestSize = 1024*1024*20,fileSizeThreshold = 1024*100)
public class UpLoadFileServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        String basePath = request.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);
        System.out.println(basePath);
        Collection&lt;Part&gt; parts = request.getParts();
        if(parts!=null){
            for (Part part : parts) {
                String fileName = part.getSubmittedFileName();
                if (fileName != null) {
                    //该项是文件

                    //获取新的文件名
                    String newFileName = FileUploadUtils.getNewFileName(fileName);
                    //获取存储目录
                    String newPath = FileUploadUtils.getNewPath(basePath,fileName);
                    part.write(newPath+&quot;\\&quot;+newFileName);
                    System.out.println(fileName+&quot;上传成功&quot;);
                    response.getWriter().write(&quot;上传成功&quot;);
                }else{
                    //不是文件，是其他属性
                    String name = part.getName();//获取属性名
                    String value = request.getParameter(name);
                    System.out.println(name+&quot;:&quot;+value);
                }
            }
        }
    }
}</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/04/08/JSP/" title="JSP"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: JSP</span></a><a class="button is-default" href="/2019/03/27/Tomcat%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" title="Tomcat安装配置"><span class="has-text-weight-semibold">下一页: Tomcat安装配置</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>&lt;a href=&quot;http://www.beian.miit.gov.cn/&quot;&gt;备案号&lt;/a&gt;</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>