<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>动态规划算法基本思想</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="概念动态规划（Dynamic Programming)算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。
现在通过一个例子来了解一下DP的基本原理。
首先，要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。
如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)


首先我们思考一个问题，如何用最少的硬币凑够 i 元(i&amp;lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。2.这个规模变小后的问题和原来的问题是.."></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">动态规划算法基本思想</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java代码实现"><span class="toc-text">java代码实现</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E7%AE%97%E6%B3%95"><i class="tag post-item-tag">算法</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">动态规划算法基本思想</h1><time class="has-text-grey" datetime="2019-11-27T02:22:53.000Z">2019-11-27</time><article class="mt-2 post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>动态规划（Dynamic Programming)算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p>
<p>现在通过一个例子来了解一下DP的基本原理。</p>
<p>首先，要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。</p>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p>
<a id="more"></a>

<p>首先我们思考一个问题，如何用最少的硬币凑够 <code>i</code> 元(<code>i&lt;11</code>)？<br>为什么要这么问呢？ 两个原因：<br>1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。<br>2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p>
<p>好了，让我们从最小的 <code>i</code> 开始吧。<br>当 <code>i=0</code>，即我们需要多少个硬币来凑够 0 元。 由于1，3，5都大于0，即没有比 0 小的币值，因此凑够 0 元我们最少需要 0 个硬币。这时候我们发现用一个标记来表示这句<strong>凑够0元我们最少需要0个硬币</strong>会比较方便， 如果一直用纯文字来表述，不出一会儿就会觉得很绕了。那么， 我们用 <code>d(i)=j</code> 来表示<strong>凑够i元最少需要j个硬币</strong>。于是我们已经得到了 <code>d(0)=0</code>， 表示凑够 0 元最小需要 0 个硬币。<br>当 <code>i=1</code> 时，只有面值为 1 元的硬币可用， 因此我们拿起一个面值为 1 的硬币，接下来只需要凑够 0 元即可，而这个是已经知道答案的， 即 <code>d(0)=0</code>。所以，<code>d(1)=d(1-1)+1=d(0)+1=0+1=1</code>。(括号内 <code>1-1</code> 表示当前要凑的钱数减掉当前面值后仍需要凑的钱数，可由前面的 <code>d(x)</code> 获得）<br>当 <code>i=2</code> 时，仍然只有面值为 1 的硬币可用，于是拿起一个面值为 1 的硬币， 接下来只需要再凑够 <code>2-1=1</code> 元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以 <code>d(2)=d(2-1)+1=d(1)+1=1+1=2</code>。<br>看看 <code>i=3</code>时的情况。当 <code>i=3</code> 时，我们能用的硬币就有两种了：1 元的和 3 元的(5 元的仍然没用，因为你需要凑的数目是3元！)。 既然能用的硬币有两种，我就有两种方案:</p>
<ul>
<li>如果我拿了一个 1 元的硬币，我的目标就变为了： 凑够 <code>3-1=2</code> 元需要的最少硬币数量。即 <code>d(3)=d(3-1)+1=d(2)+1=2+1=3</code>。 这个方案说的是，我拿3个1元的硬币；</li>
<li>第二种方案是我拿起一个 3 元的硬币， 我的目标就变成：凑够 <code>3-3=0</code> 元需要的最少硬币数量。即 <code>d(3)=d(3-3)+1=d(0)+1=0+1=1</code>。 这个方案说的是，我拿1个3元的硬币。</li>
</ul>
<p>好了，这两种方案哪种更优呢？ 记得我们是要用最少的硬币数量来凑够3元的。所以， 选择<code>d(3)=1</code>，怎么来的呢？具体是这样得到的：<code>d(3)=min{d(3-1)+1, d(3-3)+1}</code>。</p>
<p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：<strong>状态</strong>和<strong>状态转移方程</strong>。</p>
<p>上文中 <code>d(i)</code> 表示凑够 <code>i</code> 元需要的最少硬币数量，我们将它定义为该问题的<strong>状态</strong>， 这个状态是怎么找出来的呢?<br>根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：<code>d(11)</code>，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用 <code>d(i)</code> 表示状态，那么状态转移方程自然包含 <code>d(i)</code>， 上文中包含状态 <code>d(i)</code> 的方程是：<code>d(3)=min{d(3-1)+1, d(3-3)+1}</code>。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<pre><code>d(i)=min{ d(i-vj)+1,d(i-1)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</code></pre><h1 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h1><pre><code class="java">//n:需要凑齐多少钱
public String dp(int n) {
    n++;//从0元开始，所以需要加1
    int[] min = new int[n];
    int[] v = {1,3,5};
    min[0] = 0
    for(int i=1;i&lt;n;i++) {
        min[i] = min[i-1]+1;//默认情况下为上一种情况再加1块钱硬币
        for(int j=0;j&lt;v.length;j++) {
            if(v[j] &gt;i) {
                break;
            }
            if(min[i-v[j]] &lt; min[i-1]) {
                //减去当前面值后所需硬币数量+1个当前面值的硬币
                min[i] = min[i-v[j]] +1;
            }
        }
    }
    return min[n-1];
}</code></pre>
<p>参考文章：</p>
<blockquote>
<ul>
<li><a href="http://hawstein.com/2013/03/26/dp-novice-to-advanced/" target="_blank" rel="noopener">动态规划：从新手到专家</a></li>
<li><a href="https://www.jianshu.com/p/a7741619dd58" target="_blank" rel="noopener">LeetCode[5] - 最长回文子串&amp;&amp;动态规划</a></li>
</ul>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/12/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="排序算法总结"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 排序算法总结</span></a><a class="button is-default" href="/2019/11/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/" title="权限认证"><span class="has-text-weight-semibold">下一页: 权限认证</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备18114217号</a></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>