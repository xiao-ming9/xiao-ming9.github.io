<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Zookeeper基本使用</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Zookeeper基本使用</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper特点"><span class="toc-text">Zookeeper特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Zookeeper安装"><span class="toc-text">Zookeeper安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单机安装"><span class="toc-text">单机安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群安装部署"><span class="toc-text">集群安装部署</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell命令操作"><span class="toc-text">Shell命令操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#监听服务器节点动态上下线案例"><span class="toc-text">监听服务器节点动态上下线案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实现"><span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器端"><span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端"><span class="toc-text">客户端</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Zookeeper"><i class="tag post-item-tag">Zookeeper</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Zookeeper基本使用</h1><time class="has-text-grey" datetime="2019-11-19T14:00:41.000Z">2019-11-19</time><article class="mt-2 post-content"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Zookeeper是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p>
<blockquote>
<p>Zookeeper = 文件系统 + 通知机制  </p>
</blockquote>
<h2 id="Zookeeper特点"><a href="#Zookeeper特点" class="headerlink" title="Zookeeper特点"></a>Zookeeper特点</h2><ul>
<li>一个领导者（Leader），多个跟随者（Follower）组成的集群</li>
<li>集群中只要有半数以上节点存活，Zookeeper集群就能够正常服务</li>
<li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</li>
<li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>实时性，在一定时间范围内，Client能读到最新数据<a id="more"></a>

</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Zookeeper的数据模型结构与 Unix 文件系统很类似，整体上可以看作一棵树，每个节点称为一个<code>ZNode</code>，每一个<code>ZNode</code>默认能够存储1MB的数据，每个<code>ZNode</code>都可以通过其路径唯一标识。</p>
<p><img src="https://qiniu.xiaoming.net.cn/zookeeper%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png" alt="Zookerper节点结构"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>统一命名服务：在分布式环境下，经常需要对应用或服务进行统一命名，便于识别。例如IP不容易记，使用域名。</li>
<li>统一配置管理</li>
</ol>
<ul>
<li>在分布式环境下，一般要求在一个集群下，所有节点的配置信息是一致的。在 Zookeeper 中，可以将配置信息写入到 Zookeeper 上的一个 Znode 中。</li>
<li>对配置文件修改后，希望能够快速同步到各个节点上。每个客户端服务器监听这个Znode，一旦Znode中的数据被修改，Zookeeper将通知各个客户端服务器。</li>
</ul>
<ol start="3">
<li>统一集群管理：分布式环境中，实时掌握每个节点的状态是必要的，要求可以根据节点实时状态作出一些调整。Zookeeper可以实现实时监控节点状态变化。可将节点信息写入到Zookeeper的一个Znode，监听这个Znode可以获取它实时状态变化。</li>
<li>服务器动态上下线：客户端能够实时洞察到服务器上下线的变化。服务器将是否在线的状态写入到Znode中，客户端获取到当前在线服务器列表，并注册监听，当服务器有上下线时就会发起事件通知。</li>
<li>软负载均衡：在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。</li>
</ol>
<h1 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h1><h2 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h2><p>在Zookeeper官网上下载压缩包，解压后配置文件在<code>conf/zoo_sample.cfg</code>文件中。可以根据需要修改配置文件。</p>
<p>启动和关闭的相关文件在<code>bin</code>目录下：</p>
<ul>
<li>启动Zookeeper：<pre><code>bin/zkServer.sh start</code></pre></li>
<li>查看进程是否启动<pre><code>jps</code></pre></li>
<li>查看状态<pre><code class="shell">$ bin/zkServer.sh status
</code></pre>
</li>
</ul>
<p>/usr/bin/java<br>ZooKeeper JMX enabled by default<br>Using config: /Users/xiaoming/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg<br>Client port found: 2181. Client address: localhost.<br>Mode: standalone</p>
<pre><code>- 启动客户端</code></pre><p>bin/zkCli.sh</p>
<pre><code>- 退出客户端</code></pre><p>quit</p>
<pre><code>- 停止Zookeeper</code></pre><p>bin/zkServer.sh stop</p>
<pre><code>
## 配置文件参数

```apacheconf
# 通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒
# Zookeeper使用的基本时间，服务器之间和客户端和服务器之间维持心跳的时间间隔，也就是每个ticketTime就会发送一次心跳，时间单位为毫秒。
# 用于心跳机制，并且设置最小的session超时时间为两倍心跳时间
tickTime=2000
# LF初始通信时限(初次连接时间）
# 集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（ticketTime的数量），用来限定集群中Zookeeper服务器连接到Leader的时限
initLimit=10
# LF同步通信时限
# 集群中Leader和Follower之间的最大响应时间单位，
syncLimit=5
# 数据文件目录+数据持久化路径
# 主要用于保存Zookeeper中的数据
dataDir=/tmp/zookeeper
# 客户端连接的端口，用于监听客户端连接的端口
clientPort=2181
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to “0” to disable auto purge feature
#autopurge.purgeInterval=1</code></pre><h2 id="集群安装部署"><a href="#集群安装部署" class="headerlink" title="集群安装部署"></a>集群安装部署</h2><p>集群模式下需要在每台服务器存储zookeeper数据的文件中创建一个<code>myid</code>文件，这个文件只有一个数据就是该节点的值，例如server1则写1，server2则写2。<strong>Zookeeper启动时读取此文件，拿到里面的数据与<code>zoo.cfg</code>里面的配置信息比较从而判断到底是哪个server</strong>。</p>
<p>同时，需要在配置文件最后加入集群信息：</p>
<pre><code>server.A=B:C:D</code></pre><ul>
<li>B是这个服务器的ip地址</li>
<li>C是这个服务器与集群中的Leader服务器交换信息的端口</li>
<li>D是万一集群中Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器互相通信的端口</li>
</ul>
<p>配置示例：</p>
<pre><code class="apacheconf"># The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial 
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just 
# example sakes.
dataDir=/Users/xiaoming/Zookeeper/server1/zkData
# the port at which the clients will connect
clientPort=2181
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to “0” to disable auto purge feature
#autopurge.purgeInterval=1
server.1=127.0.0.1:2888:3888
server.2=127.0.0.1:2889:3889
server.3=127.0.0.1:2890:3890</code></pre>
<p>之后只需要在各个服务器启动Zookeeper即可。可以通过<code>bin/zkServer.sh status</code>查看当前节点状态。</p>
<h1 id="Shell命令操作"><a href="#Shell命令操作" class="headerlink" title="Shell命令操作"></a>Shell命令操作</h1><ol>
<li>启动客户端<pre><code>bin/zkCli.sh</code></pre></li>
<li>显示所有操作命令<pre><code>help</code></pre></li>
<li>查看当前znode中所包含的内容<pre><code>ls /</code></pre></li>
<li>查看当前节点数据并能看到更新次数等数据<pre><code>ls2 /</code></pre></li>
<li>创建普通节点<pre><code>create /app1 “hello app1”
create /app1/server101 “127.0.0.1”</code></pre></li>
<li>获取节点的值<pre><code>get /app1</code></pre></li>
<li>创建短暂节点(在当前客户端可以查看到，退出当前客户端然后再重启客户端会发现该节点已经被删除）<pre><code>create -e /app-emphemeral 888</code></pre></li>
<li>创建带有序号的节点(会按照顺序依次在创建的节点后面添加递增序号）<pre><code>create -s /app2/aa 888
</code></pre></li>
</ol>
<p>Created /app2/bb0000000001</p>
<pre><code>9. 修改节点数据值</code></pre><p>set /app1 999</p>
<pre><code>10. 节点的值变化监听
- 在 104 主机上注册监听`/app1` 节点数据变化</code></pre><p> [zk: localhost:2181(CONNECTED) 26] get  -w /app1 watch</p>
<pre><code>- 在 103 主机上修改`/app1`节点的数据</code></pre><p> [zk: localhost:2181(CONNECTED) 5] set /app1 777 </p>
<pre><code>- 观察 104 主机收到数据变化的监听</code></pre><p>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDataChanged path:/app1</p>
<pre><code>11. 节点的字节点变化监听（路径变化）
- 在 104 主机上注册监听/app1 节点的子节点变化</code></pre><p>[zk: localhost:2181(CONNECTED) 1] ls /app1 watch<br>[aa0000000001, server101] </p>
<pre><code>- 在 103 主机/app1 节点上创建子节点 </code></pre><p>[zk: localhost:2181(CONNECTED) 6] create /app1/bb 666<br>Created /app1/bb </p>
<pre><code>- 观察 104 主机收到子节点变化的监听 </code></pre><p>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/app1</p>
<pre><code>12. 删除节点(如果存在字节点，需要先删除字节点）</code></pre><p>delete /app1/bb</p>
<pre><code>13. 递归删除节点</code></pre><p>rmr /app2</p>
<pre><code>14. 查看节点状态</code></pre><p>stat /app1</p>
<pre><code>
# 内部原理
1. 半数机制：集群中半数以上的机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。
2. Zookeeper虽然在配置文件中并没有指定`Master`和`Slave`。但是Zookeeper工作时，是有一个节点为`Leader`,其他则为`Follower`,`Leader`是通过内部的选举机制临时产生的。

## 选举机制
Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举：
1. 服务器初始化启动
2. 服务器运行期间无法和Leader保持连接

### 服务器启动时期的Leader选举
若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下：
1. 每个Server发出一个投票：由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的`myid`和`ZXID`，使用`(myid, ZXID)`来表示，此时Server1的投票为`(1, 0)`，Server2的投票为`(2, 0)`，然后各自将这个投票发给集群中其他机器。
2. 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。
3. 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下:
- 优先检查ZXID。ZXID比较大的服务器优先作为Leader。
- 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。
对于Server1而言，它的投票是`(1, 0)`，接收Server2的投票为`(2, 0)`，首先会比较两者的`ZXID`，均为0，再比较`myid`，此时Server2的`myid`最大，于是更新自己的投票为`(2, 0)`，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。
4. 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了`(2, 0)`的投票信息，此时便认为已经选出了Leader。
5. 改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为`FOLLOWING`，如果是Leader，就变更为`LEADING`。

### 服务器运行期间的Leader选举

在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。选举过程如下：
1. 变更状态。Leader挂后，余下的非Observer服务器都会讲自己的服务器状态变更为`LOOKING`，然后开始进入Leader选举过程。
2. 每个Server会发出一个投票。在运行期间，每个服务器上的`ZXID`可能不同，此时假定Server1的`ZXID`为123，Server3的`ZXID`为122；在第一轮投票中，Server1和Server3都会投自己，产生投票`(1, 123)`，`(3, 122)`，然后各自将投票发送给集群中所有机器。
3. 接收来自各个服务器的投票。与启动时过程相同。
4. 处理投票。与启动时过程相同，此时，Server1将会成为Leader。
5. 统计投票。与启动时过程相同。
6. 改变服务器的状态。与启动时过程相同。

## 节点类型
主要有两种类型：
- `持久（Persistent)`：客户端与服务器端断开连接后，创建的节点不删除
- `短暂（Ephemeral）`：客户端和服务器断开连接后，创建的节点不删除

### 持久化节点
分为持久化目录节点和持久化顺序编号目录节点：
- 持久化目录节点：客户端与Zookeeper断开连接后，该节点依旧存在。
- 持久化顺序编号目录节点：客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。

### 临时节点
分为临时目录节点和临时顺序编号目录节点。
- 临时目录节点：客户端与Zookeeper断开连接后，该节点被删除。
- 临时顺序编号目录节点：客户端与Zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。

&gt; 创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。  
&gt; 在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。  

![Zookeeper节点类型](https://qiniu.xiaoming.net.cn/zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B.png)

## Stat结构体
使用`stat`命令可以查看节点的状态，其返回的数据代表的意义如下：
1. **czxid**：引起这个znode创建的`zxid`，创建节点事务的`zxid`
&gt; 每次修改 ZooKeeper 状态都会收到一个`zxid`形式的时间戳，也就是 ZooKeeper 事务 ID。 事务 ID 是 ZooKeeper 中所有修改总的次序。每个修改都有唯一的`zxid`，如果`zxid1`小 于`zxid2`，那么`zxid1`在`zxid2`之前发生。  
2. **ctime**：znode被创建的毫秒数（从1970年开始）
3. **mzxid**：znode最后更行的zxid
4. **mtime**：最后修改的毫秒数（从1970年开始）
5. **pZxid**：znode做后更新的字节点zxid
6. **cversion**：znode字节点变化号，znode字节点修改次数
7. **dataversion**：znode数据变化号
8. **aclVersion**：znode访问控制列表的变化号
9. **ephemeralOwner**：如果是临时节点，这个是 znode 拥有者的 session id。如果不是临时节点则是 0。
10. **dataLength**：znode的数据长度
11. **numChildren**：znode字节点数量

## 监听器原理 
1. 首先有一个`main()`线程
2. 在`main()`线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connect），一个负责监听（listener）
3. 通过`connect`线程将注册的监听事件发送给Zookeeper
4. 在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中
5. Zookeeper监听到有数据或者路径变化，就会将这个消息发送给`listener`线程
6. `listener`线程内部调用了`process()`方法

![Zookerper监听器原理](https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/zookeeper%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86.png?raw=true)

常见的监听：
- 监听节点数据的变化：`get -w path`
- 监听字节点增减的变化：`ls -w path`

## 写数据流程
![Zookeeper写数据流程](https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/zookeeper%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png?raw=true)

# API使用
需要引入如下配置：
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.5.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</code></pre><pre><code class="java">import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.List;

public class TestZookeeper {

    //连接的服务器，用”,”分割，注意不能有空格
    private static String connectString = “127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183”;
    private static int sessionTimeout = 2000;
    private ZooKeeper zkClient = null;

    /**
     * 创建Zookeeper客户端
     * @throws IOException
     */
    @Before
    public void init() throws IOException {
        zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                //收到事件通知后的回调函数（用户的业务逻辑）
                System.out.println(watchedEvent.getType()+”—“+watchedEvent.getPath());

                //再次启动监听
                try {
                    List&lt;String&gt; children = zkClient.getChildren(“/“, true);
                    for (String child:children) {
                        System.out.println(child);
                    }
                } catch (KeeperException e) {
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    /**
     * 创建字节点
     * @throws KeeperException
     * @throws InterruptedException
     */
    @Test
    public void create() throws KeeperException, InterruptedException {
        //参数1：创建节点的路径
        //参数2：节点数据,需要使用字节数组
        //参数3：节点权限
        //参数4：节点的类型
        String nodeCreated = zkClient.create(“/idea”,”hello,idea”.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        System.out.println(nodeCreated);
    }

    /**
     * 获取子节点
     * @throws KeeperException
     * @throws InterruptedException
     */
    @Test
    public void getChildren() throws KeeperException, InterruptedException {
        List&lt;String&gt; children = zkClient.getChildren(“/“, true);
        for(String child:children) {
            System.out.println(child);
        }

        //延时阻塞
        Thread.sleep(Long.MAX_VALUE);
    }

    /**
     * 判断znode是否存在
     * @throws KeeperException
     * @throws InterruptedException
     */
    @Test
    public void exist() throws KeeperException, InterruptedException {
        Stat exists = zkClient.exists(&quot;/idea&quot;, false);
        System.out.println(exists == null?&quot;not exist&quot;:&quot;exist&quot;);
    }
}</code></pre>
<h1 id="监听服务器节点动态上下线案例"><a href="#监听服务器节点动态上下线案例" class="headerlink" title="监听服务器节点动态上下线案例"></a>监听服务器节点动态上下线案例</h1><p>在分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。</p>
<p><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/zookeeper%E5%8A%A8%E6%80%81%E8%8A%82%E7%82%B9%E4%B8%8A%E4%B8%8B%E7%BA%BF.png?raw=true" alt="Zookeeper动态节点上下线"></p>
<p>从zookeeper角度来说，服务器和客户端其实都属于zookeepr的客户端。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre><code class="java">import org.apache.zookeeper.*;

import java.io.IOException;

public class DistributeServer {
    private static String connectString = “127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183”;
    private static int sessionTimeout = 2000;
    private ZooKeeper zk = null;
    private String parentNode = “/servers”;//提前创建好该节点

    /**
     * 创建到zk的客户端连接
     * @throws IOException
     */
    public void getConnect() throws IOException {
        zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {

            }
        });
    }

    /**
     * 注册服务器
     * @param hostname
     * @throws KeeperException
     * @throws InterruptedException
     */
    public void registServer(String hostname) throws KeeperException, InterruptedException {
        String create = zk.create(parentNode + “/server”, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(hostname+” is online” + create);
    }

    /**
     * 业务功能
     * @param hostname
     * @throws InterruptedException
     */
    public void business(String hostname) throws InterruptedException {
        System.out.println(hostname + &quot; is working...&quot;);
        Thread.sleep(Long.MAX_VALUE);
    }

    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        //获取zk连接
        DistributeServer server = new DistributeServer();
        server.getConnect();
        //利用zk连接注册服务器信息
        server.registServer(args[0]);
        //启动业务功能
        server.business(args[0]);
    }
}</code></pre>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class DistributeClient {
    private static String connectString = “127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183”;
    private static int sessionTimeout = 2000;
    private ZooKeeper zkClient = null;
    private String parentNode = “/servers”;//提前创建好该节点
    private volatile ArrayList&lt;String&gt; serversList = new ArrayList&lt;&gt;();

    //创建到zk的客户端连接
    public void getConnect() throws IOException {
         zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                //启动监听
                try {
                    getServerList();
                } catch (KeeperException e) {
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public void getServerList() throws KeeperException, InterruptedException {
        //获取服务器字节点信息，并且对父节点进行监听
        List&lt;String&gt; children = zkClient.getChildren(parentNode, true);
        ArrayList&lt;String&gt; servers = new ArrayList&lt;&gt;();

        for(String child:children) {
            byte[] data = zkClient.getData(parentNode + “/“ + child, false, null);
            servers.add(new String(data));
        }

        //把servers赋给成员serversList，以提供给各业务线程使用
        serversList = servers;
        System.out.println(serversList);
    }

    //业务功能
    public void business() throws InterruptedException {
        System.out.println(“client is working…”);
        Thread.sleep(Long.MAX_VALUE);
    }

    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        // 获取 zk 连接
        DistributeClient client = new DistributeClient();
        client.getConnect();
        // 获取 servers 的子节点信息，从中获取服务器信息列表
        client.getServerList();
        // 业务进程启动
        client.business();
    }
}</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/11/20/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Zookeeper/" title="Zookeeper"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Zookeeper</span></a><a class="button is-default" href="/2019/11/15/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><span class="has-text-weight-semibold">下一页: 分布式</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>