<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>消息队列(更新中...)</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">消息队列(更新中...)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-为什么要使用消息队列"><span class="toc-text">1. 为什么要使用消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过异步处理提高系统性能（削峰、减少响应所需时间）"><span class="toc-text">通过异步处理提高系统性能（削峰、减少响应所需时间）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#降低系统耦合性"><span class="toc-text">降低系统耦合性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入消息队列的缺点："><span class="toc-text">引入消息队列的缺点：　　</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-消息队列实现机制-AMPQ-协议"><span class="toc-text">2. 消息队列实现机制/ AMPQ 协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RabbitMQ交换机exchange的类型有哪些？"><span class="toc-text">3. RabbitMQ交换机exchange的类型有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fanout"><span class="toc-text">fanout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#direct"><span class="toc-text">direct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#topic"><span class="toc-text">topic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#headers"><span class="toc-text">headers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-如何保证消息可靠性传输？-RabbitMQ-消息确认机制（事务-Confirm）"><span class="toc-text">4. 如何保证消息可靠性传输？/RabbitMQ 消息确认机制（事务+Confirm）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务机制"><span class="toc-text">事务机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Confirm模式"><span class="toc-text">Confirm模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#producer端confirm模式的实现原理"><span class="toc-text">producer端confirm模式的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通confirm模式"><span class="toc-text">普通confirm模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量confirm模式"><span class="toc-text">批量confirm模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步confirm模式"><span class="toc-text">异步confirm模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-几种消息队列对比"><span class="toc-text">5. 几种消息队列对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-如何保证消息队列的高可用？"><span class="toc-text">6. 如何保证消息队列的高可用？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#普通集群模式"><span class="toc-text">普通集群模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像集群模式"><span class="toc-text">镜像集群模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-如何保证消息不会被重复消费（保证消息幂等性）？"><span class="toc-text">7. 如何保证消息不会被重复消费（保证消息幂等性）？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-如何保证消息队列消费的顺序性？"><span class="toc-text">8. 如何保证消息队列消费的顺序性？</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E9%9D%A2%E8%AF%95"><i class="tag post-item-tag">面试</i></a><a href="/tags/RabbitMQ"><i class="tag post-item-tag">RabbitMQ</i></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><i class="tag post-item-tag">消息队列</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">消息队列(更新中...)</h1><time class="has-text-grey" datetime="2019-11-21T03:16:15.000Z">2019-11-21</time><article class="mt-2 post-content"><h1 id="1-为什么要使用消息队列"><a href="#1-为什么要使用消息队列" class="headerlink" title="1. 为什么要使用消息队列"></a>1. 为什么要使用消息队列</h1><ol>
<li>通过异步处理提高系统性能（削峰、减少响应所需的时间）</li>
<li>降低系统的耦合性</li>
</ol>
<h2 id="通过异步处理提高系统性能（削峰、减少响应所需时间）"><a href="#通过异步处理提高系统性能（削峰、减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（削峰、减少响应所需时间）"></a>通过异步处理提高系统性能（削峰、减少响应所需时间）</h2><p><img src="https://camo.githubusercontent.com/bc24d4adc2b279738dd8b08d5205d4d517b0a3e0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32312f313632653633613865333462613533343f773d39313026683d33353026663d6a70656726733d3239313233" alt="使用消息队列服务器"></p>
<a id="more"></a>

<p>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p>
<p>通过以上分析可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 </p>
<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。</p>
<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h2 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h2><p><img src="https://camo.githubusercontent.com/786eb0835f335e5b67fefa8fa8e626b543b40c19/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32312f313632653636363566613339346233623f773d37393026683d32393026663d6a70656726733d3134393436" alt="降低系统耦合性"></p>
<p>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。</p>
<p>　　消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p>　　另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>
<h2 id="引入消息队列的缺点："><a href="#引入消息队列的缺点：" class="headerlink" title="引入消息队列的缺点：　　"></a>引入消息队列的缺点：　　</h2><ul>
<li><strong>系统可用性降低</strong>：系统可用性在某种程度上降低。在加入MQ之前，不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后就需要去考虑了</li>
<li><strong>系统复杂性提高</strong>：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题</strong>：消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h1 id="2-消息队列实现机制-AMPQ-协议"><a href="#2-消息队列实现机制-AMPQ-协议" class="headerlink" title="2. 消息队列实现机制/ AMPQ 协议"></a>2. 消息队列实现机制/ AMPQ 协议</h1><p>AMPQ，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同开发语言等条件的限制。</p>
<p>AMQP 其实和Http一样都是一种协议， 只不过 Http 是针对网络传输的， 而 AMQP 是基于消息队列的</p>
<p>AMQP 协议中的基本概念：</p>
<ul>
<li>Broker: 接收和分发消息的应用，我们在介绍消息中间件的时候所说的消息系统就是 Message Broker。</li>
<li>Virtual host: 出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</li>
<li>Connection: publisher／consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，Broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。</li>
<li>Channel: 如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</li>
<li>Exchange: message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</li>
<li>Queue: 消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。</li>
<li>Binding: exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<p>AMPQ 提供了五种消息模型：</p>
<ul>
<li>direct exchange</li>
<li>fnout exchange</li>
<li>topic change</li>
<li>headers exchange</li>
<li>system exchange</li>
</ul>
<h1 id="3-RabbitMQ交换机exchange的类型有哪些？"><a href="#3-RabbitMQ交换机exchange的类型有哪些？" class="headerlink" title="3. RabbitMQ交换机exchange的类型有哪些？"></a>3. RabbitMQ交换机exchange的类型有哪些？</h1><p>RabbitMQ常用的Exchange类型有<code>fanout</code>,<code>direct</code>,<code>topic</code>,<code>headers</code>。</p>
<h2 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h2><p><code>fanout</code>类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以<code>fanout</code>类型是所有的交换机类型里面速度最快的。<code>fanout</code>类型常用来广播消息。</p>
<h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><p><code>direct</code>类型的Exchange路由规则也很简单，它会把消息路由到那些<code>Bindingkey</code>与<code>RoutingKey</code>完全匹配的<code>Queue</code>中。</p>
<p><img src="https://camo.githubusercontent.com/7177328efe9e95372a9b7fb8b51022312d2e601b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f33373030383032312e6a7067" alt="direct Exchange"></p>
<p>以上图为例，如果发送消息的时候设置路由键为<code>warning</code>,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为<code>Info</code>或者<code>debug</code>，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p><code>direct</code>类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p><code>direct</code>类型的交换器路由规则是完全匹配<code>BindingKey</code>和<code>RoutingKey</code>，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。<code>topic</code>类型的交换器在匹配规则上进行了扩展，它与<code>direct</code>类型的交换器相似，也是将消息路由到<code>BindingKey</code>和<code>RoutingKey</code>相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li><code>RoutingKey</code>为一个点号<code>.</code>分隔的字符串（被点号<code>.</code>分隔开的每一段独立的字符串称为一个单词），如 <code>com.rabbitmq.client</code>、<code>java.util.concurrent</code>、<code>com.hidden.client</code>;</li>
<li><code>BindingKey</code>和<code>RoutingKey</code>一样也是点号<code>.</code>分隔的字符串；</li>
<li><code>BindingKey</code>中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多个单词(可以是零个)。</li>
</ul>
<p><img src="https://camo.githubusercontent.com/ad72829eb75cde62383a48361e3a77708a80f955/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37333834332e6a7067" alt="topicExchange"></p>
<h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><p><code>headers</code>类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 <code>headers</code> 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 <code>headers</code>（也是一个键值对的形式)对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。<code>headers</code> 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h1 id="4-如何保证消息可靠性传输？-RabbitMQ-消息确认机制（事务-Confirm）"><a href="#4-如何保证消息可靠性传输？-RabbitMQ-消息确认机制（事务-Confirm）" class="headerlink" title="4. 如何保证消息可靠性传输？/RabbitMQ 消息确认机制（事务+Confirm）"></a>4. 如何保证消息可靠性传输？/RabbitMQ 消息确认机制（事务+Confirm）</h1><p>在 Rabbitmq 中可以通过持久化来解决因为服务器异常而导致的数据丢失问题。但是还存在另外一个问题：生产者将消息发送出去之后，消息是否真正到达Rabbitmq服务器是无法确定的（即Rabbitmq不会反馈任何消息给生产者），默认情况下是不知道消息有没有正确到达的。</p>
<p>导致的问题：消息到达服务器之前丢失，那么持久化也不能解决此问题，因为消息根本没有到达Rabbitmq服务器。</p>
<p>Rabbitmq提供了两种解决方式：</p>
<ul>
<li>通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案。</li>
<li>通过将channel设置成confirm模式来实现。</li>
</ul>
<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p>RabbitMQ中与事务机制有关的方法有三个：txSelect(),txCommit()以及txRollback()。txSelect()用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect()开启事务之后，便可以发布消息给broker代理服务器了，如果txCommit()提交成功了，则表明消息到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候便可以捕获异常通过txRollback回滚事务了。</p>
<p>缺点：采用这种模式比较耗时，降低了Rabbitmq的吞吐量</p>
<h2 id="Confirm模式"><a href="#Confirm模式" class="headerlink" title="Confirm模式"></a>Confirm模式</h2><p>Confirm模式是相对比较高效的结局方案，分为三种情况：普通Confirm模式，批量Confirm模式以及异步Confirm模式。</p>
<h3 id="producer端confirm模式的实现原理"><a href="#producer端confirm模式的实现原理" class="headerlink" title="producer端confirm模式的实现原理"></a>producer端confirm模式的实现原理</h3><p>生产者将信道设置成 confirm 模式,一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 deliver-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm 模式最大的好处在于它是异步的，一旦发布了一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。</p>
<h3 id="普通confirm模式"><a href="#普通confirm模式" class="headerlink" title="普通confirm模式"></a>普通confirm模式</h3><p>每发送一条消息后，调用 <code>waitForConfirms</code> 方法，等待服务器端confirm,实际上是一种串行confirm了。</p>
<p>该技术实现相对比较简单，但是有一个主要缺点：由于消息确认会阻止所有后续消息的发布，因此它会大大减慢发布速度。这种方法不会提供每秒超过数百条已发布消息的吞吐量。</p>
<h3 id="批量confirm模式"><a href="#批量confirm模式" class="headerlink" title="批量confirm模式"></a>批量confirm模式</h3><p>每发送一批消息后，调用 <code>waitForConfirms</code> 方法，等待服务器端confirm。批量 confirm 模式稍微复杂一点，客户端程序需要定期(每隔多少秒)或者定量(达到多少条)或者两则结合起来 publish 消息，然后等待服务器端 confirm, 相比普通 confirm 模式，批量极大提升 confirm 效率，但是问题在于一旦出现 confirm 返回 false 或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量 confirm 性能应该是不升反降的。</p>
<h3 id="异步confirm模式"><a href="#异步confirm模式" class="headerlink" title="异步confirm模式"></a>异步confirm模式</h3><p>提供了一个回调方法，服务端confirm了一条或者多条消息之后Client端会回调这个方法。</p>
<p>Channel 对象提供的 ConfirmListener() 回调方法只包含 deliveryTag（当前Channel发出的消息序号），我们需要自己为每一个 Channel 维护一个 unconfirm 的消息序号集合，每 publish 一条数据，集合中元素加1，每回调一次 handleAck 方法，unconofirm 集合删掉相应的一条（multiple=false）或者多条（multiple=true）记录。从程序运行效率上看，这个 unconfirm 集合最好采用有序集合SortedSet 存储结构。实际上，SDK中的 waitForConfirms() 方法也是通过SortedSet维护这个消息序号的。</p>
<h1 id="5-几种消息队列对比"><a href="#5-几种消息队列对比" class="headerlink" title="5. 几种消息队列对比"></a>5. 几种消息队列对比</h1><p><strong>ActiveMQ</strong>：的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</p>
<p><strong>RabbitMQ</strong>：在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<p><strong>RocketMQ</strong>：阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的。</p>
<p><strong>kafka</strong>：特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</p>
<h1 id="6-如何保证消息队列的高可用？"><a href="#6-如何保证消息队列的高可用？" class="headerlink" title="6. 如何保证消息队列的高可用？"></a>6. 如何保证消息队列的高可用？</h1><p>RabbitMQ 有三种模式：单机模式，普通集群模式，镜像集群模式。</p>
<p>对于 RabbitMQ，要保证高可用，就需要使用集群模式。</p>
<h2 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h2><p>就是在多台机器上启动多个 rabbitmq 实例，每个机器启动一个。但是你创建的 queue，只会放在一个rabbtimq 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。当你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p>
<p>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p>
<p>而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 rabbitmq 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p>
<p>这方案主要是提高吞吐量的，并没有什么高可用可言，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<p><img src="http://qiniu.xiaoming.net.cn/RabbitMQ%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4.png" alt="RabbitMQ普通集群"></p>
<h2 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h2><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p>
<p><img src="http://qiniu.xiaoming.net.cn/RabbitMQ%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" alt="RabbitMQ镜像集群模式"></p>
<p>如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<p>这样的话，好处在于，任何一个机器宕机了，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，增加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展 queue。</p>
<h1 id="7-如何保证消息不会被重复消费（保证消息幂等性）？"><a href="#7-如何保证消息不会被重复消费（保证消息幂等性）？" class="headerlink" title="7. 如何保证消息不会被重复消费（保证消息幂等性）？"></a>7. 如何保证消息不会被重复消费（保证消息幂等性）？</h1><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费。</p>
<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示”我已经消费过了，下次要是重启，就继续从上次消费到的 offset 来继续消费”。</p>
<p>但是凡事总有意外，比如有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>举个例子：</p>
<p>有这么个场景。数据 1，2，3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152，153，154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1，2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka ，接着把上次消费到的那个地方后面的数据继续给传递过来。由于之前的 offset 没有提交成功，那么数据 1，2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Kafka%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9.png" alt="kakfka重复消费"></p>
<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，可能就把数据 1,2 在数据库里插入了 2 次，那么数据就错啦。</p>
<p>举个例子。假设有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<blockquote>
<p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p>
</blockquote>
<p>所以第二个问题来了，怎么保证消息队列消费的幂等性？</p>
<ol>
<li>当把数据插入数据库时，先根据主键查一下，如果这数据都有了，你就别插入了，update 一下就好。</li>
<li>如果是写 Redis，那没问题了，每次都是 set，天然幂等性。</li>
<li>如果不是上面两个场景，那做的稍微复杂一点，需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那就别处理了，保证别重复处理相同的消息即可。</li>
</ol>
<p>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p>
<h1 id="8-如何保证消息队列消费的顺序性？"><a href="#8-如何保证消息队列消费的顺序性？" class="headerlink" title="8. 如何保证消息队列消费的顺序性？"></a>8. 如何保证消息队列消费的顺序性？</h1><p>在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证是按照顺序来的吧？不然本来是：增加、修改、删除；换了顺序给执行成删除、修改、增加，就全错了。</p>
<p>本来这个数据同步过来，应该最后这个数据被删除了；结果搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>
<p>先看看顺序会错乱的俩场景：</p>
<p>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1、data2、data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1、data3。这不明显乱了。</p>
<p>解决方案是拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 </p>
<p><img src="http://qiniu.xiaoming.net.cn/RabbitMQ%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7.png" alt="RabbitMQ保证消息顺序性"></p>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://github.com/shishan100/Java-Interview-Advanced" target="_blank" rel="noopener">中华石杉–互联网Java进阶面试训练营</a><br><a href="https://juejin.im/post/5cbd679af265da039b086d4f" target="_blank" rel="noopener">RabbitMq底层原理分析</a>  </p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/11/25/RabbitMQ/" title="RabbitMQ"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: RabbitMQ</span></a><a class="button is-default" href="/2019/11/20/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Zookeeper/" title="Zookeeper"><span class="has-text-weight-semibold">下一页: Zookeeper</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>