<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1. java线程状态转换 新建（New）创建后未启动 可运行（Runnable）可能正在运行，也可能正在等待CPU时间片包含了操作系统线程状态的Running和Ready 阻塞（Blocked）等待获取一个排他锁，如果其线程释放了锁就会结束此状态。 无限期等待（Waiting）等待其他线程显示的唤醒，否则不会被分配CPU时间片。">
<meta name="keywords" content="java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;09&#x2F;09&#x2F;%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="1. java线程状态转换 新建（New）创建后未启动 可运行（Runnable）可能正在运行，也可能正在等待CPU时间片包含了操作系统线程状态的Running和Ready 阻塞（Blocked）等待获取一个排他锁，如果其线程释放了锁就会结束此状态。 无限期等待（Waiting）等待其他线程显示的唤醒，否则不会被分配CPU时间片。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;c1a87ea139bc0379f5c98484416594843ff29d6d&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f546872656164506f6f6c4578656375746f722545362539452538342545392538302541302545362539362542392545362542332539352e706e67">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;AQS%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;ba078291-791e-4378-b6d1-ece76c2f0b14.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;f71af66b-0d54-4399-a44b-f47b58321984.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;15851555-5abc-497d-ad34-efed10f43a6b.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;8b7ebbad-9604-4375-84e3-f412099d170c.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;2797a609-68db-4d7b-8701-41ac9a34b14f.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;942f33c9-8ad9-4987-836f-007de4c21de0.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;6270c216-7ec0-4db7-94de-0003bce37cd2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;233f8d89-31d7-413f-9c02-042f19c46ba1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;Mark%20Word.jpeg">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;5b88733982213fd9ff109e146afdb0dc07c27c32&#x2F;notes&#x2F;pics&#x2F;051e436c-0e46-4c59-8f67-52d89d656182.png">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;ThreadLocal%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;a66819fd82c6adfa69b368edf3c52b1fa9cdc89d&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;11e7cbe718a70a81c42c37a13a257f91ef48dfd7&#x2F;687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f39333636363231372e6a7067">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;111e9bd4936833f774e1a11a2e7bead849ec0ab2&#x2F;687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f33323030353733382e6a7067">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;ReentrantLock%20UML%E5%9B%BE">
<meta property="og:image" content="http:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;volatile%E5%BA%95%E5%B1%82%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0.webp">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;CyC2018&#x2F;CS-Notes&#x2F;raw&#x2F;master&#x2F;notes&#x2F;pics&#x2F;e42f188f-f4a9-4e6f-88fc-45f4682072fb.png">
<meta property="og:updated_time" content="2020-11-25T04:32:50.135Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png">

<link rel="canonical" href="http://yoursite.com/2019/09/09/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>java并发 | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-09 11:50:58" itemprop="dateCreated datePublished" datetime="2019-09-09T11:50:58+08:00">2019-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-25 12:32:50" itemprop="dateModified" datetime="2020-11-25T12:32:50+08:00">2020-11-25</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-java线程状态转换"><a href="#1-java线程状态转换" class="headerlink" title="1. java线程状态转换"></a>1. java线程状态转换</h1><p><img src="https://qiniu.xiaoming.net.cn/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p>
<h2 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h2><p>创建后未启动</p>
<h2 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h2><p>可能正在运行，也可能正在等待CPU时间片<br>包含了操作系统线程状态的<code>Running</code>和<code>Ready</code></p>
<h2 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h2><p>等待获取一个排他锁，如果其线程释放了锁就会结束此状态。</p>
<h2 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h2><p>等待其他线程显示的唤醒，否则不会被分配CPU时间片。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</td>
<td><code>Object.notify()/Object.notifyAll()</code></td>
</tr>
<tr>
<td>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.park()</code>方法</td>
<td><code>LockSupport.unpark(Thread)</code></td>
</tr>
</tbody></table>
<h2 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用<code>Thread.sleep()</code>方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用<code>Object.wait()</code>方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用<code>Thread.sleep()</code>和<code>Object.wait()</code>等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Thread.sleep()</code>方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</td>
<td>时间结束/<code>Object.notify()</code>/<code>Object.notifyAll()</code></td>
</tr>
<tr>
<td>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</td>
<td>时间结束/被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.parkNanos()</code>方法</td>
<td><code>LockSupport.unpark(Thread)</code></td>
</tr>
<tr>
<td><code>LockSupport.parkUntil()</code>方法</td>
<td><code>LockSupport.unpark(Thread)</code></td>
</tr>
</tbody></table>
<h2 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h2><p>可以是线程任务结束之后自己结束，或者产生了异常而结束。</p>
<h1 id="2-创建线程的三种方式"><a href="#2-创建线程的三种方式" class="headerlink" title="2. 创建线程的三种方式"></a>2. 创建线程的三种方式</h1><ul>
<li>实现<code>Runnable</code>接口</li>
<li>实现<code>Callable</code>接口</li>
<li>继承<code>Thread</code>类</li>
</ul>
<h2 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h2><p>需要实现<code>run</code>方法<br>通过<code>Thread</code>调用<code>start()</code>方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><p>与<code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值可以通过<code>FutureTask</code>进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//需要实现call函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ft.get()</code>方法用于获取返回值，如果线程没有执行完，该方法会一直阻塞到线程执行完毕。另外可以调用<code>ft.isDone()</code>函数检验线程是否执行完毕，该方法不会被阻塞。</p>
</blockquote>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>同样也是需要实现<code>run()</code>方法，因为<code>Thread</code>类也实现了<code>Runable</code>接口。</p>
<p>当调用<code>start()</code>方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的<code>run()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<blockquote>
<p>工具类<code>Executors</code>可以实现<code>Runnable</code>对象和<code>Callable</code>对象之间的相互转换。（<code>Executors.callable（Runnable task）</code>或<code>Executors.callable（Runnable task，Object result）</code>）。</p>
</blockquote>
<h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><p>线程池的顶级接口是<code>Executor</code>,管理多个异步任务的执行，而无需程序员显示的管理线程的生命周期。</p>
<blockquote>
<p>线程池的顶级接口是<code>Executor</code>,线程池接口是<code>ExecutorService</code></p>
</blockquote>
<p>主要有以下几种类型的<code>Executor</code>:</p>
<ul>
<li><code>CachedThreadPool</code>:创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务</li>
<li><code>FixedThreadPool</code>:创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程池到达最大大小，一旦达到最大值就保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</li>
<li><code>SingleThreadExecutor</code>:单线程线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行</li>
<li><code>ScheduledThreadPool</code>:创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求</li>
</ul>
<p><code>Executor</code>接口：执行已经提交的<code>Runnable</code>任务的对象</p>
<p><code>ExecutorService</code>接口：提供管理终止的方法，以及跟踪一个或多个异步任务执行状况而生成的<code>Future</code>方法</p>
<p><code>Executors</code>类：定义了<code>Executor</code>，<code>ExecutorService</code>等的工厂和实用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    </span><br><span class="line">    ExecutorService es = Executors.newScheduledThreadPool(<span class="number">3</span>);<span class="comment">//大小无限，但仍然需要指定大小</span></span><br><span class="line">    ((ScheduledExecutorService) es4).schedule(<span class="keyword">new</span> MyRunnable(),<span class="number">3000</span>, TimeUnit.MILLISECONDS);<span class="comment">//延迟执行以及周期</span></span><br><span class="line">    es4.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如果创建线程池"><a href="#如果创建线程池" class="headerlink" title="如果创建线程池"></a>如果创建线程池</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p><strong><code>Executors</code>返回线程池对象的弊端如下：</strong></p>
<ul>
<li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：允许请求的队列长度为<code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致OOM。</li>
<li><code>CacheThreadPool</code>和<code>ScheduledThreadPool</code>：允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致OOM</li>
</ul>
<h3 id="方法一：通过ThreadPoolExecutor构造方法实现"><a href="#方法一：通过ThreadPoolExecutor构造方法实现" class="headerlink" title="方法一：通过ThreadPoolExecutor构造方法实现"></a>方法一：通过<code>ThreadPoolExecutor</code>构造方法实现</h3><p><img src="https://camo.githubusercontent.com/c1a87ea139bc0379f5c98484416594843ff29d6d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f546872656164506f6f6c4578656375746f722545362539452538342545392538302541302545362539362542392545362542332539352e706e67" alt="ThreadPoolExecutor构造方法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>maximunPoolSize</td>
<td>int</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>线程最大空闲时间</td>
</tr>
<tr>
<td>unit</td>
<td>TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue<Runnable></td>
<td>线程等待队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>线程创建工厂</td>
</tr>
<tr>
<td>handler</td>
<td>RejectedExecutionHandler</td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<p>当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。</p>
<h3 id="方法二-通过Executor框架的工具类Executors来实现-见上面例子"><a href="#方法二-通过Executor框架的工具类Executors来实现-见上面例子" class="headerlink" title="方法二 通过Executor框架的工具类Executors来实现(见上面例子)"></a>方法二 通过<code>Executor</code>框架的工具类<code>Executors</code>来实现(见上面例子)</h3><h1 id="4-Daemon守护线程"><a href="#4-Daemon守护线程" class="headerlink" title="4. Daemon守护线程"></a>4. Daemon守护线程</h1><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p>
<p><code>main()</code>属于非守护线程</p>
<p>在线程启动前使用<code>setDaemon</code>方法将一个线程设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-sleep-方法"><a href="#5-sleep-方法" class="headerlink" title="5. sleep()方法"></a>5. sleep()方法</h1><p><code>Thread.sleep(millisec)</code>方法会休眠当前正在执行的线程，<code>millisec</code>单位为毫秒。</p>
<p>该方法可能会有两个异常：</p>
<ul>
<li><code>IllegalArgumentException</code>:如果参数为负数</li>
<li><code>InterruptedException</code>:如果任何线程中断了当前线程，就会抛出此异常，此时线程的中断状态将被清除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="6-yield-方法"><a href="#6-yield-方法" class="headerlink" title="6. yield()方法"></a>6. yield()方法</h1><p>对静态方法<code>Thread.yield()</code>的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<p><strong>与 sleep() 方法的区别</strong>：</p>
<ul>
<li><code>sleep()</code>方法给其他进程运行时不会考虑进程的优先级问题，因此会给低优先级的线程以运行的机会；<code>yield()</code>方法只会给相同优先级或者更高优先级的线程以运行的机会。</li>
<li><code>sleep()</code>方法声明会抛出<code>InterruptedException</code>异常，而<code>yield()</code>方法没有声明任何异常。</li>
<li><code>sleep()</code>方法比<code>yield()</code>方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h1 id="7-线程中断的InterruptedException-interrupted-interrupt区别"><a href="#7-线程中断的InterruptedException-interrupted-interrupt区别" class="headerlink" title="7. 线程中断的InterruptedException,interrupted,interrupt区别"></a>7. 线程中断的<code>InterruptedException</code>,<code>interrupted</code>,<code>interrupt</code>区别</h1><p>一个线程执行完毕后会自动结束，如果在运行过程中发生异常会提前结束。</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>该方法用于标记中断一个线程，从而使线程发生提前中断。</p>
<h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的<code>interrupt()</code>方法来中断该线程，如果线程处于阻塞、无期限等待或有期限等待状态，就会抛出<code>InterruptedException</code>,从而提前结束该线程。但是不能中断I/O阻塞和<code>synchronized</code>锁阻塞。</p>
<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>该方法用于判断线程是否设置了中断标记，同时会清除中断标记。</p>
<p>如果一个线程的<code>run()</code>方法执行了一个无限循环，并且没有执行<code>sleep()</code>等会抛出<code>InterruptedException</code>的操作，那么调用线程的<code>interrupt()</code>方法就无法使线程提前结束。但是调用<code>interrupt()</code>方法会设置线程中的中断标记，此时调用<code>interrupted()</code>方法会返回<code>true</code>,因此可以在循环体中使用<code>interrupted()</code>方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<h2 id="线程池中的中断操作"><a href="#线程池中的中断操作" class="headerlink" title="线程池中的中断操作"></a>线程池中的中断操作</h2><p>调用<code>Executor</code>的<code>shutdown()</code>方法会等待线程都执行完毕之后再关闭，但是如果调用的是<code>shutdownNow()</code>方法，则相当于调用了每个线程的<code>interrupt()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只想中断<code>Executor</code>中的一个线程，可以通过使用 <code>submit()</code>方法来提交一个线程，它会返回一个<code>Future&lt;?&gt;</code>对象，通过调用该对象的<code>cancel(true)</code>方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h1 id="8-锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？"><a href="#8-锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？" class="headerlink" title="8. (锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？"></a>8. (锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？</h1><p>Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的<code>synchronized</code>,第二个是JDK实现的<code>ReentrantLock</code>。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="说一说对Synchronized关键字的理解"><a href="#说一说对Synchronized关键字的理解" class="headerlink" title="说一说对Synchronized关键字的理解"></a>说一说对Synchronized关键字的理解</h3><p>每一个对象有一把锁，线程可以使用 <code>synchronized</code> 关键字来获取对象上的锁。<code>synchronized</code> 关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。<code>synchronized</code>关键字主要用于解决多个线程之间访问同步资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在同一时刻只能有一个线程执行。</p>
<p>早期的<code>synchronized</code>属于重量级锁，效率低下，因为监视器锁(<code>monitor</code>)是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的，Java的线程都是映射到操作系统的原生线程上。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是早期<code>synchronized</code>效率低的原因。java6之后从JVM层面对<code>synchronized</code>较大优化，所以现在<code>synchronized</code>锁效率也优化的跟<code>ReentrantLock</code>差不多了，JDK1.6引入了偏向锁，轻量级锁，自旋锁，自适应自旋锁，锁消除，锁粗化等技术来减少锁操作的开销。</p>
<h3 id="说一说自己怎么使用synchronized关键字"><a href="#说一说自己怎么使用synchronized关键字" class="headerlink" title="说一说自己怎么使用synchronized关键字"></a>说一说自己怎么使用<code>synchronized</code>关键字</h3><h4 id="同步一个代码块"><a href="#同步一个代码块" class="headerlink" title="同步一个代码块"></a>同步一个代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步一个方法"><a href="#同步一个方法" class="headerlink" title="同步一个方法"></a>同步一个方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个方法都只能<strong>作用于同一个对象</strong>,如果调用两个对象上的同步代码块，就不会进行同步。如果是同时调用一个对象上的同步代码块或同步方法，两个线程就会进行同步，当一个进入语句块时，另一个必须等待。</p>
</blockquote>
<h4 id="同步一个类"><a href="#同步一个类" class="headerlink" title="同步一个类"></a>同步一个类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句时，也会进行同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步一个静态方法"><a href="#同步一个静态方法" class="headerlink" title="同步一个静态方法"></a>同步一个静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作用于整个类。因为静态成员不属于任何一个实例对象，是类成员（<code>static</code>表明这是该类的一个静态资源，不管<code>new</code>了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态<code>synchronized</code>方法，而线程B需要调用这个实例对象所属类的静态<code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态<code>synchronized</code>方法占用的锁是当前类的锁，而访问非静态<code>synchronized</code>方法占用的锁是当前实例对象锁。</p>
</blockquote>
<h3 id="双重校验锁实现单例对象（线程安全）"><a href="#双重校验锁实现单例对象（线程安全）" class="headerlink" title="双重校验锁实现单例对象（线程安全）"></a>双重校验锁实现单例对象（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//注意要使用volatile关键字修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面<code>uniqueInstance = new Singleton()</code>这段代码中，其实是分为三步执行：</p>
<ol>
<li>为<code>uniqueInstance</code>分配内存空间</li>
<li>初始化<code>uniqueInstance</code></li>
<li>将<code>uniqueInstance</code>指向分配的内存地址。</li>
</ol>
<p>但是由于JVM具有<strong>指令重排</strong>的特性，执行顺序有可能是1-&gt;3-&gt;2。指令重排在单线程下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1执行了1和3，此时T2调用<code>getUniqueInstance()</code>后发现<code>uniqueInstance</code>不为空，因此返回<code>uniqueInstance</code>,但此时<code>uniqueInstance</code>还未被初始化。</p>
<p>使用<code>volatile</code>禁止JVM指令重排，保证多线程环境下也能正常运行。</p>
<h3 id="讲一下synchronized关键字底层原理"><a href="#讲一下synchronized关键字底层原理" class="headerlink" title="讲一下synchronized关键字底层原理"></a>讲一下synchronized关键字底层原理</h3><blockquote>
<p><code>synchronized</code>关键字的原理属于JVM层面，通过 JDK 自带的<code>javap</code>命令查看<code>SynchronizedDemo</code>类的相关字节码信息：首先切换到类的对应目录执行<code>javac SynchronizedDemo.java</code>命令生成编译后的<code>.class</code>文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
</blockquote>
<h4 id="同步语句块的情况"><a href="#同步语句块的情况" class="headerlink" title="同步语句块的情况"></a>同步语句块的情况</h4><p><code>synchronized</code>同步语句块的实现使用的是<code>monitorenter</code>和<code>monitorexit</code>指令，其中<code>monitorenter</code>指令指向同步代码块开始位置，<code>monitorexit</code>指令则指明同步代码块的结束位置。当执行<code>monitorenter</code>指令时，线程试图获取锁也就是<code>monitor</code>的持有权（<code>monitor</code>对象存在于每个Java对象的对象头中，<code>synchronized</code>锁便是通过这种方式获得锁的，也是为什么java中任意对象可以作为锁的原因）。当计数器为0则表示成功获取，获取后将锁计数器设为1也就就是加1。相应的在执行<code>monitorexit</code>指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="synchronized修饰方法的情况"><a href="#synchronized修饰方法的情况" class="headerlink" title="synchronized修饰方法的情况"></a>synchronized修饰方法的情况</h4><p><code>synchronized</code>修饰方法并没有<code>monitorenter</code>和<code>monitorexit</code>指令，取而代之的是<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法，JVM通过该<code>ACC_SYNCHRONIZED</code>访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h3 id="Synchronized-是否一定线程安全"><a href="#Synchronized-是否一定线程安全" class="headerlink" title="Synchronized 是否一定线程安全"></a>Synchronized 是否一定线程安全</h3><p>从上面的实现原理可以知道，synchronized 针对方法和同步语句块的加锁对象不一致，所以如果使用 synchronized 修饰的地方不同，就有可能引起并发访问一个变量这种线程不安全的情况。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>是<code>java.util.concurrent</code>(J.U.C)包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized和ReentrantLock区别"><a href="#synchronized和ReentrantLock区别" class="headerlink" title="synchronized和ReentrantLock区别"></a>synchronized和ReentrantLock区别</h2><ol>
<li><strong>两者都是可重入锁</strong>，“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁时还可以获取，如果是不可重入锁的话，会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0才能释放锁。</li>
<li><code>synchronized</code>是JVM实现的，<code>ReentrantLock</code>是JDK实现的</li>
<li>新版本的<code>synchronized</code>进行了很多优化，例如自旋锁，<code>synchronized</code>与<code>ReentrantLock</code>大致相同。</li>
<li>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。  <strong><code>ReentrantLock</code>可中断（通过<code>lock.lockInterruptibly()</code>来实现），而<code>synchronized</code>不行</strong>。</li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br><code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但是也可以是公平的（通过<code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>。</li>
<li>一个<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>对象（绑定多个条件）,从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”。</li>
</ol>
<p><strong>使用选择</strong>：除非需要使用<code>ReentrantLock</code>的高级功能，否则优先使用<code>synchronized</code>。这是因为<code>synchronized</code>是 JVM 实现的一种锁机制，JVM 原生地支持它，而<code>ReentrantLock</code>不是所有的 JDK 版本都支持。并且使用<code>synchronized</code>不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<p>（ReentrantLock 实现公平锁和非公平锁见35题）</p>
<h1 id="9-线程之间协作方式-线程同步和调度的相关方法"><a href="#9-线程之间协作方式-线程同步和调度的相关方法" class="headerlink" title="9. 线程之间协作方式/线程同步和调度的相关方法"></a>9. 线程之间协作方式/线程同步和调度的相关方法</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h2><p>在一个线程中调用另一个线程的<code>join()</code>方法，会将当前线程挂起，等待另一个线程执行完毕之后再继续往下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();   <span class="comment">//调用a方法，会先让a方法执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(),notify(),notifyAll()"></a>wait(),notify(),notifyAll()</h2><p><code>wait()</code>方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用<code>notify()</code>或者<code>notifyAll()</code>方法。</p>
<p>它们都属于<code>Object</code>的一部分，而不属于<code>Thread</code>。</p>
<p>只能用在同步方法或者同步控制块中使用，获得当前对象的锁资源，否则会在运行时抛出<code>IllegalMonitorStateException</code>。</p>
<p>使用<code>wait()</code>挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行<code>notify()</code>或者<code>notifyAll()</code>来唤醒挂起的线程，造成死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>wait()</code>和<code>sleep()</code>的区别</strong>：</p>
<ul>
<li><code>wait()</code>是<code>Object</code>类下的方法，而<code>sleep()</code>是<code>Thread</code>类下的方法</li>
<li><code>wait()</code>会释放锁，而<code>sleep()</code>不会</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await(),signal(),signalAll()"></a>await(),signal(),signalAll()</h2><p><code>java.util.concurrent</code>类库中提供了<code>Condition</code>类来实现线程之间的协调，可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p>
<p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活。</p>
<p>使用<code>Lock</code>来获取一个<code>Condition</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外还有 JUC 下的 AQS 队列同步器（第 10 题）。</p>
<h1 id="10-JUC下的AQS"><a href="#10-JUC下的AQS" class="headerlink" title="10. JUC下的AQS"></a>10. JUC下的AQS</h1><p><code>AQS</code>，即<code>AbstractQueuedSynchronizer</code>,队列同步器,是一个用来构建锁和同步器的框架，使用<code>AQS</code>能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的<code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如<code>ReentrantReadWriteLock</code>，<code>SynchronizerQueue</code>，<code>FutureTask</code>等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。其主要有以下几个组件：</p>
<ul>
<li><code>ReentrantLock</code></li>
<li><code>Condition</code></li>
<li><code>CountDownLatch</code></li>
<li><code>CyclicBarrier</code></li>
<li><code>Semaphore</code></li>
<li><code>FutureTask</code></li>
</ul>
<h2 id="原理概念"><a href="#原理概念" class="headerlink" title="原理概念"></a>原理概念</h2><p><code>AQS</code>的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配机制，这个机制<code>AQS</code>是用<code>CLH</code>队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p><code>AQS</code>使用一个<code>int</code>成员变量来表示同步状态，通过内置的<code>FIFO</code>队列来完成获取资源线程的排队工作。<code>AQS</code>使用<code>CAS</code>对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过<code>protected</code>类型的<code>getState</code>,<code>setState</code>,<code>compareAndSetState</code>进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update（如果当前同步状态的值等于expect（期望值））</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS对资源的两种共享方式"><a href="#AQS对资源的两种共享方式" class="headerlink" title="AQS对资源的两种共享方式"></a>AQS对资源的两种共享方式</h3><ol>
<li><strong>Exclusive</strong>(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</li>
</ol>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
<ol start="2">
<li><strong>Share</strong>(共享)：多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>。</li>
</ol>
<h4 id="独占锁的实现"><a href="#独占锁的实现" class="headerlink" title="独占锁的实现"></a>独占锁的实现</h4><p><img src="http://qiniu.xiaoming.net.cn/AQS%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0" alt="AQS 独占锁的实现"></p>
<h2 id="AQS自定义同步器"><a href="#AQS自定义同步器" class="headerlink" title="AQS自定义同步器"></a>AQS自定义同步器</h2><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源<code>state</code>的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<p><strong>AQS的底层使用了模版方法模式</strong>，同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承<code>AbstractQueuedSynchronizer</code>并重写指定的方法。（这些重写方法很简单，无非是对于共享资源<code>state</code>的获取和释放）</li>
<li>将<code>AQS</code>组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，每个方法都抛出<code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是<code>final</code>，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<blockquote>
<p>在<code>ReentrantLock</code>中，<code>state</code>初始化为0，表示未锁定状态。A线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将<code>state+1</code>。此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（<code>state</code>会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证<code>state</code>是能回到零态的。</p>
</blockquote>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个或者多个线程等待多个线程。</p>
<p><code>CountDownLatch</code>中，任务分为N个子线程去执行，<code>state</code>也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>一次，<code>state</code>会<code>CAS</code>(Compare and Swap)减1。等到所有子线程都执行完后(即<code>state=0</code>)，会<code>unpark()</code>主调用线程，然后主调用线程就会从<code>await()</code>函数返回，继续后余动作。</p>
<p>内部维护了一个计数器<code>cnt</code>，每次调用<code>countDown()</code>方法会让计数器的值减1，减到0的时候，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务,那些之前调用<code>await()</code>方法而在等待的线程就会被唤醒。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="CountDownLatch"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalCount = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await(); <span class="comment">//main线程会阻塞在这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch的三种典型用法"><a href="#CountDownLatch的三种典型用法" class="headerlink" title="CountDownLatch的三种典型用法"></a>CountDownLatch的三种典型用法</h3><ol>
<li>某一线程在开始运行前等待n个线程执行完毕。将<code>CountDownLatch</code> 的计数器初始化为<code>n</code>(<code>new CountDownLatch(n)</code>)，每当一个任务线程执行完毕，就将计数器减1(<code>countdownlatch.countDown()</code>)，当计数器的值变为0时，在<code>CountDownLatch</code>上<code>await()</code>的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的<code>CountDownLatch</code>对象，将其计数器初始化为 1(<code>new CountDownLatch(1)</code>) ，多个线程在开始执行任务前首先<code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code>时，计数器变为0，多个线程同时被唤醒。</li>
<li>死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</li>
</ol>
<h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次被使用。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和<code>CountdownLatch</code>相似，都是通过维护计数器来实现的。线程执行<code>await()</code>方法之后计数器会减1，并进行等待，直到计数器为0，所有调用<code>await()</code>方法而在等待的线程才能继续执行。</p>
<p><code>CyclicBarrier</code>和<code>CountdownLatch</code>的一个区别是，<code>CyclicBarrier</code>的计数器通过调用<code>reset()</code>方法可以循环使用，所以它才叫做循环屏障。</p>
<p><code>CyclicBarrier</code>有两个构造函数，其中<code>parties</code>指示计数器的初始值，<code>barrierAction</code>在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f71af66b-0d54-4399-a44b-f47b58321984.png" alt="CyclicBarrier"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);   <span class="comment">//阻塞在这里等待totalThread变为0</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>
<li><code>CountDownLatch</code>是计数器，只能使用一次，而<code>CyclicBarrier</code>计数器提供了<code>reset</code>方法，可以多次使用。</li>
<li><code>CountDownLatch</code>的设计思想强调的是一个（多个）线程等待其他线程执行完成后才能执行，而<code>CyclicBarrier</code>则是强调要多个线程都到达某一个条件，才能一起执行后续步骤。</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">//默认一次只用掉一个信号量，也可以参数传多个  </span></span><br><span class="line">                    <span class="comment">//检查是否有权限，没有就一直阻塞到有或者被中断</span></span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回<code>false</code>。</p>
<p>Semaphore 有两种模式，公平模式和非公平模式。</p>
<ul>
<li>公平模式： 调用<code>acquire</code>的顺序就是获取许可证的顺序，遵循<code>FIFO</code>；</li>
<li>非公平模式： 抢占式的。</li>
</ul>
<p><code>Semaphore</code>对应的两个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>Callable</code>接口它可以有返回值，返回值通过<code>Future</code>进行封装。<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，该接口继承自<code>Runnable</code>和<code>Future</code>接口，这使得<code>FutureTask</code>既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>FutureTask</code>适用于异步获取执行结果或取消执行任务的场景。当一个任务需要执行很久时，就可以使用<code>FutureTask</code>进行封装，主线程在完成自己的任务后再回来获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-Java内存模型"><a href="#11-Java内存模型" class="headerlink" title="11. Java内存模型"></a>11. Java内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>处理器上的寄存器读写速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。<br><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" alt="java内存模型"></p>
<p>所有的变量都存储在主内存中，每个线程都有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能操作自己工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。<br><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/15851555-5abc-497d-ad34-efed10f43a6b.png" alt="工作内存和主内存"></p>
<h1 id="12-内存间交互操作"><a href="#12-内存间交互操作" class="headerlink" title="12. 内存间交互操作"></a>12. 内存间交互操作</h1><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作：<br><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="内存交互操作"></p>
<ul>
<li><code>read</code>:把一个变量的值从主内存传输到工作内存中</li>
<li><code>load</code>:在<code>read</code>之后执行，把<code>read</code>得到的值放入工作内存的变量副本中</li>
<li><code>use</code>:把工作内存中一个变量的值传递给执行引擎</li>
<li><code>assign</code>:把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li><code>store</code>:把工作内存的一个变量的值传送到主内存中</li>
<li><code>write</code>:在<code>store</code>之后执行，把<code>store</code>得到的值放入主内存的变量中</li>
<li><code>lock</code>:作用于主内存的变量</li>
<li><code>unlock</code></li>
</ul>
<h1 id="13-内存模型的三大特性"><a href="#13-内存模型的三大特性" class="headerlink" title="13. 内存模型的三大特性"></a>13. 内存模型的三大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>Java内存模型保证了上面的交互操作都具有原子性。例如对一个<code>int</code>类型的变量执行<code>assign</code>赋值操作，这个操作就是原子性的。但是Java内存模型允许虚拟机将没有被<code>volatile</code>修饰的 64 位数据（<code>long</code>，<code>double</code>）的读写操作划分为两次 32 位的操作来进行，即<code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 操作<strong>可以不具备原子性</strong>。</p>
<blockquote>
<p>注意，<code>int</code>等原子性的类型在多线程环境中虽然具有原子性，但是还是会出现线程安全问题。如下代码：最后输出结果有可能小于1000.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">        ThreadUnsafeExample threadUnsafeExample = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1000</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                threadUnsafeExample.add();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(threadUnsafeExample.getCnt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个线程同时对<code>cnt</code>进行操作，<code>load</code>,<code>assign</code>和<code>store</code>等一系列操作整体上看<strong>不具有原子性</strong>，如下图所示，在T1线程修改<code>cnt</code>并且还没有将修改后的值写入主内存，T2依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增操作，但是主内存中<code>cnt</code>的值最后为1而不是2。因此对<code>int</code>类型读写操作满足原子性只是说明<code>load</code>,<code>assign</code>,<code>store</code>这些<strong>单个操作具备原子性</strong>。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="多线程下单个操作原子性"></p>
<p>可以使用<code>AtomicInteger</code>重写之前线程不安全的代码之后得到线程安全的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他不变</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cnt.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>synchronized</code>互斥锁来保证操作的原子性，它对应内存间交互操作为<code>lock</code>和<code>unlock</code>，在虚拟机实现上对应的字节码指令为<code>monitorenter</code>和<code>monitorexit</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。<br>主要有三种实现可见性的方式：</p>
<ul>
<li><code>volatile</code>关键字：当一个变量被<code>volatile</code>修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。</li>
<li><code>synchronized</code>，对一个变量执行<code>unlock</code>操作之前，必须把变量值同步回主内存。</li>
<li><code>final</code>:被<code>final</code>关键字修饰的字段在构造器中一旦初始化完成，并且没有发生<code>this</code>逃逸（其他线程通过<code>this</code>引用访问到初始化一半的对象），那么其他线程就能看见<code>final</code>字段的值。<blockquote>
<p>对上面的线程不安全实例的变量<code>cnt</code>使用<code>volatile</code>修饰并不能解决线程安全问题，因为<code>volatile</code>并不能保证操作的原子性，还是有可能发生两个线程获取到同一个主内存值的情况。</p>
</blockquote>
</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性指的是<strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有的操作都是无序的</strong>，前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。无序是因为发生了指令重排序。在java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br><code>volatile</code>关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过<code>synchronized</code>来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。典型的应用是双重检查锁实现的单例模式。</p>
<blockquote>
<p><code>volatile</code>关键字的主要作用一个是<strong>保证变量的可见性</strong>，另一个是<strong>防止指令重排序</strong></p>
</blockquote>
<h1 id="14-先行发生原则"><a href="#14-先行发生原则" class="headerlink" title="14. 先行发生原则"></a>14. 先行发生原则</h1><p>用<code>volatile</code>和<code>synchronized</code>可以保证有序性，除此之外，JVM还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h2 id="单一线程原则"><a href="#单一线程原则" class="headerlink" title="单一线程原则"></a>单一线程原则</h2><blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。<br><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="单一线程原则"></p>
<h2 id="管程锁定规则"><a href="#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h2><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个<code>unlock</code>操作先行发生于后面对同一个锁的<code>lock</code>操作<br><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="管程锁定规则"></p>
<h2 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h2><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作。<br><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="volatile变量规则"></p>
<h2 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h2><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p><code>Thread</code>对象的<code>start()</code>方法调用先行发生于此线程的每一个动作。<br><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="线程启动规则"></p>
<h2 id="线程加入规则"><a href="#线程加入规则" class="headerlink" title="线程加入规则"></a>线程加入规则</h2><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p><code>Thread</code>对象的结束先行于发生于<code>join()</code>方法的返回<br><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="线程加入规则"></p>
<h2 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h2><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>interrupted()</code>方法检测是否有发生中断。</p>
<h2 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h2><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</p>
<h2 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h2><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p>
<h1 id="15-线程安全"><a href="#15-线程安全" class="headerlink" title="15. 线程安全"></a>15. 线程安全</h1><p>线程安全是指多个线程不管以何种方式访问某个类，并且在主调代码不需要进行同步，都能表现正确的行为。<br>线程安全有以下几种实现方式：</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变的，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li><code>final</code>关键字修饰的基本数据类型</li>
<li><code>String</code></li>
<li>枚举类型</li>
<li><code>Number</code>部分子类，如<code>Long</code>,<code>Double</code>等数值包装类型，<code>BigInteger</code>,<code>BigDecimal</code>等大数据类型。但同为<code>Number</code>的原子类<code>AtomicInteger</code>和<code>AtomicLong</code>则是可变的。</li>
</ul>
<p>对于集合类型，可以使用<code>Collections.unmodifiableXXX()</code>方法来获取一个不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">"a"</span>,<span class="number">1</span>);<span class="comment">//会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Collections.unmodifiableXXX()</code>先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p><code>synchronized</code>和<code>ReentrantLock</code></p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具有原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：<strong>比较并交换</strong>（Compare-and-Swap，CAS）。<code>CAS</code>指令需要3个操作数，分别是内存地址<code>V</code>，旧的预期值<code>A</code>和新值<code>B</code>。当执行操作时，只有当<code>V</code>的值等于<code>A</code>,才将<code>V</code>的值更新为<code>B</code>。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>详细使用见第20题</p>
<h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那<code>CAS</code>操作就会误认为它从来没有被改变过。</p>
<p><code>J.U.C</code>包提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>来解决这个问题，它可以通过控制变量值的版本来保证<code>CAS</code>的正确性。大部分情况下<code>ABA</code>问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类跟高效。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定要进行同步。如果一个方法本来就不涉及共享数据，那么它就无须任何同步措施去保证正确性。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为<strong>局部变量存储在虚拟机栈中，属于线程私有的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">    executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在一个线程之内，这样，无需同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（<code>Thread-per-Request</code>）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以<strong>使用线程本地存储</strong>来解决线程安全问题。</p>
<p>可以使用<code>java.lang.ThreadLocal</code>类来实现线程本地存储功能。</p>
<p>以下代码中，<code>thread1</code>设置了<code>threadLocal</code>为1，而<code>thread2</code>设置<code>threadLocal</code>为2，过了一段时间之后，<code>thread1</code>读取<code>threadLocal</code>依然是1，不受<code>thread2</code>的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());   <span class="comment">//输出1</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>ThreadLocal</code>详细分析见后面19题</p>
</blockquote>
<h3 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h3><p>这些代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1 id="16-锁优化"><a href="#16-锁优化" class="headerlink" title="16. 锁优化"></a>16. 锁优化</h1><p>锁优化主要是指JVM对<code>synchronized</code>的优化。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String</code>是一个不可变的类，编译器会对<code>String</code>的拼接自动优化。在JDK1.5之前，会转化为<code>StringBuffer</code>对象的连续<code>append()</code>操作。</p>
<blockquote>
<p>现在使用<code>StringBuilder</code>,线程不安全，效率高</p>
</blockquote>
<p>每个<code>append()</code>方法中都有一个同步块。虚拟机观察变量<code>sb</code>，很快就会发现它的动态作用域被限制在<code>concatString()</code>方法内部。也就是说，<code>sb</code>的所有引用永远不会逃逸到<code>concatString()</code>方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的<code>append()</code>方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个<code>append()</code>操作之前直至最后一个<code>append()</code>操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（<code>unlocked</code>）、偏向锁状态（<code>biasble</code>）、轻量级锁状态（<code>lightweight locked</code>）和重量级锁状态（<code>inflated</code>）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为<code>Mark Word</code>。其中<code>tag bits</code>对应了五个状态，这些状态在右侧的<code>state</code>表格中给出。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" alt="HotSpot虚拟机对象头的内存布局"></p>
<p><img src="http://qiniu.xiaoming.net.cn/Mark%20Word.jpeg" alt="MarkWord"></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为<code>Lock Record</code>的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的<code>Mark Word</code>。而右侧就是一个锁对象，包含了<code>Mark Word</code>和其它信息。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/5b88733982213fd9ff109e146afdb0dc07c27c32/notes/pics/051e436c-0e46-4c59-8f67-52d89d656182.png" alt="虚拟机栈"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用<code>CAS</code>操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用<code>CAS</code>操作进行同步，如果<code>CAS</code>失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为<code>0 01</code>，说明锁对象的锁未锁定（<code>unlocked</code>）状态。此时虚拟机在当前线程的虚拟机栈中创建<code>Lock Record</code>，然后使用<code>CAS</code>操作将对象的<code>Mark Word</code>更新为<code>Lock Record</code>指针。如果<code>CAS</code>操作成功了，那么线程就获取了该对象上的锁，并且对象的<code>Mark Word</code>的锁标记变为 <code>00</code>，表示该对象处于轻量级锁状态。</p>
<p>如果<code>CAS</code>操作失败了，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>也就是说，偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态（不会立即膨胀为重量级锁）。</p>
<p><strong>锁膨胀顺序：偏向锁-&gt;轻量级锁-&gt;自旋锁-&gt;重量级锁</strong></p>
<h1 id="17-多线层开发的良好实践"><a href="#17-多线层开发的良好实践" class="headerlink" title="17. 多线层开发的良好实践"></a>17. 多线层开发的良好实践</h1><ul>
<li><p>给线程起个有意义的名字，这样可以方便找 Bug。</p>
</li>
<li><p>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</p>
</li>
<li><p>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p>
</li>
<li><p>使用 BlockingQueue 实现生产者消费者问题。</p>
</li>
<li><p>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</p>
</li>
<li><p>使用本地变量和不可变类来保证线程安全。</p>
</li>
<li><p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务</p>
</li>
</ul>
<h1 id="18-synchronized关键字和volatile关键字的区别"><a href="#18-synchronized关键字和volatile关键字的区别" class="headerlink" title="18. synchronized关键字和volatile关键字的区别"></a>18. synchronized关键字和volatile关键字的区别</h1><ul>
<li><code>volatile</code>关键字是线程同步的轻量级实现，所以<code>volatile</code>性能比<code>synchronized</code>性能要好。但是<code>volatile</code>关键字只能用于变量而<code>synchronized</code>可以修饰方法和代码块。实际开发中<code>synchronized</code>比较常见。</li>
<li>多线程使用<code>volatile</code>关键字不会发生阻塞，而<code>synchronized</code>可能会发生阻塞。</li>
<li><code>volatile</code>关键字保证数据的可见性，但是不能保证数据的原子性。<code>synchronized</code>关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h1 id="19-ThreadLocal"><a href="#19-ThreadLocal" class="headerlink" title="19. ThreadLocal"></a>19. ThreadLocal</h1><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用<code>get（）</code>和<code>set（）</code>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码对应的底层结构图为：<br><img src="http://qiniu.xiaoming.net.cn/ThreadLocal%E6%A8%A1%E5%9E%8B.png" alt="ThreadLocal结构图"></p>
<p>每个<code>Thread</code>都有一个<code>ThreadLocal.ThreadLocalMap</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line"> <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>可以把<code>ThreadLocalMap</code>理解为<code>ThreadLocal</code>类实现的定制化<code>HashMap</code>。默认情况下这两个变量都是null，只有当当前线程调用<code>ThreadLocal</code>类的<code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，调用的是<code>ThreadLocalMap</code>类对应的<code>get()</code>,<code>set()</code>方法。</p>
<p>当调用一个<code>ThreadLocal</code>的<code>set(T value)</code>方法时，先得到当前线程的<code>ThreadLocalMap</code>对象，然后将<code>ThreadLocal-&gt;value</code>键值对插入到该<code>Map</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get()</code>方法类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>,而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为<code>key</code>的键值对。<code>ThreadLocalMap</code>的<code>key</code>就是<code>ThreadLocal</code>对象，<code>value</code>就是<code>ThreadLocal</code>对象调用<code>set</code>方法设置的值</p>
<p><code>ThreadLocal</code>从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<h1 id="ThreadLocal-应用场景"><a href="#ThreadLocal-应用场景" class="headerlink" title="ThreadLocal 应用场景"></a>ThreadLocal 应用场景</h1><ol>
<li>比如线程中处理一个非常复杂的业务，可能方法有很多，那么，使用 ThreadLocal 可以代替一些参数的显式传递；</li>
<li>比如用来存储用户 Session。Session 的特性很适合 ThreadLocal ，因为 Session 之前当前会话周期内有效，会话结束便销毁。</li>
<li>在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 ThreadLocal 的方式，例如高性能序列化框架 Kyro 就要用 ThreadLocal 来保证高性能和线程安全；</li>
<li>还有像线程内上线文管理器、数据库连接等可以用到 ThreadLocal;</li>
</ol>
<p>在一些场景 (尤其是使用线程池) 下，由于<code>ThreadLocal.ThreadLocalMap</code>的底层数据结构导致<code>ThreadLocal</code>有内存泄漏的情况，应该尽可能在每次使用<code>ThreadLocal</code>后手动调用<code>remove()</code>，以避免出现<code>ThreadLocal</code>经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h2 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h2><p><code>ThreadLocalMap</code>中使用的<code>key</code>为<code>ThreadLocal</code>的弱引用，所以，如果<code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候<code>key</code>会被清理掉，而<code>value</code>不会被清理掉。这样依赖，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>。如果不采取任何措施的话，<code>value</code>永远无法被GC回收，这个时候可能会产生内存泄漏。<code>ThreadLocalMap</code>实现中考虑到了这种情况，在调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法的时候，会清理掉<code>key</code>为<code>null</code>的记录。在使用完<code>ThreadLocal</code>方法之后，最好手动使用<code>remove()</code>方法。原因：</p>
<ul>
<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>生命周期，可能导致内存泄漏</li>
<li>分配使用了<code>ThreadLocal</code>又不调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>
</ul>
<blockquote>
<p><strong>弱引用</strong>：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h2><p>分析两种情况：</p>
<ul>
<li><code>key</code>使用强引用：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>
<li><code>key</code>使用弱引用：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次ThreadLocalMap调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>比较两种情况，可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get,remove</code>的时候会被清除。</p>
<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：<strong>由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>的<code>value</code>就会导致内存泄漏</strong>，而不是因为弱引用。</p>
<h1 id="20-JUC下Atomic原子类"><a href="#20-JUC下Atomic原子类" class="headerlink" title="20. JUC下Atomic原子类"></a>20. JUC下Atomic原子类</h1><p><code>Atomic</code>是指一个操作是不可中断的，即使是在多个线程一起执行任的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>并发包<code>java.util.concurrent</code>的原子类都存放在<code>java.util.concurrent.atomic</code>下，主要包括以下4类：</p>
<p><strong>基本类型</strong></p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新引用类型里的字段原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong>：</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>:原子更新长整型字段的更新器</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新可能出现的ABA问题。</li>
</ul>
<h2 id="AtomicInteger的使用"><a href="#AtomicInteger的使用" class="headerlink" title="AtomicInteger的使用"></a>AtomicInteger的使用</h2><p><code>JUC</code>包里的整数原子类<code>AtomicInteger</code>的方法调用了<code>Unsafe</code>类中的<code>CAS</code>操作。</p>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<p>以下代码使用了<code>AtomicInteger</code>执行了自增的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>下面是<code>incrementAndGet</code>源码，它调用了<code>Unsafe</code>的<code>getAndAddInt()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getAndAddInt</code>方法的源码如下：</p>
<p><code>offset</code>指示该字段相对对象内存地址的偏移，<code>delta</code>指示操作需要加的数值，这里为1。通过<code>getIntVolatile</code>方法得到旧的预期值，通过调用<code>weakCompareAndSetInt</code>来进行CAS比较，如果该字段内存地址中的值等于v，那么就更新内存地址<code>o+offset</code>的值为<code>v+delta</code>。</p>
<p>在发生冲突时，其做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中CAS比较的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>综上，<code>AtomicInteger</code>主要利用 <strong><code>CAS+volatile+native</code></strong> 方法来保证原子操作，从而避免<code>synchronized</code>的高开销。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。<code>UnSafe</code>类的<code>objectFieldOffset()</code>方法是一个本地方法，这个方法是用来<strong>拿到“原来的值”的内存地址</strong>，返回值是<code>valueOffset</code>。另外<code>value</code>是一个<code>volatile</code>变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><p>以<code>AtomicIntegerArray</code>为例</p>
<h3 id="AtomicIntegerArray类常用方法"><a href="#AtomicIntegerArray类常用方法" class="headerlink" title="AtomicIntegerArray类常用方法"></a>AtomicIntegerArray类常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<h3 id="常见方法使用"><a href="#常见方法使用" class="headerlink" title="常见方法使用"></a>常见方法使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(atomicIntegerArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        temvalue = atomicIntegerArray.getAndSet(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"temvalue: "</span>+temvalue+<span class="string">";atomicIntegerArray: "</span>+atomicIntegerArray);</span><br><span class="line">        temvalue = atomicIntegerArray.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"temvalue: "</span>+temvalue+<span class="string">";atomicIntegerArray:"</span>+atomicIntegerArray);</span><br><span class="line">        temvalue = atomicIntegerArray.getAndAdd(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"temvalue: "</span>+temvalue+<span class="string">";atomicIntegerArray:"</span>+atomicIntegerArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><p>基本类型原子类只能更新一个变量，如果<strong>需要原子更新多个变量</strong>，需要使用引用类型原子类。</p>
<h3 id="AtomicReference使用示例"><a href="#AtomicReference使用示例" class="headerlink" title="AtomicReference使用示例"></a>AtomicReference使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"xm"</span>,<span class="number">18</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        Person updatePerson = <span class="keyword">new</span> Person(<span class="string">"xxm"</span>,<span class="number">16</span>);</span><br><span class="line">        ar.compareAndSet(person,updatePerson);</span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先创建了一个<code>Person</code>对象，然后把<code>Person</code>对象设置进<code>AtomicReference</code>对象中，然后调用<code>compareAndSet</code>方法，该方法就是通过通过<code>CAS</code>操作设置<code>ar</code>。如果<code>ar</code>的值为<code>person</code>的话，则将其设置为<code>updatePerson</code>。实现原理与<code>AtomicInteger</code>类中的<code>compareAndSet</code>方法相同。</p>
<h3 id="AtomicStampedReference类使用示例"><a href="#AtomicStampedReference类使用示例" class="headerlink" title="AtomicStampedReference类使用示例"></a>AtomicStampedReference类使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//实例化，获取当前引用值和版本戳的值</span></span><br><span class="line">        <span class="keyword">final</span> Integer initialRef = <span class="number">0</span>,initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(initialRef,initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> +asr.getReference() + <span class="string">",currentStamp="</span>+asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Integer newReference = <span class="number">666</span>,newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="comment">//比较当前引用和版本戳是否和预期相同，相同就替换新的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", casResult="</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前的引用值和版本戳值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Integer currentValue = asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> currentStamp = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span>+currentValue+<span class="string">",currentStamp="</span>+currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单独设置版本戳的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptStampResult = asr.attemptStamp(newStamp,<span class="number">88</span>);<span class="comment">//期望值以及希望修改的新值</span></span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", attemptStampResult="</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新设置当前值和版本戳值</span></span><br><span class="line">        asr.set(initialRef,initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span>+asr.getReference()+<span class="string">"currentStamp="</span>+asr.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicMarkableReference使用示例"><a href="#AtomicMarkableReference使用示例" class="headerlink" title="AtomicMarkableReference使用示例"></a>AtomicMarkableReference使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化，设置当前值和标记值（布尔类型）</span></span><br><span class="line">        <span class="keyword">final</span> Boolean initialRef = <span class="keyword">null</span>,initialMark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(initialRef,initialMark);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference() + <span class="string">",currentMark="</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Boolean newReference1 = <span class="keyword">true</span>, newMark1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference()</span><br><span class="line">                + <span class="string">", currentMark="</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">", casResult="</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Boolean currentValue = amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> currentMark = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + currentValue + <span class="string">", currentMark="</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptMarkResult = amr.attemptMark(newReference1, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference()</span><br><span class="line">                + <span class="string">", currentMark="</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">", attemptMarkResult="</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference() + <span class="string">", currentMark="</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h2><p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用<code>public volatile</code>修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");</span><br><span class="line"></span><br><span class="line">		User user = <span class="keyword">new</span> User(<span class="string">"Java"</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">		System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="21-简要描述线程与进程的关系，区别以及优缺点"><a href="#21-简要描述线程与进程的关系，区别以及优缺点" class="headerlink" title="21. 简要描述线程与进程的关系，区别以及优缺点"></a>21. 简要描述线程与进程的关系，区别以及优缺点</h1><p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="java运行时内存区域"></p>
<p>从上图可以看出，一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源（<strong>JDK1.8之后使用元空间</strong>），但是每个线程有自己的<strong>程序计数器，虚拟机栈和本地方法栈</strong>。</p>
<blockquote>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<p>线程是进程划分成更小的运行单位。线程和进程最大的不同在于基本上各个进程都是独立的，而线程则不一定。同一进程中的不同线程极有可能相互影响。线程执行开销小，但不利于资源的管理和保护；进程则相反。</p>
<h1 id="22-并发与并行的区别"><a href="#22-并发与并行的区别" class="headerlink" title="22. 并发与并行的区别"></a>22. 并发与并行的区别</h1><ul>
<li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并行</strong>：单位时间内，多个任务同时执行</li>
</ul>
<h1 id="23-说说sleep-方法和wait-方法的区别和共同点？"><a href="#23-说说sleep-方法和wait-方法的区别和共同点？" class="headerlink" title="23. 说说sleep()方法和wait()方法的区别和共同点？"></a>23. 说说sleep()方法和wait()方法的区别和共同点？</h1><ul>
<li>两者最主要的区别在于：<code>sleep</code>方法没有释放锁，<code>wait()</code>方法释放了锁。</li>
<li>两者都可用用于暂停线程的执行</li>
<li><code>wait()</code>通常被用于<strong>线程间交互/通信</strong>，<code>sleep</code>通常被用于<strong>暂行执行</strong>。</li>
<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的<code>notify()</code>或者<code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。或者可以使用<code>wait(long timeout)</code>超时后线程自动苏醒。</li>
</ul>
<h1 id="24-调用start-方法时会执行run-方法，为什么不能直接调用run方法？"><a href="#24-调用start-方法时会执行run-方法，为什么不能直接调用run方法？" class="headerlink" title="24. 调用start()方法时会执行run()方法，为什么不能直接调用run方法？"></a>24. 调用start()方法时会执行run()方法，为什么不能直接调用run方法？</h1><p><code>new</code>一个<code>Thread</code>,线程进入了新建状态，然后调用<code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code>会执行线程的相应准备工作，然后自动去执行<code>run()</code>方法的内容，这时真正的多线程工作。而直接执行<code>run()</code>方法，会把<code>run</code>方法当成一个<code>main()</code>线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>也就是说，调用<code>start()</code>方法可启动线程并使线程进入就绪状态，而<code>run</code>方法只是<code>thread</code>的一个普通方法调用，还是在主线程里执行。</p>
<h1 id="25-ConcurrentSkipListMap"><a href="#25-ConcurrentSkipListMap" class="headerlink" title="25. ConcurrentSkipListMap"></a>25. ConcurrentSkipListMap</h1><p><code>ConcurrentSkipListMap</code>是并发容器的一种，其运用了跳表的数据结构。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是<code>O(logn)</code>,所以在并发数据结构中，JDK 使用跳表来实现一个<code>Map</code>。</p>
<p>跳表的本质是同时维护了多个链表，并且链表是分层的，最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p>
<p><img src="https://camo.githubusercontent.com/11e7cbe718a70a81c42c37a13a257f91ef48dfd7/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f39333636363231372e6a7067" alt="跳表结构"></p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素18。</p>
<p><img src="https://camo.githubusercontent.com/111e9bd4936833f774e1a11a2e7bead849ec0ab2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f33323030353733382e6a7067" alt="跳表遍历"></p>
<p>查找18的时候原来需要遍历18次，现在只需要7次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p>
<p>从上面很容易看出，跳表是一种利用空间换时间的算法。</p>
<p>使用跳表实现<code>Map</code>和使用哈希算法实现<code>Map</code>的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK中实现这一数据结构的类是<code>ConcurrentSkipListMap</code>。</p>
<h1 id="26-什么是乐观锁和悲观锁，使用场景分别是什么？"><a href="#26-什么是乐观锁和悲观锁，使用场景分别是什么？" class="headerlink" title="26. 什么是乐观锁和悲观锁，使用场景分别是什么？"></a>26. 什么是乐观锁和悲观锁，使用场景分别是什么？</h1><p><strong>乐观锁</strong>：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制</strong>和<strong>CAS算法</strong>实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<code>CAS</code>实现的。</p>
<p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p><strong>两种锁的使用场景</strong>：</p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般<strong>多写的场景下用悲观锁就比较合适</strong>。</p>
<h1 id="27-乐观锁常见的两种实现方式是什么？"><a href="#27-乐观锁常见的两种实现方式是什么？" class="headerlink" title="27. 乐观锁常见的两种实现方式是什么？"></a>27. 乐观锁常见的两种实现方式是什么？</h1><p>乐观锁常见的两种实现方式是<strong>版本号机制</strong>和<strong>CAS算法</strong></p>
<h2 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h2><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数，当数据被修改时，<code>version</code>值会加一。当线程A要更新数据值时，在读取数据的同时也会读取<code>version</code>值，在提交更新时，若刚才读取到的<code>version</code>值为当前数据库中的<code>version</code>值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>即 <code>compare and swap</code>（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h1 id="28-乐观锁的缺点"><a href="#28-乐观锁的缺点" class="headerlink" title="28. 乐观锁的缺点"></a>28. 乐观锁的缺点</h1><p>乐观锁主要有以下几个问题：</p>
<ul>
<li>ABA问题</li>
<li>循环时间开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA” 问题。</p>
<p>JDK 1.5 以后的<code>AtomicStampedReference</code>类就提供了检测ABA问题的能力，其中的<code>compareAndSet</code>方法就是<strong>首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</strong>。</p>
<h2 id="循环时间开销"><a href="#循环时间开销" class="headerlink" title="循环时间开销"></a>循环时间开销</h2><p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的<code>pause</code>指令那么效率会有一定的提升，<code>pause</code>指令有两个作用，<strong>第一它可以延迟流水线执行指令（de-pipeline）</strong>,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。<strong>第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush）</strong>，从而提高CPU的执行效率。</p>
<h2 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h2><p>CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。但是从JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>
<h1 id="29-CAS和Synchronized的使用场景"><a href="#29-CAS和Synchronized的使用场景" class="headerlink" title="29. CAS和Synchronized的使用场景"></a>29. CAS和Synchronized的使用场景</h1><blockquote>
<p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
</blockquote>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而<code>CAS</code>基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，<code>CAS</code>自旋的概率会比较大，从而浪费更多的CPU资源，效率低于<code>synchronized</code>。</p>
<blockquote>
<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的<strong>偏向锁</strong>和<strong>轻量级锁</strong>以及其它各种优化之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠<code>Lock-Free</code>的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
</blockquote>
<h1 id="30-如何正确的停止一个线程-为什么不推荐使用-stop-和-suspend-方法？"><a href="#30-如何正确的停止一个线程-为什么不推荐使用-stop-和-suspend-方法？" class="headerlink" title="30. 如何正确的停止一个线程?/为什么不推荐使用 stop 和 suspend 方法？"></a>30. 如何正确的停止一个线程?/为什么不推荐使用 stop 和 suspend 方法？</h1><p>初始的Java版本中定义了一个 <code>stop</code> 方法来终止一个线程，还定义了一个 <code>suspend</code> 方法来阻塞一个线程，直到另一个线程调用 <code>resume</code> 方法。在1.2之后就被弃用了。</p>
<p>反对使用 <code>stop()</code>，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</p>
<p><code>suspend()</code> 方法容易发生死锁。调用 <code>suspend()</code> 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 <code>suspend()</code>。</p>
<p>要正确停止一个线程，应该使用 <code>interrupt()</code> 方法。在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用  <code>wait()</code> 命其进入等待状态。若标志指出线程应当恢复，则用一个 <code>notify()</code> 重新启动线程。<code>interrupt()</code> 其本身并不是一个强制打断线程的方法，其仅仅会修改线程的 <code>interrupt</code> 标志位，然后让线程自行去读标志位，自行判断是否需要中断。</p>
<p><code>interrupt()</code>是一个“很软”的操作，也就是提醒线程应该结束了，至于如何结束，什么时候结束，以及是否需要结束，都是由线程自行处理。所以，<code>interrupt()</code>的使用，会让开发做更多的事，但这是有必要的，因为只有线程自己，才知道如何合适的结束自己。</p>
<h1 id="31-使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"><a href="#31-使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。" class="headerlink" title="31. 使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"></a>31. 使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThread multiThread = <span class="keyword">new</span> MultiThread();</span><br><span class="line">        Inc inc = multiThread.<span class="keyword">new</span> Inc();</span><br><span class="line">        Dec dec = multiThread.<span class="keyword">new</span> Dec();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(inc);</span><br><span class="line">            thread.start();</span><br><span class="line">            thread = <span class="keyword">new</span> Thread(dec);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"-inc:"</span> +j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"-dec:"</span> +j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-Java多线程回调的理解？"><a href="#32-Java多线程回调的理解？" class="headerlink" title="32. Java多线程回调的理解？"></a>32. Java多线程回调的理解？</h1><p>所谓回调，是指客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便叫做回调方法。</p>
<p>实例：设置一个提问者（客户程序C），一个回答者（服务程序S），而回答者需要回答提问者一个很深奥的问题时，这时需要很多时间去查找，提问者又开始做其他的事情，等回答者找到答案后，再把答案告诉提问者。</p>
<p><strong>回答者的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回答1+1,很简单不需要线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">answerAdd</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//回答地球为什么是圆的</span></span><br><span class="line">        askQuestion();</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置回调接口，这个接口中有回调方法，在提问者中实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallPhone</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String question)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调接口的对象</span></span><br><span class="line">    CallPhone callPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回答地球为什么是圆的，比较费时间，使用sleep</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">askQuestion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始查找资料..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//花了3天</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把答案返回到回调接口的call方法中</span></span><br><span class="line">        <span class="keyword">if</span>(callPhone != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//提问者实例化callPhone对象，相当于提问者已经告诉回答者用什么方式回答答案</span></span><br><span class="line">            <span class="comment">//该接口方法的实现在提问者的类里面</span></span><br><span class="line">            callPhone.call(<span class="string">"回答者知道答案了！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提问者的类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xm.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Asker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java回调方法的使用：</span></span><br><span class="line"><span class="comment">     * 1. 在回答者的类内部创建回调的接口</span></span><br><span class="line"><span class="comment">     * 2. 在回答者的类内部创建回调接口的对象</span></span><br><span class="line"><span class="comment">     * 3. 在提问者类里面实例化接口对象，重写接口方法</span></span><br><span class="line"><span class="comment">     * 2-3 这个点很重要，回调对象的实例化，要在提问者的类内实例化，然后重写接口的方法</span></span><br><span class="line"><span class="comment">     * 相当于提问者先把一个联络方式给回答者，回答者找到答案后，通过固定的联络方式，来告诉提问者答案</span></span><br><span class="line"><span class="comment">     * 4. 调用开始新线程的start方法</span></span><br><span class="line"><span class="comment">     * 5. 原来的提问者还可以做自己的事</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//问1+1，线程同步</span></span><br><span class="line">        Answer answer = <span class="keyword">new</span> Answer();</span><br><span class="line">        <span class="keyword">int</span> add = answer.answerAdd(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//回答1+1答案</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//问地球为什么是圆的，回调方法的使用</span></span><br><span class="line">        <span class="comment">//相当于先定好一个返回答案的方式，再来执行实际操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化回调接口的对象</span></span><br><span class="line">        Answer.CallPhone callPhone = question -&gt; &#123;</span><br><span class="line">            <span class="comment">//回答者回答问题后才能输出答案</span></span><br><span class="line">            System.out.println(question);</span><br><span class="line">        &#125;;</span><br><span class="line">        answer.callPhone = callPhone;</span><br><span class="line">        System.out.println(<span class="string">"交代完毕！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相关交代完毕后再执行查询操作</span></span><br><span class="line">        answer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"提问者做自己的事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设计模式中模版方法模式也是使用了回调</p>
</blockquote>
<h1 id="33-非公平锁和公平锁在-ReentrantLock-里的实现是怎么样的？"><a href="#33-非公平锁和公平锁在-ReentrantLock-里的实现是怎么样的？" class="headerlink" title="33. 非公平锁和公平锁在 ReentrantLock 里的实现是怎么样的？"></a>33. 非公平锁和公平锁在 ReentrantLock 里的实现是怎么样的？</h1><p><img src="http://qiniu.xiaoming.net.cn/ReentrantLock%20UML%E5%9B%BE" alt="ReentrantLock UML图"></p>
<p>ReentrantLock 属于 AQS 的一个子类，AQS 依赖于内部的 FIFO 同步队列（<code>CLH</code>）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个 <code>Node</code> 对象并将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>ReentrantLock 内部有一个抽象类 <code>Sync</code>，继承了 <code>AQS</code>。而公平锁的实现就是 <code>FairSync</code>，非公平锁的实现就是 <code>NodFairSync</code>。</p>
<p>两把锁的区别在于 <code>lock</code> 方法的实现。</p>
<h2 id="公平锁-lock方法实现"><a href="#公平锁-lock方法实现" class="headerlink" title="公平锁 lock方法实现"></a>公平锁 lock方法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是 AQS 的 <code>acquire</code>方法，而 AQS 会回调子类的 <code>tryAcquire</code>方法。</p>
<p>公平锁的情况是通过在构造方法中指定使用公平锁，此时内部类的 <code>sync</code> 为子类 <code>FairSync</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FairSync</code> 中 <code>tryAcquire</code> 的方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量，如果是0，说明锁可以获取</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断AQS队列中是否有等待的线程，如果没有，就是用CAS尝试获取。获取成功后，将CLH的持有线程改成当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重入锁逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  <span class="comment">//overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面判断AQS队列中是否有等待的线程便是公平的体现。</p>
<h2 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h2><p>ReentrantLock 默认采用的是非公平锁，除非在构造方法中传入参数 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//直接就是用CAS进行操作获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock 中的公平锁和非公平锁的区别就在于：</p>
<p>调用 <code>lock</code> 方法获取锁的时候要不要判断 AQS 队列中是否有等待的线程，公平锁为了让每一个线程都均衡的使用锁，就需要判断，如果有，让给他，非公平锁很霸道，不让不让就不让。</p>
<p>但如果失败了，进入队列了，进会按照 AQS 的逻辑来，整体顺序就是公平的。</p>
<p>还有个注意的地方就是：ReentrantLock 的 <code>tryLock</code>（无超时机制） 方法使用的非公平策略。符合他的设计。<br>而 <code>tryLock(long timeout, TimeUnit unit)</code> 方法则会根据 <code>Sync</code> 的具体实现来调用。不会直接的调用 <code>nonfairTryAcquire</code> 方法。</p>
<h1 id="34-LongAdder-和-AtomicLong-的区别？"><a href="#34-LongAdder-和-AtomicLong-的区别？" class="headerlink" title="34. LongAdder 和 AtomicLong 的区别？"></a>34. LongAdder 和 AtomicLong 的区别？</h1><ul>
<li><p><code>AutomaticLong</code>的底层是通过 CAS(compareAndSwap) 来实现线程的同步，是<strong>在一个死循环内不断的尝试修改目标的值，直到修改成功</strong>。如果在竞争不激烈的情况下，它修改成功的概率很高，否则的话修改失败的概率就会很高， 在大量修改失败的时候这些原子操作就会多次循环尝试， 因此性能就会受到影响。<strong>对于普通类型的 <code>long</code> 和 <code>dubble</code> 变量 JVM 允许将64位的读或者写操作拆分成2个32位的读或者写操作</strong>(使用 <code>volatile</code> 修饰)</p>
</li>
<li><p><code>LongAdder</code> 的内部实现思想是： 将热点数据分离，将 <code>AutomaticLong</code> 的内部核心数据 <code>value</code> 分割成一个数组，每个线程访问时，通过 <code>Hash</code> 等算法映射到其中一个数字进行计数，<strong>最终的计数结果为这个数组的求和累加</strong>，其中热点数据 <code>value</code> 它会被分割成多个单元的 <code>cell</code>，每个 <code>cell</code> 独立维护内部的值，当前对象的实际值由所有的 <code>cell</code> 累计合成，这样热点就进行了有效的分离，提高了并行度。即 <code>LongAdder</code> 是在 <code>AtomicLong</code> 的基础上将单点的更新压力分散到各个节点上。在低并发的时候通过对 <code>base</code> 的值直接更新，可以很好地保证和 <code>AutomaticLong</code> 性能基本一致，而在高并发的时候则通过分散提高了性能。</p>
</li>
<li><p><strong><code>LongAdder</code> 缺点</strong>：在统计的时候如果有并发更新，可能会导致统计的数据有些误差。在实际处理高并发中，我们根据实际业务场景优先考虑使用 <code>LongAdder</code> 而不是继续使用 <code>AtomicLong</code>，当然在线程竞争很低的情况下 <code>AutomaticLong</code> 才是最佳选择(序列号生成等要求准确且全局唯一)。</p>
</li>
</ul>
<h1 id="35-volatile底层实现"><a href="#35-volatile底层实现" class="headerlink" title="35. volatile底层实现"></a>35. volatile底层实现</h1><p>关键字 volatile 主要有两个作用：</p>
<ul>
<li><strong>内存可见性</strong>：当一个变量被 volatile 修饰后，表示着线程本地内存无效，当一个线程修改共享变量后它会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取（不能保证数据的原子性）。</li>
<li><strong>禁止指令重排序</strong>：通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</li>
</ul>
<p>其实现主要涉及到两个 CPU 术语：</p>
<ul>
<li><strong>内存屏障</strong>（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。</li>
<li><strong>缓存行</strong>（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</li>
</ul>
<h2 id="可见性实现原理"><a href="#可见性实现原理" class="headerlink" title="可见性实现原理"></a>可见性实现原理</h2><p>通过打印 volatile 汇编指令如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/volatile%E5%BA%95%E5%B1%82%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0.webp" alt="volatile底层汇编实现"></p>
<p>加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码对比发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。volatile 变量在字节码级别没有任何区别，在汇编级别使用了 lock 指令前缀。</p>
<blockquote>
<p>lock 指令在多核处理器下会引发下面的事件：<br><strong>将当前处理器的缓存行的数据写回到系统内存，同时使其他 CPU 里缓存了该内存地址的数据置为无效</strong>。<br>为了提高处理速度，处理器一般不直接和内存通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完成后并不知道处理器何时将缓存数据写回到内存。但如果对加了 volatile 修饰的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量在缓存行的数据写回到系统内存。这时只是写回到系统内存，但其他处理器的缓存行中的数据还是旧的，要使其他处理器缓存行的数据也是新写回的系统内存的数据，就需要实现缓存一致性协议。即在一个处理器将自己缓存行的数据写回到系统内存后，其他的每个处理器就会通过嗅探在总线上传播的数据来检查自己缓存的数据是否已过期，当处理器发现自己缓存行对应的内存地址的数据被修改后，就会将自己缓存行缓存的数据设置为无效，当处理器要对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到自己的缓存行，重新缓存。</p>
</blockquote>
<p>总结：volatile 可见性的实现就是借助了 CPU 的 lock 指令，通过在写 volatile 的机器指令前加上 lock 前缀，使写 volatile 具有以下两个原则：</p>
<ul>
<li>写 volatile 时处理器会将缓存写回到主内存。</li>
<li>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</li>
</ul>
<h2 id="防止指令重排实现原理"><a href="#防止指令重排实现原理" class="headerlink" title="防止指令重排实现原理"></a>防止指令重排实现原理</h2><p>lock 指令后就是一个原子操作。原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （上下文切换，切换到另一个线程）。</p>
<p>当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>
<p>lock 前缀指令其实就相当于一个内存屏障。内存屏障是一组CPU处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。</p>
<p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>，即读屏障和写屏障。</p>
<p>内存屏障有两个作用：</p>
<ul>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ul>
<p>对于 <code>Load Barrier</code> 来说，在指令前插入 <code>Load Barrier</code>，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p>
<p>对于 <code>Store Barrier</code> 来说，在指令后插入 <code>Store Barrier</code>，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<p>java 的内存屏障通常所谓的四种即 <code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>,实际上也是上述两种的组合，完成一系列的屏障和数据同步功能:</p>
<ul>
<li>LoadLoad 屏障：对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreStore 屏障：对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li>LoadStore 屏障：对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreLoad 屏障：对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。<strong>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</strong></li>
</ul>
<p>编译器和执行器可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉 CPU 和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。</p>
<p>JMM 为 volatile 加内存屏障有以下4种情况：</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障，防止写 volatile 与后面的写操作重排序。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障，防止写 volatile 与后面的读操作重排序。</li>
<li>在每个 volatile 读操作的前面插入一个 LoadLoad 屏障，防止读 volatile 与后面的读操作重排序。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障，防止读 volatile 与后面的写操作重排序。</li>
</ul>
<p>内存屏障另一个作用是强制更新一次不同 CPU 的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个CPU核心或者哪个CPU执行的。这正是 volatile 实现内存可见性的基础。</p>
<h2 id="volatile-修饰数组和对象"><a href="#volatile-修饰数组和对象" class="headerlink" title="volatile 修饰数组和对象"></a>volatile 修饰数组和对象</h2><p>volatile 修饰对象或数组时，只能保证他们的引用地址的可见性，而不能保证其内部元素具有可见性。</p>
<p>但是如果对于同一个数组，用 volatile 修饰后，在一个线程改编数组中的值，在另一个线程中还是可以马上读取到更新的新值，原因是：</p>
<blockquote>
<p>当另一个线程读取 array 时，因为 array 的引用被 volatile 修饰，所以线程对所有变量都会从主内存去获取，当然也就包括数组的内部值（例如 array[0]）。 所以会让人产生误解，以为是volatile修饰的数组保证了其数组的可见性，其实不然。</p>
</blockquote>
<h1 id="36-为什么要使用多线程"><a href="#36-为什么要使用多线程" class="headerlink" title="36. 为什么要使用多线程"></a>36. 为什么要使用多线程</h1><p>先从总体上来说：</p>
<ul>
<li>从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li>从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li>单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li>多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h1 id="37-BlockingQueue"><a href="#37-BlockingQueue" class="headerlink" title="37. BlockingQueue"></a>37. BlockingQueue</h1><p><code>java.util.concurrent.BlockingQueue</code>接口有以下阻塞队列的实现：</p>
<ul>
<li><code>FIFO</code>队列 ：<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>（固定长度）</li>
<li>优先级队列 ：<code>PriorityBlockingQueue</code></li>
</ul>
<p>提供了阻塞的<code>take()</code>和<code>put()</code>方法：如果队列为空<code>take()</code>将阻塞，直到队列中有内容；如果队列为满<code>put()</code>将阻塞，直到队列有空闲位置。</p>
<h2 id="使用BlockingQueue实现生产者，消费者案例"><a href="#使用BlockingQueue实现生产者，消费者案例" class="headerlink" title="使用BlockingQueue实现生产者，消费者案例"></a>使用BlockingQueue实现生产者，消费者案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"product..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String take = blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"consume..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Producer producer  = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p><code>ArrayBlockingQueue</code>是<code>BlockingQueue</code>接口的有界队列实现类，底层采用<strong>数组</strong>来实现。<code>ArrayBlockingQueue</code>一旦创建，<strong>容量不能改变</strong>。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code>默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到<code>ArrayBlockingQueue</code>。而非公平性则是指访问<code>ArrayBlockingQueue</code>的顺序不是遵守严格的时间顺序，有可能存在，当<code>ArrayBlockingQueue</code>可以被访问时，长时间阻塞的线程依然无法访问到<code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的<code>ArrayBlockingQueue</code>，可采用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p><code>LinkedBlockingQueue</code>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与<code>ArrayBlockingQueue</code>相比起来具有更高的吞吐量，为了防止<code>LinkedBlockingQueue</code>容量迅速增，损耗大量内存。通常在创建<code>LinkedBlockingQueue</code>对象时，会指定其大小，如果未指定，容量等于<code>Integer.MAX_VALUE</code>。</p>
<blockquote>
<p>有界无界是根据容量是否为<code>Interger.MAX_VALUE</code>来判别。</p>
</blockquote>
<h3 id="相关构造方法"><a href="#相关构造方法" class="headerlink" title="相关构造方法"></a>相关构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某种意义上的无界队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化时通过构造器参数<code>Comparator</code>来指定排序规则。</p>
<p><code>PriorityBlockingQueue</code>并发控制采用的是<code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code>是有界队列，<code>LinkedBlockingQueue</code>也可以通过在构造函数中传入<code>capacity</code>指定队列最大的容量，但是<code>PriorityBlockingQueue</code>只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是<code>PriorityQueue</code>的线程安全版本。不可以插入<code>null</code>值，同时，插入队列的对象必须是可比较大小的（<code>comparable</code>），否则报<code>ClassCastException</code>异常。它的插入操作<code>put</code>方法不会<code>block</code>，因为它是无界队列（<code>take</code>方法在队列为空的时候会阻塞）。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>Java提供的线程安全的<code>Queue</code>可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子就是<code>BlockingQueue</code>,而非阻塞队列的典型例子就是<code>ConcurrentLinkedQueue</code>,在实际应用中要根据需要选用阻塞队列或者非阻塞队列。<strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过CAS操作实现</strong></p>
<p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构,通过使用CAS非阻塞算法来实现线程安全。<code>ConcurrentLinkedQueue</code>应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>
<p><code>ConcurrentLinkedQueue</code>适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的<code>ConcurrentLinkedQueue</code>来替代。</p>
<h1 id="38-Fork-Join"><a href="#38-Fork-Join" class="headerlink" title="38. Fork/Join"></a>38. Fork/Join</h1><p>主要用于并行计算中，就是把大的计算任务拆分成多个小任务并行计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>; <span class="comment">//设置分割门槛</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写的方法，在任务执行后将根据这里进行判断是否继续划分更小的任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">//任务足够小则计算</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分割为更小的任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(start,middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//分割执行</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinExample forkJoinExample = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Future result  = forkJoinPool.submit(forkJoinExample);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ForkJoin</code>使用<code>ForkJoinPool</code>来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>
<p><code>ForkJoinPool</code>实现了<strong>工作窃取算法</strong>来提高CPU的利用率。每个线程都维护了一个双端链表，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，<code>Thread2</code>从<code>Thread1</code>的队列中拿出最晚的<code>Task1</code>任务，<code>Thread1</code>会拿出<code>Task2</code>来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。<br><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" alt="工作窃取算法"></p>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a><br><a href="https://www.jianshu.com/p/ccb493a2df21" target="_blank" rel="noopener">如何正确的停止一个线程？</a><br><a href="https://www.jianshu.com/p/10ef84dc5eef" target="_blank" rel="noopener">volatile修饰数组或引用对象的问题</a><br><a href="https://blog.csdn.net/weixin_40790474/article/details/88871596?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">单线程下StringBuffer与StringBuilder有区别吗</a><br><a href="https://juejin.im/post/5bfcf9896fb9a049b7800e20#heading-3" target="_blank" rel="noopener">图解AQS系列（上）–独占锁</a><br><a href="https://cloud.tencent.com/developer/article/1098405" target="_blank" rel="noopener">ThreadLocal 原理和使用场景分析</a><br><a href="https://zhuanlan.zhihu.com/p/67129507" target="_blank" rel="noopener">用synchronized就一定线程安全吗？</a>  </p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/05/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="面试复习——计算机网络">
      <i class="fa fa-chevron-left"></i> 面试复习——计算机网络
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/19/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="next" title="Java虚拟机">
      Java虚拟机 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-java线程状态转换"><span class="nav-number">1.</span> <span class="nav-text">1. java线程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#新建（New）"><span class="nav-number">1.1.</span> <span class="nav-text">新建（New）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可运行（Runnable）"><span class="nav-number">1.2.</span> <span class="nav-text">可运行（Runnable）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞（Blocked）"><span class="nav-number">1.3.</span> <span class="nav-text">阻塞（Blocked）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无限期等待（Waiting）"><span class="nav-number">1.4.</span> <span class="nav-text">无限期等待（Waiting）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限期等待（Timed-Waiting）"><span class="nav-number">1.5.</span> <span class="nav-text">限期等待（Timed Waiting）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死亡（Terminated）"><span class="nav-number">1.6.</span> <span class="nav-text">死亡（Terminated）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-创建线程的三种方式"><span class="nav-number">2.</span> <span class="nav-text">2. 创建线程的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现Runnable"><span class="nav-number">2.1.</span> <span class="nav-text">实现Runnable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现Callable接口"><span class="nav-number">2.2.</span> <span class="nav-text">实现Callable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承Thread类"><span class="nav-number">2.3.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现接口-VS-继承-Thread"><span class="nav-number">2.4.</span> <span class="nav-text">实现接口 VS 继承 Thread</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-线程池"><span class="nav-number">3.</span> <span class="nav-text">3. 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如果创建线程池"><span class="nav-number">3.1.</span> <span class="nav-text">如果创建线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：通过ThreadPoolExecutor构造方法实现"><span class="nav-number">3.1.1.</span> <span class="nav-text">方法一：通过ThreadPoolExecutor构造方法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二-通过Executor框架的工具类Executors来实现-见上面例子"><span class="nav-number">3.1.2.</span> <span class="nav-text">方法二 通过Executor框架的工具类Executors来实现(见上面例子)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Daemon守护线程"><span class="nav-number">4.</span> <span class="nav-text">4. Daemon守护线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-sleep-方法"><span class="nav-number">5.</span> <span class="nav-text">5. sleep()方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-yield-方法"><span class="nav-number">6.</span> <span class="nav-text">6. yield()方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-线程中断的InterruptedException-interrupted-interrupt区别"><span class="nav-number">7.</span> <span class="nav-text">7. 线程中断的InterruptedException,interrupted,interrupt区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt"><span class="nav-number">7.1.</span> <span class="nav-text">interrupt()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InterruptedException"><span class="nav-number">7.2.</span> <span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupted"><span class="nav-number">7.3.</span> <span class="nav-text">interrupted()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池中的中断操作"><span class="nav-number">7.4.</span> <span class="nav-text">线程池中的中断操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？"><span class="nav-number">8.</span> <span class="nav-text">8. (锁）Java提供了哪些机制控制多个线程对共享资源的互斥访问？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">8.1.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说一说对Synchronized关键字的理解"><span class="nav-number">8.1.1.</span> <span class="nav-text">说一说对Synchronized关键字的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一说自己怎么使用synchronized关键字"><span class="nav-number">8.1.2.</span> <span class="nav-text">说一说自己怎么使用synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步一个代码块"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">同步一个代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步一个方法"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">同步一个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步一个类"><span class="nav-number">8.1.2.3.</span> <span class="nav-text">同步一个类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步一个静态方法"><span class="nav-number">8.1.2.4.</span> <span class="nav-text">同步一个静态方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双重校验锁实现单例对象（线程安全）"><span class="nav-number">8.1.3.</span> <span class="nav-text">双重校验锁实现单例对象（线程安全）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讲一下synchronized关键字底层原理"><span class="nav-number">8.1.4.</span> <span class="nav-text">讲一下synchronized关键字底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步语句块的情况"><span class="nav-number">8.1.4.1.</span> <span class="nav-text">同步语句块的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized修饰方法的情况"><span class="nav-number">8.1.4.2.</span> <span class="nav-text">synchronized修饰方法的情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized-是否一定线程安全"><span class="nav-number">8.1.5.</span> <span class="nav-text">Synchronized 是否一定线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">8.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和ReentrantLock区别"><span class="nav-number">8.3.</span> <span class="nav-text">synchronized和ReentrantLock区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-线程之间协作方式-线程同步和调度的相关方法"><span class="nav-number">9.</span> <span class="nav-text">9. 线程之间协作方式/线程同步和调度的相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#join-方法"><span class="nav-number">9.1.</span> <span class="nav-text">join()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-notifyAll"><span class="nav-number">9.2.</span> <span class="nav-text">wait(),notify(),notifyAll()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#await-signal-signalAll"><span class="nav-number">9.3.</span> <span class="nav-text">await(),signal(),signalAll()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-JUC下的AQS"><span class="nav-number">10.</span> <span class="nav-text">10. JUC下的AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理概念"><span class="nav-number">10.1.</span> <span class="nav-text">原理概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS对资源的两种共享方式"><span class="nav-number">10.1.1.</span> <span class="nav-text">AQS对资源的两种共享方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占锁的实现"><span class="nav-number">10.1.1.1.</span> <span class="nav-text">独占锁的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS自定义同步器"><span class="nav-number">10.2.</span> <span class="nav-text">AQS自定义同步器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">10.3.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch的三种典型用法"><span class="nav-number">10.3.1.</span> <span class="nav-text">CountDownLatch的三种典型用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch的不足"><span class="nav-number">10.3.2.</span> <span class="nav-text">CountDownLatch的不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">10.4.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier和CountDownLatch的区别"><span class="nav-number">10.4.1.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">10.5.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">10.6.</span> <span class="nav-text">FutureTask</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Java内存模型"><span class="nav-number">11.</span> <span class="nav-text">11. Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存和工作内存"><span class="nav-number">11.1.</span> <span class="nav-text">主内存和工作内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-内存间交互操作"><span class="nav-number">12.</span> <span class="nav-text">12. 内存间交互操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-内存模型的三大特性"><span class="nav-number">13.</span> <span class="nav-text">13. 内存模型的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">13.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性"><span class="nav-number">13.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性"><span class="nav-number">13.3.</span> <span class="nav-text">有序性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-先行发生原则"><span class="nav-number">14.</span> <span class="nav-text">14. 先行发生原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一线程原则"><span class="nav-number">14.1.</span> <span class="nav-text">单一线程原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管程锁定规则"><span class="nav-number">14.2.</span> <span class="nav-text">管程锁定规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile变量规则"><span class="nav-number">14.3.</span> <span class="nav-text">volatile变量规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程启动规则"><span class="nav-number">14.4.</span> <span class="nav-text">线程启动规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程加入规则"><span class="nav-number">14.5.</span> <span class="nav-text">线程加入规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程中断规则"><span class="nav-number">14.6.</span> <span class="nav-text">线程中断规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象终结规则"><span class="nav-number">14.7.</span> <span class="nav-text">对象终结规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传递性"><span class="nav-number">14.8.</span> <span class="nav-text">传递性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-线程安全"><span class="nav-number">15.</span> <span class="nav-text">15. 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变"><span class="nav-number">15.1.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥同步"><span class="nav-number">15.2.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞同步"><span class="nav-number">15.3.</span> <span class="nav-text">非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">15.3.1.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicInteger"><span class="nav-number">15.3.2.</span> <span class="nav-text">AtomicInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA"><span class="nav-number">15.3.3.</span> <span class="nav-text">ABA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无同步方案"><span class="nav-number">15.4.</span> <span class="nav-text">无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈封闭"><span class="nav-number">15.4.1.</span> <span class="nav-text">栈封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程本地存储"><span class="nav-number">15.4.2.</span> <span class="nav-text">线程本地存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入代码（Reentrant-Code）"><span class="nav-number">15.4.3.</span> <span class="nav-text">可重入代码（Reentrant Code）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-锁优化"><span class="nav-number">16.</span> <span class="nav-text">16. 锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自旋锁"><span class="nav-number">16.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁消除"><span class="nav-number">16.2.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁粗化"><span class="nav-number">16.3.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轻量级锁"><span class="nav-number">16.4.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏向锁"><span class="nav-number">16.5.</span> <span class="nav-text">偏向锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-多线层开发的良好实践"><span class="nav-number">17.</span> <span class="nav-text">17. 多线层开发的良好实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-synchronized关键字和volatile关键字的区别"><span class="nav-number">18.</span> <span class="nav-text">18. synchronized关键字和volatile关键字的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-ThreadLocal"><span class="nav-number">19.</span> <span class="nav-text">19. ThreadLocal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal-应用场景"><span class="nav-number">20.</span> <span class="nav-text">ThreadLocal 应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal内存泄漏问题"><span class="nav-number">20.1.</span> <span class="nav-text">ThreadLocal内存泄漏问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用弱引用？"><span class="nav-number">20.2.</span> <span class="nav-text">为什么使用弱引用？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-JUC下Atomic原子类"><span class="nav-number">21.</span> <span class="nav-text">20. JUC下Atomic原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger的使用"><span class="nav-number">21.1.</span> <span class="nav-text">AtomicInteger的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法："><span class="nav-number">21.1.1.</span> <span class="nav-text">常用方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">21.1.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组类型原子类"><span class="nav-number">21.2.</span> <span class="nav-text">数组类型原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicIntegerArray类常用方法"><span class="nav-number">21.2.1.</span> <span class="nav-text">AtomicIntegerArray类常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见方法使用"><span class="nav-number">21.2.2.</span> <span class="nav-text">常见方法使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用类型原子类"><span class="nav-number">21.3.</span> <span class="nav-text">引用类型原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicReference使用示例"><span class="nav-number">21.3.1.</span> <span class="nav-text">AtomicReference使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicStampedReference类使用示例"><span class="nav-number">21.3.2.</span> <span class="nav-text">AtomicStampedReference类使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicMarkableReference使用示例"><span class="nav-number">21.3.3.</span> <span class="nav-text">AtomicMarkableReference使用示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的属性修改类型原子类"><span class="nav-number">21.4.</span> <span class="nav-text">对象的属性修改类型原子类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-简要描述线程与进程的关系，区别以及优缺点"><span class="nav-number">22.</span> <span class="nav-text">21. 简要描述线程与进程的关系，区别以及优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-并发与并行的区别"><span class="nav-number">23.</span> <span class="nav-text">22. 并发与并行的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-说说sleep-方法和wait-方法的区别和共同点？"><span class="nav-number">24.</span> <span class="nav-text">23. 说说sleep()方法和wait()方法的区别和共同点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-调用start-方法时会执行run-方法，为什么不能直接调用run方法？"><span class="nav-number">25.</span> <span class="nav-text">24. 调用start()方法时会执行run()方法，为什么不能直接调用run方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-ConcurrentSkipListMap"><span class="nav-number">26.</span> <span class="nav-text">25. ConcurrentSkipListMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表"><span class="nav-number">26.1.</span> <span class="nav-text">跳表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-什么是乐观锁和悲观锁，使用场景分别是什么？"><span class="nav-number">27.</span> <span class="nav-text">26. 什么是乐观锁和悲观锁，使用场景分别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-乐观锁常见的两种实现方式是什么？"><span class="nav-number">28.</span> <span class="nav-text">27. 乐观锁常见的两种实现方式是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#版本号机制"><span class="nav-number">28.1.</span> <span class="nav-text">版本号机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS算法"><span class="nav-number">28.2.</span> <span class="nav-text">CAS算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-乐观锁的缺点"><span class="nav-number">29.</span> <span class="nav-text">28. 乐观锁的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA问题"><span class="nav-number">29.1.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环时间开销"><span class="nav-number">29.2.</span> <span class="nav-text">循环时间开销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只能保证一个共享变量的原子操作"><span class="nav-number">29.3.</span> <span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-CAS和Synchronized的使用场景"><span class="nav-number">30.</span> <span class="nav-text">29. CAS和Synchronized的使用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-如何正确的停止一个线程-为什么不推荐使用-stop-和-suspend-方法？"><span class="nav-number">31.</span> <span class="nav-text">30. 如何正确的停止一个线程?/为什么不推荐使用 stop 和 suspend 方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"><span class="nav-number">32.</span> <span class="nav-text">31. 使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-Java多线程回调的理解？"><span class="nav-number">33.</span> <span class="nav-text">32. Java多线程回调的理解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-非公平锁和公平锁在-ReentrantLock-里的实现是怎么样的？"><span class="nav-number">34.</span> <span class="nav-text">33. 非公平锁和公平锁在 ReentrantLock 里的实现是怎么样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁-lock方法实现"><span class="nav-number">34.1.</span> <span class="nav-text">公平锁 lock方法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非公平锁的实现"><span class="nav-number">34.2.</span> <span class="nav-text">非公平锁的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-LongAdder-和-AtomicLong-的区别？"><span class="nav-number">35.</span> <span class="nav-text">34. LongAdder 和 AtomicLong 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-volatile底层实现"><span class="nav-number">36.</span> <span class="nav-text">35. volatile底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性实现原理"><span class="nav-number">36.1.</span> <span class="nav-text">可见性实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#防止指令重排实现原理"><span class="nav-number">36.2.</span> <span class="nav-text">防止指令重排实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-修饰数组和对象"><span class="nav-number">36.3.</span> <span class="nav-text">volatile 修饰数组和对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-为什么要使用多线程"><span class="nav-number">37.</span> <span class="nav-text">36. 为什么要使用多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-BlockingQueue"><span class="nav-number">38.</span> <span class="nav-text">37. BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用BlockingQueue实现生产者，消费者案例"><span class="nav-number">38.1.</span> <span class="nav-text">使用BlockingQueue实现生产者，消费者案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">38.2.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">38.3.</span> <span class="nav-text">LinkedBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关构造方法"><span class="nav-number">38.3.1.</span> <span class="nav-text">相关构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">38.4.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">38.5.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-Fork-Join"><span class="nav-number">39.</span> <span class="nav-text">38. Fork/Join</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
