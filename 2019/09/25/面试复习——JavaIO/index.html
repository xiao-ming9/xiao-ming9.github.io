<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1. 同步和异步的概念是什么 同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回 异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已经接收到请求，但是被调用者并没有返回结果，此时线程可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。  同步和异步的最大区别在于异步的话调用者不需要等待处理结束，被调用者会通过回调等机制来通知调用者其返回结果。">
<meta name="keywords" content="java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaIO">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;09&#x2F;25&#x2F;%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94JavaIO&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="1. 同步和异步的概念是什么 同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回 异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已经接收到请求，但是被调用者并没有返回结果，此时线程可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。  同步和异步的最大区别在于异步的话调用者不需要等待处理结束，被调用者会通过回调等机制来通知调用者其返回结果。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;5ef6de9824ae82bb0c403522a647953d1193a362&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f322e706e67">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;04b258a50ca7f9762f43d64e70f4489440bae4eb&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f332e706e67">
<meta property="og:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;3a68153ce17be90275df07a47409afaea91aff83&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67">
<meta property="og:updated_time" content="2020-03-22T10:57:56.890Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;5ef6de9824ae82bb0c403522a647953d1193a362&#x2F;68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f322e706e67">

<link rel="canonical" href="http://yoursite.com/2019/09/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94JavaIO/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JavaIO | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94JavaIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaIO
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-25 21:53:52" itemprop="dateCreated datePublished" datetime="2019-09-25T21:53:52+08:00">2019-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 18:57:56" itemprop="dateModified" datetime="2020-03-22T18:57:56+08:00">2020-03-22</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-同步和异步的概念是什么"><a href="#1-同步和异步的概念是什么" class="headerlink" title="1. 同步和异步的概念是什么"></a>1. 同步和异步的概念是什么</h1><ul>
<li><strong>同步</strong>：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回</li>
<li><strong>异步</strong>：异步就是发起一个调用后，立刻得到被调用者的回应表示已经接收到请求，但是被调用者并没有返回结果，此时线程可以处理其他的请求，被调用者通常依靠<strong>事件，回调</strong>等机制来通知调用者其返回结果。</li>
</ul>
<p>同步和异步的最大区别在于异步的话调用者不需要等待处理结束，被调用者会通过回调等机制来通知调用者其返回结果。</p>
<a id="more"></a>

<h1 id="2-阻塞和非阻塞的概念是什么"><a href="#2-阻塞和非阻塞的概念是什么" class="headerlink" title="2. 阻塞和非阻塞的概念是什么"></a>2. 阻塞和非阻塞的概念是什么</h1><ul>
<li><strong>阻塞</strong>：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞</strong>：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<blockquote>
<p>例子：你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</p>
</blockquote>
<h1 id="3-BIO，NIO，AIO区别"><a href="#3-BIO，NIO，AIO区别" class="headerlink" title="3. BIO，NIO，AIO区别"></a>3. BIO，NIO，AIO区别</h1><p>Java中<code>BIO</code>,<code>NIO</code>和<code>AIO</code>理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p>
<h2 id="BIO（Blocking-I-O）"><a href="#BIO（Blocking-I-O）" class="headerlink" title="BIO（Blocking I/O）"></a>BIO（Blocking I/O）</h2><p>同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<h3 id="传统BIO"><a href="#传统BIO" class="headerlink" title="传统BIO"></a>传统BIO</h3><p>BIO通信（一请求一应答）模型图如下：</p>
<p><img src="https://camo.githubusercontent.com/5ef6de9824ae82bb0c403522a647953d1193a362/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f322e706e67" alt="传统BIO模型图"></p>
<p>采用<strong>BIO通道模型</strong>的服务端，通常由一个独立的<code>Acceptor</code>线程负责监听客户端的连接。一般通过在<code>while(true)</code>循环中服务端会调用<code>accept()</code>方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成，不过可以通过多线程来支持多个客户端的连接，如上图所示。</p>
<p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<p>如果要让BIO通信模型能够同时处理多个客户端请求，就必须使用多线程（主要原因是<code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code>涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每一个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的<strong>一请求一应答通信模型</strong>。可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过<strong>线程池机制</strong>改善，线程池还可以让线程的创建和回收成本相对较低。使用<code>FixedThreadPool</code>可以有效的控制线程的最大数量，保证系统优先的资源的控制，实现<strong>N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型</strong>。（N可能远远大于M）。也就是伪异步IO。</p>
<h3 id="伪异步IO"><a href="#伪异步IO" class="headerlink" title="伪异步IO"></a>伪异步IO</h3><p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，有人对它的线程模型进行了优化一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p>
<p>伪异步IO模型图：</p>
<p><img src="https://camo.githubusercontent.com/04b258a50ca7f9762f43d64e70f4489440bae4eb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f332e706e67" alt="伪异步IO模型图"></p>
<p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的<code>Socket</code>封装成一个<code>Task</code>（该任务实现<code>java.lang.Runnable</code>接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面代码中演示了BIO通信（一请求一应答）模型。我们会在客户端创建多个线程依次连接服务端并向其发送”当前时间+:hello world”，服务端会为每个客户端线程创建一个线程来处理.</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个socket对象，指定要连接的服务器</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">3333</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.getOutputStream().write((<span class="keyword">new</span> Date() + <span class="string">": hello world"</span>).getBytes());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Socket服务端处理客户端连接请求</span></span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//等待客户端连接，会造成阻塞，如果客户端连接成功，立即返回一个Socket对象</span></span><br><span class="line">          Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">int</span> len;</span><br><span class="line">              <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              InputStream inputStream = socket.getInputStream();</span><br><span class="line">              <span class="comment">// 按字节流方式读取数据</span></span><br><span class="line">              <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是一种同步非阻塞的I/O模型，在java1.4中引入了NIO框架，对应<code>java.nio</code>包，提供了<code>Channel</code>、<code>Selector</code>、<code>Buffer</code>等抽象。</p>
<p>NIO中的N可以理解为<code>Non-blocking</code>，不单纯是<code>New</code>。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的<code>Socket</code>和<code>ServerSocket</code>相对应的<code>SocketChannel</code>和<code>ServerSocketChannel</code>两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<h3 id="NIO的特性-与IO的区别"><a href="#NIO的特性-与IO的区别" class="headerlink" title="NIO的特性/与IO的区别"></a>NIO的特性/与IO的区别</h3><h4 id="Non-Blocking-IO（非阻塞IO）"><a href="#Non-Blocking-IO（非阻塞IO）" class="headerlink" title="Non-Blocking IO（非阻塞IO）"></a>Non-Blocking IO（非阻塞IO）</h4><p><strong>IO流是阻塞的，NIO流是不阻塞的</strong>。</p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到<code>Buffer</code>,同时可以继续做别的事情，当数据读取到<code>buffer</code>中后，线程再继续处理数据。写数据也是一样。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或<code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<h4 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h4><p><strong>IO面向流（Stream oriented），而NIO面向缓冲区（Buffer oriented）</strong></p>
<p><code>Buffer</code>是一个对象，它包含一些要写入或者读出的数据。在NIO类库中加入<code>Buffer</code>对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中，可以将数据直接写入或者将数据直接读到<code>Stream</code>对象中。虽然<code>Stream</code>中也有<code>Buffer</code>开头的扩展类，但只是流的包装类，<strong>还是从流读到缓冲区</strong>，而NIO是直接读到<code>Buffer</code>中进行操作。</p>
<p>在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>最常用的缓冲区是<code>ByteBuffer</code>，一个<code>ByteBuffer</code>提供了一组功能用于操作<code>byte</code>数组。除了<code>ByteBuffer</code>，还有其他一些缓冲区，事实上，每一种Java基本类型（除了<code>Boolean</code>）都有对应的一种缓冲区。</p>
<p>在Java NIO中使用的核心缓冲区如下：（涵盖了通过I/O发送的基本数据类型：byte，char，short，int，long，float，double）：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>LongBuffer</li>
</ul>
<h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel(通道)"></a>Channel(通道)</h4><p><strong>NIO通过<code>Channel</code>（通道）进行读写</strong></p>
<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和<code>Buffer</code>交互。因为<code>Buffer</code>，通道可以异步地读写。</p>
<p>在Java NIO中，主要使用的通道如下（涵盖了UDP和TCP网络IO，以及文件IO）：</p>
<ul>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>FileChannel</li>
<li>ServerSocketChannel</li>
</ul>
<h4 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a>Selector(选择器)</h4><p><strong>NIO有选择器，而IO没有</strong></p>
<p>这是一个可以用于监听多个通道的对象，如数据到达，连接打开等等。因此，单线程可以监视多个通道中的数据。</p>
<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。因此，为了提高系统效率选择器是有用的。</p>
<p><img src="https://camo.githubusercontent.com/3a68153ce17be90275df07a47409afaea91aff83/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67" alt="选择器"></p>
<p>要使用<code>Seclector</code>的话，必须把<code>Channel</code>注册到<code>Selector</code>上，然后就可以调用<code>Seclector</code>的<code>select()</code>方法。这个方法会进入阻塞，直到有一个<code>channel</code>的状态符合条件，当方法返回时，线程可以处理这些时间。</p>
<h3 id="NIO读数据和写数据的方式"><a href="#NIO读数据和写数据的方式" class="headerlink" title="NIO读数据和写数据的方式"></a>NIO读数据和写数据的方式</h3><p>通常来说NIO中的所有IO都是从<code>Channel</code>（通道）开始的。</p>
<ul>
<li>从通道进行数据读取：创建一个缓冲区，然后请求通道读取数据</li>
<li>从通道进行数据写入：创建一个缓冲区，填充数据，并要求通道写入数据</li>
</ul>
<h3 id="NIO核心组件"><a href="#NIO核心组件" class="headerlink" title="NIO核心组件"></a>NIO核心组件</h3><p>NIO包含下面几个核心组件：</p>
<ul>
<li><code>Channel</code>(通道)</li>
<li><code>Buffer</code>(缓冲区)</li>
<li><code>Selector</code>(选择器)</li>
</ul>
<p>NIO整个体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>上面客户端保持不变，服务端修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span></span><br><span class="line">    <span class="comment">// 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span></span><br><span class="line">    Selector serverSelector = Selector.open();</span><br><span class="line">    <span class="comment">// 2. clientSelector负责轮询连接是否有数据可读</span></span><br><span class="line">    Selector clientSelector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">        ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line">        listenerChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">3333</span>));</span><br><span class="line">        listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">          <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                  SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                  clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                  clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">          <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                  ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                  <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">                  clientChannel.read(byteBuffer);</span><br><span class="line">                  byteBuffer.flip();</span><br><span class="line">                  System.out.println(</span><br><span class="line">                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                  key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，JDK原生 NIO 有以下缺点：</p>
<ul>
<li>编程复杂，编程模型难</li>
<li>JDK的NIO底层由epoll实现，该实现饱受诟病的空轮询bug会导致cpu飙升100%</li>
<li>项目庞大之后，自行实现的NIO很容易出现各类bug，维护成本较高</li>
</ul>
<h2 id="AIO（Asynchronous-I-O）"><a href="#AIO（Asynchronous-I-O）" class="headerlink" title="AIO（Asynchronous I/O）"></a>AIO（Asynchronous I/O）</h2><p>AIO也就是NIO2，在Java7引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。（<strong>除了AIO其他的IO类型都是同步的</strong>）</p>
<h1 id="4-Java-IO类型"><a href="#4-Java-IO类型" class="headerlink" title="4. Java IO类型"></a>4. Java IO类型</h1><h2 id="按操作方式（类结构）"><a href="#按操作方式（类结构）" class="headerlink" title="按操作方式（类结构）"></a>按操作方式（类结构）</h2><p><strong>字节流和字符流</strong></p>
<ul>
<li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。</li>
<li>字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。</li>
</ul>
<p><strong>输出流和输入流</strong>：</p>
<ul>
<li>输出流：从内存读出到文件。只能进行写操作。</li>
<li>输入流：从文件读入到内存。只能进行读操作。</li>
</ul>
<blockquote>
<p>注意： 这里的出和入，都是相对于系统内存而言的。</p>
</blockquote>
<p><strong>节点流和处理流</strong>：</p>
<ul>
<li>节点流：直接与数据源相连，读入或读出。</li>
<li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。</li>
</ul>
<p>为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。</p>
<h3 id="分类说明"><a href="#分类说明" class="headerlink" title="分类说明"></a>分类说明</h3><h4 id="输入字节流InputStream"><a href="#输入字节流InputStream" class="headerlink" title="输入字节流InputStream"></a>输入字节流InputStream</h4><ul>
<li><code>ByteArrayInputStream</code>,<code>StringBufferInputStream</code>,<code>FileInputStream</code>是三种基本的介质流，它们分别从<code>Byte</code>数组、<code>StringBuffer</code>和本地文件中读取数据</li>
<li><code>PipedInputStream</code>是从与其他线程共用的管道中读取数据。<code>PipedInputStream</code>的一个实例要和<code>PipedOutputStream</code>的一个实例共同使用，共同完成管道的读取写入操作，主要用于线程操作。</li>
<li><code>DataInputStream</code>:将基础数据类型读取出来</li>
<li><code>ObjectInputStream</code>和所有<code>FilterInputStream</code>的子类都是装饰流（装饰器模式的主角）。</li>
</ul>
<h4 id="输出字节流OutputStream"><a href="#输出字节流OutputStream" class="headerlink" title="输出字节流OutputStream"></a>输出字节流OutputStream</h4><ul>
<li><code>ByteArrayOutputStream</code>、<code>FileOutputStream</code>：是两种基本的介质流，它们分别从<code>Byte</code>数组、本地文件写入数据。</li>
<li><code>PipedOutputStream</code>是向与其它线程共用的管道中写入数据。</li>
<li><code>DataOutputStream</code>将基础数据类型写入到文件中</li>
<li><code>ObjectOutputStream</code>和所有<code>FilterOutputStream</code>的子类都是装饰流。</li>
</ul>
<h4 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h4><ul>
<li><code>FileReader</code>,<code>CharReader</code>,<code>StringReader</code>是三种基本的介质流，它们分在本地文件、<code>Char</code>数组、<code>String</code>中读取数据。</li>
<li><code>PipedReader</code>是从与其他线程共用的管道中读取数据</li>
<li><code>BufferedReader</code>：加缓冲功能，避免频繁读写硬盘</li>
<li><code>InputStreamReader</code>：加一个连接字节流和字符流的桥梁，它将字节流转换成字符流。</li>
</ul>
<h4 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h4><ul>
<li><code>StringWriter</code>:向<code>String</code>中写入数据</li>
<li><code>CharArrayWriter</code>：实现一个可用作字符输入流的字符缓冲区</li>
<li><code>PipedWriter</code>：是向与其它线程共用的管道中写入数据</li>
<li><code>BufferedWriter</code>:增加缓冲功能，避免频繁读写硬盘。</li>
<li><code>PrintWriter</code>和<code>PrintStream</code>将对象的格式表示打印到文本输出流。两者极其类似，功能和使用也类似。</li>
<li><code>OutputStreamWriter</code>：是<code>OutputStream</code>到<code>writer</code>转换的桥梁，它的子类<code>FileWriter</code>其实就是一个实现此功能的具体类。功能和使用和<code>OutputStream</code>类似</li>
</ul>
<h2 id="按操作对象"><a href="#按操作对象" class="headerlink" title="按操作对象"></a>按操作对象</h2><h3 id="对文件进行操作（节点流）"><a href="#对文件进行操作（节点流）" class="headerlink" title="对文件进行操作（节点流）"></a>对文件进行操作（节点流）</h3><ul>
<li><code>FileInputStream</code>（字节输入流）</li>
<li><code>FileOutputStream</code>（字节输出流）</li>
<li><code>FileReader</code>（字符输入流）</li>
<li><code>FileWriter</code>（字符输出流）</li>
</ul>
<h3 id="对管道进行操作（节点流）"><a href="#对管道进行操作（节点流）" class="headerlink" title="对管道进行操作（节点流）"></a>对管道进行操作（节点流）</h3><ul>
<li><code>PipedInputStream</code>（字节输入流）</li>
<li><code>PipedOutStream</code>（字节输出流）</li>
<li><code>PipedReader</code>（字符输入流）</li>
<li><code>PipedWriter</code>（字符输出流）</li>
</ul>
<blockquote>
<p><code>PipedInputStream</code>的一个实例要和<code>PipedOutputStream</code>的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。</p>
</blockquote>
<h3 id="字节-字符数组流（节点流）："><a href="#字节-字符数组流（节点流）：" class="headerlink" title="字节/字符数组流（节点流）："></a>字节/字符数组流（节点流）：</h3><ul>
<li><code>ByteArrayInputStream</code></li>
<li><code>ByteArrayOutputStream</code></li>
<li><code>CharArrayReader</code></li>
<li><code>CharArrayWriter</code></li>
</ul>
<p>上面的三种是<strong>节点流</strong>，除此之外其它都是<strong>处理流</strong>，需要跟节点流配合使用。</p>
<h3 id="Buffered缓冲流（处理流）"><a href="#Buffered缓冲流（处理流）" class="headerlink" title="Buffered缓冲流（处理流）"></a>Buffered缓冲流（处理流）</h3><p>带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。</p>
<ul>
<li><code>BufferedInputStream</code></li>
<li><code>BufferedOutputStream</code></li>
<li><code>BufferedReader</code></li>
<li><code>BufferedWriter</code></li>
</ul>
<h3 id="转化流（处理流）："><a href="#转化流（处理流）：" class="headerlink" title="转化流（处理流）："></a>转化流（处理流）：</h3><p><code>InputStreamReader</code>：把字节转化成字符<br><code>OutputStreamWriter</code>：把字符转化成字节</p>
<h3 id="基本类型数据流（处理流）"><a href="#基本类型数据流（处理流）" class="headerlink" title="基本类型数据流（处理流）"></a>基本类型数据流（处理流）</h3><p>用于操作基本数据类型值。</p>
<p>因为平时若是输出一个8个字节的long类型或4个字节的float类型，可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，数据流就解决了输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。</p>
<ul>
<li><code>DataInputStream</code></li>
<li><code>DataOutputStream</code></li>
</ul>
<h3 id="打印流（处理流）："><a href="#打印流（处理流）：" class="headerlink" title="打印流（处理流）："></a>打印流（处理流）：</h3><p>一般是打印到控制台，可以进行控制打印的地方。</p>
<ul>
<li><code>PrintStream</code></li>
<li><code>PrintWriter</code></li>
</ul>
<h3 id="对象流（处理流）："><a href="#对象流（处理流）：" class="headerlink" title="对象流（处理流）："></a>对象流（处理流）：</h3><p>把封装的对象直接输出，而不是一个个在转换成字符串再输出。</p>
<ul>
<li><code>ObjectInputStream</code>:对象反序列化</li>
<li><code>ObjectOutputStream</code>:对象序列化</li>
</ul>
<h3 id="合并流（处理流）："><a href="#合并流（处理流）：" class="headerlink" title="合并流（处理流）："></a>合并流（处理流）：</h3><ul>
<li><code>SequenceInputStream</code>:可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。</li>
</ul>
<h3 id="其他类：File（已经被Java7的Path取代）"><a href="#其他类：File（已经被Java7的Path取代）" class="headerlink" title="其他类：File（已经被Java7的Path取代）"></a>其他类：File（已经被Java7的Path取代）</h3><p><code>File</code>类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 <strong><code>File</code>类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。</strong></p>
<h3 id="其他类：RandomAccessFile"><a href="#其他类：RandomAccessFile" class="headerlink" title="其他类：RandomAccessFile"></a>其他类：RandomAccessFile</h3><p>该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：</p>
<ul>
<li>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。</li>
<li>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)。</li>
</ul>
<h1 id="5-什么是IO流"><a href="#5-什么是IO流" class="headerlink" title="5. 什么是IO流"></a>5. 什么是IO流</h1><p>IO流是一种数据的流从源头流到目的地，比如文件拷贝，输入流和输出流都包括了。输入流从文件中读取数据存储到进程中，输出流从进程中读取数据然后写入到目标文件。</p>
<h1 id="6-字节流和字符流的区别"><a href="#6-字节流和字符流的区别" class="headerlink" title="6. 字节流和字符流的区别"></a>6. 字节流和字符流的区别</h1><p>字节流在JDK1.0只被引进，用于操作包含ASCII字符的文件，JAVA也支持其它的字符如<code>Unicode</code>,为了读取包含<code>Unicode</code>字符的文件，JAVA语言设计者在JDK1.1中加入了字符流。ASCII作为<code>Unicode</code>的子集，对于英文字符的文件，可以使用字节流也可以使用字符流。</p>
<h1 id="7-Java中流类的超类主要有哪些？"><a href="#7-Java中流类的超类主要有哪些？" class="headerlink" title="7. Java中流类的超类主要有哪些？"></a>7. Java中流类的超类主要有哪些？</h1><ul>
<li><code>java.io.InputStream</code></li>
<li><code>java.io.OutputStream</code></li>
<li><code>java.io.Reader</code></li>
<li><code>java.io.Writer</code></li>
</ul>
<h1 id="8-FileInputStream和FileOutputStream是什么？"><a href="#8-FileInputStream和FileOutputStream是什么？" class="headerlink" title="8. FileInputStream和FileOutputStream是什么？"></a>8. FileInputStream和FileOutputStream是什么？</h1><p>这是在拷贝文件操作的时候，经常用到的两个类。在处理小文件的时候，它们性能表现还不错，在大文件的时候，最好使用<code>BufferedInputStream</code>(或<code>BufferedReader</code>) 和<code>BufferedOutputStream</code>(或<code>BufferedWriter</code>)</p>
<h1 id="9-字节流和字符流，更倾向于用哪个"><a href="#9-字节流和字符流，更倾向于用哪个" class="headerlink" title="9. 字节流和字符流，更倾向于用哪个"></a>9. 字节流和字符流，更倾向于用哪个</h1><p>字符流。因为它们更新一些。许多在字符流中存在的特性，字节流中不存在。比如使用<code>BufferedReader</code>而不是<code>BufferedInputStreams</code>或<code>DataInputStream</code>,使用<code>newLine()</code>方法来读取下一行，但是在字节流中我们需要做额外的操作。</p>
<h1 id="10-System-out-println-是什么？"><a href="#10-System-out-println-是什么？" class="headerlink" title="10. System.out.println()是什么？"></a>10. System.out.println()是什么？</h1><p><code>System</code>是一个<code>java.lang</code>包中的类，用于和底层的操作系统进行交互。</p>
<p><code>out</code>是一个静态的<code>PrintStream</code>类型的成员变量。</p>
<p><code>println</code>是<code>PrintStream</code>的一个方法</p>
<h1 id="11-什么是Filter流"><a href="#11-什么是Filter流" class="headerlink" title="11. 什么是Filter流"></a>11. 什么是Filter流</h1><p><code>Filter Stream</code>是一种IO流主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能。</p>
<h1 id="12-有哪些可用的Filter流"><a href="#12-有哪些可用的Filter流" class="headerlink" title="12. 有哪些可用的Filter流"></a>12. 有哪些可用的Filter流</h1><p>在<code>java.io</code>包中主要有4个可用的<code>filter Stream</code>。包括两个字节<code>Filter Stream</code>,两个字符<code>Filter Stream</code>。分别是：<code>FilterInputStream</code>,<code>FilterOutputStream</code>,<code>FilterReader</code>,<code>FilterWriter</code>。<strong>这些类是抽象类，不能被实例化</strong>。</p>
<p><strong>有哪些Filter流的子类</strong></p>
<ul>
<li><code>LineNumberInputStream</code>：给目标文件增加行号</li>
<li><code>DataInputStream</code>:有些特殊的方法如<code>readInt()</code>,<code>readDouble()</code>和<code>readLine()</code>等可以读取一个<code>int</code>,<code>double</code>和一个<code>string</code>等对应的基本数据类型的返回值。</li>
<li><code>BufferedInputStream</code>：增加性能</li>
<li><code>PushbackInputStream</code>：推送要求的字节到系统中</li>
</ul>
<h1 id="13-SequenceInputStream的作用"><a href="#13-SequenceInputStream的作用" class="headerlink" title="13. SequenceInputStream的作用"></a>13. SequenceInputStream的作用</h1><p>这个类的作用是将多个输入流合并成一个输入流，通过<code>SequenceInputStream</code>类包装后形成新的一个总的输入流。在拷贝多个文件到一个目标文件的时候非常有用。</p>
<h1 id="14-说说PrintStream和PrintWriter"><a href="#14-说说PrintStream和PrintWriter" class="headerlink" title="14. 说说PrintStream和PrintWriter"></a>14. 说说PrintStream和PrintWriter</h1><p>它们两个功能相同，但是属于不同的类。字节流和字符流，它们都有<code>println</code>方法。</p>
<h1 id="15-在文件拷贝的时候，哪一种流可用于提升更多的性能？"><a href="#15-在文件拷贝的时候，哪一种流可用于提升更多的性能？" class="headerlink" title="15. 在文件拷贝的时候，哪一种流可用于提升更多的性能？"></a>15. 在文件拷贝的时候，哪一种流可用于提升更多的性能？</h1><p>在字节流的时候，使用<code>BufferedInputStream</code>和<code>BufferedOutputStream</code></p>
<p>在字符流的时候，使用<code>BufferedReader</code>和<code>BufferedWriter</code></p>
<h1 id="16-说说管道流（Piped-Stream）"><a href="#16-说说管道流（Piped-Stream）" class="headerlink" title="16. 说说管道流（Piped Stream）"></a>16. 说说管道流（Piped Stream）</h1><p>用于从与其他线程共用的管道中读取数据，有四种管道流，<code>PipedInputStream</code>,<code>PipedOutputStream</code>,<code>PipedReader</code>和<code>PipedWtiter</code>。在多个线程或进程中传递数据的时候管道流非常有用。</p>
<p>PipedInputStream 的一个实例要和 PipedOutputStream 的一个实例共同使用，共同完成管道的读取写入操作，主要用于线程操作。</p>
<h1 id="17-说说File类"><a href="#17-说说File类" class="headerlink" title="17. 说说File类"></a>17. 说说File类</h1><p>它不属于IO流，也不是用于文件操作系统，它主要用于知道一个文件的属性，读写权限，大小等信息。</p>
<p>递归的列出一个目录下的所有文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="keyword">null</span> || !dir.exists())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dir.isFile())&#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(File file:dir.listFiles())&#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Java7开始，可以使用<code>Paths</code>和<code>Files</code>代替<code>File</code>。</p>
<h1 id="18-说说RandomAccessFile"><a href="#18-说说RandomAccessFile" class="headerlink" title="18. 说说RandomAccessFile"></a>18. 说说RandomAccessFile</h1><p>它在<code>java.io</code>包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。它是<code>Object</code>的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是<code>RandomAccessFile</code>既可以读文件，也可以写文件。</p>
<p><code>DataInputStream</code>和<code>DataOutputStream</code>有的方法，在<code>RandomAccessFile</code>中都存在。</p>
<h1 id="19-Buffer（缓冲区）介绍"><a href="#19-Buffer（缓冲区）介绍" class="headerlink" title="19. Buffer（缓冲区）介绍"></a>19. Buffer（缓冲区）介绍</h1><p><code>Buffer</code>本质就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。</p>
<p>利用Buffer读写数据，通常遵循四个步骤：</p>
<ul>
<li>把数据写入<code>buffer</code></li>
<li>调用<code>flip</code></li>
<li>从<code>Buffer</code>中读取数据</li>
<li>调用<code>buffer.clear()</code>或者<code>buffer.compact()</code></li>
</ul>
<p>当写入数据到<code>buffer</code>中时，<code>buffer</code>会记录已经写入的数据大小。当需要读数据时，<strong>通过<code>flip()</code>方法把<code>buffer</code>从写模式调整为读模式</strong>；在读模式下，可以读取所有已经写入的数据。</p>
<p>当读取完数据后，需要清空<code>buffer</code>，以满足后续写入操作。清空<code>buffer</code>有两种方式：调用<code>clear()</code>或<code>compact()</code>方法。<code>clear</code>会清空整个<code>buffer</code>，<code>compact</code>则只清空已读取的数据，未被读取的数据会被移动到<code>buffer</code>的开始位置，写入位置则近跟着未读数据之后。</p>
<p><code>Buffer</code>缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被<code>NIO Buffer</code>管理，并提供一系列的方法用于更简单的操作这块内存。</p>
<p>一个Buffer有三个属性，分别是：</p>
<ul>
<li><code>capacity</code>容量: 作为一块内存，<code>buffer</code>有一个固定的大小，这个大小就是<code>capacity</code>。也就是最多只能写入容量值得字节，整形等数据。一旦<code>buffer</code>写满了就需要清空已读数据以便下次继续写入新的数据。</li>
<li><code>position</code>位置: 当写入数据到<code>Buffer</code>的时候需要从一个确定的位置开始，默认初始化时这个位置<code>position</code>为0，一旦写入了数据比如一个字节，整形数据，那么<code>position</code>的值就会指向数据之后的一个单元，<code>position</code>最大可以到<code>capacity-1</code>；<br>当从<code>Buffer</code>读取数据时，也需要从一个确定的位置开始。<code>buffer</code>从写入模式变为读取模式时，<code>position</code>会归零，每次读取后，<code>position</code>向后移动。</li>
<li>limit限制: 在写模式，<code>limit</code>的含义是我们所能写入的最大数据量，它等同于<code>buffer</code>的容量。<br>一旦切换到读模式，<code>limit</code>则代表我们所能读取的最大数据量，他的值等同于写模式下<code>position</code>的位置。换句话说，可以读取与写入数量相同的字节数（限制设置为写入的字节数，由位置标记）。</li>
</ul>
<p><code>position</code>和<code>limit</code>的具体含义取决于当前<code>buffer</code>的模式。<code>capacity</code>在两种模式下都表示容量。</p>
<h2 id="Buffer的使用方式"><a href="#Buffer的使用方式" class="headerlink" title="Buffer的使用方式"></a>Buffer的使用方式</h2><h3 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h3><p>为了获得缓冲区对象，必须首先分配一个缓冲区。在每个<code>Buffer</code>类中，<code>allocate()</code>方法用于分配缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">28</span>);   <span class="comment">//分配容量为28字节</span></span><br><span class="line">CharBUffer buf = CharBuffer.allocate(<span class="number">1024</span>); <span class="comment">//分配空间大小为1024个字符</span></span><br></pre></td></tr></table></figure>

<h3 id="写入数据到缓冲区"><a href="#写入数据到缓冲区" class="headerlink" title="写入数据到缓冲区"></a>写入数据到缓冲区</h3><p>写数据到<code>Buffer</code>有两种方法：</p>
<ul>
<li>从<code>Channel</code>中写数据到<code>Buffer</code></li>
<li>手动写数据到<code>Buffer</code>，调用<code>put</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> byteRead = inChannel.read(buf);     <span class="comment">//从通道写入数据</span></span><br><span class="line">buf.put(<span class="number">27</span>);    <span class="comment">//向buffer手动写入数据</span></span><br></pre></td></tr></table></figure>

<h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p><code>flip()</code>方法可以把<code>Buffer</code>从写模式切换到读模式。调用<code>flip</code>方法会把<code>position</code>归零，并设置<code>limit</code>为之前的<code>position</code>的值。也就是说，现在<code>position</code>代表的是读取位置，<code>limit</code>标示的是已写入的数据位置。</p>
<h3 id="从Buffer读取数据"><a href="#从Buffer读取数据" class="headerlink" title="从Buffer读取数据"></a>从Buffer读取数据</h3><p>从<code>Buffer</code>读数据也有两种方式。</p>
<ul>
<li>从<code>buffer</code>读数据到<code>channel</code></li>
<li>从<code>buffer</code>直接读取数据，调用<code>get</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);    <span class="comment">//读入到channel</span></span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get();     <span class="comment">//直接读取</span></span><br></pre></td></tr></table></figure>

<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><p><code>Buffer.rewind()</code>方法将<code>position</code>置为0，这样我们可以重复读取<code>buffer</code>中的数据,<code>limit</code>保持不变。</p>
<h2 id="clear-和-compact"><a href="#clear-和-compact" class="headerlink" title="clear() 和 compact()"></a>clear() 和 compact()</h2><p>一旦从<code>buffer</code>中读取完数据，需要复用<code>buffer</code>为下次写数据做准备。只需要调用<code>clear（）</code>或<code>compact（）</code>方法。</p>
<p>如果调用的是<code>clear()</code>方法，<code>position</code>将被设回0，<code>limit</code>被设置成<code>capacity</code>的值。换句话说，<code>Buffer</code>被清空了。<code>Buffer</code>中的数据并未清除，只是这些标记告诉我们可以从哪里开始往<code>Buffer</code>里写数据。</p>
<p>如果<code>Buffer</code>还有一些数据没有读取完，调用<code>clear</code>就会导致这部分数据被“遗忘”，因为没有标记这部分数据未读。针对这种情况，如果需要保留未读数据，那么可以使用<code>compact</code>。 </p>
<p><code>compact()</code>和<code>clear()</code>的区别就在于:<strong>对未读数据的处理，是保留这部分数据还是一起清空</strong>。</p>
<h2 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h2><p>通过调用<code>Buffer.mark()</code>方法，可以标记<code>Buffer</code>中的一个特定<code>position</code>。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个<code>position</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();  <span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset(); <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure>

<h2 id="equals-and-compareTo"><a href="#equals-and-compareTo" class="headerlink" title="equals() and compareTo()"></a>equals() and compareTo()</h2><p>可以用<code>eqauls</code>和<code>compareTo</code>比较两个buffer</p>
<p><strong><code>equals()</code></strong>:</p>
<p>判断两个<code>buffer</code>相对，需满足：</p>
<ul>
<li>类型相同</li>
<li><code>buffer</code>中剩余字节数相同</li>
<li>所有剩余字节相等</li>
</ul>
<p>从上面的三个条件可以看出，<code>equals</code>只比较<code>buffer</code>中的部分内容，并不会去比较每一个元素。</p>
<p><strong><code>compareTo()</code></strong>:</p>
<p><code>compareTo</code>也是比较<code>buffer</code>中的剩余元素，只不过这个方法适用于比较排序的</p>
<h1 id="20-Channel"><a href="#20-Channel" class="headerlink" title="20. Channel"></a>20. Channel</h1><p>通常来说NIO中的所有IO都是从<code>Channel</code>（通道）开始的。</p>
<ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
<h2 id="通道和流的区别？"><a href="#通道和流的区别？" class="headerlink" title="通道和流的区别？"></a>通道和流的区别？</h2><p>Java NIO Channel通道和流非常相似，主要有以下几点区别：</p>
<ul>
<li>通道可以读也可以写，流一般来说是单向的（只能读或者写，所以用流进行IO操作的时候需要分别创建一个输入流和一个输出流）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区Buffer来读写。</li>
</ul>
<h2 id="Java-NIO中最重要的几个Channel的实现"><a href="#Java-NIO中最重要的几个Channel的实现" class="headerlink" title="Java NIO中最重要的几个Channel的实现"></a>Java NIO中最重要的几个Channel的实现</h2><ul>
<li><code>FileChannel</code>：用于文件的数据读写</li>
<li><code>DatagramChannel</code>：用于UDP的数据读写</li>
<li><code>SocketChannel</code>：用于TCP的数据读写，一般是客户端实现</li>
<li><code>ServerSocketChannel</code>:允许监听TCP链接请求，每个请求会创建会一个<code>SocketChannel</code>，一般是服务器实现</li>
</ul>
<h2 id="FileChannel的使用"><a href="#FileChannel的使用" class="headerlink" title="FileChannel的使用"></a>FileChannel的使用</h2><p>使用<code>FileChannel</code>读取数据到<code>Buffer</code>（缓冲区）以及利用<code>Buffer</code>（缓冲区）写入数据到<code>FileChannel</code></p>
<h3 id="开启FileChannel"><a href="#开启FileChannel" class="headerlink" title="开启FileChannel"></a>开启FileChannel</h3><p>使用之前，<code>FileChannel</code>必须被打开，但是<strong>无法直接打开<code>FileChannel</code>（<code>FileChannel</code>是抽象类）</strong>。需要通过<code>InputStream</code>，<code>OutputStream</code>或<code>RandomAccessFile</code>获取<code>FileChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个RandomAccessFile（随机访问文件）对象，</span></span><br><span class="line">RandomAccessFile raf=<span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\niodata.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//通过RandomAccessFile对象的getChannel()方法。FileChannel是抽象类。</span></span><br><span class="line">FileChannel inChannel=raf.getChannel();</span><br></pre></td></tr></table></figure>

<h3 id="从FileChannel读取数据-写入数据"><a href="#从FileChannel读取数据-写入数据" class="headerlink" title="从FileChannel读取数据/写入数据"></a>从FileChannel读取数据/写入数据</h3><p>从<code>FileChannel</code>中读取数据/写入数据之前首先要创建一个<code>Buffer</code>（缓冲区）对象。</p>
<p>使用<code>FileChannel</code>的<code>read()</code>方法读取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.创建一个读数据缓冲区对象</span></span><br><span class="line">BytesBuffer buf = <span class="keyword">new</span> BytesBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.从通道中读取数据写入缓冲区</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p>使用<code>FileChannel</code>的<code>write()</code>方法从缓冲区读取数据写入到通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个写数据缓冲区对象</span></span><br><span class="line">ByteBuffer buf2 = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line">buf2.put(<span class="string">"filechannel test"</span>.getBytes());</span><br><span class="line">buf2.flip();</span><br><span class="line">inChannel.write(buf2);</span><br></pre></td></tr></table></figure>
<h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTxt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个RandomAccessFile（随机访问文件）对象，</span></span><br><span class="line">        RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\niodata.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//通过RandomAccessFile对象的getChannel()方法。FileChannel是抽象类。</span></span><br><span class="line">        FileChannel inChannel=raf.getChannel();</span><br><span class="line">        <span class="comment">//2.创建一个读数据缓冲区对象</span></span><br><span class="line">        ByteBuffer buf=ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        <span class="comment">//3.从通道中读取数据</span></span><br><span class="line">        <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">        <span class="comment">//创建一个写数据缓冲区对象</span></span><br><span class="line">        ByteBuffer buf2=ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        buf2.put(<span class="string">"filechannel test"</span>.getBytes());</span><br><span class="line">        buf2.flip();</span><br><span class="line">        inChannel.write(buf2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">            <span class="comment">//Buffer有两种模式，写模式和读模式。在写模式下调用flip()之后，Buffer从写模式变成读模式。</span></span><br><span class="line">            buf.flip();</span><br><span class="line">           <span class="comment">//如果还有未读内容</span></span><br><span class="line">            <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清空缓存区</span></span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = inChannel.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭RandomAccessFile（随机访问文件）对象</span></span><br><span class="line">        raf.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道之间数据传输"><a href="#通道之间数据传输" class="headerlink" title="通道之间数据传输"></a>通道之间数据传输</h3><p>在Java NIO中，如果一个<code>channel</code>是<code>FileChannel</code>类型的，那么它可以直接把数据传输到另一个<code>channel</code>。</p>
<ul>
<li><strong>transferFrom</strong>：把数据从通道源传输到<code>FileChannel</code></li>
<li><strong>transferTo</strong>：把<code>FileChannel</code>数据传输到另一个<code>channel</code></li>
</ul>
<h2 id="SocketChannel和ServerSocketChannel的使用"><a href="#SocketChannel和ServerSocketChannel的使用" class="headerlink" title="SocketChannel和ServerSocketChannel的使用"></a>SocketChannel和ServerSocketChannel的使用</h2><p>利用<code>SocketChannel</code>和<code>ServerSocketChannel</code>实现客户端与服务器端简单通信：</p>
<p><code>SocketChannel</code>用于创建基于tcp协议的客户端对象，因为<code>SocketChannel</code>中不存在<code>accept()</code>方法，所以，它不能成为一个服务端程序。通过<code>connect()</code>方法，<code>SocketChannel</code>对象可以连接到其他tcp服务器程序。</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过SocketChannel的open()方法创建一个SocketChannel对象</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//2. 连接到远程服务器（连接此通道的socket）</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">3333</span>));</span><br><span class="line">        <span class="comment">//3. 创建写数据缓存区对象</span></span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        writeBuffer.put(<span class="string">"hello WebServer,this is WebClient"</span>.getBytes());</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        socketChannel.write(writeBuffer);</span><br><span class="line">        <span class="comment">//创建读数据缓冲区对象</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socketChannel.read(readBuffer);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//4. 将Buffer从写模式变为读模式</span></span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (readBuffer.hasRemaining())&#123;</span><br><span class="line">            stringBuffer.append((<span class="keyword">char</span>) readBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"从服务端接收的数据："</span>+stringBuffer);</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServerSocketChannel</code>允许监听TCP链接请求，通过<code>ServerSocketChannelImpl</code>的<code>accept()</code>方法可以创建一个<code>SocketChannel</code>对象用户从客户端读/写数据。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过ServerSocketChannel的open()方法创建一个ServerSocketChannel对象，open方法的作用：打开套接字通道</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.通过ServerSocketChannel绑定ip地址和port(端口号)</span></span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">3333</span>));</span><br><span class="line">        <span class="comment">//通过ServerSocketChannelImpl的accept()方法创建一个SocketChannel对象从客户端读/写</span></span><br><span class="line">        SocketChannel socketChannel = ssc.accept();</span><br><span class="line">        <span class="comment">//3. 创建写数据的缓存区对象</span></span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        writeBuffer.put(<span class="string">"hello WebClient,this is from WebServer"</span>.getBytes());</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        socketChannel.write(writeBuffer);</span><br><span class="line">        <span class="comment">//创建读数据的缓存区对象</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socketChannel.read(readBuffer);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//4.将Buffer从写模式变为读模式</span></span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (readBuffer.hasRemaining()) &#123;</span><br><span class="line">            stringBuffer.append((<span class="keyword">char</span>)readBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"从客户端接受的数据："</span>+stringBuffer);</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        ssc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DatagramChannel的使用"><a href="#DatagramChannel的使用" class="headerlink" title="DatagramChannel的使用"></a>DatagramChannel的使用</h2><p><code>DatagramChannel</code>，类似于java网络编程的<code>DatagramSocket</code>类；使用UDP进行网络传输， UDP是无连接，面向数据报文段的协议，对传输的数据不保证安全与完整。</p>
<h3 id="获取DatagramChannel"><a href="#获取DatagramChannel" class="headerlink" title="获取DatagramChannel"></a>获取DatagramChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过DatagramChannel的open()方法创建一个DatagramChannel对象</span></span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line"><span class="comment">//绑定一个port端口</span></span><br><span class="line">datagramChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));<span class="comment">//表示可以在1234端口接收数据报</span></span><br></pre></td></tr></table></figure>

<h3 id="接收-发送消息"><a href="#接收-发送消息" class="headerlink" title="接收/发送消息"></a>接收/发送消息</h3><p><strong>接收消息</strong>：先创建一个缓存区对象，然后通过<code>receive</code>方法接收消息，这个方法返回一个<code>SocketAddress</code>对象，表示发送消息方的地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure>
<p><strong>发送消息</strong>：由于UDP下，服务端和客户端通信并不需要建立连接，只需要知道对方地址即可发出消息，但是是否发送成功或者成功被接收到是没有保证的;发送消息通过<code>send</code>方法发出，该方法返回一个<code>int</code>值，表示成功发送的字节数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(<span class="string">"datagramchannel"</span>.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">int</span> send = channel.send(buf,<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">1234</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><p><code>Channel</code>提供了一种被称为<code>Scatter/Gather</code>的新功能，也称为本地矢量I/O。<code>Scatter/Gather</code>是指在多个缓冲区上实现一个简单的 I/O 操作。正确使用<code>Scatter / Gather</code>可以明显提高性能。</p>
<p>大多数现代操作系统都支持本地矢量I/O（native vectored I/O）操作。当在一个通道上请求一个<code>Scatter/Gather</code>操作时，该请求会被翻译为适当的本地调用来直接填充或抽取缓冲区，减少或避免了缓冲区拷贝和系统调用；</p>
<p><code>Scatter/Gather</code>应该使用直接的<code>ByteBuffers</code>以从本地I/O获取最大性能优势。</p>
<blockquote>
<p><code>Scatter/Gather</code>功能是通道(Channel)提供的,并不是<code>Buffer</code>。</p>
</blockquote>
<ul>
<li><code>Scatter</code>: 从一个<code>Channel</code>读取的信息分散到N个缓冲区中(<code>Buufer</code>).</li>
<li><code>Gather</code>: 将N个<code>Buffer</code>里面内容按照顺序发送到一个<code>Channel</code>.</li>
</ul>
<h3 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h3><p><code>scattering read</code>是把数据从单个<code>Channel</code>写入到多个<code>buffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123;header,body&#125;;</span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>
<p><code>read()</code>方法内部会负责把数据按顺序写进传入的<code>buffer</code>数组内。一个<code>buffer</code>写满后，接着写到下一个<code>buffer</code>中。</p>
<h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p><code>gathering write</code>把多个<code>buffer</code>的数据写入到同一个<code>channel</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">Bytebuffer[] bufferArray = &#123;header,body&#125;;</span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>
<p><code>write()</code>方法内部会负责把数据按顺序写入到channel中。</p>
<blockquote>
<p>无论是<code>scatter</code>还是<code>gather</code>操作，都是按照buffer在数组中的顺序来依次读取或写入的;另外，并不是所有数据都写入到通道，写入的数据要根据<code>position</code>和<code>limit</code>的值来判断，只有<code>position</code>和<code>limit</code>之间的数据才会被写入</p>
</blockquote>
<h1 id="21-Selector"><a href="#21-Selector" class="headerlink" title="21. Selector"></a>21. Selector</h1><p><code>Selector</code>一般称为选择器 ，也可以翻译为多路复用器。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个<code>channel</code>,也就是可以管理多个网络链接。</p>
<p>使用<code>Selector</code>的好处在于： 使用更少的线程就可以来处理通道了，相比使用多个线程，避免了线程上下文切换带来的开销。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用<code>Selector.open()</code>方法创建一个<code>Selector</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h3 id="注册Channel到Selector"><a href="#注册Channel到Selector" class="headerlink" title="注册Channel到Selector"></a>注册Channel到Selector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p><strong>Channel必须是非阻塞的，所以<code>FileChannel</code>不适用于<code>Selector</code></strong>,因为<code>FileChannel</code>不能切换为非阻塞模式，更准确的说是<strong>因为<code>FileChannel</code>没有继承<code>SelectableChannel</code></strong>。<code>SocketChannel</code>可以正常使用。</p>
<p><code>SelectableChannel</code>抽象类有一个<code>configureBlocking()</code>方法用于使通道处于阻塞模式或者非阻塞模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>SelectableChannel</code>抽象类的<code>configureBlocking()</code>方法是由<code>AbstractSelectableChannel</code>抽象类实现的，<code>SocketChannel</code>,<code>ServerSocketChannel</code>,<code>DatagramChannel</code>都是直接继承了<code>AbstractSelectableChannel</code>抽象类。</p>
</blockquote>
<p><code>register()</code>方法的第二个参数是一个<strong>interest集合</strong>，意思是在通过<code>Selector</code>监听<code>Channel</code>时对什么事件感兴趣，可以监听四种不同类型的事件：</p>
<ul>
<li><strong>Connect</strong></li>
<li><strong>Accept</strong></li>
<li><strong>Read</strong></li>
<li><strong>Write</strong></li>
</ul>
<p>通道触发了一个事件意思是该事件已经就绪。比如某个<code>Channel</code>成功连接到另一个服务器称为<strong>连接就绪</strong>。一个<code>Server Socket Channel</code>准备好接收新进入的连接称为<strong>接收就绪</strong>。一个有数据可读的通道可以说是<strong>读就绪</strong>。等待写数据的通道可以说是<strong>写就绪</strong>。</p>
<p>这四种事件用<code>SelectionKey</code>的四个常量来表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey.OP_CONNECT</span><br><span class="line">SelectionKey.OP_ACCEPT</span><br><span class="line">SelectionKey.OP_READ</span><br><span class="line">SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure>
<p>它们在<code>SelectionKey</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出<strong>每个事件可以被当成一个位域</strong>，如果要监听多个事件，可以用或运算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>一个<code>SelectionKey</code>键表示一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key.attachment(); <span class="comment">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span></span><br><span class="line">key.channel(); <span class="comment">// 返回该SelectionKey对应的channel。</span></span><br><span class="line">key.selector(); <span class="comment">// 返回该SelectionKey对应的Selector。</span></span><br><span class="line">key.interestOps(); <span class="comment">//返回代表需要Selector监控的IO操作的bit mask(位掩码)</span></span><br><span class="line">key.readyOps();<span class="comment">// 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span></span><br></pre></td></tr></table></figure>
<p>可以通过以下方法来判断<code>Selector</code>是否对<code>Channel</code>的某种事件感兴趣：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p><strong>key.readyOps()</strong></p>
<p><code>ready</code>集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ready集合的方法</span></span><br><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查这些操作是否就绪的方法</span></span><br><span class="line">key.isAcceptable();<span class="comment">//是否可读，是返回 </span></span><br><span class="line"><span class="function">trueboolean <span class="title">isWritable</span><span class="params">()</span>：<span class="comment">//是否可写，是返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isConnectable</span><span class="params">()</span>：<span class="comment">//是否可连接，是返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span>：<span class="comment">//是否可接收，是返回 true</span></span></span><br></pre></td></tr></table></figure>
<p>从<code>SelectionKey</code>访问<code>Channel</code>和<code>Selector</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = key.channel();</span><br><span class="line">Selctor selector = key.selector();</span><br></pre></td></tr></table></figure>
<p>可以将一个对象或者更多信息附到<code>SelectionKey</code>上，这样就能方便的识别某个给定的通道。例如，可以附加与通道一起使用的<code>Buffe</code>r，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key.attach(theObject);</span><br><span class="line">Object attachedObj = key.attachment();</span><br></pre></td></tr></table></figure>
<p>还可以在用<code>register()</code>方法向<code>Selector</code>注册<code>Channel</code>的时候附加对象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector,SelectionKey.OP_READ,theObject);</span><br></pre></td></tr></table></figure>
<h3 id="从Selector中选择channel"><a href="#从Selector中选择channel" class="headerlink" title="从Selector中选择channel"></a>从<code>Selector</code>中选择<code>channel</code></h3><p>选择器维护注册过的通道的集合，并且这种注册关系都被封装在<code>SelectionKey</code>当中。</p>
<p><code>Selector</code>维护的三种类型的<code>SelectionKey</code>集合：</p>
<ul>
<li>已注册的键的集合：所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过<code>keys()</code>方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发<code>java.lang.UnsupportedOperationException</code>。</li>
<li>已选择的键的集合：已注册的键的集合的子集。这个集合的每个成员都是相关的通道被选择器(在前一个选择操作中)判断为已经准备好的，并且包含于键的<code>interest</code>集合中的操作。这个集合通过<code>selectedKeys()</code>方法返回(并有可能是空的)。不要将已选择的键的集合与<code>ready</code>集合弄混了。这是一个键的集合，每个键都关联一个已经准备好至少一种操作的通道。每个键都有一个内嵌的<code>ready</code>集合，指示了所关联的通道已经准备好的操作。键可以直接从这个集合中移除，但不能添加。试图向已选择的键的集合中添加元素将抛出<code>java.lang.UnsupportedOperationException</code>。</li>
<li>已取消的键的集合：已注册的键的集合的子集，这个集合包含了<code>cancel()</code>方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</li>
</ul>
<blockquote>
<p>当键被取消（可以通过<code>isValid()</code>方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用<code>select()</code>方法时（或者一个正在进行的<code>select()</code>调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。通道会被注销，而新的<code>SelectionKey</code>将被返回。当通道关闭时，所有相关的键会自动取消（一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出<code>CancelledKeyException</code>。</p>
</blockquote>
<p><strong><code>select()</code>方法介绍</strong></p>
<p>在刚初始化的<code>Selector</code>对象中，上面的三个集合都是空的。通过<code>Selector</code>的<code>select()</code>方法可以选择已经准备就绪的通道（这些通道包含感兴趣的事件）。比如对读就绪的通道感兴趣，那么<code>select（）</code>方法就会返回读事件已经就绪的那些通道。</p>
<p><code>Selector</code>重载的几个<code>select()</code>方法：</p>
<ul>
<li><code>int select()</code>:阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li><code>int select(long timeout)</code>：和<code>select()</code>一样，但最长阻塞时间为<code>timeout</code>毫秒。</li>
<li><code>int selectNow()</code>:非阻塞，只要有通道就绪就立刻返回。</li>
</ul>
<p><code>select()</code>方法返回的<code>int</code>值表示有多少通道已经就绪,是自上次调用<code>select()</code>方法后有多少通道变成就绪状态。之前在<code>select（）</code>调用时进入就绪的通道不会在本次调用中被记入，而在前一次<code>select（）</code>调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用<code>select()</code>方法，如果有一个通道变成就绪状态，返回了1，若再次调用<code>select()</code>方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的<code>channel</code>没有做任何操作，现在就有两个就绪的通道，但在每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用<code>select()</code>方法，并且返回值不为0时，则可以通过调用<code>Selector</code>的<code>selectedKeys()</code>方法来访问已选择键集合 。如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys=selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>进而可以拿到和某<code>SelectionKey</code>关联的<code>Selector</code>和<code>Channel</code>。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="停止选择的方法"><a href="#停止选择的方法" class="headerlink" title="停止选择的方法"></a>停止选择的方法</h3><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,有以下三种方式可以唤醒在<code>select（）</code>方法中阻塞的线程。</p>
<ul>
<li><p><code>wakeup()</code>方法 ：通过调用<code>Selector</code>对象的<code>wakeup（）</code>方法让处在阻塞状态的<code>select()</code>方法立刻返回。该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对<code>select()</code>方法的一次调用将立即返回。</p>
</li>
<li><p><code>close()</code>方法 ：通过<code>close（）</code>方法关闭<code>Selector</code>，该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似<code>wakeup（）</code>），同时使得注册到该<code>Selector</code>的所有<code>Channel</code>被注销，所有的键将被取消，但是<code>Channel</code>本身并不会关闭。</p>
</li>
</ul>
<h2 id="模版代码"><a href="#模版代码" class="headerlink" title="模版代码"></a>模版代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8080</span>));</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> readyNum = selector.select();</span><br><span class="line">    <span class="keyword">if</span>(readyNum == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = it.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">//接受连接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">//通道可读</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//通道可写</span></span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用实例：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            <span class="comment">//注册channel，并且指定感兴趣的事件是Accept</span></span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            writeBuffer.put(<span class="string">"received"</span>.getBytes());</span><br><span class="line">            writeBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> nReady = selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">//创建新的连接，并且把连接注册到selector上，而且，声明这个channel只对读操作感兴趣</span></span><br><span class="line">                        SocketChannel socketChannel = ssc.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                        readBuffer.clear();</span><br><span class="line">                        socketChannel.read(readBuffer);</span><br><span class="line"></span><br><span class="line">                        readBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">"received: "</span>+<span class="keyword">new</span> String(readBuffer.array()));</span><br><span class="line">                        key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                        writeBuffer.rewind();</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel)key.channel();</span><br><span class="line">                        socketChannel.write(writeBuffer);</span><br><span class="line">                        key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorWebClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">            ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">            writeBuffer.put(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">            writeBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                writeBuffer.rewind();</span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line">                readBuffer.clear();</span><br><span class="line">                socketChannel.read(readBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="22-文件IO的Path"><a href="#22-文件IO的Path" class="headerlink" title="22.文件IO的Path"></a>22.文件IO的Path</h1><p>Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的基于<code>java.io.File</code>的文件IO操作方式</p>
<h2 id="创建一个Path"><a href="#创建一个Path" class="headerlink" title="创建一个Path"></a>创建一个Path</h2><p>创建一个Path示例可以通过<strong>Paths工具类</strong>的<code>get()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用绝对路径</span></span><br><span class="line">Path path = Paths.get(<span class="string">"c:\\data\\myfile.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用相对路径</span></span><br><span class="line">Path path = Pahts.get(<span class="string">"/home/xiaoming/myfile.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的创建方式等效于下面这种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path path = FileSystems.getDefault().getPath(<span class="string">"c:\\data\\myfile.txt"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="File和Path之间的转换，File和URI之间的转换"><a href="#File和Path之间的转换，File和URI之间的转换" class="headerlink" title="File和Path之间的转换，File和URI之间的转换"></a>File和Path之间的转换，File和URI之间的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:/my.ini"</span>);</span><br><span class="line">Path p = file.toPath();</span><br><span class="line">p.toFile();</span><br><span class="line">file.toURI();</span><br></pre></td></tr></table></figure>
<h2 id="获取Path的相关信息"><a href="#获取Path的相关信息" class="headerlink" title="获取Path的相关信息"></a>获取Path的相关信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Paths工具类的get()方法创建</span></span><br><span class="line">Path path = Paths.get(<span class="string">"D:\\XMind\\bcl-java.txt"</span>);</span><br><span class="line"><span class="comment">//使用FileSystems工具类创建</span></span><br><span class="line">Path path2 = FileSystems.getDefault().getPath(<span class="string">"c:\\data\\myfile.txt"</span>);</span><br><span class="line">System.out.println(<span class="string">"文件名："</span> + path.getFileName());</span><br><span class="line">System.out.println(<span class="string">"名称元素的数量："</span> + path.getNameCount());</span><br><span class="line">System.out.println(<span class="string">"父路径："</span> + path.getParent());</span><br><span class="line">System.out.println(<span class="string">"根路径："</span> + path.getRoot());</span><br><span class="line">System.out.println(<span class="string">"是否是绝对路径："</span> + path.isAbsolute());</span><br><span class="line"><span class="comment">//startsWith()方法的参数既可以是字符串也可以是Path对象</span></span><br><span class="line">System.out.println(<span class="string">"是否是以为给定的路径D:开始："</span> + path.startsWith(<span class="string">"D:\\"</span>) );</span><br><span class="line">System.out.println(<span class="string">"该路径的字符串形式："</span> + path.toString());</span><br></pre></td></tr></table></figure>

<h2 id="移除冗余项"><a href="#移除冗余项" class="headerlink" title="移除冗余项"></a>移除冗余项</h2><p>某些时候需要处理的Path路径中可能会有一个或两个点</p>
<ul>
<li><code>.</code>表示的是当前目录</li>
<li><code>..</code>表示父目录或者说是上一级目录：</li>
</ul>
<p>使用<code>Path</code>类的<code>normalize()</code>和<code>toRealPath()</code>方法可以把<code>.</code>和<code>..</code>去除。</p>
<ul>
<li><code>normalize()</code>: 返回一个路径，该路径是冗余名称元素的消除。</li>
<li><code>toRealPath()</code>: 融合了<code>toAbsolutePath()</code>方法和<code>normalize()</code>方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.表示的是当前目录</span></span><br><span class="line">Path currentDir = Paths.get(<span class="string">"."</span>);</span><br><span class="line">System.out.println(currentDir.toAbsolutePath());    <span class="comment">//输出C:\Users\Administrator\NIODemo\.</span></span><br><span class="line">        </span><br><span class="line">Path currentDir2 = Paths.get(<span class="string">".\\NIODemo.iml"</span>);</span><br><span class="line">System.out.println(<span class="string">"原始路径格式："</span>+currentDir2.toAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">"执行normalize（）方法之后："</span>+currentDir2.toAbsolutePath().normalize());</span><br><span class="line">System.out.println(<span class="string">"执行toRealPath()方法之后："</span>+currentDir2.toRealPath());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//..表示父目录或者说是上一级目录：</span></span><br><span class="line">Path currentDir3 = Paths.get(<span class="string">".."</span>);</span><br><span class="line">System.out.println(<span class="string">"原始路径格式："</span>+currentDir3.toAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">"执行normalize（）方法之后："</span>+currentDir3.toAbsolutePath().normalize());</span><br><span class="line">System.out.println(<span class="string">"执行toRealPath()方法之后："</span>+currentDir3.toRealPath());</span><br></pre></td></tr></table></figure>
输出:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\NIODemo\.</span><br><span class="line">原始路径格式：C:\Users\Administrator\NIODemo\.\NIODemo.iml</span><br><span class="line">执行normalize（）方法之后：C:\Users\Administrator\NIODemo\NIODemo.iml</span><br><span class="line">执行toRealPath()方法之后：C:\Users\Administrator\NIODemo\NIODemo.iml</span><br><span class="line">原始路径格式：C:\Users\Administrator\NIODemo\..</span><br><span class="line">执行normalize（）方法之后：C:\Users\Administrator</span><br><span class="line">执行toRealPath()方法之后：C:\Users\Administrator</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="23-Files类"><a href="#23-Files类" class="headerlink" title="23. Files类"></a>23. Files类</h1><p>Java NIO中的<code>Files</code>类（<code>java.nio.file.Files</code>）提供了多种操作文件系统中文件的方法。</p>
<blockquote>
<p><code>java.nio.file.Files</code>类和<code>java.nio.file.Path</code>相结合使用的</p>
</blockquote>
<h2 id="检查给定的Path在文件系统中是否存在"><a href="#检查给定的Path在文件系统中是否存在" class="headerlink" title="检查给定的Path在文件系统中是否存在"></a>检查给定的Path在文件系统中是否存在</h2><p>通过<code>Files.exists()</code>检测文件路径是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Paht path = Paths.get(<span class="string">"D:\\..."</span>);</span><br><span class="line"><span class="keyword">boolean</span> pathExists = Files.exists(path,<span class="keyword">new</span> LinkOption[]&#123;LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line">System.out.println(pathExists);</span><br></pre></td></tr></table></figure>
<p><code>Files.exists()</code>的第二个参数是一个数组，这个参数直接影响到<code>Files.exists()</code>如何确定一个路径是否存在。在本例中，这个数组内包含了<code>LinkOptions.NOFOLLOW_LINKS</code>，表示检测时不包含符号链接文件。</p>
<h2 id="创建文件-文件夹"><a href="#创建文件-文件夹" class="headerlink" title="创建文件/文件夹"></a>创建文件/文件夹</h2><p>创建文件：通过<code>Files.createFile()</code>创建文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">"C:\\mystuff.txt"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Files.exists(target))</span><br><span class="line">        Files.createFile(target);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建文件夹：有两种方式</p>
<ul>
<li>通过<code>Files.createDirectory()</code>创建</li>
<li>通过<code>Files.createDirectories()</code>创建</li>
</ul>
<p>区别：<code>Files.createDirectories()</code>会首先创建所有不存在的父目录来创建目录，而<code>Files.createDirectory()</code>方法只是创建目录，如果它的上级目录不存在就会报错。</p>
<h2 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h2><p>通过<code>Files.delete()</code>可以删除一个文件或目录</p>
<h2 id="把一个文件从一个地址复制到另一个位置"><a href="#把一个文件从一个地址复制到另一个位置" class="headerlink" title="把一个文件从一个地址复制到另一个位置"></a>把一个文件从一个地址复制到另一个位置</h2><p>通过<code>Files.copy()</code>方法可以吧一个文件从一个地址复制到另一个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath      = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">Path destinationPath = Paths.get(<span class="string">"data/logging-copy.properties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, destinationPath);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileAlreadyExistsException e) &#123;</span><br><span class="line">    <span class="comment">//destination file already exists</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//something else went wrong</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copy</code>操作还可可以强制覆盖已经存在的目标文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(sourcePath,destinationPath,StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<h2 id="获取文件的属性"><a href="#获取文件的属性" class="headerlink" title="获取文件的属性"></a>获取文件的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"D:\\XMind\\bcl-java.txt"</span>);</span><br><span class="line">System.out.println(Files.getLastModifiedTime(path));</span><br><span class="line">System.out.println(Files.size(path));</span><br><span class="line">System.out.println(Files.isSymbolicLink(path));</span><br><span class="line">System.out.println(Files.isDirectory(path));</span><br><span class="line">System.out.println(Files.readAttributes(path,<span class="string">"*"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="遍历一个文件夹"><a href="#遍历一个文件夹" class="headerlink" title="遍历一个文件夹"></a>遍历一个文件夹</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path dir = Paths.get(<span class="string">"D:\\Java"</span>);</span><br><span class="line"><span class="keyword">try</span>(DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir))&#123;</span><br><span class="line">    <span class="keyword">for</span>(Path e : stream)&#123;</span><br><span class="line">        System.out.println(e.getFileName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newDirectoryStream</code>只会遍历单个目录，不会遍历整个目录。遍历整个目录需要使用：<code>Files.walkfileTree()</code>。这个方法具有递归遍历目录的功能。</p>
<p><code>walkFileTree</code>接受一个<code>Path</code>和<code>FileVisitor</code>作为参数。<code>Path</code>对象是需要遍历的目录，<code>FileVistor</code>则会在每次遍历中被调用。</p>
<p><code>FileVisitor</code>需要调用方自行实现，然后作为参数传入<code>walkFileTree()</code>.<code>FileVisitor</code>的每个方法会在遍历过程中被调用多次。如果不需要处理每个方法，那么可以继承它的默认实现类<code>SimpleFileVisitor</code>，它将所有的接口做了空实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFileTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path startingDir = Paths.get(<span class="string">"D:\\apache-tomcat-9.0.0.M17"</span>);</span><br><span class="line">        List&lt;Path&gt; result = <span class="keyword">new</span> LinkedList&lt;Path&gt;();</span><br><span class="line">        Files.walkFileTree(startingDir, <span class="keyword">new</span> FindJavaVisitor(result));</span><br><span class="line">        System.out.println(<span class="string">"result.size()="</span> + result.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FindJavaVisitor</span> <span class="keyword">extends</span> <span class="title">SimpleFileVisitor</span>&lt;<span class="title">Path</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Path&gt; result;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FindJavaVisitor</span><span class="params">(List&lt;Path&gt; result)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.toString().endsWith(<span class="string">".java"</span>))&#123;</span><br><span class="line">                result.add(file.getFileName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-NIO用到哪些新技术"><a href="#24-NIO用到哪些新技术" class="headerlink" title="24. NIO用到哪些新技术"></a>24. NIO用到哪些新技术</h1><p>NIO在基础的IO流上发展处新的特点，分别是：<strong>内存映射技术</strong>，<strong>字符及编码</strong>，<strong>非阻塞I/O</strong>和<strong>文件锁定</strong>。</p>
<h2 id="内存映射技术"><a href="#内存映射技术" class="headerlink" title="内存映射技术"></a>内存映射技术</h2><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件能创建文件和修改那些大到无法读入内存的文件。有了内存映射文件，就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件虽然最终也要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度快了很多。</p>
<p>NIO中内存映射主要用到以下两个类：</p>
<ul>
<li><code>java.nio.MappedByteBuffer</code></li>
<li><code>java.nio.channels.FileChannel</code></li>
</ul>
<p><code>FileChannel</code>主要通过类中的<code>map</code>方法实现内存映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数设置映射模式，支持三种模式：</p>
<ul>
<li><code>FileChannel.MapMode.READ_ONLY</code>：只读缓冲区，在缓冲区中如果发生写操作则会产生<code>ReadOnlyBufferException</code>；</li>
<li><code>FileChannel.MapMode.READ_WRITE</code>：读写缓冲区，任何时刻如果通过内存映射的方式修改了文件则立刻会对磁盘上的文件执行相应的修改操作。别的进程如果也共享了同一个映射，则也会同步看到变化。而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，<strong>没有执行IO输出流的<code>flush()</code>或者<code>close()</code>操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束</strong>；</li>
<li><code>FileChannel.MapMode.PRIVATE</code>：可写缓冲区，但任何修改是缓冲区私有的，不会回到文件中。</li>
</ul>
<p>内存映射一旦有效建立，就会一直保持有效，直到<code>MappedByteBuffer</code>对象被回收，并没有相应的办法提前卸载掉映射内存。此外，<strong>映射缓冲区不会绑定到创建它们的通道，关闭相关的<code>FileChannel</code>不会破坏映射，只有缓冲对象本身的处理打破了映射</strong>。</p>
<p><strong>内存映射文件的优点</strong>：</p>
<ul>
<li>用户进程将文件数据视为内存，因此不需要发出<code>read()</code>或<code>write()</code>系统调用。</li>
<li>当用户进程触摸映射的内存空间时，将自动生成页面错误，以从磁盘引入文件数据。 如果用户修改映射的内存空间，受影响的页面将自动标记为脏，并随后刷新到磁盘以更新文件。</li>
<li>操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存。</li>
<li>数据始终是页面对齐的，不需要缓冲区复制。</li>
<li>可以映射非常大的文件，而不消耗大量内存来复制数据。</li>
</ul>
<h2 id="字符及编码"><a href="#字符及编码" class="headerlink" title="字符及编码"></a>字符及编码</h2><p>编码就是把字符转换为字节，而解码就是把字节重新转化为字符。</p>
<p>字符编码方案定义了如何把字符编码的序列表达为字节序列。字符编码的数值不需要与编码字节相同，也不需要是一对一或一对多个的关系。原则上，把字符集编码和解码近似视为对象的序列化和反序列化。</p>
<p>常字符数据编码是用于网络传输或文件存储。编码方案不是字符集，它是映射；但是因为它们之间的紧密联系，大部分编码都与一个独立的字符集相关联。例如，<code>UTF-8</code>，仅用来编码<code>Unicode</code>字符集。尽管如此，用一个编码方案处理多个字符集还是可能发生的。例如，EUC可以对几个亚洲语言的字符进行编码。</p>
<p>目前字符编码方案有<code>US-ASCII</code>,<code>UTF-8</code>,<code>GB2312</code>, <code>BIG5</code>,<code>GBK</code>,<code>GB18030</code>,<code>UTF-16BE</code>, <code>UTF-16LE</code>, <code>UTF-16</code>,<code>UNICODE</code>。其中<code>Unicode</code>试图把全世界所有语言的字符集统一到全面的映射之中。大部分的操作系统在I/O与文件存储方面仍是以字节为导向的，所以无论使用何种编码，<code>Unicode</code>或其他编码，在字节序列和字符集编码之间仍需要进行转化。</p>
<ul>
<li>GBK编码中，中文字符占2个字节，英文字符占1个字节</li>
<li>UTF-8编码中，中文字符占3个字节，英文字符占1个字节</li>
<li>UTF-16BE编码中，中文字符和英文字符都占2个字节</li>
</ul>
<p><code>UTF-16be</code>中的<code>be</code>指的是<code>Big Endian</code>，也就是大端。相应地也有<code>UTF-16le</code>,<code>le</code>指的是<code>Little Endian</code>，也就是小端。</p>
<p>Java的内存编码使用双字节编码<code>UTF-16be</code>，这不是指Java只支持这一种编码方式，而是说<code>char</code>这种类型使用<code>UTF-16be</code>进行编码。<code>char</code>类型占<code>16</code>位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个<code>char</code>来存储。</p>
<p><strong>String编码方式</strong>：</p>
<p><code>String</code>可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为<code>String</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<p>在调用无参数<code>getBytes()</code>方法时，默认的编码方式不是 <code>UTF-16be</code>。双字节编码的好处是可以使用一个<code>char</code>存储中文和英文，而将<code>String</code>转为<code>bytes[]</code>字节数组就不再需要这个好处，因此也就不再需要双字节编码。<code>getBytes()</code>的默认编码方式与平台有关，一般为<code>UTF-8</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure>

<p><code>java.nio.charset</code>包组成的类就是用于字符编码。</p>
<p>字符的编码和解码是使用很频繁的，如果使用<code>UTF-8</code>字符集进行编码，但是却是用<code>UTF-16</code>字符集进行解码，那么这条信息对于用户来说其实是无用的。因为没人能看得懂。在NIO中提供了两个类<code>CharsetEncoder</code>和<code>CharsetDecoder</code>来实现编码转换方案。</p>
<p><code>CharsetEncoder</code>类是一个状态编码引擎。实际上，编码器有状态意味着它们不是线程安全的：<strong><code>CharsetEncoder</code>对象不应该在线程中共享</strong>。<code>CharsetEncoder</code>对象是一个状态转换引擎：字符进去，字节出来。一些编码器的调用可能需要完成转换。编码器存储在调用之间转换的状态。</p>
<p>字符集解码器是编码器的逆转。通过特殊的编码方案把字节编码转化成16-位<code>Unicode</code>字符的序列。与<code>CharsetEncoder</code>类似的, <code>CharsetDecoder</code>也是状态转换引擎。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>一般来说IO模型分为：同步同步阻塞，同步非阻塞，异步阻塞，异步非阻塞四种IO模型。</p>
<p>NIO中用到了同步非阻塞IO模型，同时还用到了多路复用IO模型。</p>
<p>NIO的非阻塞 I/O 机制是围绕选择器和通道构建的。<code>Channel</code>类表示服务器和客户机之间的一种通信机制。<code>Selector</code>类是<code>Channel</code>的多路复用器。<code>Selector</code>类将传入客户机请求多路分用并将它们分派到各自的请求处理程序。</p>
<p>利用多路复用机制避免了线程的阻塞，提高了连接的数量。一个线程就可以管理多个<code>socket</code>，只有当<code>socket</code>真正有读写事件发生才会占用资源来进行实际的读写操作。虽然多线程+阻塞IO达到类似的效果，但是由于在多线程+阻塞IO中，每个<code>socket</code>对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p>
<p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问<code>socket</code>状态时通过用户线程去进行的，而在多路复用IO中，轮询每个<code>socket</code>状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<h2 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h2><p>NIO中的文件通道（<code>FileChannel</code>）在读写数据的时候主要使用了阻塞模式，它不能支持非阻塞模式的读写，而且<code>FileChannel</code>的对象是不能够直接实例化的,它的实例只能通过<code>getChannel()</code>从一个打开的文件对象上边读取（<code>RandomAccessFile</code>、<code>FileInputStream</code>、<code>FileOutputStream</code>），并且通过调用<code>getChannel()</code>方法返回一个<code>Channel</code>对象去连接同一个文件，也就是针对同一个文件进行读写操作。</p>
<p>文件锁的出现解决了很多Java应用程序和非Java程序之间共享文件数据的问题，在以前的JDK版本中，没有文件锁机制使得Java应用程序和其他非Java进程程序之间不能够针对同一个文件共享数据，有可能造成很多问题，JDK1.4里面有了<code>FileChannel</code>，它的锁机制使得文件能够针对很多非Java应用程序以及其他Java应用程序可见。但是Java里面的文件锁机制主要是基于共享锁模型，在不支持共享锁模型的操作系统上，文件锁本身也起不了作用，JDK1.4使用文件通道读写方式可以向一些文件发送锁请求,<code>FileChannel</code>的锁模型主要针对的是每一个文件，并不是每一个线程和每一个读写通道，也就是以文件为中心进行共享以及独占，也就是文件锁本身并不适合于同一个JVM的不同线程之间。</p>
<p><code>FileChannel</code>关于文件锁的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryLock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@position</span> 要锁定区域的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@size</span> 要锁定区域的尺寸</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@shared</span> true为共享锁，false为独占锁</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>锁定区域的范围不一定要限制在文件的<code>size</code>值以内，锁可以扩展从而超出文件尾。因此，可以提前把待写入数据的区域锁定，也可以锁定一个不包含任何文件内容的区域，比如文件最后一个字节以外的区域。如果之后文件增长到达那块区域，那么文件锁就可以保护该区域的文件内容了。相反地，如果锁定了文件的某一块区域，然后文件增长超出了那块区域，那么新增加的文件内容将不会受到文件锁的保护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c://1.txt"</span>, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="comment">// 写入4个字节</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"abcd"</span>.getBytes()));</span><br><span class="line">        <span class="comment">// 将前2个字节区域锁定（共享锁）</span></span><br><span class="line">        FileLock lock1 = fileChannel.lock(<span class="number">0</span>, <span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 当前锁持有锁的类型（共享锁/独占锁）</span></span><br><span class="line">        lock1.isShared();</span><br><span class="line">        <span class="comment">// IOException 不能修改只读的共享区域</span></span><br><span class="line">        <span class="comment">// fileChannel.write(ByteBuffer.wrap("a".getBytes()));</span></span><br><span class="line">        <span class="comment">// 可以修改共享锁之外的区域，从第三个字节开始写入</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"ef"</span>.getBytes()), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OverlappingFileLockException 重叠的文件锁异常</span></span><br><span class="line">        <span class="comment">// FileLock lock2 = fileChannel.lock(0, 3, true);</span></span><br><span class="line">        <span class="comment">// FileLock lock3 = fileChannel.lock(0, 3, false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到创建锁的通道</span></span><br><span class="line">        lock1.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的起始位置</span></span><br><span class="line">        <span class="keyword">long</span> position = lock1.position();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的范围</span></span><br><span class="line">        <span class="keyword">long</span> size = lock1.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断锁是否与指定文件区域有重叠</span></span><br><span class="line">        lock1.overlaps(position, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得用try/catch/finally&#123;release()&#125;方法释放锁</span></span><br><span class="line">        lock1.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-Java-NIO-AsynchronousFileChannel异步文件通道"><a href="#25-Java-NIO-AsynchronousFileChannel异步文件通道" class="headerlink" title="25. Java NIO AsynchronousFileChannel异步文件通道"></a>25. Java NIO AsynchronousFileChannel异步文件通道</h1><p>Java7中新增了<code>AsynchronousFileChannel</code>作为nio的一部分。<code>AsynchronousFileChannel</code>使得数据可以进行异步读写。</p>
<h2 id="创建AsynchronousFileChannel"><a href="#创建AsynchronousFileChannel" class="headerlink" title="创建AsynchronousFileChannel"></a>创建AsynchronousFileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test.xml"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path,StandardOpenOption.READ);</span><br></pre></td></tr></table></figure>
<p><code>open()</code>的第一个参数是一个Path实体，指向需要操作的文件。第二个参数是操作类型。上述示例用的是<code>StandardOpenOption.READ</code>表示以读的形式操作文件。</p>
<h2 id="读取数据（Reading-Data）"><a href="#读取数据（Reading-Data）" class="headerlink" title="读取数据（Reading Data）"></a>读取数据（Reading Data）</h2><p>读取<code>AsynchronousFileChannel</code>的数据有两种方式。每种方法都会调用<code>AsynchronousFileChannel</code>的一个<code>read()</code>接口。</p>
<h3 id="通过Future读取数据"><a href="#通过Future读取数据" class="headerlink" title="通过Future读取数据"></a>通过Future读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式中，<code>read()</code>接受一个<code>ByteBuffer</code>作为第一个参数，数据会被读取到<code>ByteBuffer</code>中。第二个参数是开始读取数据的位置。</p>
<p><code>read()</code>方法会立刻返回，即使读操作没有完成。我们可以通过<code>isDone()</code>方法检查操作是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(data);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure>

<h3 id="CompletionHandler读取数据"><a href="#CompletionHandler读取数据" class="headerlink" title="CompletionHandler读取数据"></a>CompletionHandler读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line"></span><br><span class="line">        attachment.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[attachment.limit()];</span><br><span class="line">        attachment.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，一旦读取完成，将会触发<code>CompletionHandler</code>的<code>completed()</code>方法，并传入一个<code>Integer</code>和<code>ByteBuffer</code>。前面的整形表示的是读取到的字节数大小。第二个<code>ByteBuffer</code>也可以换成其他合适的对象方便数据写入。如果读取操作失败了，那么会触发<code>failed()</code>方法。</p>
<h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p>和读数据一样，写数据也有两种不同方式，调用不同的<code>write()</code>方法</p>
<h3 id="通过Future写数据"><a href="#通过Future写数据" class="headerlink" title="通过Future写数据"></a>通过Future写数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);</span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Write done"</span>);</span><br></pre></td></tr></table></figure>
<p>首先把文件已写方式打开，接着创建一个<code>ByteBuffer</code>作为写入数据的目的地。再把数据进<code>ByteBuffer</code>。最后检查一下是否写入完成。需要注意的是，这里的文件必须是已经存在的，否者在尝试<code>write</code>数据是会抛出一个<code>java.nio.file.NoSuchFileException</code>。<br>可以通过以下方法检查文件是否存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过CompletionHandler写数据"><a href="#通过CompletionHandler写数据" class="headerlink" title="通过CompletionHandler写数据"></a>通过CompletionHandler写数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line">AsynchronousfileChannel fileChannel = AsynchronousFileChannel.open(path,StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">fileChannel.write(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes written: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Write failed"</span>);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="26-Java-I-O用到了什么设计模式"><a href="#26-Java-I-O用到了什么设计模式" class="headerlink" title="26 Java I/O用到了什么设计模式"></a>26 Java I/O用到了什么设计模式</h1><p>Java I/O使用了装饰者设计模式。以<code>InputStream</code>为例：</p>
<ul>
<li><code>InputStream</code>是抽象组件</li>
<li><code>FileInputStream</code>是<code>InputStream</code>的子类，属于具体组件，提供了字节流的输入操作</li>
<li><code>FilterInputStream</code>属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如<code>BufferedInputStream</code>为<code>FileInputStream</code>提供了缓存功能。</li>
</ul>
<p>实例化一个具有缓存功能的字节流对象时，只需要在<code>FileInputStream</code>对象上再套一层<code>BufferedInputStream</code>对象即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>
<h1 id="27-对象序列化"><a href="#27-对象序列化" class="headerlink" title="27. 对象序列化"></a>27. 对象序列化</h1><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：<code>ObjectOutputStream.writeObject()</code></li>
<li>反序列化：<code>ObjectInputStream.readObject()</code></li>
</ul>
<p><strong>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态</strong></p>
<p>序列化的类需要实现<code>Serializable</code>接口，它只是一个标准，没有任何方法需要实现，但必须标记上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>transient</code>关键字可以使一些属性不会被序列化。</p>
<p><code>ArrayList</code>中存储数据的数组<code>elementData</code>是用<code>transient</code>修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<h1 id="28-网络操作"><a href="#28-网络操作" class="headerlink" title="28. 网络操作"></a>28. 网络操作</h1><p>Java中支持的网络操作：</p>
<ul>
<li><code>InetAddress</code>：用于表示网络上的硬件资源，即IP地址</li>
<li><code>URL</code>：统一资源定位符</li>
<li><code>Sockets</code>：使用TCP协议实现网络通信</li>
<li><code>Datagram</code>：使用UDP协议实现网络通信</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></figure>

<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从URL中读取字节流数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul>
<li><code>ServerSocket</code>：服务器端类</li>
<li><code>Socket</code>：客户端类</li>
<li>服务器和客户端通过<code>InputStream</code>和<code>OutputStream</code>进行输入输出。</li>
</ul>
<h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul>
<li><code>DatagramSocket</code>：通信类</li>
<li><code>DatagramPacket</code>：数据包类</li>
</ul>
<p><strong>参考内容</strong></p>
<blockquote>
<p>主要参考以来两篇博客以及相关博客推荐，因找的博客比较多，没注意记录，最后好多忘了在哪2333，如果有侵权，请及时联系我，非常抱歉。<br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a><br><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a>  </p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/19/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="prev" title="Java虚拟机">
      <i class="fa fa-chevron-left"></i> Java虚拟机
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-同步和异步的概念是什么"><span class="nav-number">1.</span> <span class="nav-text">1. 同步和异步的概念是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-阻塞和非阻塞的概念是什么"><span class="nav-number">2.</span> <span class="nav-text">2. 阻塞和非阻塞的概念是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-BIO，NIO，AIO区别"><span class="nav-number">3.</span> <span class="nav-text">3. BIO，NIO，AIO区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BIO（Blocking-I-O）"><span class="nav-number">3.1.</span> <span class="nav-text">BIO（Blocking I/O）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统BIO"><span class="nav-number">3.1.1.</span> <span class="nav-text">传统BIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪异步IO"><span class="nav-number">3.1.2.</span> <span class="nav-text">伪异步IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码示例"><span class="nav-number">3.1.3.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO"><span class="nav-number">3.2.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO的特性-与IO的区别"><span class="nav-number">3.2.1.</span> <span class="nav-text">NIO的特性/与IO的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Non-Blocking-IO（非阻塞IO）"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Non-Blocking IO（非阻塞IO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer（缓冲区）"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Buffer（缓冲区）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel-通道"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">Channel(通道)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector-选择器"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">Selector(选择器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO读数据和写数据的方式"><span class="nav-number">3.2.2.</span> <span class="nav-text">NIO读数据和写数据的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO核心组件"><span class="nav-number">3.2.3.</span> <span class="nav-text">NIO核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码示例-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIO（Asynchronous-I-O）"><span class="nav-number">3.3.</span> <span class="nav-text">AIO（Asynchronous I/O）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Java-IO类型"><span class="nav-number">4.</span> <span class="nav-text">4. Java IO类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#按操作方式（类结构）"><span class="nav-number">4.1.</span> <span class="nav-text">按操作方式（类结构）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类说明"><span class="nav-number">4.1.1.</span> <span class="nav-text">分类说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入字节流InputStream"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">输入字节流InputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出字节流OutputStream"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">输出字节流OutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符输入流Reader"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">字符输入流Reader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符输出流Writer"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">字符输出流Writer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按操作对象"><span class="nav-number">4.2.</span> <span class="nav-text">按操作对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对文件进行操作（节点流）"><span class="nav-number">4.2.1.</span> <span class="nav-text">对文件进行操作（节点流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对管道进行操作（节点流）"><span class="nav-number">4.2.2.</span> <span class="nav-text">对管道进行操作（节点流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节-字符数组流（节点流）："><span class="nav-number">4.2.3.</span> <span class="nav-text">字节/字符数组流（节点流）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffered缓冲流（处理流）"><span class="nav-number">4.2.4.</span> <span class="nav-text">Buffered缓冲流（处理流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转化流（处理流）："><span class="nav-number">4.2.5.</span> <span class="nav-text">转化流（处理流）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型数据流（处理流）"><span class="nav-number">4.2.6.</span> <span class="nav-text">基本类型数据流（处理流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印流（处理流）："><span class="nav-number">4.2.7.</span> <span class="nav-text">打印流（处理流）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象流（处理流）："><span class="nav-number">4.2.8.</span> <span class="nav-text">对象流（处理流）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并流（处理流）："><span class="nav-number">4.2.9.</span> <span class="nav-text">合并流（处理流）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他类：File（已经被Java7的Path取代）"><span class="nav-number">4.2.10.</span> <span class="nav-text">其他类：File（已经被Java7的Path取代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他类：RandomAccessFile"><span class="nav-number">4.2.11.</span> <span class="nav-text">其他类：RandomAccessFile</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-什么是IO流"><span class="nav-number">5.</span> <span class="nav-text">5. 什么是IO流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-字节流和字符流的区别"><span class="nav-number">6.</span> <span class="nav-text">6. 字节流和字符流的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Java中流类的超类主要有哪些？"><span class="nav-number">7.</span> <span class="nav-text">7. Java中流类的超类主要有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-FileInputStream和FileOutputStream是什么？"><span class="nav-number">8.</span> <span class="nav-text">8. FileInputStream和FileOutputStream是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-字节流和字符流，更倾向于用哪个"><span class="nav-number">9.</span> <span class="nav-text">9. 字节流和字符流，更倾向于用哪个</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-System-out-println-是什么？"><span class="nav-number">10.</span> <span class="nav-text">10. System.out.println()是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-什么是Filter流"><span class="nav-number">11.</span> <span class="nav-text">11. 什么是Filter流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-有哪些可用的Filter流"><span class="nav-number">12.</span> <span class="nav-text">12. 有哪些可用的Filter流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-SequenceInputStream的作用"><span class="nav-number">13.</span> <span class="nav-text">13. SequenceInputStream的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-说说PrintStream和PrintWriter"><span class="nav-number">14.</span> <span class="nav-text">14. 说说PrintStream和PrintWriter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-在文件拷贝的时候，哪一种流可用于提升更多的性能？"><span class="nav-number">15.</span> <span class="nav-text">15. 在文件拷贝的时候，哪一种流可用于提升更多的性能？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-说说管道流（Piped-Stream）"><span class="nav-number">16.</span> <span class="nav-text">16. 说说管道流（Piped Stream）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-说说File类"><span class="nav-number">17.</span> <span class="nav-text">17. 说说File类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-说说RandomAccessFile"><span class="nav-number">18.</span> <span class="nav-text">18. 说说RandomAccessFile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Buffer（缓冲区）介绍"><span class="nav-number">19.</span> <span class="nav-text">19. Buffer（缓冲区）介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer的使用方式"><span class="nav-number">19.1.</span> <span class="nav-text">Buffer的使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分配缓冲区"><span class="nav-number">19.1.1.</span> <span class="nav-text">分配缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入数据到缓冲区"><span class="nav-number">19.1.2.</span> <span class="nav-text">写入数据到缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#翻转"><span class="nav-number">19.1.3.</span> <span class="nav-text">翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从Buffer读取数据"><span class="nav-number">19.1.4.</span> <span class="nav-text">从Buffer读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rewind"><span class="nav-number">19.1.5.</span> <span class="nav-text">rewind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear-和-compact"><span class="nav-number">19.2.</span> <span class="nav-text">clear() 和 compact()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mark-与reset-方法"><span class="nav-number">19.3.</span> <span class="nav-text">mark()与reset()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals-and-compareTo"><span class="nav-number">19.4.</span> <span class="nav-text">equals() and compareTo()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-Channel"><span class="nav-number">20.</span> <span class="nav-text">20. Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通道和流的区别？"><span class="nav-number">20.1.</span> <span class="nav-text">通道和流的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO中最重要的几个Channel的实现"><span class="nav-number">20.2.</span> <span class="nav-text">Java NIO中最重要的几个Channel的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FileChannel的使用"><span class="nav-number">20.3.</span> <span class="nav-text">FileChannel的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开启FileChannel"><span class="nav-number">20.3.1.</span> <span class="nav-text">开启FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从FileChannel读取数据-写入数据"><span class="nav-number">20.3.2.</span> <span class="nav-text">从FileChannel读取数据/写入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭FileChannel"><span class="nav-number">20.3.3.</span> <span class="nav-text">关闭FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">20.3.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道之间数据传输"><span class="nav-number">20.3.5.</span> <span class="nav-text">通道之间数据传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SocketChannel和ServerSocketChannel的使用"><span class="nav-number">20.4.</span> <span class="nav-text">SocketChannel和ServerSocketChannel的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DatagramChannel的使用"><span class="nav-number">20.5.</span> <span class="nav-text">DatagramChannel的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取DatagramChannel"><span class="nav-number">20.5.1.</span> <span class="nav-text">获取DatagramChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收-发送消息"><span class="nav-number">20.5.2.</span> <span class="nav-text">接收/发送消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scatter-Gather"><span class="nav-number">20.6.</span> <span class="nav-text">Scatter/Gather</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scattering-Reads"><span class="nav-number">20.6.1.</span> <span class="nav-text">Scattering Reads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gathering-Writes"><span class="nav-number">20.6.2.</span> <span class="nav-text">Gathering Writes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Selector"><span class="nav-number">21.</span> <span class="nav-text">21. Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用方式"><span class="nav-number">21.1.</span> <span class="nav-text">使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector的创建"><span class="nav-number">21.1.1.</span> <span class="nav-text">Selector的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册Channel到Selector"><span class="nav-number">21.1.2.</span> <span class="nav-text">注册Channel到Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SelectionKey"><span class="nav-number">21.1.3.</span> <span class="nav-text">SelectionKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从Selector中选择channel"><span class="nav-number">21.1.4.</span> <span class="nav-text">从Selector中选择channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#停止选择的方法"><span class="nav-number">21.1.5.</span> <span class="nav-text">停止选择的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版代码"><span class="nav-number">21.2.</span> <span class="nav-text">模版代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-文件IO的Path"><span class="nav-number">22.</span> <span class="nav-text">22.文件IO的Path</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个Path"><span class="nav-number">22.1.</span> <span class="nav-text">创建一个Path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File和Path之间的转换，File和URI之间的转换"><span class="nav-number">22.2.</span> <span class="nav-text">File和Path之间的转换，File和URI之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Path的相关信息"><span class="nav-number">22.3.</span> <span class="nav-text">获取Path的相关信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移除冗余项"><span class="nav-number">22.4.</span> <span class="nav-text">移除冗余项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Files类"><span class="nav-number">23.</span> <span class="nav-text">23. Files类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#检查给定的Path在文件系统中是否存在"><span class="nav-number">23.1.</span> <span class="nav-text">检查给定的Path在文件系统中是否存在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件-文件夹"><span class="nav-number">23.2.</span> <span class="nav-text">创建文件/文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文件或目录"><span class="nav-number">23.3.</span> <span class="nav-text">删除文件或目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把一个文件从一个地址复制到另一个位置"><span class="nav-number">23.4.</span> <span class="nav-text">把一个文件从一个地址复制到另一个位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取文件的属性"><span class="nav-number">23.5.</span> <span class="nav-text">获取文件的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历一个文件夹"><span class="nav-number">23.6.</span> <span class="nav-text">遍历一个文件夹</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-NIO用到哪些新技术"><span class="nav-number">24.</span> <span class="nav-text">24. NIO用到哪些新技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存映射技术"><span class="nav-number">24.1.</span> <span class="nav-text">内存映射技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符及编码"><span class="nav-number">24.2.</span> <span class="nav-text">字符及编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞IO"><span class="nav-number">24.3.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件锁定"><span class="nav-number">24.4.</span> <span class="nav-text">文件锁定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-Java-NIO-AsynchronousFileChannel异步文件通道"><span class="nav-number">25.</span> <span class="nav-text">25. Java NIO AsynchronousFileChannel异步文件通道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建AsynchronousFileChannel"><span class="nav-number">25.1.</span> <span class="nav-text">创建AsynchronousFileChannel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取数据（Reading-Data）"><span class="nav-number">25.2.</span> <span class="nav-text">读取数据（Reading Data）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Future读取数据"><span class="nav-number">25.2.1.</span> <span class="nav-text">通过Future读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletionHandler读取数据"><span class="nav-number">25.2.2.</span> <span class="nav-text">CompletionHandler读取数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写数据"><span class="nav-number">25.3.</span> <span class="nav-text">写数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Future写数据"><span class="nav-number">25.3.1.</span> <span class="nav-text">通过Future写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过CompletionHandler写数据"><span class="nav-number">25.3.2.</span> <span class="nav-text">通过CompletionHandler写数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Java-I-O用到了什么设计模式"><span class="nav-number">26.</span> <span class="nav-text">26 Java I/O用到了什么设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-对象序列化"><span class="nav-number">27.</span> <span class="nav-text">27. 对象序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-网络操作"><span class="nav-number">28.</span> <span class="nav-text">28. 网络操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InetAddress"><span class="nav-number">28.1.</span> <span class="nav-text">InetAddress</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URL"><span class="nav-number">28.2.</span> <span class="nav-text">URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sockets"><span class="nav-number">28.3.</span> <span class="nav-text">Sockets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Datagram"><span class="nav-number">28.4.</span> <span class="nav-text">Datagram</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
