<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="MySQL基本命令MySQL 数据库的一个实例可以同时包含多个数据库（每条命令结束后加分号），不区分大小写  查看当前实例下包含多少个数据库： show databases； show CREATE DATABASE 数据库名；#查看创建库的信息  用户需要创建新的数据库： create database [IF NOT EXISTS]数据库名； create database 数据库名 char">
<meta name="keywords" content="mysql">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2018&#x2F;04&#x2F;20&#x2F;MySQL&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="MySQL基本命令MySQL 数据库的一个实例可以同时包含多个数据库（每条命令结束后加分号），不区分大小写  查看当前实例下包含多少个数据库： show databases； show CREATE DATABASE 数据库名；#查看创建库的信息  用户需要创建新的数据库： create database [IF NOT EXISTS]数据库名； create database 数据库名 char">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-05-14T14:34:56.537Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2018/04/20/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>MySQL | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-20T00:00:00+08:00">2018-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 22:34:56" itemprop="dateModified" datetime="2021-05-14T22:34:56+08:00">2021-05-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL基本命令"><a href="#MySQL基本命令" class="headerlink" title="MySQL基本命令"></a>MySQL基本命令</h1><p>MySQL 数据库的一个实例可以同时包含多个数据库（每条命令结束后加分号），不区分大小写</p>
<ol>
<li><p>查看当前实例下包含多少个数据库：</p>
<pre><code class="sql">show databases；
show CREATE DATABASE 数据库名；#查看创建库的信息</code></pre>
</li>
<li><p>用户需要创建新的数据库：</p>
<pre><code>create database [IF NOT EXISTS]数据库名；
create database 数据库名 character set GBK/UTF-8/...;#指定编码
show variables like &#39;character%&#39;;#查看编码</code></pre></li>
<li><p>删除指定数据库：</p>
<pre><code>drop database 数据库名；</code></pre><a id="more"></a>
</li>
<li><p>进入数据库：</p>
<pre><code>use 数据库名；
select database();#查看当前选择的数据库</code></pre></li>
<li><p>进入数据库后，查询该数据库下包含多少个数据表：</p>
<pre><code>show tables;</code></pre></li>
<li><p>查看指定数据表的表结构（查看该表有多少列，每列的数据类型等信息）：</p>
<pre><code>desc 表名；</code></pre></li>
<li><p>MySQL语句注释：使用“#”或者“–”，多行注释使用“/* */”</p>
</li>
</ol>
<h1 id="MySQL数据库存储机制"><a href="#MySQL数据库存储机制" class="headerlink" title="MySQL数据库存储机制"></a>MySQL数据库存储机制</h1><ol>
<li>MySAM：对事务支持不够好</li>
<li>InnoDB：系统默认机制</li>
</ol>
<pre><code>ENGING=MyISAM——强制使用第一种机制
ENGING=InnoDB——强制使用第二种机制</code></pre><h1 id="SQL语句基础"><a href="#SQL语句基础" class="headerlink" title="SQL语句基础"></a>SQL语句基础</h1><p>SQL 结构化查询语句 </p>
<h2 id="DDL语句：操作数据库对象的语句"><a href="#DDL语句：操作数据库对象的语句" class="headerlink" title="DDL语句：操作数据库对象的语句"></a>DDL语句：操作数据库对象的语句</h2><ul>
<li>包括创建（create）、删除（drop）、修改（alter）数据库对象</li>
<li>最基本的数据库对象是数据表，数据表是存储数据的逻辑单元</li>
<li>常见的数据库对象</li>
</ul>
<table>
<thead>
<tr>
<th align="left">对象名称</th>
<th align="left">对应关键字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">表</td>
<td align="left">table</td>
<td align="left">表以行和列的形式存在：列就是字段，行就是记录</td>
</tr>
<tr>
<td align="left">数据字典</td>
<td align="left"></td>
<td align="left">就是系统表，存放数据库相关信息的表</td>
</tr>
<tr>
<td align="left">约束</td>
<td align="left">constraint</td>
<td align="left">执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td align="left">视图</td>
<td align="left">view</td>
<td align="left">一个或者多个数据表数据的逻辑显示。视图并不存储数据</td>
</tr>
<tr>
<td align="left">索引</td>
<td align="left">index</td>
<td align="left">用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td align="left">函数</td>
<td align="left">function</td>
<td align="left">用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td align="left">存储过程</td>
<td align="left">procedure</td>
<td align="left">用于完成一次完整的业务处理，没有返回值，但可以通过传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td align="left">触发器</td>
<td align="left">trigger</td>
<td align="left">相当于一个事件监听器，当数据库发生特定事件后，触发器触发，完成相应的处理</td>
</tr>
</tbody></table>
<h3 id="创建表的语法"><a href="#创建表的语法" class="headerlink" title="创建表的语法"></a>创建表的语法</h3><ul>
<li>只需指定该表包含多少列，每列的数据类型信息，无需指定多少行，因为数据库的行是动态的，每条用于保存一条用户数据</li>
<li>语法：</li>
</ul>
<pre><code>create table [模式名.]表名
(
  #可以有多个列定义
  columnName datatype [default expr]，
  ...
)</code></pre><ul>
<li>每个列定义之间以英文逗号隔开，<code>最后一个不用</code></li>
<li><code>列定义由列名、列类型和可选默认值组成</code></li>
<li>指定默认值用“default 值”</li>
<li><code>这种建表语句只是创建一个空表，表里没有任何数据</code></li>
<li>MySQL支持的列类型</li>
</ul>
<table>
<thead>
<tr>
<th>列类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint/smallint/mediumint/int(integer)/bigint</td>
<td>1字节/2字节/3字节/4字节/8字节整数，又可分为有无符号两种。这些整数类型区别仅仅是表数范围不同</td>
</tr>
<tr>
<td>float/double</td>
<td>单精度、双精度浮点数</td>
</tr>
<tr>
<td>decimal(dec)</td>
<td>精确小数类型，相当于float double不会产生精度丢失问题,decimal(M,D),指定数M位，其中小数点后D位</td>
</tr>
<tr>
<td>data</td>
<td>日期类型，不能保存时间</td>
</tr>
<tr>
<td>time</td>
<td>时间类型，不能保存日期</td>
</tr>
<tr>
<td>datatime</td>
<td>日期、时间类型</td>
</tr>
<tr>
<td>timestamp</td>
<td>时间戳类型</td>
</tr>
<tr>
<td>year</td>
<td>年类型，仅仅保存时间的年份</td>
</tr>
<tr>
<td>char</td>
<td>定长字符串类型</td>
</tr>
<tr>
<td>varchar</td>
<td>可变长度字符串类型</td>
</tr>
<tr>
<td>binary</td>
<td>定长二进制字符串类型，它以二进制形式保存字符串</td>
</tr>
<tr>
<td>varbinary</td>
<td>可变长度的二进制字符串类型，以二进制形式</td>
</tr>
<tr>
<td>tinyblob/blob/mediumblob/longblob</td>
<td>1字节/2字节/3字节/4字节的二进制大对象，用于存储图片、音乐等二进制数据，分别可存储：255B/64KB/16MB/4GB的大小，区分大小写</td>
</tr>
<tr>
<td>tinytext/text/mediumtext/longtext</td>
<td>1字节/2字节/3字节/4字节文本对象，可用于存储超长长度的字符串，分别可存储255B/64KB/16MB/4GB，不区分大小写</td>
</tr>
<tr>
<td>enmu(‘value1’,’value2’,…)</td>
<td>枚举类型，该列的值只能是enum中多个值的其中一个</td>
</tr>
<tr>
<td>set(‘value1’,’value2’,…)</td>
<td>集合类型，该列的值可以是set后括号中的其中几个</td>
</tr>
<tr>
<td>- 使用子查询建表语句，则可以在建表的同时插入数据</td>
<td></td>
</tr>
</tbody></table>
<pre><code>create table [模式名.]表名 [colum[,colum...]]
as subquery;</code></pre><p>新表中的字段列表必须与子查询中字段列表数量匹配，创建新表时的字段列表可以省略（表示新表的列名与选择结果完全相同）</p>
<h3 id="查看表结构的语法"><a href="#查看表结构的语法" class="headerlink" title="查看表结构的语法"></a>查看表结构的语法</h3><blockquote>
<p><code>describe(desc简写)</code> 表名：显示出一个表</p>
</blockquote>
<blockquote>
<p><code>show create table</code> 表名：显示更详细，包括代码</p>
</blockquote>
<h3 id="修改表结构的语法"><a href="#修改表结构的语法" class="headerlink" title="修改表结构的语法"></a>修改表结构的语法</h3><ul>
<li>修改表结构使用<code>alter table</code>，包括增加列定义、修改列定义、删除列、重命名列等操作<h4 id="增加列定义"><a href="#增加列定义" class="headerlink" title="增加列定义"></a>增加列定义</h4></li>
</ul>
<pre><code>alter table 表名
add
(
   #可以有多个列定义
   column_name1 datatype [default expr] [first|after col_name],
   ...
)</code></pre><p>如果只新增一列，可以省略圆括号，在add后紧跟一个列定义即可。</p>
<p><code>字符串值是由单引号引起的</code></p>
<h4 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h4><pre><code>alter table 表名
modify column_name datatype(修改后的类型) [default expr] [first|after col_name](指定需要将目标修改到指定位置）;</code></pre><ul>
<li>该修改语句每次只能修改一个列定义</li>
<li>add新增的列名是原表中不存在的，modify修改的是原表中已存在的</li>
<li>first 表示添加在最开始处，after xxx表示添加在xxx之后<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4></li>
</ul>
<pre><code>alter table 表名
drop colum_name</code></pre><h4 id="重命名数据表"><a href="#重命名数据表" class="headerlink" title="重命名数据表"></a>重命名数据表</h4><pre><code>alter table 表名
rename to 新名</code></pre><h4 id="完全改变列定义-change"><a href="#完全改变列定义-change" class="headerlink" title="完全改变列定义 change"></a>完全改变列定义 <code>change</code></h4><pre><code>alter table 表名
change old_column new_column type [default expr][first|after col_name]</code></pre><p>一般只有需要修改列名时才会使用change选项</p>
<h3 id="删除表的语法"><a href="#删除表的语法" class="headerlink" title="删除表的语法"></a>删除表的语法</h3><pre><code>drop table 表名</code></pre><ul>
<li>表结构被删除，表对象不再存在；</li>
<li>表里所有数据也被删除；</li>
<li>表里所有相关索引，约束也被删除<h3 id="truncate-表"><a href="#truncate-表" class="headerlink" title="truncate 表"></a>truncate 表</h3>作用：<code>删除表里全部数据和结构，在重新建立一个新表（更彻底，无法找回</code><pre><code>truncate 表名</code></pre><h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2></li>
<li>约束类型：<blockquote>
<p>NOT NULL：非空约束，指定某列不能为空。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>UNIQUE：唯一约束，指定某列或者几列组合不能重复。</p>
</blockquote>
<blockquote>
<p>PRIMARY KEY：主键，指定该列的值可以唯一的标识该条记录。</p>
</blockquote>
<blockquote>
<p>POREING KEY：外键，指定该行记录从属于主表中的一条记录，主要用于保证参照完整性。</p>
</blockquote>
<blockquote>
<p>CHECK：检查，指定一个布尔表达式，用于指定对应列的值必需满足该表达式</p>
</blockquote>
<p><code>MySQL不支持CHECK约束，可使用但没卵用</code></p>
<ul>
<li>根据约束对数据列的限制，约束分为如下两类：<blockquote>
<p>单列约束：每个约束只约束一列。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>多列约束:每个约束可以约束多个数据列。</p>
</blockquote>
<h3 id="NOT-NULL约束"><a href="#NOT-NULL约束" class="headerlink" title="NOT NULL约束"></a>NOT NULL约束</h3><ul>
<li>它只能作为<code>列级约束</code>使用</li>
<li><code>非空约束不能指定名字</code></li>
<li>null值：<blockquote>
<p>所有数据类型的值都可以是null；</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>空字符串不等于null，0也不等于null；</p>
</blockquote>
<blockquote>
<p><code>在数据库中null不等于null</code>；</p>
</blockquote>
<ul>
<li>使用：</li>
</ul>
<ol>
<li>只要在列表定义后添加<code>not null</code>；</li>
</ol>
<pre><code>create table hehe
(
  #建立了非空约束，这意味着hehe_id不可以为null
  hehe_id int not null,
  # MySQL的非空约束不能指定名字
  hehe_name varchar(255) default &#39;xyz&#39; not null,
  #下面列可以为空，默认就是可以为空
  hehe_gender varchar(2) null
);</code></pre><ol start="2">
<li>在使用alter table 修改表时增加或者删除非空约束</li>
</ol>
<pre><code>#增加非空约束
alter table hehe
modify hehe_gender varchar(2) not null
#取消非空约束
modify hehe_name varchar(2) null;
#取消非空约束，并指定默认值
alter table hehe
modify hehe_name varchar(255) default &#39;abc&#39; null;</code></pre><h3 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a>UNIQUE约束</h3><ul>
<li>唯一约束用于保证指定列或指定列组合不允许出现重复值，<code>但可以出现多个null</code></li>
<li>当某列创建唯一约束时，会为该列相应的创建唯一索引</li>
<li>如果不给唯一约束起名，该唯一约束默认与列名同名</li>
<li>如果需要为多列建组合约束，或者需要<code>为唯一约束指定约束名</code>，`只能用表级约束语法。</li>
<li>使用：</li>
</ul>
<ol>
<li>列级约束语法：在定义后增加<code>unique</code>关键字即可</li>
</ol>
<pre><code>#建表时创建唯一约束，使用列级约束法建立约束
create table unique_test
(
  #建立了非空约束
  test_id int not null,
  #unique是唯一约束，使用列级约束法建立唯一约束
  test_name varchar(255) unique
);a</code></pre><ol start="2">
<li>表级约束语法：<code>[constraint 约束名] 约束定义</code></li>
</ol>
<ul>
<li>即可放在create table中，也可放在alter table中使用关键字add来添加约束<pre><code class="sql">create table unique_test2
(
test_id int not null,
test_name varchar(255),
test_pass varchar(255),
#使用表级约束法语句建立唯一约束
unique (test_name),
#使用表级约束法建立唯一约束，并指定约束名
constraint test2_uk unique (test_pass)
\
#使用表级约束法建立唯一约束，指定两列组合不允许重复
constraint test3_uk unique(test_name,test_pass)
\
#使用add关键字添加唯一约束
add unique(test_name,test_pass),
);</code></pre>
</li>
<li>在修改表结构时使用add关键字添加唯一约束</li>
</ul>
<pre><code>alter table unique_test3
add unique(test_name,test_pass);</code></pre><p>3.在修改表时使用modify关键字，为单列采用列级约束语法来增加唯一约束</p>
<pre><code>alter table unique_test3
modify test_name verchar(255) unique;</code></pre><p>5.删除约束：<code>drop index 约束名</code></p>
<pre><code>alter table unique_test3
drop index text3_uk;</code></pre><h3 id="PRIMARY-KEY约束"><a href="#PRIMARY-KEY约束" class="headerlink" title="PRIMARY KEY约束"></a>PRIMARY KEY约束</h3><ul>
<li><p><code>主键约束相当于非空约束和唯一约束</code></p>
</li>
<li><p>主键列的值可用于唯一的标识表中的一条记录</p>
</li>
<li><p><code>每一个表中最多允许有一个主键</code>，主键是表中能唯一确定一行记录的字段或字段组合</p>
</li>
<li><p>不管用户是否为主键约束指定约束名，MySQL总是将所有的主键约束命名为PRIMARY</p>
</li>
<li><p>MySQL在主键约束所在列或列组合上建立对应的唯一索引</p>
</li>
<li><p>使用：<code>primary key</code></p>
<p>1.列级约束法 </p>
</li>
</ul>
<pre><code>create table primary_test
(
  #建立了主键约束
  test_id int primary key,
  test_name varchar(255)
);</code></pre><p>2.表级约束法:<code>[constraint 约束名]</code> 约束定义</p>
<pre><code>create table primary_test2
(
  test_id int not null,
  test_name varchar(255),
  teat_pass varchar(255),
  #指定约束名对MySQL无效
  constraint test_pk primary key (test_id)
  \
  #建立多列组合的主键约束
  primary key (test_name,test_pass)
);</code></pre><pre><code>alter table primary_test3
modify test_nama varchar(255) primary key;</code></pre><p>3.删除指定表的主键约束：<code>drop primary key</code></p>
<pre><code>alter table primary_test3
drop primary key;
\
drop primary key (test_name,test_pass);</code></pre><ol start="4">
<li>自增长特性：<code>auto_increment</code></li>
</ol>
<ul>
<li>如果某个数据列的类型是整形，而且该列作为主键列，可指定该列具有自增长功能。</li>
<li>该功能通常用于设置逻辑主键列–该列的值没有任何物理意义，仅仅用于表示每行记录</li>
<li>一旦指定了某列具有自增长特性，则向该表插入记录时可不为该列指定值，由数据库系统自动生成<pre><code>create table primary_test4
(
#建立主键约束，使用自增长
test_id int auto_increment primary key,
test_name varchar(255),
test_pass varchar(255)
);</code></pre><h3 id="FOREIGN-KEY约束"><a href="#FOREIGN-KEY约束" class="headerlink" title="FOREIGN KEY约束"></a>FOREIGN KEY约束</h3></li>
<li>外键约束主要用于保证一个或两个数据表之间的参考完整性，外键是构建于一个表的两个字段或者两个表的字段之间的参照关系：<code>子（从）表外键列的值必须在主表被参照列的值范围之内，或者为空。</code></li>
<li>当主表的记录被从表记录参照后，必须先把从表里参照记录的所有记录全部删除后，才可以删除主表的该记录或者删除主表记录时级联删除从表所有参照该记录的从表记录</li>
<li><code>从表外键参照的只能是主表主键列或者唯一键列。同一个表中可以拥有多个外键。</code></li>
<li>对于一对多的关联关系，<code>通常在多的一端增加外键列</code></li>
<li>增加外键列的表被称为从表</li>
<li>使用：<code>references</code></li>
</ul>
<ol>
<li>列级约束语法(MySQL建立的列级约束语法不会生效)</li>
</ol>
<pre><code class="sql">#为保证从表参照的主表存在，通常应该先建主表
create table teacher_table
(
  #auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键
  teacher_id int auto_increment,
  teacher_name varchar(255)，
  primary key(teacher_id)
)；
create table student_table
(
  #为本表建立主键约束
  student_id int auto_increment primary key,
  student_name varchar(255),
  #指定java_teacher参照到teacher_table的teacher_id列
  java_teacher int references teacher_table(teacher_id)
);</code></pre>
<ol start="2">
<li>表级约束语法：<code>foreign key</code><pre><code class="sql">#为保证从表参照的主表存在，通常应该先建主表
create table teacher_table1
(
#auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键
teacher_id int auto_increment,
teacher_name varchar(255)，
primary key(teacher_id)
)；
create table student_table
(
#为本表建立主键约束
student_id int auto_increment primary key,
student_name varchar(255),
#指定java_teacher参照到teacher_table的teacher_id列
foreign key (java_teacher) references teacher_table1(teacher_id)
);</code></pre>
</li>
</ol>
<ul>
<li>使用表级约束语法可以为外键约束指定约束名，如果没有，MySQL会为该键命名为table_name_ibfk //table是从表的表名，而n从1开始的整数</li>
<li>如果需要建立多列组合的外键约束，必须使用表级约束法<pre><code class="sql">#为保证从表参照的主表存在，通常应该先建主表
create table teacher_table3
(
#auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键
teacher_pass varchar(255),
teacher_name varchar(255)，
primary key(teacher_name,teacher_pass)
)；
create table student_table3
(
#为本表建立主键约束
student_id int auto_increment primary key,
student_name varchar(255),
java_teacher_name varchar(255),
java_teacher_pass varchar(255),
#指定两列的联合外键
foreign key (java_teacher_name,java_teacher_pass) references teacher_table3(teacher_name,teacher_pass)
);</code></pre>
</li>
</ul>
<ol start="3">
<li>显示指定外键约束的名字，可使用<code>constraint</code>来指定名字<pre><code class="sql">#为保证从表参照的主表存在，通常应该先建主表
create table teacher_table2
(
#auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键
teacher_id int auto_increment,
teacher_name varchar(255)，
primary key(teacher_id)
)；
create table student_table2
(
#为本表建立主键约束
student_id int auto_increment primary key,
student_name varchar(255),
java_teacher int,
#指定java_teacher参照到teacher_table的teacher_id列，并指定外键约束名为student_teacher_fk
constraint student_teacher_fk foreign key (java_teacher) references teacher_table2(teacher_id)
);</code></pre>
</li>
<li>删除外键约束：<code>alter table后加 drop foreign key 约束名</code><pre><code>#删除student_table3表上名为student_table3_ibfk_1的外键约束
alter table student_table3
drop foreign key student_tables3_ibfk_1;</code></pre></li>
<li>增加外键约束：<code>add foreign key</code><pre><code class="sql">alter table student_table3
add foreign key(java_teacher_name,java_teacher_pass) references teacher_table3(teacher_name,teacher_pass);</code></pre>
</li>
<li>自关联：参照自身<pre><code>creater table foreign_test
(
foreign_id int auto_increment primary key,
foreign_name varchar(255),
refer_id int,
foreign key(refer_id) references foreign_test(foreign_id)
)</code></pre></li>
<li>删除主表记录：</li>
</ol>
<ul>
<li><code>on delete cascade</code>:删除主表记录时，把参照该主表记录的从表记录全部联级删除</li>
<li><code>on delete set null</code>：删除主表记录时，把参照该主表记录的从表记录的外键设为null</li>
<li>在建立外键约束后添加<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2></li>
<li>索引是一个数据库对象，从属于数据表</li>
<li>作用：加快对表的查询</li>
<li>索引在数据字典中独立存在，但不能独立存在，<code>必须属于某个表</code></li>
<li>创建索引：<blockquote>
<p>自动：当在表上定义<code>主键约束、唯一约束和外键约束</code>时，系统会为该数据自动创建对应的索引</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>手动：用户可以通过<code>create index</code>语句来创建索引</p>
</blockquote>
<ul>
<li>删除索引：<blockquote>
<p>自动：数据表被删除时，该表上的索引自动被删除</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>手动：通过<code>drop index</code>语句来删除指定数据表上的指定索引</p>
</blockquote>
<ul>
<li>一个表中可以有多个索引列，每个索引都可用于加速该列的查询速度</li>
<li>语法：</li>
</ul>
<ol>
<li>创建索引：</li>
</ol>
<ul>
<li>在创建表时创建索引：<pre><code>creat table 表名
(
  字段1，字段2... 
  [unique]index [索引别名](列名)；//默认与列名相同
);</code></pre> 加<code>unique</code>限定索引的值必须是唯一的</li>
<li>在已存在的表上创建索引</li>
</ul>
<pre><code>create (unique)index index_name
on table_name (column[,column]...);</code></pre><pre><code>#提高employees基于last_name字段的查询速度
create index exm_last_name_idx
on emoployees (last_name);</code></pre><pre><code>#同时对多列建立索引
create index emp_last_name_idx2
on employees(first_name , last_name);</code></pre><ul>
<li>使用alter table创建索引<pre><code>alter table 表名
add [unique] index [索引名] [列名]；</code></pre></li>
</ul>
<ol start="2">
<li>删除索引<pre><code>drop index 索引名 on 表名</code></pre><pre><code>#删除了employees表上的emp_last_name_idx2索引
drop index emp_last_name_idx2
on employees</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2></li>
</ol>
<ul>
<li>视图是一个或多个数据表中数据的逻辑显示，<code>并不能存储数据</code></li>
<li>视图只是数据表的逻辑显示，也就是一个<code>查询结果</code></li>
<li>语法：</li>
</ul>
<ol>
<li>创建/修改视图</li>
</ol>
<ul>
<li><code>create or replace</code><pre><code>#如果指定视图名不存在，则创建视图；如果指定视图名已经存在，则使用新视图替换原有视图
create or replace view 视图名
as select
subquery</code></pre><pre><code>create or replace view view_test[(a,b)]//创建字段别名
as
select teacher_name,teacher_pass from teacher_table;</code></pre></li>
<li><code>alter view 视图名</code><pre><code>alter view 视图名
as select 语句</code></pre><blockquote>
<p>使用<code>with check option</code>子句创建的视图不允许修改</p>
</blockquote>
</li>
</ul>
<pre><code>create or replace view view_test
as
select teache_name  from teacher_table
#指定不允许修改该视图数据
with check option；</code></pre><ol start="2">
<li>删除视图：<code>drop view</code> 视图名；</li>
<li>查看视图：</li>
</ol>
<ul>
<li><code>describe(desc) 视图名</code>：查看基本信息</li>
<li><code>show table status like 视图名</code>：查看基本属性（基本都为null）</li>
<li><code>show create view 表名</code>：详细信息，包括建视图语句</li>
</ul>
<ol start="4">
<li>更新视图：DML语句<h2 id="DML语句：操作数据表里的数据"><a href="#DML语句：操作数据表里的数据" class="headerlink" title="DML语句：操作数据表里的数据"></a>DML语句：<code>操作数据表里的数据</code></h2><blockquote>
<p>插入新数据</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>修改已有数据</p>
</blockquote>
<blockquote>
<p>删除不需要的数据</p>
</blockquote>
<ul>
<li>DML语句由<code>insert into、update和delete from</code>三个命令组成</li>
</ul>
<ol>
<li><code>insert into语句</code></li>
</ol>
<ul>
<li>用于向指定数据表中插入记录，每次只能插入一条</li>
</ul>
<pre><code class="sql">insert into table_name[(column [,column...])]
values(value [,value...]); #字符串使用单引号</code></pre>
<blockquote>
<p>表名后用括号列出所有需要插入值的列名，而values后用括号列出对应需要插入的值</p>
</blockquote>
<blockquote>
<p>如果省略表名后面的括号及括号里的列名列表，默认将为所有列插入值，则需要为每一列都指定一个值，也可以为无法确定的值的列分配null</p>
</blockquote>
<blockquote>
<p>只有在数据库中已经成功创建了数据表之后，才可以向数据表中插入记录</p>
</blockquote>
<blockquote>
<p>外键列的值必须是被参照列里已有的值，所以向从表中插入记录之前，通常应该先向主表中插入记录，否则从表记录的外键列只能为null</p>
</blockquote>
<blockquote>
<p>外键约束保证被参照的记录必须存在，但并不保证必须有被参照记录，即<code>外键列可以为null</code></p>
</blockquote>
<pre><code>insert into teacher_table2(teacher_name)
values(&#39;xyz&#39;);

insert into teacher_table2
#使用null代替主键列的值
values(null,&#39;abc&#39;);</code></pre><ul>
<li>带子查询的插入语句：可以一次插入多条记录<blockquote>
<p>只要求选择出的数据和插入目的表的数据列个数相等、数据类型匹配</p>
</blockquote>
<pre><code>insert into student_table2(student_name)
#用带子查询的值来插入
select teacher_name from teacher_table2;</code></pre></li>
<li>拓展语法：可以一次性插入多条记录，在values后使用多个括号包含多条记录，表示多条记录的多个括号之间以英文逗号（，）隔开<pre><code>insert into teacher_table2
#同时插入多个值
values(null,&quot;Yeeku&quot;),
(null,&quot;Sharfly&quot;);</code></pre></li>
</ul>
<ol start="2">
<li><code>update set语句</code></li>
</ol>
<ul>
<li>用于修改数据表的记录，每次可以修改多条记录，通过使用<code>where子句限定修改哪些记录</code></li>
<li>where与if类似，没有where的句子总为true，即该表所有记录都会被修改<pre><code>update table_name
set column1=value1[,column2=value2]...
[where condition];</code></pre></li>
<li>update语句还可以一次修改多列，通过<code>set关键字后使用column1=value1，column2=value2...来实现，修改多列的值之间用英文逗号隔开</code><pre><code>#把teacher_table2表中所有的teacher_name列的值改为’孙悟空‘
update teacher_table2
set teacher_name=&#39;孙悟空&#39;；
</code></pre></li>
</ul>
<p>#通过where条件来指定只修改特定记录<br>update teacher_table2<br>set teacher_name=’猪八戒’<br>where teacher_id&gt;1;</p>
<pre><code>3. `delete from语句`
- 用于删除指定数据表记录，使用时不需要指定列名，因为总是整行地删除
- 可使用where
- 格式语法</code></pre><p>delete from table_name<br>[where condition];</p>
<pre><code></code></pre><p>#把student_table2表中的记录全部删除<br>delete from student_table2;</p>
<p>#使用where限定只删除指定记录，可以加上limit限制每次删除数量<br>delete from teacher_table2<br>where teache_id &gt;2 limit 1;</p>
<pre><code>- 只有先将从表中参照主表记录的所有记录全部删除后，才能删除主表记录
## 单表查询
- `select语句`：用于从一个或者多个数据表中选出特定的行、列的交集
- 语法格式：</code></pre><p>select coulmu1,column2…<br>from 数据源<br>[where condition]</p>
<pre><code>&gt; 数据源可以是表、视图等；如果没有where条件，默认选出所有行；`如果想选出所有列，则可使用带星号(*)代表所有列`；
</code></pre><p>select *<br>from teacher_table;</p>
<pre><code>- select语句可使用算数运算符（+、-、*、/）
&gt; 不仅可以在列和常量、变量之间进行运算，`也可以在两列之间进行运算`。

&gt; 数据列很像一个变量，但其值具有指定的范围，因此能使用变量的地方，基本上都可以使用数据列。
</code></pre><p>select teacher_id +5<br>from teacher_table;</p>
<p>#查询出teacher_table表中teacher_id<em>3大于4的记录<br>select *<br>from teacher_table<br>where teacher_id</em>3&gt;4;</p>
<h1 id="数据列实际上可当成一个变量"><a href="#数据列实际上可当成一个变量" class="headerlink" title="数据列实际上可当成一个变量"></a>数据列实际上可当成一个变量</h1><p>select 3*5，,20<br>from teacher_table;</p>
<pre><code>- MySQL使用 `concat` 函数来进行字符串连接运算：
```sql
-- 选择出teacher_name和&#39;xxx&#39;字符串连接后的结果
select concat(teacher_name,&#39;xxx&#39;)
from teacher_table;</code></pre><p>如果让字符串和 null 进行连接运算，将使整个算数表达式的返回值为 null</p>
<ul>
<li>可以为数据列或者表达式起一个别名，<code>别名紧跟数据列，中间以空格隔开，或者使用as关键字隔开</code><pre><code class="sql">select teacher_id +5 as MY_ID
from teacher_table;
</code></pre>
</li>
</ul>
<p>#可以用双引号实现别名中的特殊字符<br>select teacher_id + 5 “MY’id”<br>from teacher_table;</p>
<p>#为多列起名<br>select teacher_id +5 MY_id,teacher_name 老师名<br>from teacher_table;</p>
<p>#为表起别名<br>select teacher_id +5<br>from teacher_table t;</p>
<p>#运算符在多列之间进行运算<br>select teacher_id +5 MY_ID,concat(teacher_name,teacher_id) teacher_name<br>from teacher_table<br>where teacher_id *2&gt;3;</p>
<p>select 5+4<br>from teacher_table<br>where 2&lt;9;</p>
<pre><code>&gt; SQL会把常量当成一列，对于上面最后的语句，有多少条语句该常量就出现多少次

&gt;select 5+4 from dual;dual没有任何意义，仅仅相当于from后面的占位符

- select 会默认把所有符合条件的记录全部选出来，即使两行记录完全一样。可以使用 `distinct` 关键字从查询结果中清除重复行。
```sql
select distinct student_name,java_teacher
from student_table;</code></pre><blockquote>
<p> <code>distinct</code> 紧跟 <code>select</code> 关键字，它的作用是去除后面字段组合的重复值，而不管对应记录在数据库里是否重复，例如：(1,’a’,’b’) 和 (2,’a’,’b’) 两条记录在数据库里是不重复的，但如果仅选择后面两列，则 <code>distinct</code> 会认为两条记录重复</p>
</blockquote>
<ul>
<li>运算符：SQL 中判断两个值是否相等的比较运算符是单等号，赋值运算符是冒号等号(:=)</li>
<li>特殊的比较运算符</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>expr1 (not) between expr2 and expr3</td>
<td>expr1的值在两者之间</td>
</tr>
<tr>
<td>expr1 <code>in</code>(expr2,expr3,…)</td>
<td>expr1的值等于后面括号中的任意一个</td>
</tr>
<tr>
<td>like</td>
<td>查询与like后的字符串匹配的字符串</td>
</tr>
<tr>
<td>is (not) null</td>
<td>要求指定值等于null</td>
</tr>
<tr>
<td>```</td>
<td></td>
</tr>
<tr>
<td>select * from student_table</td>
<td></td>
</tr>
<tr>
<td>where student_id between 2 and 4;</td>
<td></td>
</tr>
</tbody></table>
<p>#选出java_teacher&lt;=2，student_id&gt;=2的所有记录<br>select * from student_table<br>whrer 2 between java_teacher and student_id;</p>
<p>#选出student_id 为2或4的所有记录<br>select * from student_table<br>where student_id in (2,4);<br>/<br>where 2 in (student_id,java_teacher);</p>
<pre><code>&gt; like 后面可以加两个通配符：`下划线(_):代表一个任意字符；百分号(%):代表任意多个字符。`
</code></pre><p>where student_name like ‘孙%’；<br>where student_name like ‘__’；//用两个下划线代表两个字符</p>
<pre><code>&gt;`MySQL使用\作为转义字符`；标准SQL语句没有转义字符，而是使用escape关键字显示进行转义</code></pre><p>#选出所有名字以下划线开头的学生<br>select * from student_table<br>where student_name like ‘_%’;</p>
<p>select * from student_table<br>where student_name like ‘_%’ escape ‘&#39;;</p>
<pre><code>&gt;where student_name is null;#选择出student_name为null的所有记录。
- 逻辑运算符：`and、or和not`
&gt; 优先级：`所有比较运算符&gt;not&gt;and&gt;or`</code></pre><p>where student_name like ‘<em>_’ and(or) student_id &gt;3;<br>where not student_name like ‘\</em>%’;</p>
<pre><code>- 执行查询后的查询顺序默认按照插入顺序排列，使用`order by 子句，默认按升序排列`；若需要`强制降序排列，则需要在列名后使用desc关键字`
&gt; order by column_name1 [desc] , column_name2 ...

&gt; 如果按多列排序，每列的asc，desc必须单独设定。如果指定了多个拍序列，只有`当第一列中存在多个相同值时，第二个排序列才会起作用`
</code></pre><p>#按java_teacher列降序排序，当java_teacher列的值相同时按student_name列的升序排列<br>select * from student_table<br>order by java_teacher desc， student_name;</p>
<pre><code>### group by分组查询
- 表达式：
```mysql
group by 属性名 [having表达式] [with rollup]</code></pre><ol>
<li>单独使用，只会列出第一个出现的值<br>```sql</li>
</ol>
<p>– 只会筛选出第一个出现GradeName1的student的数据<br>select * from t_student group by gradeName;</p>
<pre><code>需要注意，最新的版本的 MySQL 标准**不再允许 `SELECT` 列表，`HAVING` 条件语句，或 `ORDER BY` 语句中出现 `GROUP BY` 中未列表的可聚合列**。而 MySQL 中有一个状态 `ONLY_FULL_GROUP_BY` 来标识是否遵从这一标准，默认为开启状态。

所以这样的语句是不可以的:

```sql
SELECT gender, 
       last_name 
FROM   employees 
GROUP  BY gender </code></pre><p>将 <code>last_name</code> 从 SELECT 中移除或将其添加到 GROUP BY 中都可以修复：</p>
<pre><code class="mysql">SELECT gender,
FROM   employees 
GROUP  BY gender 

SELECT gender,
last_name
FROM employees
GROUP BY gender,
last_name</code></pre>
<p>但这样的修改查询出来就可能就不是想要的结果了。</p>
<p>针对以上情况，可以有三种方式来解决：</p>
<p><strong>关闭 ONLY_FULL_GROUP_BY</strong></p>
<p>可以选择关掉 MySQL 的 <code>ONLY_FULL_GROUP_BY</code> 模式，有两种方式，通过设置 <code>sql_mode</code> 来关闭。</p>
<p>首先查看变更前的 <code>sql_mode</code>：</p>
<pre><code class="sql">mysql&gt; SELECT @@sql_mode;
+-----------------------------------------------------------------------------------------------------------------------+
| @@sql_mode                                                                                                            |
+-----------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |
+-----------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>
<p>通过以下脚本关闭 ：</p>
<pre><code class="shell">SET SESSION sql_mode=(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY,&#39;,&#39;&#39;));</code></pre>
<p>再次查询 <code>@@sql_mode</code> 返回中应该已经没有该模式了。</p>
<pre><code class="mysql">mysql&gt; SELECT @@sql_mode;
+----------------------------------------------------------------------------------------------------+
| @@sql_mode                                                                                         |
+----------------------------------------------------------------------------------------------------+
| STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |
+----------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>
<p>第二种是找到 MySQL 配置文件修改并保存。</p>
<p>MySQL 的配置文件名为 <code>my.cnf</code>，可通过以下命令查看你位置：</p>
<pre><code class="shell">$ mysql --help | grep cnf
                      order of preference, my.cnf, $MYSQL_TCP_PORT,
/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</code></pre>
<p>找到后编辑并保存，重启 MySQL 后生效。</p>
<pre><code class="shell">[mysqld]
-sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
+sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</code></pre>
<p>如果文件中没有 <code>sql_mode</code> 配置项可手动添加上。</p>
<p>因为 <code>ONLY_FULL_GROUP_BY</code> 更加符合 SQL 标准，所以不建议关掉。</p>
<p><strong>ANY_VALUE()</strong></p>
<p>还可以通过 <code>ANY_VALUE()</code> 来改造查询语句以避免报错。</p>
<p>使用 <code>ANY_VALUE()</code> 包裹的值不会被检查，跳过该错误。所以这样是可以的：</p>
<pre><code class="sql">SELECT gender, 
-       last_name
+       ANY_VALUE(last_name) 
FROM   employees 
GROUP  BY gender </code></pre>
<p><strong>添加列间的依赖</strong></p>
<p>像这个示例中:</p>
<pre><code>SELECT gender, 
       last_name 
FROM   employees 
GROUP  BY gender </code></pre><p>假如让 <code>gender</code> 变成不重复的主键，<code>last_name</code> 便与 <code>gender</code> 产生了一种关系，即 <code>gender</code> 可唯一确定 <code>last_name</code>。此时便可进行 <code>GROUP BY</code> 了。因为，<strong>之所以报错是因为在进行聚合的时候有不能确定的列参与了进来</strong>。这也是正确的使用场景。</p>
<ol start="2">
<li>与 <code>group concat()</code> 函数一起使用：会把所有值列出来</li>
</ol>
<pre><code>-- 会把所有属于gradeName的studentName全部组合在一起列出来
select gradeName,group concat(studentName) from t_student  group by gradeName;</code></pre><ol start="3">
<li>与聚合函数一起使用</li>
<li>与 <code>having</code> 一起使用，限制输出结果<br>```mysql</li>
</ol>
<p>– 只会输出学生名字多于三个的年级及学生名字<br>select gradeName,group concat(studentName) from t_student  group by gradeName having count(studentName) &gt;3;</p>
<pre><code>5. 与 `with rollup` 一起使用，在最后一行增加一个叠加总和
### limit 分页查询
```sql
select 字段1，字段2 ...from 表名 limit 初始位置，记录数</code></pre><p>第一条记录从 0 开始：</p>
<pre><code class="sql">-- 输出从第一条开始的五条记录；
select * from t_student limit 0,5;</code></pre>
<h2 id="数据库函数"><a href="#数据库函数" class="headerlink" title="数据库函数"></a>数据库函数</h2><ul>
<li>可分为单行函数和多行函数<blockquote>
<p>单行函数：对单行输入单独计算，每行得到一个计算结果返回给用户。其参数可以是变量、常量或数据列；可以接收多个参数，但只返回一个值；单行函数可以改变参数的数据类型</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>多行函数：多行输入整体处理，只返回一个值</p>
</blockquote>
<ul>
<li><code>MySQL单行函数的用法</code>：<pre><code class="sql">#选出teacher_table表中teacher_name列的字符长度
select char_length(teacher_name)
from teacher_table;
</code></pre>
</li>
</ul>
<p>#求绝对值<br>select abs(x);</p>
<p>#求平方根<br>sqrt(x);</p>
<p>#求余<br>mod(x,y);</p>
<p>#计算teacher_name列字符长度的sin值<br>select sin(char_length(teacher_name))<br>from teacher_table;</p>
<p>#计算1.57的sin值<br>select sin(1.57);</p>
<p>#为指定日期添加一定时间<br>#在这种语法下interval是关键字，需要一个数值，还需要一个单位<br>SELECT DATA_ADD(‘2018-04-01’,interval 2 MOMTH)；<br>#简单用法<br>select ADDDATE(‘2018-04-01’,3);</p>
<h1 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h1><p>select CURDATE();</p>
<p>#获取当前时间<br>select curtime();</p>
<p>#返回日期d中的月份<br>select month(d);</p>
<pre><code>### 连接函数
&gt; `CONCAT(a,b)`:用于把两个字符串连接起来
```sql
SELECT CONCAT(firstname,lastname) from Table;</code></pre><blockquote>
<p><code>CONCAT_WS</code>(‘(任意的分隔符)’,firstname,lastname):在两者之间显示分隔符</p>
</blockquote>
<h3 id="截断和填充函数"><a href="#截断和填充函数" class="headerlink" title="截断和填充函数"></a>截断和填充函数</h3><ul>
<li><code>RTRIM/LTRIM</code>:从一个字符串的右端或者左端删除空格</li>
<li><code>TRIM</code>:删除想要剔除的字符，使用<code>LEADING TAILING</code>分别表示剔除开头的或末尾的，若没有则默认两边都剔除<pre><code class="sql">SELECT TRIM(LEADING &#39;X&#39; FROM &#39;XXXneedleXXX&#39;);//显示needleXXX
SELECT TRIM(TAILING &#39;X&#39; FROM &#39;XXXneedleXXX&#39;);//显示XXXneedle
SELECT TRIM(&#39;X&#39; FROM &#39;XXXneedleXXX&#39;);//显示needle</code></pre>
</li>
<li><code>RPAD()/LPAD()</code>:向一个字符串中添加字符<pre><code class="sql">SELECT RPAD(&#39;needle&#39;,10,&#39;X&#39;);//添加直到字符串达到10个字符的长度</code></pre>
<h3 id="定位和位置函数"><a href="#定位和位置函数" class="headerlink" title="定位和位置函数"></a>定位和位置函数</h3></li>
<li><code>LICATE(&#39;A&#39;,&#39;B&#39;)</code>:返回A中某个字符串在B中第一次出现的位置（从1开始，不从0开始）<h3 id="子字符串函数"><a href="#子字符串函数" class="headerlink" title="子字符串函数"></a>子字符串函数</h3></li>
<li><code>SUBSTRING(&quot;字符串&quot;,2,3)</code>：获取第2个开始的三个字符</li>
<li><code>LEFT/RIGHT(&#39;MySQL&#39;,3)</code>:获取字符串左边或右边的三个字符<h3 id="字符串修改函数"><a href="#字符串修改函数" class="headerlink" title="字符串修改函数"></a>字符串修改函数</h3></li>
<li><code>LCASE/UCASE()</code>:把字符串转化为小写或者大写，参数为列名便是这个列的所有值转化为小写/大写</li>
<li><code>REPEAT(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)</code>:把A字符串中的B全部转化为C<h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><blockquote>
<p><code>password(str)</code>:一般对用户的密码加密，不可解密</p>
</blockquote>
<pre><code class="sql">insert into 表名 values(值1，值2，...,password(&#39;字符&#39;),...)；</code></pre>
<blockquote>
<p><code>sha()</code>：用于对密码加密，不可解密，会把一段文字加密为唯一的40字符编码</p>
</blockquote>
<pre><code class="sql">insert into 表名 values (值1，值2，...,sha(&#39;字符&#39;),...);</code></pre>
<blockquote>
<p><code>md5(str)</code>:普通加密，不可解密</p>
</blockquote>
<pre><code class="sql">insert into 表名  values (值1，值2，...,password(&#39;字符&#39;),...)；</code></pre>
<blockquote>
<p><code>encode(str,pswd_str)</code>:加密函数，结果是一个二进制数，必须使用blob类型的字段来保存它，<code>可解密</code></p>
</blockquote>
<pre><code class="sql">insert into 表名  values (值1，值2，...,encode(&#39;字符&#39;,&#39;xx&#39;),...)；//&#39;xx&#39;为某个解密钥匙标记</code></pre>
<blockquote>
<p><code>decode(crypt_str,pswd_str)</code>:解密函数</p>
</blockquote>
</li>
</ul>
<pre><code class="sql">select decode(&quot;被加密数据&quot;，&quot;与被加密参数对应的钥匙标记&quot;) from 表名；</code></pre>
<h3 id="null-处理函数"><a href="#null-处理函数" class="headerlink" title="null 处理函数"></a>null 处理函数</h3><p>MySQL提供如下几个处理null的函数</p>
<p>使用：<code>select 函数名 from 表名</code></p>
<blockquote>
<p>ifnull(expr1,expr2):如果expr1为null，则返回expr2，否则返回expr1</p>
</blockquote>
<blockquote>
<p>nullif(expr1,expr2):如果expr1和expr2相等，则返回null，否则返回expr1</p>
</blockquote>
<p>if(expr1,expr2,expr3):如果expr1为true，不等于0，且不等于null，则返回expr2，否则返会expr3</p>
<blockquote>
<p>isnull(expr1):判断expr1是否为null，如果是则返回true，否则返回false</p>
</blockquote>
<ul>
<li>case函数：流程控制函数<pre><code class="sql">select 列名 ，case 用法 from 表名；</code></pre>
</li>
</ul>
<ol>
<li>用法1：用 <code>value</code> 依次与后面的 <code>compare_value1</code> 等相比较，如果 <strong><code>value</code> 与指定的 <code>compare_value</code> 相等</strong>，则返回对应的 <code>result</code>，否则返回 else 的<code>result</code><pre><code class="sql">case value
when compare_value1 then result1
when compare_value2 then result2
...
else result
end</code></pre>
</li>
<li>用法2：<code>condition</code> 内容是一个返回 <code>boolean</code> 值的条件表达式<pre><code class="sql">case
when condition1 then result1
when condition2 then result2
...
else result
end</code></pre>
<h3 id="间隔分析函数"><a href="#间隔分析函数" class="headerlink" title="间隔分析函数"></a>间隔分析函数</h3></li>
</ol>
<p>MySQL提供了三个函数用于排序时显示当前行的序号，分别为 <code>RANK()</code>，<code>DENSE_RANK()</code>和 <code>ROW_NUMBER</code>，其中 <code>RANK()</code> 在遇到重复时，显示并列排名的同时对于下一个序号会递增，而 <code>DENSE_RANK</code> 不会递增。</p>
<p>这几个函数需要结合 <code>over</code> 函数进行使用，<code>over</code>  函数的语法如下：</p>
<pre><code class="mysql">over（partition by columnname1 order by columnname2）</code></pre>
<p><code>columnname1</code> 指定分组排序的字段，<code>columnname2</code> 指定排序字段。</p>
<p>例如：在 <code>employees</code> 表中，有两个部门的记录：<code>department_id</code> ＝10 和 20，以下 sql 语句：</p>
<pre><code class="mysql">select department_id，rank（） over（partition by department_id order by salary) from employees</code></pre>
<p>就是指在部门 10 中进行薪水的排名，在部门 20 中进行薪水排名。如果是 <code>partition by org_id</code>，则是在整个公司内进行排名。</p>
<p>函数使用的具体示例如下：</p>
<pre><code class="mysql">mysql&gt; SELECT
         val,
         ROW_NUMBER() OVER w AS &#39;row_number&#39;,
         RANK()       OVER w AS &#39;rank&#39;,
         DENSE_RANK() OVER w AS &#39;dense_rank&#39;
       FROM numbers
       WINDOW w AS (ORDER BY val);
+------+------------+------+------------+
| val  | row_number | rank | dense_rank |
+------+------------+------+------------+
|    1 |          1 |    1 |          1 |
|    1 |          2 |    1 |          1 |
|    2 |          3 |    3 |          2 |
|    3 |          4 |    4 |          3 |
|    3 |          5 |    4 |          3 |
|    3 |          6 |    4 |          3 |
|    4 |          7 |    7 |          4 |
|    4 |          8 |    7 |          4 |
|    5 |          9 |    9 |          5 |
+------+------------+------+------------+</code></pre>
<h2 id="分组和组函数"><a href="#分组和组函数" class="headerlink" title="分组和组函数"></a>分组和组函数</h2><ul>
<li>组函数就是多行函数，将一组记录作为整体计算，每组记录返回一个结果</li>
<li>常用组函数：</li>
</ul>
<ol>
<li><p><code>avg([distinct|all]expr)</code>: 计算多行 expr 的平均值，expr 可以是变量、常量或者数据列，但其数据类型必须是数值型，如果使用<code>distinct</code> 表示不计算重复值，<code>all</code> 用与不用一样</p>
</li>
<li><p><code>count({*|[distinct|all]expr})</code>: 计算多行 expr 的总条数，expr 的数据类型可以是任意类型；用（*）表示统计该表内记录的行数</p>
</li>
<li><p><code>max(expr)</code>：计算多行 expr 的最大值，其中 expr 其数据类型可以是任意类型</p>
</li>
<li><p><code>min(expr)</code>：计算多行 expr 的最小值</p>
</li>
<li><p><code>sum([distinct|all]expr)</code>：计算多行 expr 的总和，expr 的数据类型必须是数值型</p>
</li>
</ol>
<pre><code class="sql">#计算的结果是20*记录的行数
select sum(20)
from student_table;

#因为expr的值是34，所以每行的值都相同
#使用distinct强制不计算重复值，所以下面计算结果为34
select sum(distinct 34)
from student_table;

#使用count统计记录行数时，null不会被计算在内
select count(student_name)
from student_table;

#对于可能出现null的列，可以用ifnull处理
select count (ifnull(student_name,0))
from student_table;</code></pre>
<ul>
<li><code>distinct</code> 和 <code>*</code> 不能同时使用</li>
<li><strong>组函数会把所有记录当成一组</strong>，为了对记录进行显示分组，可以在 select 语句后使用<code>group by</code> 子句，<code>group by</code> 子句后通常跟一个或多个列名，表名查询结果根据一列或多列进行分组，<strong>当一列或多列组合的值完全相同时，系统会把这些记录当成一组</strong><pre><code class="sql">#count(*)将会对每组得到一个结果
select count(*)
from student_table
#将java_teacher列值相同的记录当成一组
group by java_teacher;</code></pre>
</li>
<li>如果对多列进行分组，则要求多列的值完全相同时才会被当成一组<pre><code class="sql">select count(*)
from student_table
#当java_teacher、student_name两列的值完全相同时才会被当成一组
group by java_teacher , student_name;</code></pre>
</li>
<li>对于很多数据库而言，分组计算时，如果查询列表中使用了组函数，或者select语句中使用了 group by 分组子句，则要求<strong>出现在 select 列表中的字段，要么使用组函数包起来，要么必须出现在 group by 子句中</strong>。 </li>
<li>对于MySQL：如果某个数据列既没有出现在group by之后，也没有使用组函数包起来，则MySQL会输出该列的第一条记录的值。</li>
<li>如果需要对分组进行过滤，则应该<strong>使用 <code>having</code> 子句，子句后面有一个条件表达式，只有满足该表达式的分组才会被选出来</strong></li>
<li>where 和 having 的区别：</li>
</ul>
<ol>
<li>不能在 where 子句中过滤组，where 子句仅用于过滤行，过滤组必须使用 having 子句</li>
<li>不能在 where 子句中使用组函数，having 子句才可以使用组函数</li>
</ol>
<pre><code>select *
from student_table
group by java_teacher
#对组进行过滤
having count(*)&gt;2;</code></pre><h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><ul>
<li>需要选择的数据并不是来自一个表，而是来自多个数据表，这就需要使用多表查询</li>
<li>两种查询规范：</li>
</ul>
<ol>
<li><p>SQL 92规范：</p>
<blockquote>
<p>等值查询</p>
</blockquote>
<blockquote>
<p>非等值查询</p>
</blockquote>
<blockquote>
<p>外连接</p>
</blockquote>
<blockquote>
<p>广义笛卡尔积</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法：<pre><code class="sql">select column1, column2 ...
from table1,table2 ...
[where join_condition]</code></pre>
</li>
<li>多表连接中可能出现两个或多个数据列同名的列名，则需要在这些同名列之前使用表名前缀</li>
<li>等值查询:<code>where中要求两列值相等</code><pre><code class="sql">select s.*,teacher_name
from student_name s,teacher_table t
where s.java_teacher = t.teacher_id;</code></pre>
</li>
<li>非等值查询：<code>where中要求两列值不相等</code>，大于或小于</li>
<li>广义笛卡尔积：<code>没有where子句</code>，结果会有n x m条记录</li>
<li>如果要将记录进行过滤，则将过滤条件和连接条件使用and连接起来<pre><code class="sql">select s.* ,teacher_name
# 指定多个数据表，并指定表别名
from student_table s，teacher_table t
# 使用where指定连接条件，并指定student_name 列不能为null
where s.java_teacher=t.teacher_id and student_name is not null;</code></pre>
</li>
<li>MySQL 不支持左外连接和右外连接</li>
<li>自连接：对于自关联的数据表查询<pre><code class="sql"># 定义一个自关联的数据表
create table emp_table
(
 emp_id int auto_increment primary key,
 emp_name varchar(255),
 namage_id int,
 foreign key(namage_id) reference emp_table(emp_id)
);
#向表中插入数据
insert into emp_table
value (null,&#39;唐僧&#39;,null),
(null,&#39;孙悟空&#39;，null)，
(null,&#39;猪八戒&#39;，null)，
(null,&#39;沙僧&#39;，null);
</code></pre>
</li>
</ul>
<p>#自定义查询<br>select emp.emp_id,emp.emp_name 员工名，mgr.emp_name 经理名<br>from emp_table emp,emp_table mgr<br>where emp.manage_id=mgr.emp_id;</p>
<pre><code>2.SQL 99的连接查询：`多表连接查询的from后面只有一个表名`
- 交叉连接（cross join）：效果就是SQL92中的广义笛卡儿积，无需任何连接条件
```sql
select s.*,teacher_name
#SQL 99多表连接查询的from后只有一个表名
from student_table s
#cross join 交叉连接，相当于广义笛卡儿积
cross join teacher_table t；</code></pre><ul>
<li>自然连接(natual join):自然连接表面上看起来无需指定连接条件，但自然连接是有连接条件的，<code>以两个表中的同名列作为连接条件</code>，如果两个表中没有同名列，则自然连接与交叉连接效果完全一样<pre><code>select s.*,teacher_name
#SQL 99多连接查询的from后只有一个表名
from student_table s
natual join teacher_table t;</code></pre></li>
<li>using子句连接：using子句可以指定一列或者多列，用于显式指定两个表中的同名列作为连接条件。<code>假设两个表中有超过一列的同名列，如果使用natual join，则会把所有同名列当成连接条件；如果使用using子句，就可显式指定使用哪些同名列作为连接条件</code><pre><code>select s.*,teacher_name
from student_table s
#join 连接另一个表
join teacher_tale t
using(某一同名列)；</code></pre></li>
<li>on 子句连接：每个on子句只指定一个连接条件<pre><code>select s.*,teacher_name
from student_table s
#join连接另一个表
join teacher_table t
#使用on指定连接条件
on s.java_teacher = t.teacher_id;//也可以是非等值连接</code></pre></li>
<li>左、右、全外连接：分别使用<code>left [outer] join、right [outer] join和full [outer] join</code><pre><code class="sql">select s.*,teacher_name
from student_table s
right/left/full join teacher_table t
on s.java_teacher &gt;t.teacher_id;</code></pre>
<blockquote>
<p>左连接：会把左边表中所有满足连接条件的记录全部列出</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>右连接：会把右边表中所有满足连接条件的记录全部列出,左边没有的为null</p>
</blockquote>
<blockquote>
<p>全外连接：会把两个表中所有满足连接条件的记录全部列出</p>
</blockquote>
<ul>
<li>内连接：<code>inner join</code>，可以返回结合两个表的数据</li>
</ul>
<pre><code class="sql">select mismatch_topic.topic_id,mismatch_category.name
    from mismatch_topic
    inner join mismatch_category
    on (mismatch_topic.category_id = mismatch_category.category_id)
    where mismatch_topic.name = &#39;Horror movies;</code></pre>
<p>如果要查询内容位于不同的表而列名相同，可以使用 <code>using</code> 代替 <code>on</code></p>
<pre><code class="sql">select mismatch_topic.topic_id,mismatch_category.name
    from mismatch_topic
    inner join mismatch_category
    using (category_id)
    where mismatch_topic.name = &#39;Horror movies;</code></pre>
<h2 id="子查询：在查询语句中嵌套另一个查询"><a href="#子查询：在查询语句中嵌套另一个查询" class="headerlink" title="子查询：在查询语句中嵌套另一个查询"></a>子查询：在查询语句中嵌套另一个查询</h2><ul>
<li>子查询可以出现在两个位置：<blockquote>
<p>出现在from语句后当成数据表，这种用法被称为行内视图，相当于一个临时视图</p>
</blockquote>
</li>
</ul>
<pre><code class="sql">select *
from (select * from student_table) t # 必须给重命名
where t.java_teacher &gt;1;</code></pre>
<blockquote>
<p>出现在where条件后作为过滤条件的值</p>
</blockquote>
<pre><code class="go">select *
from student_table
where java_teacher &gt;
#返回单行、单列的子查询可以被标量值使用
(select teacher_id 
from teacher_table
  where teacher_name=&#39;Yeeku&#39;);</code></pre>
<ul>
<li>注意点：</li>
</ul>
<ol>
<li>子查询要用括号括起来</li>
<li>把子查询当成数据表时（出现在from之后），可以为该子查询起别名，尤其是<code>作为前缀来限定数据表时，必须给子查询起别名</code></li>
<li>把子查询当成过滤条件时，单行子查询使用单行运算符，多行子查询使用多行运算符</li>
</ol>
<ul>
<li>如果子查询返回多个值，则需要使用in、any、all等关键字</li>
</ul>
<blockquote>
<p>(not)in:把子查询返回的多个值当成一个值列表</p>
</blockquote>
<pre><code>select *
from student_table
where student_id in
(select teacher_id
from teacher_table);</code></pre><blockquote>
<p>any和all可以与&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;、=等运算符结合使用；</p>
</blockquote>
<blockquote>
<p><code>与any结合使用表示等于、大于等于、小于、小于等于、不等于、等于其中任意一个值；</code></p>
</blockquote>
<blockquote>
<p><code>与all结合使用分别表示等于、大于等于、小于、小于等于、不等于、等于全部值；</code></p>
</blockquote>
<blockquote>
<p>=any的作用与in作用相同</p>
</blockquote>
<pre><code>select *
from student_table
where student_id =
any (select_teacher_id
from teacher_table);</code></pre><blockquote>
<p>“&lt;any” 只要小于值列表中的最大值即可，”&gt;any”只要大于值列表中的最小值即可，”&lt;all” 要求小于值列表中的最小值，”&gt;all”要求大于值列表中的最大值。</p>
</blockquote>
<pre><code>select *
from student_table
where student_id &gt;
all(select teacher_id
from teacher_table);</code></pre><blockquote>
<p>子查询可以返回多行、多列，此时where子句应该有对应的数据列，并使用圆括号将多个数据列组合起来</p>
</blockquote>
<pre><code>select *
from student_table
where (student_id,student_name)
=any(select teacher_id,teacher_name
from teacher_table);</code></pre><ul>
<li>带(not) exists关键字的子查询:若子查询内容不为空，则查询外层表，否则返回空表<blockquote>
<p>select 字段…from 表1 where exists (select 字段…from 表2)；</p>
</blockquote>
</li>
</ul>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>select语句查询的结果是一个包含多条数据的结果集，可以进行<code>交（intersect）、并（union）和差（minus）运算</code></p>
<ul>
<li>对两个结果集进行集合运算，这两个结果集必须满足如下条件：<blockquote>
<p>对两个结果集所包含的<code>数据列的数量必须相等</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>两个结果集所包含的数据列的<code>数据类型也必须一一对应</code></p>
</blockquote>
<ol>
<li>union运算<blockquote>
<p>select 语句 union select 语句</p>
</blockquote>
</li>
</ol>
<pre><code>select * from teacher_table
union
#这个结果集的数据列必须与前一个结果集的数据列一一对应
select student_id,student_name from student_table;</code></pre><blockquote>
<p><code>union会自动把重复的内容去掉，若要不去掉重复内容，可使用 union all</code></p>
</blockquote>
<p>2.minus运算</p>
<blockquote>
<p>select 语句 minus select 语句</p>
</blockquote>
<ul>
<li>MySQL并不支持minus运算符，相同运算：<pre><code class="sql">select student_id,student_name from student_table
where (student_id,student_name)
not in 
(select teacher_id,teacher_name from teacher_table);</code></pre>
</li>
</ul>
<p>3.intersect运算</p>
<blockquote>
<p>select 语句 intersect select 语句</p>
</blockquote>
<ul>
<li>MySQL并不支持intersect语句，相同运算：<pre><code class="sql">select student_id ,student_name from student_table
join 
teacher_table
on (student_id =teacher_id and student_name=teacher_name);</code></pre>
<pre><code class="sql">select student_id,student_name from student_table
join 
teacher_table
on (student_id=teacher_id and student_name=teacher_name)
where student_id&lt;4 and teacher_name like &#39;李%&#39;;</code></pre>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2></li>
<li>触发器（trigger）由事件触发某个操作，这些事件包括insert into、updata、delete from语句</li>
<li>创建触发器</li>
</ul>
<ol>
<li>创建只有一个执行语句的触发器<pre><code>create trigger 触发器名 before|after 触发事件
on 表名 for each row  执行语句</code></pre><pre><code>create trigger trigger_name after insert
on t_book for each row 
update t_booktype set bookNum=bookMun+1 where new.bookTypeId = t_booktype.id;</code></pre></li>
</ol>
<ul>
<li>过渡变量：<blockquote>
<p>new :<code>只能出现在insert和update出现时</code>，在insert时表示新插入的行数据，在update表示要替换的新数据</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>old:<code>只能出现在delete和update出现时</code>，在delete时表示被删除的数据，在update表示被更改的原来的数据行</p>
</blockquote>
<ul>
<li>before 和after 的区别：<blockquote>
<p>before:在记录操纵之前触发，是先完成触发，在增删改，触发的语句先于监视的增删改；<code>（insert、update）可以对new进行修改</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>after:在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作；<code>不能对new进行修改</code></p>
</blockquote>
<blockquote>
<p><code>两者都不能对old进行修改</code></p>
</blockquote>
<ol start="2">
<li>创建有多个执行语句的触发器<pre><code>delimiter |
create trigger 触发器名 before|after 触发事件
on 表名 for each row
begin
    执行语句列表;//每句后面用分号隔开
end
| delimiter ;</code></pre><blockquote>
<p>delimiter 重新定义结束符，保证完成全部操作，然后把结束符定义回分号 </p>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>使用delimiter把触发器包括起来</code>，因为MySQL执行语句后面都要加分号</p>
</blockquote>
<pre><code>delimiter |
  create trigger trig_name after delete
      on t_book for each row
      begin
        update t_bookType set bookName=bookName-1 where old.bookTypeId=t_booktype.id;
        insert into t_log values (null,now(),&#39;在book表里删除了一条数据&#39;);
        delete from t_test where old.bookTypeId=t_test.id;
      end
| delimeter ;</code></pre><ol start="3">
<li>查看触发器</li>
</ol>
<ul>
<li><code>show triggers</code>：查看所有触发器</li>
</ul>
<ol start="4">
<li>删除触发器<blockquote>
<p>drop trigger 触发器名；</p>
</blockquote>
<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2></li>
</ol>
<ul>
<li>存储过程和函数是在数据库中定义一些SQL语句的集合，然后直接调用这些存储过程和函数来执行已经定义好的SQL语句。</li>
<li>创建存储过程:<code>create procedure</code><pre><code>create procedure 名称([proc_parameter[,...])
   [characteristic...]routine_body</code></pre><blockquote>
<p>proc_premeter 表示存储过程的参数列表；每个参数由3部分组成，分别为<code>输出输入类型、参数名称、参数类型</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>[in|out|inout]param_name type</code></p>
</blockquote>
<ul>
<li>其中in表示输入参数；out表示输出参数；inout表示既可以输入，也可以输出；<blockquote>
<p>characteristic 参数有多个取值：</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>languange sql:说明routine_body部分由sql语句组成，这也是系统默认语言</p>
</li>
<li><p>[not] deterministic: 指明存储过程的执行结果是否是确定的。deterministic表示结果是确定的，<code>每次执行存储过程，相同输入会得到相同的输出</code>；not deterministic 表示结果是非确定的，<code>相同的输入可能得到不同的输出，默认情况下都是非确定的</code></p>
</li>
<li><p>{contains SQL|NO SQL|reads sql data|modifies SQL data}： 指明子程序使用sql语句的限制，<code>默认使用contains SQL</code></p>
<blockquote>
<p>contain sql:表示子程序包含SQL语句，<code>但不包含读或写数据的语句</code></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>no sql： 表示<code>子程序中不包含SQL语句</code></p>
</blockquote>
<blockquote>
<p>read SQL data：表示<code>子程序中包含读数据的语句</code></p>
</blockquote>
<blockquote>
<p>modifies sql data： 表示<code>子程序中包含写数据的语句</code></p>
</blockquote>
<pre><code>delimiter &amp;&amp;
create procedure 存储过程名( in 变量 int,out count_num int)
   read sql data
   begin
      select count(*) from 表名 where bookTypeId=变量；
    end 
    &amp;&amp;
delimiter ；</code></pre><ul>
<li>创建存储函数<pre><code>create function 函数名([func_parameter[,..]])
  return type
  [characteristic..] routine_body</code></pre>func_parameter 表示存储函数的参数列表；可以由多个参数组成，<code>每个参数由参数名称和参数类型组成</code>：<blockquote>
<p>参数名称 参数类型</p>
</blockquote>
</li>
</ul>
<p><code>return type指定返回值类型</code></p>
<p>characteristic 参数指定存储过程的特性，该参数的取值与存储过程中的取值是一样的</p>
<p>routine_body参数是SQL代码的内容，可以使用begin…end来标志SQL代码的开始和结束</p>
<pre><code>delimiter &amp;&amp;
create function func_book( 变量)
  return varchar(20)
  begin 
    return (select bookName from t_book where id=bookId);
  end
  &amp;&amp;
delimiter ;</code></pre><ul>
<li>调用存储过程和函数</li>
</ul>
<p>1.调用存储过程：</p>
<pre><code>call 存储过程名(参数)</code></pre><ol start="2">
<li>调用存储函数：<pre><code>fun_name(参数)</code></pre></li>
</ol>
<ul>
<li>查看存储过程和函数</li>
</ul>
<ol>
<li><p>show status 语句查看存储过程和函数的状态( <code>只能查看属性状态</code>)</p>
<blockquote>
<p>show procedure|function status [like 存储过程名|函数名]</p>
</blockquote>
</li>
<li><p>show create语句查看存储过程的函数的定义(<code>能够查到定义</code>)</p>
<blockquote>
<p>show create procedure|function 存储过程名或函数名</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>修改存储过程和函数</p>
<pre><code>alter prcedure|function 存储过程|函数名(变量)
characteristic:
( [contains SQL|no SQL|read SQL data|modifies SQL data|SQL security(definer|invoder])
comment &#39;string&#39;(修改内容)</code></pre><blockquote>
<p>sql security指明谁有权限来执行，definer表示只有定义者自己才能够执行，invoder表示调用者也可以执行，comment’string’是注释信息</p>
</blockquote>
</li>
<li><p>删除存储过程和函数</p>
<blockquote>
<p>drop procedure|function 存储名或者函数名；</p>
</blockquote>
</li>
<li><p>变量的使用</p>
</li>
</ul>
<ol>
<li>定义变量<blockquote>
<p>declare var_name[,…] type [default value]</p>
</blockquote>
</li>
</ol>
<p>2.为变量赋值</p>
<blockquote>
<p>set var_name = expr[,var_name[,…]]</p>
</blockquote>
<pre><code>select col_name[,..] into var_name[,...]
          from table name where condition</code></pre><pre><code>#定义变量与使用第一种赋值方法
delimiter &amp;&amp;
create procedure pro_user()
      begin
         declare a,b varchar(20);
         set a=&#39;XXXX&#39;,b=&#39;xxxx&#39;;
         insert into t_user values (NULL,a,b)
       end
&amp;&amp;
deliiter ;

#第二种赋值
delimiter &amp;&amp;
create procedure pro_user()
      begin
         declare a,b varchar(20);
         select userName，password into a,b from t_user2 where id=2;
         insert into t_user values (NULL,a,b)
       end
&amp;&amp;
deliiter ;</code></pre><ul>
<li>游标的使用<blockquote>
<p>查询语句可能查出多条记录，在存储过程和函数中必须<code>使用游标来逐条读取查询结果集中的记录</code>。游标的使用包括声明游标、打开游标、使用游标和关闭游标。<code>游标必须声明在处理程序之前，并且声明在变量和条件之后。</code></p>
</blockquote>
</li>
</ul>
<ol>
<li><p>声明游标</p>
<blockquote>
<p>delare cursor_name cursor for select_statement(对某个查询语句的游标）；</p>
</blockquote>
</li>
<li><p>打开游标</p>
<blockquote>
<p>open cursor_name;</p>
</blockquote>
</li>
<li><p>使用游标</p>
<blockquote>
<p>fetch cursor_name into var_name[,var_name…]</p>
</blockquote>
</li>
<li><p>关闭游标</p>
<blockquote>
<p>close cuesor_name;</p>
</blockquote>
</li>
</ol>
<pre><code>delimiter &amp;&amp;
create procedure pro_user()
      begin
         declare a,b varchar(20);
         declare 游标名 cursor for select userName,password from t_user;
         open 游标名；
         fetch 游标名 into a,b;
         insert into t_user values (NULL,a,b);
         close 游标名；
       end
&amp;&amp;
deliiter ;</code></pre><ul>
<li>流程控制的使用<blockquote>
<p>流程控制语句包括if、case、loop、leave、iterate、repeat和while语句</p>
</blockquote>
</li>
</ul>
<ol>
<li>if语句<pre><code>if search_condition then statement_list
[elseif search_condition then statement_list]...
[else statement_list]
end if;</code></pre><pre><code>delimiter &amp;&amp;
create procedure pro_user(in bookId int)
   begin
      select count(*) into @num from t_user whrer id=bookId;
      if @num&gt;0 then updata t_user set userName=&#39;xxxx&#39; where id=bookId;
      else
         insert into t_user values (NULL,&#39;xxxx&#39;,&#39;xxxxx&#39;);
     end if;
    end
&amp;&amp;
deliiter ;
</code></pre></li>
</ol>
<pre><code>2. case 语句</code></pre><p>case case_value<br>   when when_value then statement_list<br>   [when when_value then statement_list]…<br>   [else ststement_list]<br>end case;</p>
<pre><code></code></pre><p>delimiter &amp;&amp;<br>create procedure pro_user(in bookId int)<br>      begin<br>         select count(*) into @num from t_user whrer id=bookId;<br>         case @num<br>           when 1 then update t_user set user_name=’xxx’ where id=bookId;<br>           when 2 then insert into t_user values (NULL,’xxx’,’xxxx’);<br>           else insert into t_user values(NULL,’xxxx’,’xxxx’);<br>         end case;<br>       end<br>&amp;&amp;<br>deliiter ;</p>
<pre><code>3. loop,leave语句
&gt; loop 语句可以使某些特定的语句重复执行，实现一个简单的循环，但是`loop语句本身没有停止循环的语句，必须遇到leave语句等才能停止循环`</code></pre><p>[begin_label:]loop<br>       statement_list<br>end loop [end_label]</p>
<pre><code>&gt; leave语句主要用于跳出循环：`leave label`
</code></pre><p>delimiter &amp;&amp;<br>create procedure pro_user(in bookId int)<br>      begin<br>         aaa: loop<br>           set totalNum=totalNum-1;<br>           if totalNum=0 then leave aaa;<br>           else insert into t_user values(totalNum,’xxxx’,’xxxxx’);<br>           end if;<br>         end loop aaa;<br>       end<br>&amp;&amp;<br>deliiter ;</p>
<pre><code>4. iterate语句
&gt; iterate 语句也是用来跳出循环的，但是iterate语句`跳出本次循环，然后进行下次循环`:`iterate label`</code></pre><p>delimiter &amp;&amp;<br>create procedure pro_user(in bookId int)<br>      begin<br>         aaa: loop<br>           set totalNum=totalNum-1;<br>           if totalNum=0 then leave aaa;<br>           elseif totalNum=3 then iterate aaa;<br>           end if;<br>           insert into t_uesr values(totalNum,’xxx’,’xxxxx’);<br>         end loop aaa;<br>       end<br>&amp;&amp;<br>deliiter ;</p>
<pre><code>5. repeat语句
&gt; repeat语句是有条件的循环语句，当满足特定条件时，就会跳出循环语句</code></pre><p>[begin_label:]repeat<br>       statement_list<br>       until search_condition<br>end repeat[end_list]</p>
<pre><code></code></pre><p>delimiter &amp;&amp;<br>create procedure pro_user(in bookId int)<br>      begin<br>        repeat<br>            set totalNum=totalNum-1;<br>            insert into t_user values (totalNum,’xxxx’,’xxxxx’);<br>            until totalNum=1;<br>        end repeat;<br>       end<br>&amp;&amp;<br>deliiter ;</p>
<pre><code>6.while语句</code></pre><p>[begin_label:]while search_condition do(别忘了)<br>     statement_list<br>end while[end_label]</p>
<pre><code></code></pre><p>delimiter &amp;&amp;<br>create procedure pro_user(in bookId int)<br>      begin<br>        while totalNum &gt;0 do<br>            insert into t_user values (totalNum,’xxxx’,’xxxxx’);<br>            set totalNum=totalNum-1；<br>        end while;<br>       end<br>&amp;&amp;<br>deliiter ;</p>
<pre><code># 事务
事务表示进行一系列操作，在失败的情况下能够退回原来的状态，成功时则继续往下进行
- 使用`BEGIN`表示开始一个事务
- `COMMIT`:出现在事务中的最后，只有在所有的查询成功地执行之后才执行此命令
- `ROLLLBACK`:当事务中的系列查询的一个或者多个失败时将使用这个命令，并且把相关的表恢复到事务之前的状态（在每个执行语句后面都加）</code></pre><p>BEGIN;<br>数据库操作语句;<br>ROLLBACK;<br>…</p>
<p>COMMIT;</p>
<pre><code>
# MySQL数据库导出和导入

导出：
```shell
mysqldump -u root -p 数据库名&gt; 导出的文件名及路径</code></pre><p>导入：（先创建数据库）</p>
<pre><code class="shell">mysql&gt;source 文件</code></pre>
<h1 id="MySQL创建用户和授权"><a href="#MySQL创建用户和授权" class="headerlink" title="MySQL创建用户和授权"></a>MySQL创建用户和授权</h1><p>创建：</p>
<pre><code class="shell">CREATE USER &#39;用户名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre>
<p>授权：</p>
<pre><code class="shell">GRANT ALL/SELECT/UPDATE/DELETE/UPDATE ON 数据库名.指定表（或*） TO &#39;用户名&#39;;</code></pre>
<p>撤销权限：</p>
<pre><code class="shell">REVOKE ALL/... ON 数据库名 FROM &#39;用户名&#39;@&#39;localhost&#39;;</code></pre>
<p>删除用户：</p>
<pre><code class="shell">DROP USER &#39;用户名&#39;;</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/04/18/HTML%20CSS/" rel="prev" title="HTML CSS">
      <i class="fa fa-chevron-left"></i> HTML CSS
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/04/21/php/" rel="next" title="php">
      php <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL基本命令"><span class="nav-number">1.</span> <span class="nav-text">MySQL基本命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL数据库存储机制"><span class="nav-number">2.</span> <span class="nav-text">MySQL数据库存储机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL语句基础"><span class="nav-number">3.</span> <span class="nav-text">SQL语句基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DDL语句：操作数据库对象的语句"><span class="nav-number">3.1.</span> <span class="nav-text">DDL语句：操作数据库对象的语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建表的语法"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建表的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看表结构的语法"><span class="nav-number">3.1.2.</span> <span class="nav-text">查看表结构的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改表结构的语法"><span class="nav-number">3.1.3.</span> <span class="nav-text">修改表结构的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增加列定义"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">增加列定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改列定义"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">修改列定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除列"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">删除列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重命名数据表"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">重命名数据表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全改变列定义-change"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">完全改变列定义 change</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除表的语法"><span class="nav-number">3.1.4.</span> <span class="nav-text">删除表的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate-表"><span class="nav-number">3.1.5.</span> <span class="nav-text">truncate 表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库约束"><span class="nav-number">3.2.</span> <span class="nav-text">数据库约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NOT-NULL约束"><span class="nav-number">3.2.1.</span> <span class="nav-text">NOT NULL约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIQUE约束"><span class="nav-number">3.2.2.</span> <span class="nav-text">UNIQUE约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PRIMARY-KEY约束"><span class="nav-number">3.2.3.</span> <span class="nav-text">PRIMARY KEY约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FOREIGN-KEY约束"><span class="nav-number">3.2.4.</span> <span class="nav-text">FOREIGN KEY约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引"><span class="nav-number">3.3.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-number">3.4.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML语句：操作数据表里的数据"><span class="nav-number">3.5.</span> <span class="nav-text">DML语句：操作数据表里的数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据列实际上可当成一个变量"><span class="nav-number">4.</span> <span class="nav-text">数据列实际上可当成一个变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库函数"><span class="nav-number">4.1.</span> <span class="nav-text">数据库函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取当前日期"><span class="nav-number">5.</span> <span class="nav-text">获取当前日期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#截断和填充函数"><span class="nav-number">5.0.1.</span> <span class="nav-text">截断和填充函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位和位置函数"><span class="nav-number">5.0.2.</span> <span class="nav-text">定位和位置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子字符串函数"><span class="nav-number">5.0.3.</span> <span class="nav-text">子字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串修改函数"><span class="nav-number">5.0.4.</span> <span class="nav-text">字符串修改函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加密函数"><span class="nav-number">5.0.5.</span> <span class="nav-text">加密函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null-处理函数"><span class="nav-number">5.0.6.</span> <span class="nav-text">null 处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#间隔分析函数"><span class="nav-number">5.0.7.</span> <span class="nav-text">间隔分析函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组和组函数"><span class="nav-number">5.1.</span> <span class="nav-text">分组和组函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多表连接查询"><span class="nav-number">5.2.</span> <span class="nav-text">多表连接查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子查询：在查询语句中嵌套另一个查询"><span class="nav-number">5.3.</span> <span class="nav-text">子查询：在查询语句中嵌套另一个查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合运算"><span class="nav-number">5.4.</span> <span class="nav-text">集合运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#触发器"><span class="nav-number">5.5.</span> <span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储过程和函数"><span class="nav-number">5.6.</span> <span class="nav-text">存储过程和函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL创建用户和授权"><span class="nav-number">6.</span> <span class="nav-text">MySQL创建用户和授权</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">2.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
