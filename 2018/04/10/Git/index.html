<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Git</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Git</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Git-简介"><span class="toc-text">Git 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建版本库"><span class="toc-text">创建版本库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#把文件添加到版本库"><span class="toc-text">把文件添加到版本库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#记录修改及查看"><span class="toc-text">记录修改及查看</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#修改记录"><span class="toc-text">修改记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#版本回退"><span class="toc-text">版本回退</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作区和暂存区"><span class="toc-text">工作区和暂存区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理修改"><span class="toc-text">管理修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#撤销修改"><span class="toc-text">撤销修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除文件"><span class="toc-text">删除文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#远程仓库"><span class="toc-text">远程仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加远程库"><span class="toc-text">添加远程库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支管理策略"><span class="toc-text">分支管理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bug分支"><span class="toc-text">Bug分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feature分支"><span class="toc-text">Feature分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多人协作"><span class="toc-text">多人协作</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/git"><i class="tag post-item-tag">git</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Git</h1><time class="has-text-grey" datetime="2018-04-09T16:00:00.000Z">2018-04-10</time><article class="mt-2 post-content"><h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><ol>
<li>分布式版本控制系统，能够记录操作的历史记录</li>
<li>完成安装后需要的配置：<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;</code></pre><blockquote>
<p>git config 命令的–global参数，表示使用的这台机器上所有的Git仓库都会使用这个配置</p>
</blockquote>
</li>
</ol>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ol>
<li>选择某个文件夹，打开<code>Git Bash here</code><pre><code>$ mkdir learngit
$cd learngit
$pwd
&lt;!--将会显示出当前文件夹目录--&gt;</code></pre><blockquote>
<p>pwd命令用于显示当期目录</p>
</blockquote>
<a id="more"></a></li>
<li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/</code></pre><blockquote>
<p>当前目录下多了一个.git的目录,没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
</blockquote>
</li>
</ol>
<h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><ol>
<li>把编辑的文件放到learngit目录下</li>
<li>用命令<code>git add</code>告诉Git，把文件添加到仓库：<blockquote>
<p>$ git add readme.txt</p>
</blockquote>
</li>
<li>使用命令<code>git commit</code>告诉Git，把文件提交到仓库<pre><code>$ git commit -m &quot;wrote a readme.text&quot;</code></pre><blockquote>
<p>-m后面输入的是本次提交的说明，可以输入任意内容</p>
</blockquote>
</li>
</ol>
<h1 id="记录修改及查看"><a href="#记录修改及查看" class="headerlink" title="记录修改及查看"></a>记录修改及查看</h1><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><pre><code>git status 
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#    modified:   readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><blockquote>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
</blockquote>
<p>查看具体修改了什么内容</p>
<blockquote>
<p><code>$git diff readme.txt</code></p>
</blockquote>
<p>修改完把其提交到仓库</p>
<blockquote>
<p>$ git add readme.txt</p>
</blockquote>
<blockquote>
<p>$ git commit -m “add distributed”</p>
</blockquote>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol>
<li><code>git log</code>命令：告诉我们修改的历史记录，显示从最近到最远的提交日志；加上 <code>--pretty=oneline参数</code>，显示一堆版本号<pre><code>$ git log --pretty=oneline
3628164fb26d48395383f8f31179f24e0882e1e0 append GPL
ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed
cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</code></pre></li>
<li><code>git reset</code>: 返回某个指定的版本<blockquote>
<p>Git必须知道当前版本是哪个版本，在Git中, <code>用HEAD表示当前版本,上一个版本就是HEAD^，上上一个版本就是HEAD\^\^</code>,当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
</blockquote>
<pre><code>$ git reset -hard HEAD^</code></pre><pre><code>//回到指定的版本，包括前一个和后一个
$ git reset -hard (版本号)//版本号没必要写全，前几位就可以了，Git会自动去找。</code></pre></li>
<li><code>git reflog</code>:记录操作的每一条命令（包括版本号），用git reflog查看命令历史，以便确定要回到未来的哪个版本。<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2></li>
<li>工作区：在电脑看到的目录</li>
<li>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li>
</ol>
<blockquote>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
</blockquote>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt=""></p>
<p>用git add把文件添加进去，实际上就是<code>把文件修改添加到暂存区</code>；</p>
<p>用git commit提交更改，实际上就是<code>把暂存区的所有内容提交到当前分支</code>。</p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><ol>
<li>Git 管理的是修改</li>
<li><code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</li>
<li>每次修改，如果不add到暂存区，那就不会加入到commit中。<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2></li>
<li><code>git checkout -- file</code>可以<code>丢弃工作区</code>的修改<pre><code>$ git checkout -- readme.txt</code></pre>命令git checkout – readme.txt意思就是，把readme.txt文件在<code>工作区</code>的修改全部撤销，这里有两种情况：</li>
</ol>
<p>一种是readme.txt自修改后还<code>没有被放到暂存区</code>，现在，撤销修改就<code>回到和版本库一模一样的状态</code>；</p>
<p>一种是readme.txt已经<code>添加到暂存区后</code>，又作了修改，现在，撤销修改就回到<code>添加到暂存区后的状态</code>。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>2. 使用<code>cat 文件名</code>可以查看文件内容</p>
<ol start="3">
<li><code>git reset HEAD file</code>可以把<code>暂存区</code>的修改撤销掉（unstage），重新放回工作区<pre><code>$ git reset HEAD readme.txt
Unstaged changes after reset:
M       readme.txt</code></pre><blockquote>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>撤销暂存区的修改后，再次撤销工作区的修改即可</p>
</blockquote>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ol>
<li>对于工作区的文件，可以直接在文件管理器或者用<code>rm 文件名</code>命令删除<pre><code>$ rm test.txt</code></pre></li>
<li>删除工作区文件后，工作区和版本库就不一致了</li>
</ol>
<ul>
<li>两种情况：<blockquote>
<p>一是确实要从版本库中删除该文件，那就<code>用命令git rm删掉，并且git commit</code>：</p>
</blockquote>
<pre><code>$ git rm test.txt
rm &#39;test.txt&#39;
$ git commit -m &quot;remove test.txt&quot;
[master d17efd8] remove test.txt
1 file changed, 1 deletion(-)
delete mode 100644 test.txt</code></pre><blockquote>
<p>另一种情况是删错了，因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本：</p>
</blockquote>
<pre><code>$ git checkout -- test.txt</code></pre></li>
<li>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2></li>
<li>在本地的所需要关联的仓库下运行命令<pre><code>$ git remote add origin https://github.com/xiao-ming9/learngit.git
</code></pre></li>
</ul>
<p>//下一步把本地库的所有内容推到远程库上<br>$ git push -u origin master</p>
<pre><code>&gt;把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。

&gt; 以后只要本地做了提交，只需要 `$git push origin master`

## 从远程库克隆
- 在GitHub上创建一个存储库之后，在本地的仓库下运行命令`git clone`</code></pre><p>//ssh协议<br>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xiao-ming9/gitskills.git<br>//https协议<br>$ git clone <a href="https://github.com/xiao-ming9/gitskills.git" target="_blank" rel="noopener">https://github.com/xiao-ming9/gitskills.git</a></p>
<pre><code># 分支管理
## 创建与合并分支
1. 创建dev分支，然后切换到dev分支</code></pre><p>$ git checkout -b dev<br>Switched to a new branch ‘dev’</p>
<pre><code>- `git checkout 加上-b参数表示创建并切换`，相当于：
```git
$ git branch dev //创建分支
$ git checkout dev//合并分支</code></pre><ol start="2">
<li>查看当前分支<br>```<br>$ git branch</li>
</ol>
<p>*dev<br> master</p>
<pre><code>- `git branch`命令会列出所有分支，`当前分支前面会标一个*号`。
3. 切换回master分支</code></pre><p>$ git checkout master<br>Switched to branch ‘master’</p>
<pre><code>4. 把dev分支的工作成果合并到master分支上</code></pre><p>$ git merge dev<br>Updating d17efd8..fec145a<br>Fast-forward<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)</p>
<pre><code>
 &gt;`git merge命令用于合并指定分支到当前分支。`
 5. 删除dev分支</code></pre><p> $ git branch -d dev</p>
<pre><code> ## 解决冲突
 - 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用`git log --graph`命令可以看到分支合并图。</code></pre><p> $ git log –graph –pretty=oneline –abbrev-commit</p>
<ul>
<li>59bc1cb conflict fixed<br>|<br>| * 75a857c AND simple</li>
<li>| 400b400 &amp; simple<br>|/</li>
<li>fec145a branch test<br>…<br>```<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2></li>
</ul>
<ul>
<li>合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，<code>删除分支后，会丢掉分支信息</code>。</li>
<li>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
Merge made by the &#39;recursive&#39; strategy.
readme.txt |    1 +
1 file changed, 1 insertion(+)</code></pre></li>
<li>可以用带参数的git<br>log查看分支情况<pre><code>$ git log --graph --pretty=onrline --abbrev-commit</code></pre></li>
<li>分支策略</li>
</ul>
<p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本</p>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ul>
<li>修改bug前，若当前内容还不想提交，使用<code>git stash</code>把当前内容封藏<pre><code>$ git stash</code></pre></li>
<li><code>使用git stash list查看封藏内容</code><pre><code>$ git stash list
stash@{0}: WIP on dev: 6224937 add merge</code></pre></li>
<li>恢复方法：</li>
</ul>
<ol>
<li><code>git stash apply</code>：恢复后，stash内容并不删除，你需要<code>用git stash drop来删除</code>；</li>
<li><code>git stash pop</code>：恢复的同时把stash内容也删了</li>
</ol>
<ul>
<li><p>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>
<pre><code>$ git stash apply stash@{0}</code></pre><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2></li>
<li><p>开发一个新feature，最好新建一个分支；</p>
</li>
<li><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;强行删除</code>。</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2></li>
<li><p>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
</li>
</ul>
<ol>
<li>查看远程库信息：<code>git remote (-v)</code><pre><code>$ git remote
origin
</code></pre></li>
</ol>
<p>//git remote -v显示更详细的信息<br>$ git remote -v<br>origin  <a href="https://github.com/xiao-ming9/learngit.git" target="_blank" rel="noopener">https://github.com/xiao-ming9/learngit.git</a> (fetch)<br>origin  <a href="https://github.com/xiao-ming9/learngit.git" target="_blank" rel="noopener">https://github.com/xiao-ming9/learngit.git</a> (push)</p>
<pre><code>&gt;上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。
2. 推送分支

- 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：
&gt;git push origin master

如果要推送其他分支，比如dev，就改成：
&gt;git push origin dev

3.抓取分支
- 用`git pull`把最新的提交从origin/dev抓下来

- 如果git pull失败了，原因是`没有指定本地dev分支与远程origin/dev分支的链接`，根据提示，设置dev和origin/dev的链接：
&gt;`git branch --set-upstream dev origin/dev`
- 多人协作的工作模式通常是这样：

1. 首先，可以试图用`git push origin branch-name`推送自己的修改；

2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull试图合并`；

3. 如果合并有冲突，则解决冲突，并在本地提交；

4. 没有冲突或者解决掉冲突后，再用`git push origin branch-name`推送就能成功！

5. 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream branch-name origin/branch-name`。

&gt;在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；
# 标签管理
## 创建标签
1. 首先切换到需要打标签的分支上
2. 用`git tag &lt;name&gt;`创建一个新标签
&gt;$ git tag v1.0
3. 可以用命令`git tag`查看所有标签
&gt;$ git tag
- 默认标签是打在最新提交的commit上的,如果需要在之前的commit上打标签，可以找到历史提交的commit id，再打上标签即可</code></pre><p>$ git log –pretty=oneline –abbrev-commit</p>
<p>$ git tag v0.9 （commit id）</p>
<pre><code>4.

&gt;可以使用git show &lt;tagname&gt;查看标签信息

&gt;可以创建带有说明的标签，`用-a指定标签名，-m指定说明文字`</code></pre><p>$ git tag -a v0.1 -m “说明内容” commit id</p>
<pre><code>## 操作标签
1. 删除标签：</code></pre><p>$ git tag -d v0.1<br>Deleted tag ‘v0.1’ (was e078af9)</p>
<pre><code>2. 推送某个标签到远程：`git push origin &lt;tagname&gt;`，或者一次性推送：`git push origin --tags`
3. 如果标签已经推送到远程，则应该现在本地删除，然后在从远程删除</code></pre><p>$ git tag -d v0.9</p>
<p>$ git push origin :refs/tags/v0.9</p>
<pre><code># 使用码云
- 国内的Git托管服务
- 本地库可以与多个远程库互相同步，但是不能同名
# 自定义Git
- 让Git显示颜色：
&gt;git config --global color.ui true

## 忽略特殊文件
- 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，然后把.gitignore提交到Git，Git就会自动忽略这些文件。
- 如果添加一个文件到Git，添加不了，原因是这个文件被.gitignore忽略了，如果要添加：
1. 用`git add -f 文件名`强制添加
2. 可以用`git check-ignore`命令检查哪个规则写错：</code></pre><p>$ git check-ignore -v App.class<br>.gitignore:3:*.class   App.class</p>
<pre><code>## 配置别名
- 替换名字：
&gt;$ git config --global alias.新名字 旧名字</code></pre><p>#用st表示status，co表示commit，ci表示commit，br表示branch<br>$ git config –global alist.st status<br>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch</p>
<pre><code>- --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。
## 配置文件
- 配置Git的时候，`加上--global是针对当前用户起作用的`，`如果不加，那只针对当前的仓库起作用`。
1. 每个仓库的Git配置文件都`放在 .git/config文件中`</code></pre><p>$ cat .git/config<br>[core]<br>        repositoryformatversion = 0<br>        filemode = false<br>        bare = false<br>        logallrefupdates = true<br>        symlinks = false<br>        ignorecase = true<br>[branch “master”]<br>[remote “github”]<br>        url = <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xiao-ming9/learngit.git<br>        fetch = +refs/heads/<em>:refs/remotes/github/</em><br>[remote “gitee”]<br>        url = <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:xiao_ming9/learngit.git<br>        fetch = +refs/heads/<em>:refs/remotes/gitee/</em></p>
<pre><code>2. 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中</code></pre><p>$cat .gitconfig<br>[user]<br>        name = xingziming<br>        email = <a href="mailto:934933088@qq.com" target="_blank" rel="noopener">934933088@qq.com</a><br>[color]<br>        ui = true</p>
<pre><code>- 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</code></pre></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2018/04/18/HTML%20CSS/" title="HTML CSS"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: HTML CSS</span></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>