<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="常用代码段new() 和 make() 选择 切片、映射和通道，使用 make   数组、结构体和所有的值类型，使用 new    new 出来的是一个指针  字符串相关操作修改字符串的一个字符str:&#x3D;&quot;hello&quot; c:&#x3D;[]byte(str) c[0]&#x3D;&#39;c&#39; s2:&#x3D; string(c) &#x2F;&#x2F; s2 &#x3D;&#x3D; &quot;cello&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="go 实用代码片段和注意事项">
<meta property="og:url" content="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="常用代码段new() 和 make() 选择 切片、映射和通道，使用 make   数组、结构体和所有的值类型，使用 new    new 出来的是一个指针  字符串相关操作修改字符串的一个字符str:&#x3D;&quot;hello&quot; c:&#x3D;[]byte(str) c[0]&#x3D;&#39;c&#39; s2:&#x3D; string(c) &#x2F;&#x2F; s2 &#x3D;&#x3D; &quot;cello&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png">
<meta property="article:published_time" content="2020-08-20T03:45:18.000Z">
<meta property="article:modified_time" content="2022-12-03T14:25:10.240Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png">


<link rel="canonical" href="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","path":"2020/08/20/go 实用代码片段和注意事项/","title":"go 实用代码片段和注意事项"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go 实用代码片段和注意事项 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-number">1.</span> <span class="nav-text">常用代码段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E5%92%8C-make-%E9%80%89%E6%8B%A9"><span class="nav-number">1.1.</span> <span class="nav-text">new() 和 make() 选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">字符串相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">修改字符串的一个字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="nav-number">1.2.2.</span> <span class="nav-text">获取字符串的字串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-for-%E6%88%96%E8%80%85-for-range-%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用 for 或者 for-range 遍历一个字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">获取一个字符串的字节数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%EF%BC%9A"><span class="nav-number">1.2.5.</span> <span class="nav-text">获取一个字符串的字符数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.2.6.</span> <span class="nav-text">字符串拼接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.3.</span> <span class="nav-text">打印字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E7%9A%84%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.4.</span> <span class="nav-text">优雅实现存储单位的常量枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">优雅的进行错误检测和处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.6.</span> <span class="nav-text">反射常用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%8D%95%E6%B5%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">写单测相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%B8%A6-body-%E7%9A%84-http-Response"><span class="nav-number">1.7.1.</span> <span class="nav-text">构造带 body 的 http Response</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-http-ResponseWriter"><span class="nav-number">1.7.2.</span> <span class="nav-text">构造 http ResponseWriter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#time-%E7%9A%84%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">time 的时区设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">空结构体的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">3.1.</span> <span class="nav-text">实现方法接收者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">实现集合类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%A9%BA%E9%80%9A%E9%81%93"><span class="nav-number">3.3.</span> <span class="nav-text">实现空通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">go 中常用的包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#regexp%E5%8C%85"><span class="nav-number">4.1.</span> <span class="nav-text">regexp包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-%E5%8C%85"><span class="nav-number">4.2.</span> <span class="nav-text">sync 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%BE%E5%AF%86%E8%AE%A1%E7%AE%97%E5%92%8Cbig%E5%8C%85"><span class="nav-number">4.3.</span> <span class="nav-text">精密计算和big包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">5.</span> <span class="nav-text">常见错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%AF%BC%E8%87%B4%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="nav-number">5.1.</span> <span class="nav-text">短变量声明导致变量覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%AF%B9%E9%9C%80%E8%A6%81-append-%E7%9A%84%E7%A9%BA%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8-make-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">不要对需要 append 的空切片使用 make 声明变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AF%E7%94%A8-defer-%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.</span> <span class="nav-text">误用 defer 关闭一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%88%87%E7%89%87%E7%9A%84%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">不需要将一个指向切片的指针传递给函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#append-%E6%95%B0%E7%BB%84%E6%97%B6%EF%BC%8C%E5%BF%BD%E7%95%A5%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">5.5.</span> <span class="nav-text">append 数组时，忽略对底层数组的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%B0%86%E5%88%87%E7%89%87%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85-append"><span class="nav-number">5.6.</span> <span class="nav-text">不要将切片作为入参在函数内 append</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.7.</span> <span class="nav-text">不要使用指针指向接口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">5.8.</span> <span class="nav-text">注意循环中的协程使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84-HTTP-Client"><span class="nav-number">5.9.</span> <span class="nav-text">不要在生产环境使用默认的 HTTP Client</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">5.9.1.</span> <span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.9.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E7%9A%84key-value%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E6%96%AD%E8%A8%80"><span class="nav-number">5.10.</span> <span class="nav-text">map的key,value不能同时断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E7%9F%A5%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="nav-number">5.11.</span> <span class="nav-text">未知枚举值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="nav-number">5.11.1.</span> <span class="nav-text">基准测试自动优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%81%E7%A7%BB%E5%88%B0%E5%A0%86%E4%B8%8A%E5%AF%BC%E8%87%B4%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E6%AF%94%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E6%9B%B4%E6%85%A2"><span class="nav-number">5.12.</span> <span class="nav-text">指针迁移到堆上导致指针传递比按值传递更慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-%E9%80%BB%E8%BE%91%E4%B8%8D%E7%AC%A6%E5%90%88%E9%A2%84%E6%9C%9F"><span class="nav-number">5.13.</span> <span class="nav-text">break 逻辑不符合预期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">5.14.</span> <span class="nav-text">缺失上下文的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%90%8D%E7%BB%99%E5%87%BD%E6%95%B0"><span class="nav-number">5.15.</span> <span class="nav-text">传递文件名给函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BA%E4%BA%8E%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%BB%BA%E8%AE%AE"><span class="nav-number">6.</span> <span class="nav-text">出于性能考虑的最佳实践和建议</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go 实用代码片段和注意事项 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 实用代码片段和注意事项
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 11:45:18" itemprop="dateCreated datePublished" datetime="2020-08-20T11:45:18+08:00">2020-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-03 22:25:10" itemprop="dateModified" datetime="2022-12-03T22:25:10+08:00">2022-12-03</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="常用代码段"><a href="#常用代码段" class="headerlink" title="常用代码段"></a>常用代码段</h1><h2 id="new-和-make-选择"><a href="#new-和-make-选择" class="headerlink" title="new() 和 make() 选择"></a>new() 和 make() 选择</h2><ul>
<li><p>切片、映射和通道，使用 make </p>
</li>
<li><p>数组、结构体和所有的值类型，使用 new</p>
</li>
</ul>
<blockquote>
<p>new 出来的是一个指针</p>
</blockquote>
<h2 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h2><h3 id="修改字符串的一个字符"><a href="#修改字符串的一个字符" class="headerlink" title="修改字符串的一个字符"></a>修改字符串的一个字符</h3><pre><code class="go">str:=&quot;hello&quot;
c:=[]byte(str)
c[0]=&#39;c&#39;
s2:= string(c) // s2 == &quot;cello&quot;
</code></pre>
<span id="more"></span>

<h3 id="获取字符串的字串"><a href="#获取字符串的字串" class="headerlink" title="获取字符串的字串"></a>获取字符串的字串</h3><pre><code class="go">substr := str[n:m]
</code></pre>
<h3 id="使用-for-或者-for-range-遍历一个字符串"><a href="#使用-for-或者-for-range-遍历一个字符串" class="headerlink" title="使用 for 或者 for-range 遍历一个字符串"></a>使用 <code>for</code> 或者 <code>for-range</code> 遍历一个字符串</h3><pre><code class="go">// gives only the bytes:
for i:=0; i &lt; len(str); i++ &#123;
… = str[i]
&#125;
// gives the Unicode characters:
for ix, ch := range str &#123;
…
&#125;
</code></pre>
<h3 id="获取一个字符串的字节数"><a href="#获取一个字符串的字节数" class="headerlink" title="获取一个字符串的字节数"></a>获取一个字符串的字节数</h3><p><code>len(str)</code></p>
<h3 id="获取一个字符串的字符数："><a href="#获取一个字符串的字符数：" class="headerlink" title="获取一个字符串的字符数："></a>获取一个字符串的字符数：</h3><p>最快速：<code>utf8.RuneCountInString(str)</code></p>
<p><code>len([]int(str))</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 <code>a += b</code> 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中</strong>。</p>
<pre><code class="go">var b bytes.Buffer
...
for condition &#123;
    b.WriteString(str) // 将字符串str写入缓存buffer
&#125;
    return b.String()
</code></pre>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>函数 <code>Printf</code> 主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：</p>
<pre><code class="go">func Printf(format string, list of variables to be printed)
</code></pre>
<p>这个格式化字符串可以含有一个或多个的格式化标识符，例如：<code>%..</code>，其中 <code>..</code> 可以被不同类型所对应的标识符替换，如 <code>%s</code> 代表字符串标识符、<code>%v</code> 代表使用类型的默认输出格式的标识符。<strong>这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加</strong>，如果参数超过 1 个则需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。</p>
<p>函数 <code>fmt.Sprintf</code> 与 <code>Printf</code> 的作用是完全相同的，<strong>不过前者将格式化后的字符串以返回值的形式返回给调用者</strong>，因此可以在程序中使用包含变量的字符串。</p>
<p>函数 <code>fmt.Print</code> 和 <code>fmt.Println</code> 会自动使用格式化标识符 <code>%v</code> 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如：</p>
<pre><code class="go">fmt.Print(&quot;Hello:&quot;, 23)
</code></pre>
<p>将输出：<code>Hello: 23</code>。</p>
<p><strong>格式化说明符</strong></p>
<p>在格式化字符串里，<code>%d</code> 用于格式化整数（<code>%x</code> 和 <code>%X</code> 用于格式化 16 进制表示的数字），<code>%g</code> 用于格式化浮点型（<code>%f</code> 输出浮点数，<code>%e</code> 输出科学计数表示法），<code>%0d</code> 用于规定输出定长的整数，其中开头的数字 0 是必须的。</p>
<p><code>%n.mg</code> 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 <code>%5.2e</code> 来输出 3.4 的结果为 <code>3.40e+00</code>。</p>
<p><code>%b</code> 是用于表示位的格式化标识符。</p>
<p>格式化说明符 <code>%c</code> 用于表示字符；当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数；<code>%U</code> 输出格式为 U+hhhh 的字符串</p>
<p>指针的格式化标识符为 <code>%p</code></p>
<h2 id="优雅实现存储单位的常量枚举"><a href="#优雅实现存储单位的常量枚举" class="headerlink" title="优雅实现存储单位的常量枚举"></a>优雅实现存储单位的常量枚举</h2><p>使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：</p>
<pre><code class="go">type ByteSize float64
const (
    _ = iota // 通过赋值给空白标识符来忽略值
    KB ByteSize = 1&lt;&lt;(10*iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</code></pre>
<h2 id="优雅的进行错误检测和处理"><a href="#优雅的进行错误检测和处理" class="headerlink" title="优雅的进行错误检测和处理"></a>优雅的进行错误检测和处理</h2><p>避免写出这样的代码：</p>
<pre><code class="go">... err1 := api.Func1()
if err1 != nil &#123;
    fmt.Println(&quot;err: &quot; + err.Error())
    return
&#125;
err2 := api.Func2()
if err2 != nil &#123;
...
    return
&#125;    
</code></pre>
<p>首先，包括在一个初始化的 <code>if</code> 语句中对函数的调用。但即使代码中到处都是以 <code>if</code> 语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：</p>
<pre><code class="go">func httpRequestHandler(w http.ResponseWriter, req *http.Request) &#123;
    err := func () error &#123;
        if req.Method != &quot;GET&quot; &#123;
            return errors.New(&quot;expected GET&quot;)
        &#125;
        if input := parseInput(req); input != &quot;command&quot; &#123;
            return errors.New(&quot;malformed command&quot;)
        &#125;
        // 可以在此进行其他的错误检测
    &#125; ()

        if err != nil &#123;
            w.WriteHeader(400)
            io.WriteString(w, err)
            return
        &#125;
        doSomething() ...
</code></pre>
<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑</p>
<h2 id="反射常用示例"><a href="#反射常用示例" class="headerlink" title="反射常用示例"></a>反射常用示例</h2><pre><code class="go">type Child struct &#123;
    Name     string
    Grade    int
    Handsome bool
&#125;

type Adult struct &#123;
    ID         string `qson:&quot;Name&quot;`
    Occupation string
    Handsome   bool
&#125;

// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，
// 并且有一个字段的 tag 或者字段名是 `Name` ，
// 如果该 `Name` 字段的值是 `qcrao`，
// 就把结构体中名为 `Handsome` 的字段值设置为 true。
func handsome(i interface&#123;&#125;) &#123;
    // 获取 i 的反射变量 Value
    v := reflect.ValueOf(i)

    // 确定 v 是一个 Slice
    if v.Kind() != reflect.Slice &#123;
        return
    &#125;

    // 确定 v 是的元素为结构体
    if e := v.Type().Elem(); e.Kind() != reflect.Struct &#123;
        return
    &#125;

    // 确定结构体的字段名含有 &quot;ID&quot; 或者 json tag 标签为 `name`
    // 确定结构体的字段名 &quot;Handsome&quot;
    st := v.Type().Elem()

    // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
    foundName := false
    for i := 0; i &lt; st.NumField(); i++ &#123;
        f := st.Field(i)
        tag := f.Tag.Get(&quot;qson&quot;)

        if (tag == &quot;Name&quot; || f.Name == &quot;Name&quot;) &amp;&amp; f.Type.Kind() == reflect.String &#123;
            foundName = true
            break
        &#125;
    &#125;

    if !foundName &#123;
        return
    &#125;

    if niceField, foundHandsome := st.FieldByName(&quot;Handsome&quot;); foundHandsome == false || niceField.Type.Kind() != reflect.Bool &#123;
        return
    &#125;

    // 设置名字为 &quot;qcrao&quot; 的对象的 &quot;Handsome&quot; 字段为 true
    for i := 0; i &lt; v.Len(); i++ &#123;
        e := v.Index(i)
        handsome := e.FieldByName(&quot;Handsome&quot;)

        // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
        var name reflect.Value
        for j := 0; j &lt; st.NumField(); j++ &#123;
            f := st.Field(j)
            tag := f.Tag.Get(&quot;qson&quot;)

            if tag == &quot;Name&quot; || f.Name == &quot;Name&quot; &#123;
                name = v.Index(i).Field(j)
            &#125;
        &#125;

        if name.String() == &quot;qcrao&quot; &#123;
            handsome.SetBool(true)
        &#125;
    &#125;
&#125;

func main() &#123;
    children := []Child&#123;
        &#123;Name: &quot;Ava&quot;, Grade: 3, Handsome: true&#125;,
        &#123;Name: &quot;qcrao&quot;, Grade: 6, Handsome: false&#125;,
    &#125;

    adults := []Adult&#123;
        &#123;ID: &quot;Steve&quot;, Occupation: &quot;Clerk&quot;, Handsome: true&#125;,
        &#123;ID: &quot;qcrao&quot;, Occupation: &quot;Go Programmer&quot;, Handsome: false&#125;,
    &#125;

    fmt.Printf(&quot;adults before handsome: %v\n&quot;, adults)
    handsome(adults)
    fmt.Printf(&quot;adults after handsome: %v\n&quot;, adults)

    fmt.Println(&quot;-------------&quot;)

    fmt.Printf(&quot;children before handsome: %v\n&quot;, children)
    handsome(children)
    fmt.Printf(&quot;children after handsome: %v\n&quot;, children)
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code>adults before handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer false&#125;]
adults after handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer true&#125;]
-------------
children before handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 false&#125;]
children after handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 true&#125;]
</code></pre>
<p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p>
<p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p>
<p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p>
<h2 id="写单测相关"><a href="#写单测相关" class="headerlink" title="写单测相关"></a>写单测相关</h2><h3 id="构造带-body-的-http-Response"><a href="#构造带-body-的-http-Response" class="headerlink" title="构造带 body 的 http Response"></a>构造带 body 的 http Response</h3><pre><code class="go">&#123;Values: gomonkey.Params&#123;&amp;http.Response&#123;Body: io.NopCloser(strings.NewReader(&quot;&quot;))&#125;, nil&#125;&#125;,
</code></pre>
<h3 id="构造-http-ResponseWriter"><a href="#构造-http-ResponseWriter" class="headerlink" title="构造 http ResponseWriter"></a>构造 http ResponseWriter</h3><pre><code class="go">w := new(httptest.ResponseRecorder)
</code></pre>
<h1 id="time-的时区设置"><a href="#time-的时区设置" class="headerlink" title="time 的时区设置"></a>time 的时区设置</h1><p>对于需要使用时间的场景，默认情况下会从当前系统中找时区信息，如果需要手动设置时区，最好所有的解析和格式化的操作都指定时区信息：</p>
<pre><code class="go">t,_ := time.ParseInLocation(layout,inputTime,location)
dateTime := time.Unix(t.Unix(),0).In(loacation).Format(layout)
</code></pre>
<p>常用的 <code>Parse</code> 方法在解析时间模板时会使用读取参数中的时区信息，没有的话就采用 UTC 时间，此时如果再调用 <code>time.Unix(t.Unix(),0).In(loacation).Format(layout)</code> ，生成的时间会加上时区时间，所以最好采用上述方式，在解析的时候就把时区信息通过 <code>ParseInLocation</code> 传入，避免时区问题。</p>
<h1 id="空结构体的应用"><a href="#空结构体的应用" class="headerlink" title="空结构体的应用"></a>空结构体的应用</h1><p>在Go中，每一个基本类型都有对应的字节宽度，声明一个变量后即使不赋值，也需要占用一定的内存。但是对于空结构体来说，其字节宽度为0，因此可以用在某些场景下作为占位符而不占用存储空间。其使用场景主要有：</p>
<ul>
<li>实现方法接收者</li>
<li>实现集合类型</li>
<li>实现空通道</li>
</ul>
<h2 id="实现方法接收者"><a href="#实现方法接收者" class="headerlink" title="实现方法接收者"></a>实现方法接收者</h2><p>在某些业务场景下，需要将方法组合起来，代表一个分组，便于后续的拓展和维护。这时候就会使用空结构体，即节省内存，也便于未来针对该类型进行公共字段等的增加。</p>
<pre><code class="go">type T struct&#123;&#125;

func (s *T) Call() &#123;
 fmt.Println(&quot;脑子进煎鱼了&quot;)
&#125;

func main() &#123;
 var s T
 s.Call()
&#125;
</code></pre>
<p>在该场景下，使用空结构体从多维度来考量是最合适的，易拓展，省空间，最结构化。</p>
<h2 id="实现集合类型"><a href="#实现集合类型" class="headerlink" title="实现集合类型"></a>实现集合类型</h2><p>由于 Go 中并没有提供集合（Set）的相关支持，当需要自己实现时，可以使用 map 来替代，对于其 value，使用空结构作为占位符，不会额外增加不必要的内存开销：</p>
<pre><code class="go">type Set map[string]struct&#123;&#125;

func (s Set) Append(k string) &#123;
 s[k] = struct&#123;&#125;&#123;&#125;
&#125;

func (s Set) Remove(k string) &#123;
 delete(s, k)
&#125;

func (s Set) Exist(k string) bool &#123;
 _, ok := s[k]
 return ok
&#125;

func main() &#123;
 set := Set&#123;&#125;
 set.Append(&quot;煎鱼&quot;)
 set.Append(&quot;咸鱼&quot;)
 set.Append(&quot;蒸鱼&quot;)
 set.Remove(&quot;煎鱼&quot;)

 fmt.Println(set.Exist(&quot;煎鱼&quot;))
&#125;
</code></pre>
<h2 id="实现空通道"><a href="#实现空通道" class="headerlink" title="实现空通道"></a>实现空通道</h2><p>在 Go channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只要用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。</p>
<pre><code class="go">func main() &#123;
 ch := make(chan struct&#123;&#125;)
 go func() &#123;
  time.Sleep(1 * time.Second)
  close(ch)
 &#125;()

 fmt.Println(&quot;脑子好像进...&quot;)
 &lt;-ch
 fmt.Println(&quot;煎鱼了！&quot;)
&#125;
</code></pre>
<p>该程序会先输出 ”脑子好像进…“ 后，再睡眠一段时间再输出 “煎鱼了！”，达到间断控制 channel 的效果。</p>
<p>由于该 channel 使用的是空结构体，因此也不会带来额外的内存开销。</p>
<h1 id="go-中常用的包"><a href="#go-中常用的包" class="headerlink" title="go 中常用的包"></a>go 中常用的包</h1><h2 id="regexp包"><a href="#regexp包" class="headerlink" title="regexp包"></a>regexp包</h2><p>主要用于正则匹配。</p>
<p>如果是简单模式，使用 <code>Match</code> 方法便可：</p>
<pre><code class="go">ok, _ := regexp.Match(pat, []byte(searchIn))
</code></pre>
<p>变量 ok 将返回 true 或者 false, 也可以使用 <code>MatchString</code>：</p>
<pre><code class="go">ok, _ := regexp.MatchString(pat, searchIn)
</code></pre>
<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。然后我们将掌握一些匹配，查找，替换相关的功能。如下：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;regexp&quot;
    &quot;strconv&quot;
)
func main() &#123;
    //目标字符串
    searchIn := &quot;John: 2578.34 William: 4567.23 Steve: 5632.18&quot;
    pat := &quot;[0-9]+.[0-9]+&quot; //正则

    f := func(s string) string&#123;
        v, _ := strconv.ParseFloat(s, 32)
        return strconv.FormatFloat(v * 2, &#39;f&#39;, 2, 32)
    &#125;

    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok &#123;
        fmt.Println(&quot;Match Found!&quot;)
    &#125;

    re, _ := regexp.Compile(pat)
    //将匹配到的部分替换为&quot;##.#&quot;
    str := re.ReplaceAllString(searchIn, &quot;##.#&quot;)
    fmt.Println(str)
    //参数为函数时
    str2 := re.ReplaceAllStringFunc(searchIn, f)
    fmt.Println(str2)
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code>Match Found!
John: ##.# William: ##.# Steve: ##.#
John: 5156.68 William: 9134.46 Steve: 11264.36
</code></pre>
<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><p><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p>
<p>假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 <code>Mutex</code> 来实现的一个典型例子如下：</p>
<pre><code class="go">import  &quot;sync&quot;

type Info struct &#123;
    mu sync.Mutex
    // ... other fields, e.g.: Str string
&#125;
</code></pre>
<p>如果一个函数想要改变这个变量可以这样写:</p>
<pre><code class="go">func Update(info *Info) &#123;
    info.mu.Lock()
    // critical section:
    info.Str = // new value
    // end critical section
    info.mu.Unlock()
&#125;
</code></pre>
<p>还有一个很有用的例子是通过 Mutex 来实现一个可以上锁的共享缓冲器:</p>
<pre><code class="go">type SyncedBuffer struct &#123;
    lock    sync.Mutex
    buffer  bytes.Buffer
&#125;
</code></pre>
<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。</p>
<h2 id="精密计算和big包"><a href="#精密计算和big包" class="headerlink" title="精密计算和big包"></a>精密计算和big包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2&#x2F;5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 <code>big.NewRat(N,D)</code> 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用于作为reciver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<pre><code class="go">// big.go
package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;math/big&quot;
)

func main() &#123;
    // Here are some calculations with bigInts:
    im := big.NewInt(math.MaxInt64)
    in := im
    io := big.NewInt(1956)
    ip := big.NewInt(1)
    ip.Mul(im, in).Add(ip, im).Div(ip, io)
    fmt.Printf(&quot;Big Int: %v\n&quot;, ip)
    // Here are some calculations with bigRat:
    rm := big.NewRat(math.MaxInt64, 1956)
    rn := big.NewRat(-1956, math.MaxInt64)
    ro := big.NewRat(19, 56)
    rp := big.NewRat(1111, 2222)
    rq := big.NewRat(1, 1)
    rq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)
    fmt.Printf(&quot;Big Rat: %v\n&quot;, rq)
&#125;

/* Output:
Big Int: 43492122561469640008497075573153004
Big Rat: -37/112
*/
</code></pre>
<p>结果如下：</p>
<pre><code>Big Int: 43492122561469640008497075573153004
Big Rat: -37/112
</code></pre>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="短变量声明导致变量覆盖"><a href="#短变量声明导致变量覆盖" class="headerlink" title="短变量声明导致变量覆盖"></a>短变量声明导致变量覆盖</h2><pre><code class="go">var remember bool = false
if something &#123;
    remember := true //错误
&#125;
// 使用remember
</code></pre>
<p>在此代码段中，<code>remember</code> 变量永远不会在 <code>if</code> 语句外面变成 <code>true</code>，如果 <code>something</code> 为 <code>true</code>，由于使用了短声明 <code>:=</code>，<code>if</code> 语句内部的新变量 <code>remember</code> 将覆盖外面的 <code>remember</code> 变量，并且该变量的值为 <code>true</code>，但是在 <code>if</code> 语句外面，变量 <code>remember</code> 的值变成了 <code>false</code>，所以正确的写法应该是：</p>
<pre><code class="go">if something &#123;
    remember = true
&#125;
</code></pre>
<p>此类错误也容易在 <code>for</code> 循环中出现，尤其当函数返回一个具名变量时难于察觉，例如以下的代码段：</p>
<pre><code class="go">func shadow() (err error) &#123;
    x, err := check1() // x是新创建变量，err是被赋值
      if err != nil &#123;
            return // 正确返回err
        &#125;
        if y, err := check2(x); err != nil &#123; // y和if语句中err被创建
            return // if语句中的err被外面的err覆盖，所以错误的返回nil！
        &#125; else &#123;
            fmt.Println(y)
        &#125;
    return
&#125;
</code></pre>
<h2 id="不要对需要-append-的空切片使用-make-声明变量"><a href="#不要对需要-append-的空切片使用-make-声明变量" class="headerlink" title="不要对需要 append 的空切片使用 make 声明变量"></a>不要对需要 append 的空切片使用 make 声明变量</h2><p>当初始化一个数组的时候，如果需要调用 append 操作往空变量里塞数据，不要在声明变量的时候，使用带 len 声明的 make（除非 len &#x3D; 0），因为这会导致 append 操作直接往数组后面添加，最后的结果是数组前面的都是空，append 往后添加数据：</p>
<pre><code class="go">func main() &#123;
    attr1 := make([]string, 4)
    fmt.Println(&quot;len0:&quot;, len(attr1)) //len0: 4
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len1:&quot;, len(attr1)) //len1: 5
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len2:&quot;, len(attr1)) //len2: 6
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len3:&quot;, len(attr1)) //len3: 7

    var attr2 []string
    attr2 = append(attr2, &quot;hello&quot;)
    attr2 = append(attr2, &quot;hello&quot;)
    attr2 = append(attr2, &quot;hello&quot;)
    fmt.Println(len(attr2)) // 3
&#125;
</code></pre>
<p>可以直接声明一个变量，或者 make 的 len 参数为 0，append 会在追加的时候自己进行初始化容量的操作。</p>
<h2 id="误用-defer-关闭一个文件"><a href="#误用-defer-关闭一个文件" class="headerlink" title="误用 defer 关闭一个文件"></a>误用 defer 关闭一个文件</h2><p>如果在一个 for 循环内部处理一系列文件，需要使用 defer 确保文件在处理完毕后被关闭，例如：</p>
<pre><code class="go">for _, file := range files &#123;
    if f, err = os.Open(file); err != nil &#123;
        return
    &#125;
    // 这是错误的方式，当循环结束时文件没有关闭，要等到整个方法执行完了才会调用
    defer f.Close()
    // 对文件进行操作
    f.Process(data)
&#125;
</code></pre>
<p>但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：</p>
<pre><code class="go">for _, file := range files &#123;
    if f, err = os.Open(file); err != nil &#123;
        return
    &#125;
    // 对文件进行操作
    f.Process(data)
    // 关闭文件
    f.Close()
 &#125;
</code></pre>
<p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p>
<h2 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h2><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。</p>
<p>因此应该这样做：</p>
<pre><code class="php">   func findBiggest( listOfNumbers []int ) int &#123;&#125;
</code></pre>
<p>而不是：</p>
<pre><code class="php">   func findBiggest( listOfNumbers *[]int ) int &#123;&#125;
</code></pre>
<p><strong>当切片作为参数传递时，切记不要解引用切片。</strong></p>
<h2 id="append-数组时，忽略对底层数组的修改"><a href="#append-数组时，忽略对底层数组的修改" class="headerlink" title="append 数组时，忽略对底层数组的修改"></a>append 数组时，忽略对底层数组的修改</h2><p>append 操作时，有如下需要注意的事项：</p>
<ul>
<li>slice本身并非指针，append追加元素后，意味着底层数组数据（或数组）、len、cap会发生变化，因此append后需要返回新的slice。</li>
<li>append在追加元素时，<strong>当前cap足够容纳元素，则直接存入数据</strong>，否则需要扩容后重新创建新的底层数组，拷贝原数组元素后，再存入追加元素。</li>
<li>cap的扩容意味着内存的重新分配，数据的拷贝等操作，为了提高append的效率，若是能预估cap的大小的话，尽量提前声明cap，避免后期的扩容操作。</li>
</ul>
<p>看下面的例子：</p>
<pre><code class="go">func main() &#123;
    var ret [][]int
    var val = make([]int, 0, 100)
    fmt.Printf(&quot;%p\n&quot;, val)
    deal(&amp;ret, val)
    fmt.Println(ret)
&#125;

func deal(ret *[][]int, val []int) &#123;
    fmt.Printf(&quot;%p\n&quot;, val) // 此时与外面的 val 指定同一个地址（都还未初始化）
    val = append(val, 1)
    val = append(val, 1)
    val = append(val, 1)
    fmt.Printf(&quot;%p\n&quot;, val) // 此时由于底层数组扩容，地址发生改变，跟原来地址不一样了
    *ret = append(*ret, val)

    //val[2] = 2

    // 此时由于为发生扩容，以及修改的是范围里的值，修改会影响原来的
    val = val[:len(val)-1]
    val = append(val, 2)
    fmt.Printf(&quot;%p\n&quot;, val)

    // 继续 append，发生扩容，不会影响原来的
    val = append(val, 4, 5, 6, 7, 8)
    val = val[:3]
    fmt.Printf(&quot;%p\n&quot;, val)
&#125;
</code></pre>
<h2 id="不要将切片作为入参在函数内-append"><a href="#不要将切片作为入参在函数内-append" class="headerlink" title="不要将切片作为入参在函数内 append"></a>不要将切片作为入参在函数内 append</h2><p>观察下面的代码：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    arr := make([]int, 3, 4)
    arr[0] = 0
    arr[1] = 1
    arr[2] = 2
    fmt.Printf(&quot;main before: len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
    ap1(arr)
    fmt.Printf(&quot;main ap1 after: len: %d cap:%d data:%+v\n\n&quot;, len(arr), cap(arr), arr)
&#125;
func ap1(arr []int) &#123;
    fmt.Printf(&quot;ap1 before:  len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
    arr[0] = 11
    arr = append(arr, 111)
    fmt.Printf(&quot;ap1 after:  len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
&#125;
</code></pre>
<p>输出：</p>
<pre><code>main before: len: 3 cap:4 data:[0 1 2]
ap1 before:  len: 3 cap:4 data:[0 1 2]
ap1 after:  len: 4 cap:4 data:[11 1 2 111]
main ap1 after: len: 3 cap:4 data:[11 1 2]
</code></pre>
<p>可以发现，函数内 append 之后，外部实参切片的值没改变，但到底是没改变，还是 <strong>“看不到”</strong> 呢？</p>
<p>首先，slice 是值传递，但是 slice 本身是一个结构体，包含一个指针，指向底层数组，将 slice 按值传递给函数，在函数内对其修改，影响将<strong>会传递到函数外</strong>，因为底层的数组被修改了，但是，<strong>slice 只能感知到 len 范围内的内容</strong>，之外的感知不到的。</p>
<p>由于值传递，外层的 slice 的 len 变量实际上并没有改变，此时还是只能读取到前 3 个值。</p>
<h2 id="不要使用指针指向接口类型"><a href="#不要使用指针指向接口类型" class="headerlink" title="不要使用指针指向接口类型"></a>不要使用指针指向接口类型</h2><p>在下面的程序中：<code>nexter</code> 是一个接口类型，并且定义了一个 <code>next()</code> 方法读取下一字节。函数 <code>nextFew1</code> 将 <code>nexter</code> 接口作为参数并读取接下来的 <code>num</code> 个字节，并返回一个切片：这是正确做法。但是 <code>nextFew2</code> 使用一个指向 <code>nexter</code> 接口类型的指针作为参数传递给函数：当使用 <code>next()</code> 函数时，系统会给出一个编译错误：</p>
<pre><code>n.next undefined (type \*nexter has no field or method next) （n.next 未定义（*nexter 类型没有 next 成员或 next 方法））
</code></pre>
<pre><code class="go">package main
import (
    “fmt”
)
type nexter interface &#123;
    next() byte
&#125;
func nextFew1(n nexter, num int) []byte &#123;
    var b []byte
    for i:=0; i &lt; num; i++ &#123;
        b[i] = n.next()
    &#125;
    return b
&#125;
func nextFew2(n *nexter, num int) []byte &#123;
    var b []byte
    for i:=0; i &lt; num; i++ &#123;
        b[i] = n.next() // 编译错误:n.next未定义（*nexter类型没有next成员或next方法）
    &#125;
    return b
&#125;
func main() &#123;
    fmt.Println(&quot;Hello World!&quot;)
&#125;
</code></pre>
<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong></p>
<h2 id="注意循环中的协程使用"><a href="#注意循环中的协程使用" class="headerlink" title="注意循环中的协程使用"></a>注意循环中的协程使用</h2><p>对于下面的代码：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var values = [5]int&#123;10, 11, 12, 13, 14&#125;

func main() &#123;
    // 版本A:
    for ix := range values &#123; // ix是索引值
        func() &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;() // 调用闭包打印每个索引值
    &#125;
    fmt.Println()
    // 版本B: 和A版本类似，但是通过调用闭包作为一个协程
    for ix := range values &#123;
        go func() &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;()
    &#125;
    fmt.Println()
    time.Sleep(5e9)
    // 版本C: 正确的处理方式
    for ix := range values &#123;
        go func(ix interface&#123;&#125;) &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;(ix)
    &#125;
    fmt.Println()
    time.Sleep(5e9)
    
    // 版本C的另外一种正确的处理方式
    //for ix := range values &#123;
    //	  ix := ix
    //    go func() &#123;
    //        fmt.Print(ix, &quot; &quot;)
    //    &#125;()
    //&#125;
    //fmt.Println()
    //time.Sleep(5e9)
    
    // 版本D: 输出值:
    for ix := range values &#123;
        val := values[ix]
        go func() &#123;
            fmt.Print(val, &quot; &quot;)
        &#125;()
    &#125;
    time.Sleep(1e9)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">        0 1 2 3 4

        4 4 4 4 4

        1 0 3 4 2

        10 11 12 13 14
</code></pre>
<p>版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。</p>
<p>如果阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：<code>4 4 4 4 4</code>。在版本 B 的循环中，<code>ix</code> 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当运行这段代码时，将看见每次循环都打印最后一个索引值 <code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 <code>ix</code> 值是 <code>4</code>。</p>
<p>版本 C 的循环写法才是正确的：调用每个闭包是将 <code>ix</code> 作为参数传递给闭包。<code>ix</code> 在每次循环时都被重新赋值，并将每个协程的 <code>ix</code> 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 <code>0 2 1 3 4</code> 或者 <code>0 3 1 2 4</code> 或者其他类似的序列，这主要取决于每个协程何时开始被执行。</p>
<p>版本 C 的另一个处理方法，<code>ix := ix</code> 可能看起来有点奇怪，但它完全有效。因为处于循环中意味着处于另一个作用域内，所以 <code>ix := ix</code> 相当于创建了另一个名为 <code>ix</code> 的变量实例。</p>
<blockquote>
<p>用 <strong>大括号</strong> <code>&#123;&#125;</code> 包围的一个代码块相当于一个新的作用域，可以定义同名变量</p>
</blockquote>
<p>在版本 D 中，能够正确输出这个数组的值，因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。</p>
<h2 id="不要在生产环境使用默认的-HTTP-Client"><a href="#不要在生产环境使用默认的-HTTP-Client" class="headerlink" title="不要在生产环境使用默认的 HTTP Client"></a>不要在生产环境使用默认的 HTTP Client</h2><p>Go 默认的 HTTP 客户端没有指定请求超时时间，允许服务劫持 goroutine。当请求外部服务时，请始终使用自定义的 <code>http.Client</code>。</p>
<p>Go 的 HTTP 包使用 <code>Client</code> 结构体来管理 HTTP(S) 通信的内部过程。<code>Clients</code> 是并发安全的对象，包含配置、管理 TCP 状态、处理 cookies 等。当使用 <code>http.Get(url)</code> 时，就会调用  <code>http.DefaultClient</code>，走的是 HTTP 默认配置，声明如下：</p>
<pre><code class="go">var DefaultClient = &amp;Client&#123;&#125;
</code></pre>
<p>除其他配置项外，<code>http.Client</code> 有一个超时时间的配置，当请求时间超过这个数值时，请求就会自动断开。该数值默认值是 0，即没有超时时间。该默认值对于 HTTP 包来说挺合理的，同时这也是一个容易让人掉进去的坑，如果请求的对象宕机或者因为其他原因一直没有响应，就会导致发起请求的 groutine 挂起，只要发生故障的服务器没有恢复，进程就会一直挂着。因为进行 API 调用是为了服务用户请求，所以这也会导致服务用户请求的 goroutine 也挂起。一旦有足够的人发起这个 http 请求，很有可能就因为系统资源达到了极限导致应用挂掉。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决这个问题的办法就是使用 <code>http.Client</code> 时定义一个合理的超时时间，比如下面这样的：</p>
<pre><code class="go">var netClient = &amp;http.Client&#123;
  Timeout: time.Second * 10,
&#125;
response, _ := netClient.Get(url)
</code></pre>
<p>设置了 10s 的超时时间，如果超时 <code>Get()</code> 将会返回错误：</p>
<pre><code class="go">&amp;httpError&#123;
  err:     err.Error() + &quot; (Client.Timeout exceeded while awaiting headers)&quot;,
  timeout: true,
&#125;
</code></pre>
<p>如果需要对请求生命周期进行更细粒度的控制，还可以另外指定自定义 <code>net.Transport</code> 和 <code>net.Dialer</code>。</p>
<p><code>Transport</code> 结构体用来管理底层 TCP 连接，<code>Dialer</code> 是用来管理连接建立的结构体。Go 的 net 包使用默认的 <code>Transport</code> 和 <code>Dialer</code>。下面是一个自定义的例子：</p>
<pre><code class="go">var netTransport = &amp;http.Transport&#123;
  Dial: (&amp;net.Dialer&#123;
    Timeout: 5 * time.Second,
  &#125;).Dial,
  TLSHandshakeTimeout: 5 * time.Second,
&#125;
var netClient = &amp;http.Client&#123;
  Timeout: time.Second * 10,
  Transport: netTransport,
&#125;
response, _ := netClient.Get(url)
</code></pre>
<p>上面代码设置了 TCP 拨号时间、TLS 握手时间和请求超时时间。如果有需要还可以设置其他选项，例如 <code>keep-alive</code> 超时时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言的 <code>net/http</code> 包是经过深思熟虑的产物，可以非常便捷地用于 HTTP(S) 通信。然而，缺少请求超时时间是一个非常容易掉进去的坑，因为这个包提供了很多诸如 http.Get(url) 等便捷的方法。请求远程服务时不设置超时时间会使应用程序依赖于该服务，如果远程服务发生故障或者有恶意程序，请求将会永远挂起，从而有可能使系统资源耗尽导致宕机。</p>
<h2 id="map的key-value不能同时断言"><a href="#map的key-value不能同时断言" class="headerlink" title="map的key,value不能同时断言"></a>map的key,value不能同时断言</h2><p>对于一个类型为 <code>interface</code> 的变量，当其实际的值为一个 <code>map</code> 值，例如 <code>map[string]string</code>，此时如果要对该变量进行类型断言，不可以直接使用如下格式：</p>
<pre><code class="go">// v:&#123;&quot;aa&quot;:&quot;vv&quot;&#125;
var v interface&#123;&#125;
v2,ok := v.(map[string]string) // ok==false
</code></pre>
<p>对于 map 的 key 和 value 进行断言时，一次只能断言一个数据结构的类型，因此需要分开进行断言：</p>
<pre><code class="go">v2,ok := v.(map[string]interface&#123;&#125;) // ok==true
v3,ok := v2[&quot;aa&quot;].(string) // ok==true
</code></pre>
<blockquote>
<p>断言的真正含义是让编译器应该把某个变量当成什么类型，而不是真的类型转换，不涉及内存上面的操作，真正的类型转换应该是会涉及内存上面的操作的。</p>
</blockquote>
<p>具体的实例见下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png" alt="map的断言"></p>
<h2 id="未知枚举值"><a href="#未知枚举值" class="headerlink" title="未知枚举值"></a>未知枚举值</h2><pre><code class="go">type Status uint32

const (
  StatusOpen Status = iota
  StatusClosed
  StatusUnknown
)
</code></pre>
<p>在这里，我们使用 iota 创建了一个枚举：</p>
<pre><code class="go">StatusOpen = 0
StatusClosed = 1
StatusUnknown = 2
</code></pre>
<p>现在，假设这个 <code>Status</code> 类型是 JSON 请求的一部分，将被 <code>marshalled/unmarshalled</code>。</p>
<p>设计了以下结构：</p>
<pre><code class="go">type Request struct &#123;
  ID        int    `json:&quot;Id&quot;`
  Timestamp int    `json:&quot;Timestamp&quot;`
  Status    Status `json:&quot;Status&quot;`
&#125;
</code></pre>
<p>然后，接收这样的请求：</p>
<pre><code class="json">&#123;
  &quot;Id&quot;: 1234,
  &quot;Timestamp&quot;: 1563362390,
  &quot;Status&quot;: 0
&#125;
</code></pre>
<p>这样子不会有任何问题，状态会被<code>unmarshalled</code>为<code>StatusOpen</code>。</p>
<p>然而，让我们以另一个未设置状态值的请求为例:</p>
<pre><code class="json">&#123;
  &quot;Id&quot;: 1235,
  &quot;Timestamp&quot;: 1563362390
&#125;
</code></pre>
<p>在这种情况下，请求结构的 <code>Status</code> 字段将初始化为它的零值(对于<code>uint32</code>类型:0)，因此结果将是 <code>StatusOpen</code> 而不是 <code>StatusUnknown</code>。所以在这种场景下，最好的做法是<strong>将枚举的未知值设置为 0</strong>：</p>
<pre><code class="go">type Status uint32

const (
  StatusUnknown Status = iota
  StatusOpen
  StatusClosed
)
</code></pre>
<p>如果状态不是 JSON 请求的一部分，它将被初始化为<code>StatusUnknown</code>，这才符合期望。</p>
<h3 id="基准测试自动优化"><a href="#基准测试自动优化" class="headerlink" title="基准测试自动优化"></a>基准测试自动优化</h3><p>基准测试主要就是测试代码整体的吞吐量，性能等，如果编写的测试代码由于被编译器所优化，会导致测试结果不准确。</p>
<p>例如下面的函数：</p>
<pre><code class="go">func clear(n uint64, i, j uint8) uint64 &#123;
  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n
&#125;
</code></pre>
<p>此函数清除给定范围内的位。为了测试它，可能如下这样做:</p>
<pre><code class="go">func BenchmarkWrong(b *testing.B) &#123;
  for i := 0; i &lt; b.N; i++ &#123;
    clear(1221892080809121, 10, 63)
  &#125;
&#125;
</code></pre>
<p>在这个基准测试中，<code>clear</code> 不调用任何其他函数，没有<strong>副作用</strong>。所以编译器将会把 <code>clear</code> 优化成内联函数。一旦内联，将会导致不准确的测试结果。</p>
<p>一个解决方案是<strong>将函数结果设置为全局变量</strong>，如下所示：</p>
<pre><code class="go">var result uint64

func BenchmarkCorrect(b *testing.B) &#123;
  var r uint64
  for i := 0; i &lt; b.N; i++ &#123;
    r = clear(1221892080809121, 10, 63)
  &#125;
  result = r
&#125;
</code></pre>
<p>如此一来，编译器将不知道<code>clear</code>是否会产生副作用。</p>
<p>因此，不会将<code>clear</code>优化成内联函数。</p>
<h2 id="指针迁移到堆上导致指针传递比按值传递更慢"><a href="#指针迁移到堆上导致指针传递比按值传递更慢" class="headerlink" title="指针迁移到堆上导致指针传递比按值传递更慢"></a>指针迁移到堆上导致指针传递比按值传递更慢</h2><p>在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。</p>
<p>那么，指针传递会比按值传递更快吗？</p>
<p>对于下面这里例子：</p>
<pre><code class="go">package main

import (
    &quot;encoding/json&quot;
    &quot;testing&quot;
)

type foo struct &#123;
    ID            string  `json:&quot;_id&quot;`
    Index         int     `json:&quot;index&quot;`
    GUID          string  `json:&quot;guid&quot;`
    IsActive      bool    `json:&quot;isActive&quot;`
    Balance       string  `json:&quot;balance&quot;`
    Picture       string  `json:&quot;picture&quot;`
    Age           int     `json:&quot;age&quot;`
    EyeColor      string  `json:&quot;eyeColor&quot;`
    Name          string  `json:&quot;name&quot;`
    Gender        string  `json:&quot;gender&quot;`
    Company       string  `json:&quot;company&quot;`
    Email         string  `json:&quot;email&quot;`
    Phone         string  `json:&quot;phone&quot;`
    Address       string  `json:&quot;address&quot;`
    About         string  `json:&quot;about&quot;`
    Registered    string  `json:&quot;registered&quot;`
    Latitude      float64 `json:&quot;latitude&quot;`
    Longitude     float64 `json:&quot;longitude&quot;`
    Greeting      string  `json:&quot;greeting&quot;`
    FavoriteFruit string  `json:&quot;favoriteFruit&quot;`
&#125;
type bar struct &#123;
    ID            string
    Index         int
    GUID          string
    IsActive      bool
    Balance       string
    Picture       string
    Age           int
    EyeColor      string
    Name          string
    Gender        string
    Company       string
    Email         string
    Phone         string
    Address       string
    About         string
    Registered    string
    Latitude      float64
    Longitude     float64
    Greeting      string
    FavoriteFruit string
&#125;

var input foo

func init() &#123;
    err := json.Unmarshal([]byte(`&#123;
        &quot;_id&quot;: &quot;5d2f4fcf76c35513af00d47e&quot;,
        &quot;index&quot;: 1,
        &quot;guid&quot;: &quot;ed687a14-590b-4d81-b0cb-ddaa857874ee&quot;,
        &quot;isActive&quot;: true,
        &quot;balance&quot;: &quot;$3,837.19&quot;,
        &quot;picture&quot;: &quot;https://placehold.it/32x32&quot;,
        &quot;age&quot;: 28,
        &quot;eyeColor&quot;: &quot;green&quot;,
        &quot;name&quot;: &quot;Rochelle Espinoza&quot;,
        &quot;gender&quot;: &quot;female&quot;,
        &quot;company&quot;: &quot;PARLEYNET&quot;,
        &quot;email&quot;: &quot;rochelleespinoza@parleynet.com&quot;,
        &quot;phone&quot;: &quot;+1 (969) 445-3766&quot;,
        &quot;address&quot;: &quot;956 Little Street, Jugtown, District Of Columbia, 6396&quot;,
        &quot;about&quot;: &quot;Excepteur exercitation labore ut cupidatat laboris mollit ad qui minim aliquip nostrud anim adipisicing est. Nisi sunt duis occaecat aliquip est irure Lorem irure nulla tempor sit sunt. Eiusmod laboris ex est velit minim ut cillum sunt laborum labore ad sunt.\r\n&quot;,
        &quot;registered&quot;: &quot;2016-03-20T12:07:25 -00:00&quot;,
        &quot;latitude&quot;: 61.471517,
        &quot;longitude&quot;: 54.01596,
        &quot;greeting&quot;: &quot;Hello, Rochelle Espinoza!You have 9 unread messages.&quot;,
        &quot;favoriteFruit&quot;: &quot;banana&quot;
      &#125;`), &amp;input)
    if err != nil &#123;
        panic(err)
    &#125;
&#125;

func byPointer(in *foo) *bar &#123;
    return &amp;bar&#123;
        ID:            in.ID,
        Address:       in.Address,
        Email:         in.Email,
        Index:         in.Index,
        Name:          in.Name,
        About:         in.About,
        Age:           in.Age,
        Balance:       in.Balance,
        Company:       in.Company,
        EyeColor:      in.EyeColor,
        FavoriteFruit: in.FavoriteFruit,
        Gender:        in.Gender,
        Greeting:      in.Greeting,
        GUID:          in.GUID,
        IsActive:      in.IsActive,
        Latitude:      in.Latitude,
        Longitude:     in.Longitude,
        Phone:         in.Phone,
        Picture:       in.Picture,
        Registered:    in.Registered,
    &#125;
&#125;

func byValue(in foo) bar &#123;
    return bar&#123;
        ID:            in.ID,
        Address:       in.Address,
        Email:         in.Email,
        Index:         in.Index,
        Name:          in.Name,
        About:         in.About,
        Age:           in.Age,
        Balance:       in.Balance,
        Company:       in.Company,
        EyeColor:      in.EyeColor,
        FavoriteFruit: in.FavoriteFruit,
        Gender:        in.Gender,
        Greeting:      in.Greeting,
        GUID:          in.GUID,
        IsActive:      in.IsActive,
        Latitude:      in.Latitude,
        Longitude:     in.Longitude,
        Phone:         in.Phone,
        Picture:       in.Picture,
        Registered:    in.Registered,
    &#125;
&#125;

var pointerResult *bar
var valueResult bar

func BenchmarkByPointer(b *testing.B) &#123;
    var r *bar
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ &#123;
        r = byPointer(&amp;input)
    &#125;
    pointerResult = r
&#125;

func BenchmarkByValue(b *testing.B) &#123;
    var r bar
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ &#123;
        r = byValue(input)
    &#125;
    valueResult = r
&#125;
</code></pre>
<p>通过基准测试分别测试了按值传递和指针传递的速度。</p>
<p>结果显示，按值传递比指针传递快3-4倍以上：</p>
<pre><code class="go">goos: darwin
goarch: amd64
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkByPointer
BenchmarkByPointer-4   	11838573	        91.03 ns/op
BenchmarkByValue
BenchmarkByValue-4     	38128300	        31.21 ns/op
PASS
</code></pre>
<p>测试结果与 Go 中如何管理内存有关，主要原因如下：</p>
<ol>
<li><p>下面是来自 Go 语言圣经的介绍：</p>
<p> 一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。</p>
<p> 一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。</p>
<p> 而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。</p>
</li>
<li><p>通俗的理解：</p>
<ul>
<li>栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（<strong>Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小</strong>）</li>
<li>堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。</li>
</ul>
</li>
</ol>
<p>众所周知，可以在<strong>堆</strong>或<strong>栈</strong>上分配变量。</p>
<ul>
<li>栈储存当前 <code>Goroutine</code> 的正在使用的变量（可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。</li>
<li>堆储存<strong>共享变量</strong>（全局变量等）。</li>
</ul>
<p>看一个简单的例子，返回单一的值：</p>
<pre><code class="go">func getFooValue() foo &#123;
  var result foo
  // Do something
  return result
&#125;
</code></pre>
<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而 <code>result</code> 变量自身会从当前 Goruntine 栈出栈。</p>
<p>虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。</p>
<p>现在，在看一个返回指针的例子：</p>
<pre><code class="go">func getFooPointer() *foo &#123;
  var result foo
  // Do something
  return &amp;result
&#125;
</code></pre>
<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果 <code>result</code> 变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（此情况称为“内存逃逸”）</p>
<p>在这个场景中，Go 编译器将把 <code>result</code> 变量<strong>转义</strong>到一个可以共享变量的地方:<strong>堆</strong>。</p>
<p>不过，传递指针是另一种情况。例如：</p>
<pre><code class="go">func main()  &#123;
  p := &amp;foo&#123;&#125;
  f(p)
&#125;
</code></pre>
<p>因为我们在同一个 Goroutine 中调用<code>f</code>，所以 <code>p</code> 变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（不需要其他 Goruntine 共享的变量就存储在栈上即可）</p>
<p>比如，<code>io.Reader</code> 中的 <code>Read</code> 方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（<strong>如果返回切片，会将切片转义到堆中</strong>。）</p>
<pre><code class="go">type Reader interface &#123;
  Read(p []byte) (n int, err error)
&#125;
</code></pre>
<p>为什么栈如此之快？ 主要有两个原因：</p>
<ol>
<li><strong>堆栈不需要垃圾收集器。</strong>就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。</li>
<li><strong>储存变量不需要考虑同步。</strong>栈属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。</li>
</ol>
<p>总之，当创建一个函数时，<strong>默认行为应该是使用值</strong>而不是指针。只有在我们<strong>想要共享变量时才应使用指针。</strong></p>
<p>如果遇到性能问题，可以使用 <code>go build -gcflags &quot;-m -m&quot;</code> 命令，来显示编译器将变量转义到堆的具体操作。</p>
<p>再次重申，对于大多数日常用例来说，值传递是最合适的。</p>
<h2 id="break-逻辑不符合预期"><a href="#break-逻辑不符合预期" class="headerlink" title="break 逻辑不符合预期"></a>break 逻辑不符合预期</h2><pre><code class="go">for &#123;
  switch f() &#123;
  case true:
    break
  case false:
    // Do something
  &#125;
&#125;
</code></pre>
<p>如果 f 返回 true，将调用 break 语句。然而，将会 break 出 switch 语句，而不是 for 循环。</p>
<p>同样的问题：</p>
<pre><code class="go">for &#123;
  select &#123;
  case &lt;-ch:
  // Do something
  case &lt;-ctx.Done():
    break
  &#125; 
&#125;
</code></pre>
<p>break 与 select 语句有关，与 for 循环无关。</p>
<p>break 出 for&#x2F;switch 或 for&#x2F;select  的一种解决方案是<strong>使用带标签的 break</strong>，如下所示：</p>
<pre><code class="go">loop:
  for &#123;
    select &#123;
    case &lt;-ch:
    // Do something
    case &lt;-ctx.Done():
      break loop
    &#125;
  &#125;
</code></pre>
<h2 id="缺失上下文的错误"><a href="#缺失上下文的错误" class="headerlink" title="缺失上下文的错误"></a>缺失上下文的错误</h2><p>Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。</p>
<p>当前的标准库(在 Go 1.13 之前)只提供 <code>error</code> 的构造函数，自然而然就会缺失其他信息。</p>
<p>看一下 <a target="_blank" rel="noopener" href="https://github.com/pkg/errors">pkg&#x2F;errors</a> 库中错误处理的思想：</p>
<p><em>An error should be handled only</em> <strong>once</strong>. Logging an error <strong>is</strong> <em>handling an error. So an error should</em> <strong>either</strong> <em>be logged or propagated.</em></p>
<blockquote>
<p>错误应该只处理一次。记录 log 错误就是在处理错误。所以，错误应该记录或者传播</p>
</blockquote>
<p>对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。</p>
<p>例如: 所期望的<code>REST</code>调用导致数据库问题的示例：</p>
<pre><code>COPYunable to server HTTP POST request for customer 1234
 |_ unable to insert customer contract abcd
     |_ unable to commit transaction
</code></pre>
<p>如果我们使用 <code>pkg/errors</code>，可以这样做：</p>
<pre><code class="go">COPYfunc postHandler(customer Customer) Status &#123;
  err := insert(customer.Contract)
  if err != nil &#123;
    log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
    return Status&#123;ok: false&#125;
  &#125;
  return Status&#123;ok: true&#125;
&#125;

func insert(contract Contract) error &#123;
  err := dbQuery(contract)
  if err != nil &#123;
    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)
  &#125;
  return nil
&#125;

func dbQuery(contract Contract) error &#123;
  // Do something then fail
  return errors.New(&quot;unable to commit transaction&quot;)
&#125;
</code></pre>
<p>如果不是由外部库返回的初始 <code>error</code> 可以使用 <code>error.New</code> 创建。中间层 <code>insert</code> 对此错误添加更多上下文信息。最终通过 <code>log</code> 错误来处理错误。每个级别要么返回错误，要么处理错误。</p>
<p>我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的 <code>db</code> 包来处理数据库访问。 该库可能会返回一个名为 <code>db.DBError</code> 的临时错误。要确定是否需要重试，我们必须检查错误原因：</p>
<p>使用 <code>pkg/errors</code> 中提供的 <code>errors.Cause</code> 可以判断错误原因。</p>
<pre><code class="go">COPYfunc postHandler(customer Customer) Status &#123;
  err := insert(customer.Contract)
  if err != nil &#123;
    switch errors.Cause(err).(type) &#123;
    default:
      log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
      return Status&#123;ok: false&#125;
    case *db.DBError:
      return retry(customer)
    &#125;
  &#125;
  return Status&#123;ok: true&#125;
&#125;

func insert(contract Contract) error &#123;
  err := db.dbQuery(contract)
  if err != nil &#123;
    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)
  &#125;
  return nil
&#125;
</code></pre>
<p>一个常见错误是部分使用 <code>pkg/errors</code>。 例如，通过这种方式检查错误：</p>
<pre><code class="go">COPYswitch err.(type) &#123;
default:
  log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
  return Status&#123;ok: false&#125;
case *db.DBError:
  return retry(customer)
&#125;
</code></pre>
<p>在此示例中，如果 <code>db.DBError</code> 被 <code>wrapped</code>，它将永远不会执行 <code>retry</code>。</p>
<h2 id="传递文件名给函数"><a href="#传递文件名给函数" class="headerlink" title="传递文件名给函数"></a>传递文件名给函数</h2><p>假设实现一个函数来计算文件中的空行数。最初的实现是这样的：</p>
<pre><code class="go">COPYfunc count(filename string) (int, error) &#123;
  file, err := os.Open(filename)
  if err != nil &#123;
    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)
  &#125;
  defer file.Close()

  scanner := bufio.NewScanner(file)
  count := 0
  for scanner.Scan() &#123;
    if scanner.Text() == &quot;&quot; &#123;
      count++
    &#125;
  &#125; 
  return count, nil
&#125;
</code></pre>
<p><code>filename</code> 作为给定的参数，然后打开该文件，再实现读空白行的逻辑，嗯，没有问题。</p>
<p>假设希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。</p>
<p>此外，如果我们想对于 <code>HTTP Body</code> 实现相同的逻辑，将不得不为此创建另一个函数。</p>
<p>Go 设计了两个很棒的接口：<code>io.Reader</code> 和 <code>io.Writer</code> (常见 IO 命令行，文件，网络等)</p>
<p>所以<strong>可以传递一个抽象数据源的<code>io.Reader</code>，而不是传递文件名</strong>。</p>
<p>仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？</p>
<p>答案并不重要，重要的是无论 <code>Reader</code> 读取的是什么类型的数据，都会使用相同的 <code>Read</code> 方法。</p>
<p>在例子中，甚至可以缓冲输入以逐行读取它（使用 <code>bufio.Reader</code> 及其 <code>ReadLine</code> 方法）：</p>
<pre><code class="go">COPYfunc count(reader *bufio.Reader) (int, error) &#123;
  count := 0
  for &#123;
    line, _, err := reader.ReadLine()
    if err != nil &#123;
      switch err &#123;
      default:
        return 0, errors.Wrapf(err, &quot;unable to read&quot;)
      case io.EOF:
        return count, nil
      &#125;
    &#125;
    if len(line) == 0 &#123;
      count++
    &#125;
  &#125;
&#125;
</code></pre>
<p>打开文件的逻辑现在交给调用 <code>count</code> 方：</p>
<pre><code class="go">COPYfile, err := os.Open(filename)
if err != nil &#123;
  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)
&#125;
defer file.Close()
count, err := count(bufio.NewReader(file))
</code></pre>
<p>无论数据源如何，都可以调用 <code>count</code>。并且，还将促进单元测试，因为可以从字符串创建一个 <code>bufio.Reader</code>，这大大提高了效率。</p>
<pre><code class="go">COPYcount, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))
</code></pre>
<h1 id="出于性能考虑的最佳实践和建议"><a href="#出于性能考虑的最佳实践和建议" class="headerlink" title="出于性能考虑的最佳实践和建议"></a>出于性能考虑的最佳实践和建议</h1><p>（1）尽可能的使用 <code>:=</code> 去初始化声明一个变量（在函数内部）；</p>
<p>（2）尽可能的使用字符代替字符串；</p>
<p>（3）尽可能的使用切片代替数组；</p>
<p>（4）尽可能的使用数组和切片代替映射（详见参考文献 15）；</p>
<p>（5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用 <code>for range</code> 去遍历切片，这比必须查询切片中的每个元素要快一些；</p>
<p>（6）当数组元素是稀疏的（例如有很多 <code>0</code> 值或者空值 <code>nil</code>），使用映射会降低内存消耗；</p>
<p>（7）初始化映射时指定其容量；</p>
<p>（8）当定义一个方法时，使用指针类型作为方法的接受者；</p>
<p>（9）在代码中使用常量或者标志提取常量的值；</p>
<p>（10）尽可能在需要分配大量内存时使用缓存；</p>
<p>（11）使用缓存模板</p>
<blockquote>
<p> <strong>参考文档</strong>：</p>
<p> <a target="_blank" rel="noopener" href="https://learnku.com/docs/the-way-to-go/chapter-description/3715">《GO入门指南》第十六章 常见的陷阱与错误</a></p>
<p> <a target="_blank" rel="noopener" href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">深度解密Go语言之反射</a></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LjSlxdo5PFVJcUhH3UDU0A">不要使用 Go 默认的 HTTP 客户端（在生产环境中）</a></p>
<p> <a target="_blank" rel="noopener" href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779">Don’t use Go’s default HTTP client (in production)</a></p>
<p> <a target="_blank" rel="noopener" href="https://studygolang.com/topics/6033/comment/17800">断言的疑惑</a></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg">详解 Go 空结构体的 3 种使用场景</a></p>
<p> <a target="_blank" rel="noopener" href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/">Go 开发中的十大常见陷阱[译]</a></p>
<p> <a target="_blank" rel="noopener" href="https://tangx.in/2021/06/22/golang-block/">Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39618369/article/details/121666608">Golang函数内slice进行append时不改变外部值问题</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/18/go%E5%85%A5%E9%97%A8/" rel="prev" title="go 入门">
                  <i class="fa fa-chevron-left"></i> go 入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/19/ElasticSearch/" rel="next" title="ElasticSearch">
                  ElasticSearch <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:50</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
