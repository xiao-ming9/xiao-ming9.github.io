<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="常用代码段new() 和 make() 选择 切片、映射和通道，使用 make   数组、结构体和所有的值类型，使用 new    new 出来的是一个指针  字符串相关操作修改字符串的一个字符str:&#x3D;&quot;hello&quot; c:&#x3D;[]byte(str) c[0]&#x3D;&#39;c&#39; s2:&#x3D; string(c) &#x2F;&#x2F; s2 &#x3D;&#x3D; &quot;cello&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="go 实用代码片段和注意事项">
<meta property="og:url" content="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/index.html">
<meta property="og:site_name" content="Silverming的杂货笔记">
<meta property="og:description" content="常用代码段new() 和 make() 选择 切片、映射和通道，使用 make   数组、结构体和所有的值类型，使用 new    new 出来的是一个指针  字符串相关操作修改字符串的一个字符str:&#x3D;&quot;hello&quot; c:&#x3D;[]byte(str) c[0]&#x3D;&#39;c&#39; s2:&#x3D; string(c) &#x2F;&#x2F; s2 &#x3D;&#x3D; &quot;cello&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png">
<meta property="article:published_time" content="2020-08-20T03:45:18.000Z">
<meta property="article:modified_time" content="2024-07-28T14:38:25.064Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png">


<link rel="canonical" href="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","path":"2020/08/20/go 实用代码片段和注意事项/","title":"go 实用代码片段和注意事项"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go 实用代码片段和注意事项 | Silverming的杂货笔记</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming的杂货笔记</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-number">1.</span> <span class="nav-text">常用代码段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E5%92%8C-make-%E9%80%89%E6%8B%A9"><span class="nav-number">1.1.</span> <span class="nav-text">new() 和 make() 选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">字符串相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">修改字符串的一个字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="nav-number">1.2.2.</span> <span class="nav-text">获取字符串的字串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-for-%E6%88%96%E8%80%85-for-range-%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用 for 或者 for-range 遍历一个字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">获取一个字符串的字节数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%EF%BC%9A"><span class="nav-number">1.2.5.</span> <span class="nav-text">获取一个字符串的字符数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.2.6.</span> <span class="nav-text">字符串拼接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.3.</span> <span class="nav-text">打印字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E7%9A%84%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.4.</span> <span class="nav-text">优雅实现存储单位的常量枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">优雅的进行错误检测和处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.6.</span> <span class="nav-text">反射常用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%8D%95%E6%B5%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">写单测相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%B8%A6-body-%E7%9A%84-http-Response"><span class="nav-number">1.7.1.</span> <span class="nav-text">构造带 body 的 http Response</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-http-ResponseWriter"><span class="nav-number">1.7.2.</span> <span class="nav-text">构造 http ResponseWriter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#time-%E7%9A%84%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">time 的时区设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">空结构体的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">3.1.</span> <span class="nav-text">实现方法接收者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">实现集合类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%A9%BA%E9%80%9A%E9%81%93"><span class="nav-number">3.3.</span> <span class="nav-text">实现空通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">go 中常用的包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#regexp%E5%8C%85"><span class="nav-number">4.1.</span> <span class="nav-text">regexp包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-%E5%8C%85"><span class="nav-number">4.2.</span> <span class="nav-text">sync 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%BE%E5%AF%86%E8%AE%A1%E7%AE%97%E5%92%8Cbig%E5%8C%85"><span class="nav-number">4.3.</span> <span class="nav-text">精密计算和big包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">5.</span> <span class="nav-text">常见错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%AF%BC%E8%87%B4%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="nav-number">5.1.</span> <span class="nav-text">短变量声明导致变量覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%AF%B9%E9%9C%80%E8%A6%81-append-%E7%9A%84%E7%A9%BA%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8-make-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">不要对需要 append 的空切片使用 make 声明变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AF%E7%94%A8-defer-%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.</span> <span class="nav-text">误用 defer 关闭一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%88%87%E7%89%87%E7%9A%84%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">不需要将一个指向切片的指针传递给函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#append-%E6%95%B0%E7%BB%84%E6%97%B6%EF%BC%8C%E5%BF%BD%E7%95%A5%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">5.5.</span> <span class="nav-text">append 数组时，忽略对底层数组的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%B0%86%E5%88%87%E7%89%87%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85-append"><span class="nav-number">5.6.</span> <span class="nav-text">不要将切片作为入参在函数内 append</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.7.</span> <span class="nav-text">不要使用指针指向接口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">5.8.</span> <span class="nav-text">注意循环中的协程使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84-HTTP-Client"><span class="nav-number">5.9.</span> <span class="nav-text">不要在生产环境使用默认的 HTTP Client</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">5.9.1.</span> <span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.9.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E7%9A%84key-value%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E6%96%AD%E8%A8%80"><span class="nav-number">5.10.</span> <span class="nav-text">map的key,value不能同时断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E7%9F%A5%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="nav-number">5.11.</span> <span class="nav-text">未知枚举值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="nav-number">5.11.1.</span> <span class="nav-text">基准测试自动优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%81%E7%A7%BB%E5%88%B0%E5%A0%86%E4%B8%8A%E5%AF%BC%E8%87%B4%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E6%AF%94%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E6%9B%B4%E6%85%A2"><span class="nav-number">5.12.</span> <span class="nav-text">指针迁移到堆上导致指针传递比按值传递更慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-%E9%80%BB%E8%BE%91%E4%B8%8D%E7%AC%A6%E5%90%88%E9%A2%84%E6%9C%9F"><span class="nav-number">5.13.</span> <span class="nav-text">break 逻辑不符合预期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">5.14.</span> <span class="nav-text">缺失上下文的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E5%90%8D%E7%BB%99%E5%87%BD%E6%95%B0"><span class="nav-number">5.15.</span> <span class="nav-text">传递文件名给函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int32-%E8%BD%AC-string-%E6%97%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-string-%E5%BC%BA%E8%BD%AC%E8%BE%93%E5%87%BA%E4%B8%BA-ASCII-%E7%A0%81"><span class="nav-number">5.16.</span> <span class="nav-text">int32 转 string 时，直接使用 string 强转输出为 ASCII 码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%8F%98%E9%87%8F%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">5.17.</span> <span class="nav-text">Go 变量并发赋值的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">5.17.1.</span> <span class="nav-text">结构体并发赋值的不安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">5.17.2.</span> <span class="nav-text">哪些类型并发赋值是安全的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC"><span class="nav-number">5.17.2.1.</span> <span class="nav-text">基本类型的并发赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%9E%8B%E3%80%81%E5%B8%83%E5%B0%94%E5%9E%8B%E3%80%81%E6%95%B4%E5%9E%8B%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.1.1.</span> <span class="nav-text">字节型、布尔型、整型、浮点型、字符型（安全）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0%E5%9E%8B%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.1.2.</span> <span class="nav-text">复数型（不安全）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.1.3.</span> <span class="nav-text">字符串（不安全）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC"><span class="nav-number">5.17.2.2.</span> <span class="nav-text">复合数据类型的并发赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.2.1.</span> <span class="nav-text">指针（安全）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.2.2.</span> <span class="nav-text">函数（安全）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="nav-number">5.17.2.2.3.</span> <span class="nav-text">数组、切片、字典、通道、接口（不安全）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.17.2.2.3.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">5.17.2.2.3.2.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">5.17.2.2.3.3.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">5.17.2.2.3.4.</span> <span class="nav-text">通道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.17.2.2.3.5.</span> <span class="nav-text">接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">5.17.3.</span> <span class="nav-text">如何保证并发赋值的安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">5.18.</span> <span class="nav-text">错误使用随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%B9%81-Seed"><span class="nav-number">5.18.1.</span> <span class="nav-text">频繁 Seed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%8F%96%E4%BD%99%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%A6%BB%E6%95%A3%E4%B8%80%E8%87%B4%E5%88%86%E5%B8%83%E9%97%B4%E5%81%9A%E6%98%A0%E5%B0%84%E6%97%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E8%83%BD%E9%99%A4%E5%B0%BD%E5%AF%BC%E8%87%B4%E5%81%8F%E7%A7%BB%EF%BC%8C%E4%B8%8D%E6%9E%84%E6%88%90%E4%B8%80%E8%87%B4%E5%88%86%E5%B8%83%E3%80%82"><span class="nav-number">5.18.2.</span> <span class="nav-text">通过取余操作对离散一致分布间做映射时，因为不能除尽导致偏移，不构成一致分布。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%E5%A4%B1%E8%AF%AF%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%9E%E9%99%85%E9%98%88%E5%80%BC%E6%AF%94%E9%A2%84%E6%9C%9F%E5%A4%A7-1"><span class="nav-number">5.18.3.</span> <span class="nav-text">边界处理失误，导致实际阈值比预期大 1%</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BA%E4%BA%8E%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%BB%BA%E8%AE%AE"><span class="nav-number">6.</span> <span class="nav-text">出于性能考虑的最佳实践和建议</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming的杂货笔记">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go 实用代码片段和注意事项 | Silverming的杂货笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 实用代码片段和注意事项
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 11:45:18" itemprop="dateCreated datePublished" datetime="2020-08-20T11:45:18+08:00">2020-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-28 22:38:25" itemprop="dateModified" datetime="2024-07-28T22:38:25+08:00">2024-07-28</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="常用代码段"><a href="#常用代码段" class="headerlink" title="常用代码段"></a>常用代码段</h1><h2 id="new-和-make-选择"><a href="#new-和-make-选择" class="headerlink" title="new() 和 make() 选择"></a>new() 和 make() 选择</h2><ul>
<li><p>切片、映射和通道，使用 make </p>
</li>
<li><p>数组、结构体和所有的值类型，使用 new</p>
</li>
</ul>
<blockquote>
<p>new 出来的是一个指针</p>
</blockquote>
<h2 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h2><h3 id="修改字符串的一个字符"><a href="#修改字符串的一个字符" class="headerlink" title="修改字符串的一个字符"></a>修改字符串的一个字符</h3><pre><code class="go">str:=&quot;hello&quot;
c:=[]byte(str)
c[0]=&#39;c&#39;
s2:= string(c) // s2 == &quot;cello&quot;
</code></pre>
<span id="more"></span>

<h3 id="获取字符串的字串"><a href="#获取字符串的字串" class="headerlink" title="获取字符串的字串"></a>获取字符串的字串</h3><pre><code class="go">substr := str[n:m]
</code></pre>
<h3 id="使用-for-或者-for-range-遍历一个字符串"><a href="#使用-for-或者-for-range-遍历一个字符串" class="headerlink" title="使用 for 或者 for-range 遍历一个字符串"></a>使用 <code>for</code> 或者 <code>for-range</code> 遍历一个字符串</h3><pre><code class="go">// gives only the bytes:
for i:=0; i &lt; len(str); i++ &#123;
… = str[i]
&#125;
// gives the Unicode characters:
for ix, ch := range str &#123;
…
&#125;
</code></pre>
<h3 id="获取一个字符串的字节数"><a href="#获取一个字符串的字节数" class="headerlink" title="获取一个字符串的字节数"></a>获取一个字符串的字节数</h3><p><code>len(str)</code></p>
<h3 id="获取一个字符串的字符数："><a href="#获取一个字符串的字符数：" class="headerlink" title="获取一个字符串的字符数："></a>获取一个字符串的字符数：</h3><p>最快速：<code>utf8.RuneCountInString(str)</code></p>
<p><code>len([]int(str))</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 <code>a += b</code> 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中</strong>。</p>
<pre><code class="go">// builder 方式
var builder strings.Builder
builder.WriteString(&quot;asong&quot;)
builder.String()


// buffer 方式，性能次于 string builder
var b bytes.Buffer
...
for condition &#123;
    b.WriteString(str) // 将字符串str写入缓存buffer
&#125;
    return b.String()
</code></pre>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>函数 <code>Printf</code> 主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：</p>
<pre><code class="go">func Printf(format string, list of variables to be printed)
</code></pre>
<p>这个格式化字符串可以含有一个或多个的格式化标识符，例如：<code>%..</code>，其中 <code>..</code> 可以被不同类型所对应的标识符替换，如 <code>%s</code> 代表字符串标识符、<code>%v</code> 代表使用类型的默认输出格式的标识符。<strong>这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加</strong>，如果参数超过 1 个则需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。</p>
<p>函数 <code>fmt.Sprintf</code> 与 <code>Printf</code> 的作用是完全相同的，<strong>不过前者将格式化后的字符串以返回值的形式返回给调用者</strong>，因此可以在程序中使用包含变量的字符串。</p>
<p>函数 <code>fmt.Print</code> 和 <code>fmt.Println</code> 会自动使用格式化标识符 <code>%v</code> 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如：</p>
<pre><code class="go">fmt.Print(&quot;Hello:&quot;, 23)
</code></pre>
<p>将输出：<code>Hello: 23</code>。</p>
<p><strong>格式化说明符</strong></p>
<p>在格式化字符串里，<code>%d</code> 用于格式化整数（<code>%x</code> 和 <code>%X</code> 用于格式化 16 进制表示的数字），<code>%g</code> 用于格式化浮点型（<code>%f</code> 输出浮点数，<code>%e</code> 输出科学计数表示法），<code>%0d</code> 用于规定输出定长的整数，其中开头的数字 0 是必须的。</p>
<p><code>%n.mg</code> 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 <code>%5.2e</code> 来输出 3.4 的结果为 <code>3.40e+00</code>。</p>
<p><code>%b</code> 是用于表示位的格式化标识符。</p>
<p>格式化说明符 <code>%c</code> 用于表示字符；当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数；<code>%U</code> 输出格式为 U+hhhh 的字符串</p>
<p>指针的格式化标识符为 <code>%p</code></p>
<h2 id="优雅实现存储单位的常量枚举"><a href="#优雅实现存储单位的常量枚举" class="headerlink" title="优雅实现存储单位的常量枚举"></a>优雅实现存储单位的常量枚举</h2><p>使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：</p>
<pre><code class="go">type ByteSize float64
const (
    _ = iota // 通过赋值给空白标识符来忽略值
    KB ByteSize = 1&lt;&lt;(10*iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</code></pre>
<h2 id="优雅的进行错误检测和处理"><a href="#优雅的进行错误检测和处理" class="headerlink" title="优雅的进行错误检测和处理"></a>优雅的进行错误检测和处理</h2><p>避免写出这样的代码：</p>
<pre><code class="go">... err1 := api.Func1()
if err1 != nil &#123;
    fmt.Println(&quot;err: &quot; + err.Error())
    return
&#125;
err2 := api.Func2()
if err2 != nil &#123;
...
    return
&#125;    
</code></pre>
<p>首先，包括在一个初始化的 <code>if</code> 语句中对函数的调用。但即使代码中到处都是以 <code>if</code> 语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：</p>
<pre><code class="go">func httpRequestHandler(w http.ResponseWriter, req *http.Request) &#123;
    err := func () error &#123;
        if req.Method != &quot;GET&quot; &#123;
            return errors.New(&quot;expected GET&quot;)
        &#125;
        if input := parseInput(req); input != &quot;command&quot; &#123;
            return errors.New(&quot;malformed command&quot;)
        &#125;
        // 可以在此进行其他的错误检测
    &#125; ()

        if err != nil &#123;
            w.WriteHeader(400)
            io.WriteString(w, err)
            return
        &#125;
        doSomething() ...
</code></pre>
<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑</p>
<h2 id="反射常用示例"><a href="#反射常用示例" class="headerlink" title="反射常用示例"></a>反射常用示例</h2><pre><code class="go">type Child struct &#123;
    Name     string
    Grade    int
    Handsome bool
&#125;

type Adult struct &#123;
    ID         string `qson:&quot;Name&quot;`
    Occupation string
    Handsome   bool
&#125;

// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，
// 并且有一个字段的 tag 或者字段名是 `Name` ，
// 如果该 `Name` 字段的值是 `qcrao`，
// 就把结构体中名为 `Handsome` 的字段值设置为 true。
func handsome(i interface&#123;&#125;) &#123;
    // 获取 i 的反射变量 Value
    v := reflect.ValueOf(i)

    // 确定 v 是一个 Slice
    if v.Kind() != reflect.Slice &#123;
        return
    &#125;

    // 确定 v 是的元素为结构体
    if e := v.Type().Elem(); e.Kind() != reflect.Struct &#123;
        return
    &#125;

    // 确定结构体的字段名含有 &quot;ID&quot; 或者 json tag 标签为 `name`
    // 确定结构体的字段名 &quot;Handsome&quot;
    st := v.Type().Elem()

    // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
    foundName := false
    for i := 0; i &lt; st.NumField(); i++ &#123;
        f := st.Field(i)
        tag := f.Tag.Get(&quot;qson&quot;)

        if (tag == &quot;Name&quot; || f.Name == &quot;Name&quot;) &amp;&amp; f.Type.Kind() == reflect.String &#123;
            foundName = true
            break
        &#125;
    &#125;

    if !foundName &#123;
        return
    &#125;

    if niceField, foundHandsome := st.FieldByName(&quot;Handsome&quot;); foundHandsome == false || niceField.Type.Kind() != reflect.Bool &#123;
        return
    &#125;

    // 设置名字为 &quot;qcrao&quot; 的对象的 &quot;Handsome&quot; 字段为 true
    for i := 0; i &lt; v.Len(); i++ &#123;
        e := v.Index(i)
        handsome := e.FieldByName(&quot;Handsome&quot;)

        // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
        var name reflect.Value
        for j := 0; j &lt; st.NumField(); j++ &#123;
            f := st.Field(j)
            tag := f.Tag.Get(&quot;qson&quot;)

            if tag == &quot;Name&quot; || f.Name == &quot;Name&quot; &#123;
                name = v.Index(i).Field(j)
            &#125;
        &#125;

        if name.String() == &quot;qcrao&quot; &#123;
            handsome.SetBool(true)
        &#125;
    &#125;
&#125;

func main() &#123;
    children := []Child&#123;
        &#123;Name: &quot;Ava&quot;, Grade: 3, Handsome: true&#125;,
        &#123;Name: &quot;qcrao&quot;, Grade: 6, Handsome: false&#125;,
    &#125;

    adults := []Adult&#123;
        &#123;ID: &quot;Steve&quot;, Occupation: &quot;Clerk&quot;, Handsome: true&#125;,
        &#123;ID: &quot;qcrao&quot;, Occupation: &quot;Go Programmer&quot;, Handsome: false&#125;,
    &#125;

    fmt.Printf(&quot;adults before handsome: %v\n&quot;, adults)
    handsome(adults)
    fmt.Printf(&quot;adults after handsome: %v\n&quot;, adults)

    fmt.Println(&quot;-------------&quot;)

    fmt.Printf(&quot;children before handsome: %v\n&quot;, children)
    handsome(children)
    fmt.Printf(&quot;children after handsome: %v\n&quot;, children)
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code>adults before handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer false&#125;]
adults after handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer true&#125;]
-------------
children before handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 false&#125;]
children after handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 true&#125;]
</code></pre>
<p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p>
<p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p>
<p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p>
<h2 id="写单测相关"><a href="#写单测相关" class="headerlink" title="写单测相关"></a>写单测相关</h2><h3 id="构造带-body-的-http-Response"><a href="#构造带-body-的-http-Response" class="headerlink" title="构造带 body 的 http Response"></a>构造带 body 的 http Response</h3><pre><code class="go">&#123;Values: gomonkey.Params&#123;&amp;http.Response&#123;Body: io.NopCloser(strings.NewReader(&quot;&quot;))&#125;, nil&#125;&#125;,
</code></pre>
<h3 id="构造-http-ResponseWriter"><a href="#构造-http-ResponseWriter" class="headerlink" title="构造 http ResponseWriter"></a>构造 http ResponseWriter</h3><pre><code class="go">w := new(httptest.ResponseRecorder)
</code></pre>
<h1 id="time-的时区设置"><a href="#time-的时区设置" class="headerlink" title="time 的时区设置"></a>time 的时区设置</h1><p>对于需要使用时间的场景，默认情况下会从当前系统中找时区信息，如果需要手动设置时区，最好所有的解析和格式化的操作都指定时区信息：</p>
<pre><code class="go">t,_ := time.ParseInLocation(layout,inputTime,location)
dateTime := time.Unix(t.Unix(),0).In(loacation).Format(layout)
</code></pre>
<p>常用的 <code>Parse</code> 方法在解析时间模板时会使用读取参数中的时区信息，没有的话就采用 UTC 时间，此时如果再调用 <code>time.Unix(t.Unix(),0).In(loacation).Format(layout)</code> ，生成的时间会加上时区时间，所以最好采用上述方式，在解析的时候就把时区信息通过 <code>ParseInLocation</code> 传入，避免时区问题。</p>
<h1 id="空结构体的应用"><a href="#空结构体的应用" class="headerlink" title="空结构体的应用"></a>空结构体的应用</h1><p>在Go中，每一个基本类型都有对应的字节宽度，声明一个变量后即使不赋值，也需要占用一定的内存。但是对于空结构体来说，其字节宽度为0，因此可以用在某些场景下作为占位符而不占用存储空间。其使用场景主要有：</p>
<ul>
<li>实现方法接收者</li>
<li>实现集合类型</li>
<li>实现空通道</li>
</ul>
<h2 id="实现方法接收者"><a href="#实现方法接收者" class="headerlink" title="实现方法接收者"></a>实现方法接收者</h2><p>在某些业务场景下，需要将方法组合起来，代表一个分组，便于后续的拓展和维护。这时候就会使用空结构体，即节省内存，也便于未来针对该类型进行公共字段等的增加。</p>
<pre><code class="go">type T struct&#123;&#125;

func (s *T) Call() &#123;
 fmt.Println(&quot;脑子进煎鱼了&quot;)
&#125;

func main() &#123;
 var s T
 s.Call()
&#125;
</code></pre>
<p>在该场景下，使用空结构体从多维度来考量是最合适的，易拓展，省空间，最结构化。</p>
<h2 id="实现集合类型"><a href="#实现集合类型" class="headerlink" title="实现集合类型"></a>实现集合类型</h2><p>由于 Go 中并没有提供集合（Set）的相关支持，当需要自己实现时，可以使用 map 来替代，对于其 value，使用空结构作为占位符，不会额外增加不必要的内存开销：</p>
<pre><code class="go">type Set map[string]struct&#123;&#125;

func (s Set) Append(k string) &#123;
 s[k] = struct&#123;&#125;&#123;&#125;
&#125;

func (s Set) Remove(k string) &#123;
 delete(s, k)
&#125;

func (s Set) Exist(k string) bool &#123;
 _, ok := s[k]
 return ok
&#125;

func main() &#123;
 set := Set&#123;&#125;
 set.Append(&quot;煎鱼&quot;)
 set.Append(&quot;咸鱼&quot;)
 set.Append(&quot;蒸鱼&quot;)
 set.Remove(&quot;煎鱼&quot;)

 fmt.Println(set.Exist(&quot;煎鱼&quot;))
&#125;
</code></pre>
<h2 id="实现空通道"><a href="#实现空通道" class="headerlink" title="实现空通道"></a>实现空通道</h2><p>在 Go channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只要用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。</p>
<pre><code class="go">func main() &#123;
 ch := make(chan struct&#123;&#125;)
 go func() &#123;
  time.Sleep(1 * time.Second)
  close(ch)
 &#125;()

 fmt.Println(&quot;脑子好像进...&quot;)
 &lt;-ch
 fmt.Println(&quot;煎鱼了！&quot;)
&#125;
</code></pre>
<p>该程序会先输出 ”脑子好像进…“ 后，再睡眠一段时间再输出 “煎鱼了！”，达到间断控制 channel 的效果。</p>
<p>由于该 channel 使用的是空结构体，因此也不会带来额外的内存开销。</p>
<h1 id="go-中常用的包"><a href="#go-中常用的包" class="headerlink" title="go 中常用的包"></a>go 中常用的包</h1><h2 id="regexp包"><a href="#regexp包" class="headerlink" title="regexp包"></a>regexp包</h2><p>主要用于正则匹配。</p>
<p>如果是简单模式，使用 <code>Match</code> 方法便可：</p>
<pre><code class="go">ok, _ := regexp.Match(pat, []byte(searchIn))
</code></pre>
<p>变量 ok 将返回 true 或者 false, 也可以使用 <code>MatchString</code>：</p>
<pre><code class="go">ok, _ := regexp.MatchString(pat, searchIn)
</code></pre>
<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。然后我们将掌握一些匹配，查找，替换相关的功能。如下：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;regexp&quot;
    &quot;strconv&quot;
)
func main() &#123;
    //目标字符串
    searchIn := &quot;John: 2578.34 William: 4567.23 Steve: 5632.18&quot;
    pat := &quot;[0-9]+.[0-9]+&quot; //正则

    f := func(s string) string&#123;
        v, _ := strconv.ParseFloat(s, 32)
        return strconv.FormatFloat(v * 2, &#39;f&#39;, 2, 32)
    &#125;

    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok &#123;
        fmt.Println(&quot;Match Found!&quot;)
    &#125;

    re, _ := regexp.Compile(pat)
    //将匹配到的部分替换为&quot;##.#&quot;
    str := re.ReplaceAllString(searchIn, &quot;##.#&quot;)
    fmt.Println(str)
    //参数为函数时
    str2 := re.ReplaceAllStringFunc(searchIn, f)
    fmt.Println(str2)
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code>Match Found!
John: ##.# William: ##.# Steve: ##.#
John: 5156.68 William: 9134.46 Steve: 11264.36
</code></pre>
<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><p><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p>
<p>假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 <code>Mutex</code> 来实现的一个典型例子如下：</p>
<pre><code class="go">import  &quot;sync&quot;

type Info struct &#123;
    mu sync.Mutex
    // ... other fields, e.g.: Str string
&#125;
</code></pre>
<p>如果一个函数想要改变这个变量可以这样写:</p>
<pre><code class="go">func Update(info *Info) &#123;
    info.mu.Lock()
    // critical section:
    info.Str = // new value
    // end critical section
    info.mu.Unlock()
&#125;
</code></pre>
<p>还有一个很有用的例子是通过 Mutex 来实现一个可以上锁的共享缓冲器:</p>
<pre><code class="go">type SyncedBuffer struct &#123;
    lock    sync.Mutex
    buffer  bytes.Buffer
&#125;
</code></pre>
<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。</p>
<h2 id="精密计算和big包"><a href="#精密计算和big包" class="headerlink" title="精密计算和big包"></a>精密计算和big包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2&#x2F;5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 <code>big.NewRat(N,D)</code> 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用于作为reciver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<pre><code class="go">// big.go
package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;math/big&quot;
)

func main() &#123;
    // Here are some calculations with bigInts:
    im := big.NewInt(math.MaxInt64)
    in := im
    io := big.NewInt(1956)
    ip := big.NewInt(1)
    ip.Mul(im, in).Add(ip, im).Div(ip, io)
    fmt.Printf(&quot;Big Int: %v\n&quot;, ip)
    // Here are some calculations with bigRat:
    rm := big.NewRat(math.MaxInt64, 1956)
    rn := big.NewRat(-1956, math.MaxInt64)
    ro := big.NewRat(19, 56)
    rp := big.NewRat(1111, 2222)
    rq := big.NewRat(1, 1)
    rq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)
    fmt.Printf(&quot;Big Rat: %v\n&quot;, rq)
&#125;

/* Output:
Big Int: 43492122561469640008497075573153004
Big Rat: -37/112
*/
</code></pre>
<p>结果如下：</p>
<pre><code>Big Int: 43492122561469640008497075573153004
Big Rat: -37/112
</code></pre>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="短变量声明导致变量覆盖"><a href="#短变量声明导致变量覆盖" class="headerlink" title="短变量声明导致变量覆盖"></a>短变量声明导致变量覆盖</h2><pre><code class="go">var remember bool = false
if something &#123;
    remember := true //错误
&#125;
// 使用remember
</code></pre>
<p>在此代码段中，<code>remember</code> 变量永远不会在 <code>if</code> 语句外面变成 <code>true</code>，如果 <code>something</code> 为 <code>true</code>，由于使用了短声明 <code>:=</code>，<code>if</code> 语句内部的新变量 <code>remember</code> 将覆盖外面的 <code>remember</code> 变量，并且该变量的值为 <code>true</code>，但是在 <code>if</code> 语句外面，变量 <code>remember</code> 的值变成了 <code>false</code>，所以正确的写法应该是：</p>
<pre><code class="go">if something &#123;
    remember = true
&#125;
</code></pre>
<p>此类错误也容易在 <code>for</code> 循环中出现，尤其当函数返回一个具名变量时难于察觉，例如以下的代码段：</p>
<pre><code class="go">func shadow() (err error) &#123;
    x, err := check1() // x是新创建变量，err是被赋值
      if err != nil &#123;
            return // 正确返回err
        &#125;
        if y, err := check2(x); err != nil &#123; // y和if语句中err被创建
            return // if语句中的err被外面的err覆盖，所以错误的返回nil！
        &#125; else &#123;
            fmt.Println(y)
        &#125;
    return
&#125;
</code></pre>
<h2 id="不要对需要-append-的空切片使用-make-声明变量"><a href="#不要对需要-append-的空切片使用-make-声明变量" class="headerlink" title="不要对需要 append 的空切片使用 make 声明变量"></a>不要对需要 append 的空切片使用 make 声明变量</h2><p>当初始化一个数组的时候，如果需要调用 append 操作往空变量里塞数据，不要在声明变量的时候，使用带 len 声明的 make（除非 len &#x3D; 0），因为这会导致 append 操作直接往数组后面添加，最后的结果是数组前面的都是空，append 往后添加数据：</p>
<pre><code class="go">func main() &#123;
    attr1 := make([]string, 4)
    fmt.Println(&quot;len0:&quot;, len(attr1)) //len0: 4
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len1:&quot;, len(attr1)) //len1: 5
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len2:&quot;, len(attr1)) //len2: 6
    attr1 = append(attr1, &quot;hello&quot;)
    fmt.Println(&quot;len3:&quot;, len(attr1)) //len3: 7

    var attr2 []string
    attr2 = append(attr2, &quot;hello&quot;)
    attr2 = append(attr2, &quot;hello&quot;)
    attr2 = append(attr2, &quot;hello&quot;)
    fmt.Println(len(attr2)) // 3
&#125;
</code></pre>
<p>可以直接声明一个变量，或者 make 的 len 参数为 0，append 会在追加的时候自己进行初始化容量的操作。</p>
<h2 id="误用-defer-关闭一个文件"><a href="#误用-defer-关闭一个文件" class="headerlink" title="误用 defer 关闭一个文件"></a>误用 defer 关闭一个文件</h2><p>如果在一个 for 循环内部处理一系列文件，需要使用 defer 确保文件在处理完毕后被关闭，例如：</p>
<pre><code class="go">for _, file := range files &#123;
    if f, err = os.Open(file); err != nil &#123;
        return
    &#125;
    // 这是错误的方式，当循环结束时文件没有关闭，要等到整个方法执行完了才会调用
    defer f.Close()
    // 对文件进行操作
    f.Process(data)
&#125;
</code></pre>
<p>但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：</p>
<pre><code class="go">for _, file := range files &#123;
    if f, err = os.Open(file); err != nil &#123;
        return
    &#125;
    // 对文件进行操作
    f.Process(data)
    // 关闭文件
    f.Close()
 &#125;
</code></pre>
<p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p>
<h2 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h2><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。</p>
<p>因此应该这样做：</p>
<pre><code class="php">   func findBiggest( listOfNumbers []int ) int &#123;&#125;
</code></pre>
<p>而不是：</p>
<pre><code class="php">   func findBiggest( listOfNumbers *[]int ) int &#123;&#125;
</code></pre>
<p><strong>当切片作为参数传递时，切记不要解引用切片。</strong></p>
<h2 id="append-数组时，忽略对底层数组的修改"><a href="#append-数组时，忽略对底层数组的修改" class="headerlink" title="append 数组时，忽略对底层数组的修改"></a>append 数组时，忽略对底层数组的修改</h2><p>append 操作时，有如下需要注意的事项：</p>
<ul>
<li>slice本身并非指针，append追加元素后，意味着底层数组数据（或数组）、len、cap会发生变化，因此append后需要返回新的slice。</li>
<li>append在追加元素时，<strong>当前cap足够容纳元素，则直接存入数据</strong>，否则需要扩容后重新创建新的底层数组，拷贝原数组元素后，再存入追加元素。</li>
<li>cap的扩容意味着内存的重新分配，数据的拷贝等操作，为了提高append的效率，若是能预估cap的大小的话，尽量提前声明cap，避免后期的扩容操作。</li>
</ul>
<p>看下面的例子：</p>
<pre><code class="go">func main() &#123;
    var ret [][]int
    var val = make([]int, 0, 100)
    fmt.Printf(&quot;%p\n&quot;, val)
    deal(&amp;ret, val)
    fmt.Println(ret)
&#125;

func deal(ret *[][]int, val []int) &#123;
    fmt.Printf(&quot;%p\n&quot;, val) // 此时与外面的 val 指定同一个地址（都还未初始化）
    val = append(val, 1)
    val = append(val, 1)
    val = append(val, 1)
    fmt.Printf(&quot;%p\n&quot;, val) // 此时由于底层数组扩容，地址发生改变，跟原来地址不一样了
    *ret = append(*ret, val)

    //val[2] = 2

    // 此时由于为发生扩容，以及修改的是范围里的值，修改会影响原来的
    val = val[:len(val)-1]
    val = append(val, 2)
    fmt.Printf(&quot;%p\n&quot;, val)

    // 继续 append，发生扩容，不会影响原来的
    val = append(val, 4, 5, 6, 7, 8)
    val = val[:3]
    fmt.Printf(&quot;%p\n&quot;, val)
&#125;
</code></pre>
<h2 id="不要将切片作为入参在函数内-append"><a href="#不要将切片作为入参在函数内-append" class="headerlink" title="不要将切片作为入参在函数内 append"></a>不要将切片作为入参在函数内 append</h2><p>观察下面的代码：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    arr := make([]int, 3, 4)
    arr[0] = 0
    arr[1] = 1
    arr[2] = 2
    fmt.Printf(&quot;main before: len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
    ap1(arr)
    fmt.Printf(&quot;main ap1 after: len: %d cap:%d data:%+v\n\n&quot;, len(arr), cap(arr), arr)
&#125;
func ap1(arr []int) &#123;
    fmt.Printf(&quot;ap1 before:  len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
    arr[0] = 11
    arr = append(arr, 111)
    fmt.Printf(&quot;ap1 after:  len: %d cap:%d data:%+v\n&quot;, len(arr), cap(arr), arr)
&#125;
</code></pre>
<p>输出：</p>
<pre><code>main before: len: 3 cap:4 data:[0 1 2]
ap1 before:  len: 3 cap:4 data:[0 1 2]
ap1 after:  len: 4 cap:4 data:[11 1 2 111]
main ap1 after: len: 3 cap:4 data:[11 1 2]
</code></pre>
<p>可以发现，函数内 append 之后，外部实参切片的值没改变，但到底是没改变，还是 <strong>“看不到”</strong> 呢？</p>
<p>首先，slice 是值传递，但是 slice 本身是一个结构体，包含一个指针，指向底层数组，将 slice 按值传递给函数，在函数内对其修改，影响将<strong>会传递到函数外</strong>，因为底层的数组被修改了，但是，<strong>slice 只能感知到 len 范围内的内容</strong>，之外的感知不到的。</p>
<p>由于值传递，外层的 slice 的 len 变量实际上并没有改变，此时还是只能读取到前 3 个值。</p>
<h2 id="不要使用指针指向接口类型"><a href="#不要使用指针指向接口类型" class="headerlink" title="不要使用指针指向接口类型"></a>不要使用指针指向接口类型</h2><p>在下面的程序中：<code>nexter</code> 是一个接口类型，并且定义了一个 <code>next()</code> 方法读取下一字节。函数 <code>nextFew1</code> 将 <code>nexter</code> 接口作为参数并读取接下来的 <code>num</code> 个字节，并返回一个切片：这是正确做法。但是 <code>nextFew2</code> 使用一个指向 <code>nexter</code> 接口类型的指针作为参数传递给函数：当使用 <code>next()</code> 函数时，系统会给出一个编译错误：</p>
<pre><code>n.next undefined (type \*nexter has no field or method next) （n.next 未定义（*nexter 类型没有 next 成员或 next 方法））
</code></pre>
<pre><code class="go">package main
import (
    “fmt”
)
type nexter interface &#123;
    next() byte
&#125;
func nextFew1(n nexter, num int) []byte &#123;
    var b []byte
    for i:=0; i &lt; num; i++ &#123;
        b[i] = n.next()
    &#125;
    return b
&#125;
func nextFew2(n *nexter, num int) []byte &#123;
    var b []byte
    for i:=0; i &lt; num; i++ &#123;
        b[i] = n.next() // 编译错误:n.next未定义（*nexter类型没有next成员或next方法）
    &#125;
    return b
&#125;
func main() &#123;
    fmt.Println(&quot;Hello World!&quot;)
&#125;
</code></pre>
<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong></p>
<h2 id="注意循环中的协程使用"><a href="#注意循环中的协程使用" class="headerlink" title="注意循环中的协程使用"></a>注意循环中的协程使用</h2><p>对于下面的代码：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var values = [5]int&#123;10, 11, 12, 13, 14&#125;

func main() &#123;
    // 版本A:
    for ix := range values &#123; // ix是索引值
        func() &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;() // 调用闭包打印每个索引值
    &#125;
    fmt.Println()
    // 版本B: 和A版本类似，但是通过调用闭包作为一个协程
    for ix := range values &#123;
        go func() &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;()
    &#125;
    fmt.Println()
    time.Sleep(5e9)
    // 版本C: 正确的处理方式
    for ix := range values &#123;
        go func(ix interface&#123;&#125;) &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;(ix)
    &#125;
    fmt.Println()
    time.Sleep(5e9)
    
    // 版本C的另外一种正确的处理方式
    //for ix := range values &#123;
    //	  ix := ix
    //    go func() &#123;
    //        fmt.Print(ix, &quot; &quot;)
    //    &#125;()
    //&#125;
    //fmt.Println()
    //time.Sleep(5e9)
    
    // 版本D: 输出值:
    for ix := range values &#123;
        val := values[ix]
        go func() &#123;
            fmt.Print(val, &quot; &quot;)
        &#125;()
    &#125;
    time.Sleep(1e9)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">        0 1 2 3 4

        4 4 4 4 4

        1 0 3 4 2

        10 11 12 13 14
</code></pre>
<p>版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。</p>
<p>如果阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：<code>4 4 4 4 4</code>。在版本 B 的循环中，<code>ix</code> 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当运行这段代码时，将看见每次循环都打印最后一个索引值 <code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 <code>ix</code> 值是 <code>4</code>。</p>
<p>版本 C 的循环写法才是正确的：调用每个闭包是将 <code>ix</code> 作为参数传递给闭包。<code>ix</code> 在每次循环时都被重新赋值，并将每个协程的 <code>ix</code> 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 <code>0 2 1 3 4</code> 或者 <code>0 3 1 2 4</code> 或者其他类似的序列，这主要取决于每个协程何时开始被执行。</p>
<p>版本 C 的另一个处理方法，<code>ix := ix</code> 可能看起来有点奇怪，但它完全有效。因为处于循环中意味着处于另一个作用域内，所以 <code>ix := ix</code> 相当于创建了另一个名为 <code>ix</code> 的变量实例。</p>
<blockquote>
<p>用 <strong>大括号</strong> <code>&#123;&#125;</code> 包围的一个代码块相当于一个新的作用域，可以定义同名变量</p>
</blockquote>
<p>在版本 D 中，能够正确输出这个数组的值，因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。</p>
<h2 id="不要在生产环境使用默认的-HTTP-Client"><a href="#不要在生产环境使用默认的-HTTP-Client" class="headerlink" title="不要在生产环境使用默认的 HTTP Client"></a>不要在生产环境使用默认的 HTTP Client</h2><p>Go 默认的 HTTP 客户端没有指定请求超时时间，允许服务劫持 goroutine。当请求外部服务时，请始终使用自定义的 <code>http.Client</code>。</p>
<p>Go 的 HTTP 包使用 <code>Client</code> 结构体来管理 HTTP(S) 通信的内部过程。<code>Clients</code> 是并发安全的对象，包含配置、管理 TCP 状态、处理 cookies 等。当使用 <code>http.Get(url)</code> 时，就会调用  <code>http.DefaultClient</code>，走的是 HTTP 默认配置，声明如下：</p>
<pre><code class="go">var DefaultClient = &amp;Client&#123;&#125;
</code></pre>
<p>除其他配置项外，<code>http.Client</code> 有一个超时时间的配置，当请求时间超过这个数值时，请求就会自动断开。该数值默认值是 0，即没有超时时间。该默认值对于 HTTP 包来说挺合理的，同时这也是一个容易让人掉进去的坑，如果请求的对象宕机或者因为其他原因一直没有响应，就会导致发起请求的 groutine 挂起，只要发生故障的服务器没有恢复，进程就会一直挂着。因为进行 API 调用是为了服务用户请求，所以这也会导致服务用户请求的 goroutine 也挂起。一旦有足够的人发起这个 http 请求，很有可能就因为系统资源达到了极限导致应用挂掉。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决这个问题的办法就是使用 <code>http.Client</code> 时定义一个合理的超时时间，比如下面这样的：</p>
<pre><code class="go">var netClient = &amp;http.Client&#123;
  Timeout: time.Second * 10,
&#125;
response, _ := netClient.Get(url)
</code></pre>
<p>设置了 10s 的超时时间，如果超时 <code>Get()</code> 将会返回错误：</p>
<pre><code class="go">&amp;httpError&#123;
  err:     err.Error() + &quot; (Client.Timeout exceeded while awaiting headers)&quot;,
  timeout: true,
&#125;
</code></pre>
<p>如果需要对请求生命周期进行更细粒度的控制，还可以另外指定自定义 <code>net.Transport</code> 和 <code>net.Dialer</code>。</p>
<p><code>Transport</code> 结构体用来管理底层 TCP 连接，<code>Dialer</code> 是用来管理连接建立的结构体。Go 的 net 包使用默认的 <code>Transport</code> 和 <code>Dialer</code>。下面是一个自定义的例子：</p>
<pre><code class="go">var netTransport = &amp;http.Transport&#123;
  Dial: (&amp;net.Dialer&#123;
    Timeout: 5 * time.Second,
  &#125;).Dial,
  TLSHandshakeTimeout: 5 * time.Second,
&#125;
var netClient = &amp;http.Client&#123;
  Timeout: time.Second * 10,
  Transport: netTransport,
&#125;
response, _ := netClient.Get(url)
</code></pre>
<p>上面代码设置了 TCP 拨号时间、TLS 握手时间和请求超时时间。如果有需要还可以设置其他选项，例如 <code>keep-alive</code> 超时时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言的 <code>net/http</code> 包是经过深思熟虑的产物，可以非常便捷地用于 HTTP(S) 通信。然而，缺少请求超时时间是一个非常容易掉进去的坑，因为这个包提供了很多诸如 http.Get(url) 等便捷的方法。请求远程服务时不设置超时时间会使应用程序依赖于该服务，如果远程服务发生故障或者有恶意程序，请求将会永远挂起，从而有可能使系统资源耗尽导致宕机。</p>
<h2 id="map的key-value不能同时断言"><a href="#map的key-value不能同时断言" class="headerlink" title="map的key,value不能同时断言"></a>map的key,value不能同时断言</h2><p>对于一个类型为 <code>interface</code> 的变量，当其实际的值为一个 <code>map</code> 值，例如 <code>map[string]string</code>，此时如果要对该变量进行类型断言，不可以直接使用如下格式：</p>
<pre><code class="go">// v:&#123;&quot;aa&quot;:&quot;vv&quot;&#125;
var v interface&#123;&#125;
v2,ok := v.(map[string]string) // ok==false
</code></pre>
<p>对于 map 的 key 和 value 进行断言时，一次只能断言一个数据结构的类型，因此需要分开进行断言：</p>
<pre><code class="go">v2,ok := v.(map[string]interface&#123;&#125;) // ok==true
v3,ok := v2[&quot;aa&quot;].(string) // ok==true
</code></pre>
<blockquote>
<p>断言的真正含义是让编译器应该把某个变量当成什么类型，而不是真的类型转换，不涉及内存上面的操作，真正的类型转换应该是会涉及内存上面的操作的。</p>
</blockquote>
<p>具体的实例见下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png" alt="map的断言"></p>
<h2 id="未知枚举值"><a href="#未知枚举值" class="headerlink" title="未知枚举值"></a>未知枚举值</h2><pre><code class="go">type Status uint32

const (
  StatusOpen Status = iota
  StatusClosed
  StatusUnknown
)
</code></pre>
<p>在这里，我们使用 iota 创建了一个枚举：</p>
<pre><code class="go">StatusOpen = 0
StatusClosed = 1
StatusUnknown = 2
</code></pre>
<p>现在，假设这个 <code>Status</code> 类型是 JSON 请求的一部分，将被 <code>marshalled/unmarshalled</code>。</p>
<p>设计了以下结构：</p>
<pre><code class="go">type Request struct &#123;
  ID        int    `json:&quot;Id&quot;`
  Timestamp int    `json:&quot;Timestamp&quot;`
  Status    Status `json:&quot;Status&quot;`
&#125;
</code></pre>
<p>然后，接收这样的请求：</p>
<pre><code class="json">&#123;
  &quot;Id&quot;: 1234,
  &quot;Timestamp&quot;: 1563362390,
  &quot;Status&quot;: 0
&#125;
</code></pre>
<p>这样子不会有任何问题，状态会被<code>unmarshalled</code>为<code>StatusOpen</code>。</p>
<p>然而，让我们以另一个未设置状态值的请求为例:</p>
<pre><code class="json">&#123;
  &quot;Id&quot;: 1235,
  &quot;Timestamp&quot;: 1563362390
&#125;
</code></pre>
<p>在这种情况下，请求结构的 <code>Status</code> 字段将初始化为它的零值(对于<code>uint32</code>类型:0)，因此结果将是 <code>StatusOpen</code> 而不是 <code>StatusUnknown</code>。所以在这种场景下，最好的做法是<strong>将枚举的未知值设置为 0</strong>：</p>
<pre><code class="go">type Status uint32

const (
  StatusUnknown Status = iota
  StatusOpen
  StatusClosed
)
</code></pre>
<p>如果状态不是 JSON 请求的一部分，它将被初始化为<code>StatusUnknown</code>，这才符合期望。</p>
<h3 id="基准测试自动优化"><a href="#基准测试自动优化" class="headerlink" title="基准测试自动优化"></a>基准测试自动优化</h3><p>基准测试主要就是测试代码整体的吞吐量，性能等，如果编写的测试代码由于被编译器所优化，会导致测试结果不准确。</p>
<p>例如下面的函数：</p>
<pre><code class="go">func clear(n uint64, i, j uint8) uint64 &#123;
  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n
&#125;
</code></pre>
<p>此函数清除给定范围内的位。为了测试它，可能如下这样做:</p>
<pre><code class="go">func BenchmarkWrong(b *testing.B) &#123;
  for i := 0; i &lt; b.N; i++ &#123;
    clear(1221892080809121, 10, 63)
  &#125;
&#125;
</code></pre>
<p>在这个基准测试中，<code>clear</code> 不调用任何其他函数，没有<strong>副作用</strong>。所以编译器将会把 <code>clear</code> 优化成内联函数。一旦内联，将会导致不准确的测试结果。</p>
<p>一个解决方案是<strong>将函数结果设置为全局变量</strong>，如下所示：</p>
<pre><code class="go">var result uint64

func BenchmarkCorrect(b *testing.B) &#123;
  var r uint64
  for i := 0; i &lt; b.N; i++ &#123;
    r = clear(1221892080809121, 10, 63)
  &#125;
  result = r
&#125;
</code></pre>
<p>如此一来，编译器将不知道<code>clear</code>是否会产生副作用。</p>
<p>因此，不会将<code>clear</code>优化成内联函数。</p>
<h2 id="指针迁移到堆上导致指针传递比按值传递更慢"><a href="#指针迁移到堆上导致指针传递比按值传递更慢" class="headerlink" title="指针迁移到堆上导致指针传递比按值传递更慢"></a>指针迁移到堆上导致指针传递比按值传递更慢</h2><p>在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。</p>
<p>那么，指针传递会比按值传递更快吗？</p>
<p>对于下面这里例子：</p>
<pre><code class="go">package main

import (
    &quot;encoding/json&quot;
    &quot;testing&quot;
)

type foo struct &#123;
    ID            string  `json:&quot;_id&quot;`
    Index         int     `json:&quot;index&quot;`
    GUID          string  `json:&quot;guid&quot;`
    IsActive      bool    `json:&quot;isActive&quot;`
    Balance       string  `json:&quot;balance&quot;`
    Picture       string  `json:&quot;picture&quot;`
    Age           int     `json:&quot;age&quot;`
    EyeColor      string  `json:&quot;eyeColor&quot;`
    Name          string  `json:&quot;name&quot;`
    Gender        string  `json:&quot;gender&quot;`
    Company       string  `json:&quot;company&quot;`
    Email         string  `json:&quot;email&quot;`
    Phone         string  `json:&quot;phone&quot;`
    Address       string  `json:&quot;address&quot;`
    About         string  `json:&quot;about&quot;`
    Registered    string  `json:&quot;registered&quot;`
    Latitude      float64 `json:&quot;latitude&quot;`
    Longitude     float64 `json:&quot;longitude&quot;`
    Greeting      string  `json:&quot;greeting&quot;`
    FavoriteFruit string  `json:&quot;favoriteFruit&quot;`
&#125;
type bar struct &#123;
    ID            string
    Index         int
    GUID          string
    IsActive      bool
    Balance       string
    Picture       string
    Age           int
    EyeColor      string
    Name          string
    Gender        string
    Company       string
    Email         string
    Phone         string
    Address       string
    About         string
    Registered    string
    Latitude      float64
    Longitude     float64
    Greeting      string
    FavoriteFruit string
&#125;

var input foo

func init() &#123;
    err := json.Unmarshal([]byte(`&#123;
        &quot;_id&quot;: &quot;5d2f4fcf76c35513af00d47e&quot;,
        &quot;index&quot;: 1,
        &quot;guid&quot;: &quot;ed687a14-590b-4d81-b0cb-ddaa857874ee&quot;,
        &quot;isActive&quot;: true,
        &quot;balance&quot;: &quot;$3,837.19&quot;,
        &quot;picture&quot;: &quot;https://placehold.it/32x32&quot;,
        &quot;age&quot;: 28,
        &quot;eyeColor&quot;: &quot;green&quot;,
        &quot;name&quot;: &quot;Rochelle Espinoza&quot;,
        &quot;gender&quot;: &quot;female&quot;,
        &quot;company&quot;: &quot;PARLEYNET&quot;,
        &quot;email&quot;: &quot;rochelleespinoza@parleynet.com&quot;,
        &quot;phone&quot;: &quot;+1 (969) 445-3766&quot;,
        &quot;address&quot;: &quot;956 Little Street, Jugtown, District Of Columbia, 6396&quot;,
        &quot;about&quot;: &quot;Excepteur exercitation labore ut cupidatat laboris mollit ad qui minim aliquip nostrud anim adipisicing est. Nisi sunt duis occaecat aliquip est irure Lorem irure nulla tempor sit sunt. Eiusmod laboris ex est velit minim ut cillum sunt laborum labore ad sunt.\r\n&quot;,
        &quot;registered&quot;: &quot;2016-03-20T12:07:25 -00:00&quot;,
        &quot;latitude&quot;: 61.471517,
        &quot;longitude&quot;: 54.01596,
        &quot;greeting&quot;: &quot;Hello, Rochelle Espinoza!You have 9 unread messages.&quot;,
        &quot;favoriteFruit&quot;: &quot;banana&quot;
      &#125;`), &amp;input)
    if err != nil &#123;
        panic(err)
    &#125;
&#125;

func byPointer(in *foo) *bar &#123;
    return &amp;bar&#123;
        ID:            in.ID,
        Address:       in.Address,
        Email:         in.Email,
        Index:         in.Index,
        Name:          in.Name,
        About:         in.About,
        Age:           in.Age,
        Balance:       in.Balance,
        Company:       in.Company,
        EyeColor:      in.EyeColor,
        FavoriteFruit: in.FavoriteFruit,
        Gender:        in.Gender,
        Greeting:      in.Greeting,
        GUID:          in.GUID,
        IsActive:      in.IsActive,
        Latitude:      in.Latitude,
        Longitude:     in.Longitude,
        Phone:         in.Phone,
        Picture:       in.Picture,
        Registered:    in.Registered,
    &#125;
&#125;

func byValue(in foo) bar &#123;
    return bar&#123;
        ID:            in.ID,
        Address:       in.Address,
        Email:         in.Email,
        Index:         in.Index,
        Name:          in.Name,
        About:         in.About,
        Age:           in.Age,
        Balance:       in.Balance,
        Company:       in.Company,
        EyeColor:      in.EyeColor,
        FavoriteFruit: in.FavoriteFruit,
        Gender:        in.Gender,
        Greeting:      in.Greeting,
        GUID:          in.GUID,
        IsActive:      in.IsActive,
        Latitude:      in.Latitude,
        Longitude:     in.Longitude,
        Phone:         in.Phone,
        Picture:       in.Picture,
        Registered:    in.Registered,
    &#125;
&#125;

var pointerResult *bar
var valueResult bar

func BenchmarkByPointer(b *testing.B) &#123;
    var r *bar
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ &#123;
        r = byPointer(&amp;input)
    &#125;
    pointerResult = r
&#125;

func BenchmarkByValue(b *testing.B) &#123;
    var r bar
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ &#123;
        r = byValue(input)
    &#125;
    valueResult = r
&#125;
</code></pre>
<p>通过基准测试分别测试了按值传递和指针传递的速度。</p>
<p>结果显示，按值传递比指针传递快3-4倍以上：</p>
<pre><code class="go">goos: darwin
goarch: amd64
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkByPointer
BenchmarkByPointer-4   	11838573	        91.03 ns/op
BenchmarkByValue
BenchmarkByValue-4     	38128300	        31.21 ns/op
PASS
</code></pre>
<p>测试结果与 Go 中如何管理内存有关，主要原因如下：</p>
<ol>
<li><p>下面是来自 Go 语言圣经的介绍：</p>
<p> 一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。</p>
<p> 一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。</p>
<p> 而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。</p>
</li>
<li><p>通俗的理解：</p>
<ul>
<li>栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（<strong>Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小</strong>）</li>
<li>堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。</li>
</ul>
</li>
</ol>
<p>众所周知，可以在<strong>堆</strong>或<strong>栈</strong>上分配变量。</p>
<ul>
<li>栈储存当前 <code>Goroutine</code> 的正在使用的变量（可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。</li>
<li>堆储存<strong>共享变量</strong>（全局变量等）。</li>
</ul>
<p>看一个简单的例子，返回单一的值：</p>
<pre><code class="go">func getFooValue() foo &#123;
  var result foo
  // Do something
  return result
&#125;
</code></pre>
<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而 <code>result</code> 变量自身会从当前 Goruntine 栈出栈。</p>
<p>虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。</p>
<p>现在，在看一个返回指针的例子：</p>
<pre><code class="go">func getFooPointer() *foo &#123;
  var result foo
  // Do something
  return &amp;result
&#125;
</code></pre>
<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果 <code>result</code> 变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（此情况称为“内存逃逸”）</p>
<p>在这个场景中，Go 编译器将把 <code>result</code> 变量<strong>转义</strong>到一个可以共享变量的地方:<strong>堆</strong>。</p>
<p>不过，传递指针是另一种情况。例如：</p>
<pre><code class="go">func main()  &#123;
  p := &amp;foo&#123;&#125;
  f(p)
&#125;
</code></pre>
<p>因为我们在同一个 Goroutine 中调用<code>f</code>，所以 <code>p</code> 变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（不需要其他 Goruntine 共享的变量就存储在栈上即可）</p>
<p>比如，<code>io.Reader</code> 中的 <code>Read</code> 方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（<strong>如果返回切片，会将切片转义到堆中</strong>。）</p>
<pre><code class="go">type Reader interface &#123;
  Read(p []byte) (n int, err error)
&#125;
</code></pre>
<p>为什么栈如此之快？ 主要有两个原因：</p>
<ol>
<li><strong>堆栈不需要垃圾收集器。</strong>就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。</li>
<li><strong>储存变量不需要考虑同步。</strong>栈属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。</li>
</ol>
<p>总之，当创建一个函数时，<strong>默认行为应该是使用值</strong>而不是指针。只有在我们<strong>想要共享变量时才应使用指针。</strong></p>
<p>如果遇到性能问题，可以使用 <code>go build -gcflags &quot;-m -m&quot;</code> 命令，来显示编译器将变量转义到堆的具体操作。</p>
<p>再次重申，对于大多数日常用例来说，值传递是最合适的。</p>
<h2 id="break-逻辑不符合预期"><a href="#break-逻辑不符合预期" class="headerlink" title="break 逻辑不符合预期"></a>break 逻辑不符合预期</h2><pre><code class="go">for &#123;
  switch f() &#123;
  case true:
    break
  case false:
    // Do something
  &#125;
&#125;
</code></pre>
<p>如果 f 返回 true，将调用 break 语句。然而，将会 break 出 switch 语句，而不是 for 循环。</p>
<p>同样的问题：</p>
<pre><code class="go">for &#123;
  select &#123;
  case &lt;-ch:
  // Do something
  case &lt;-ctx.Done():
    break
  &#125; 
&#125;
</code></pre>
<p>break 与 select 语句有关，与 for 循环无关。</p>
<p>break 出 for&#x2F;switch 或 for&#x2F;select  的一种解决方案是<strong>使用带标签的 break</strong>，如下所示：</p>
<pre><code class="go">loop:
  for &#123;
    select &#123;
    case &lt;-ch:
    // Do something
    case &lt;-ctx.Done():
      break loop
    &#125;
  &#125;
</code></pre>
<h2 id="缺失上下文的错误"><a href="#缺失上下文的错误" class="headerlink" title="缺失上下文的错误"></a>缺失上下文的错误</h2><p>Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。</p>
<p>当前的标准库(在 Go 1.13 之前)只提供 <code>error</code> 的构造函数，自然而然就会缺失其他信息。</p>
<p>看一下 <a target="_blank" rel="noopener" href="https://github.com/pkg/errors">pkg&#x2F;errors</a> 库中错误处理的思想：</p>
<p><em>An error should be handled only</em> <strong>once</strong>. Logging an error <strong>is</strong> <em>handling an error. So an error should</em> <strong>either</strong> <em>be logged or propagated.</em></p>
<blockquote>
<p>错误应该只处理一次。记录 log 错误就是在处理错误。所以，错误应该记录或者传播</p>
</blockquote>
<p>对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。</p>
<p>例如: 所期望的<code>REST</code>调用导致数据库问题的示例：</p>
<pre><code>COPYunable to server HTTP POST request for customer 1234
 |_ unable to insert customer contract abcd
     |_ unable to commit transaction
</code></pre>
<p>如果我们使用 <code>pkg/errors</code>，可以这样做：</p>
<pre><code class="go">COPYfunc postHandler(customer Customer) Status &#123;
  err := insert(customer.Contract)
  if err != nil &#123;
    log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
    return Status&#123;ok: false&#125;
  &#125;
  return Status&#123;ok: true&#125;
&#125;

func insert(contract Contract) error &#123;
  err := dbQuery(contract)
  if err != nil &#123;
    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)
  &#125;
  return nil
&#125;

func dbQuery(contract Contract) error &#123;
  // Do something then fail
  return errors.New(&quot;unable to commit transaction&quot;)
&#125;
</code></pre>
<p>如果不是由外部库返回的初始 <code>error</code> 可以使用 <code>error.New</code> 创建。中间层 <code>insert</code> 对此错误添加更多上下文信息。最终通过 <code>log</code> 错误来处理错误。每个级别要么返回错误，要么处理错误。</p>
<p>我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的 <code>db</code> 包来处理数据库访问。 该库可能会返回一个名为 <code>db.DBError</code> 的临时错误。要确定是否需要重试，我们必须检查错误原因：</p>
<p>使用 <code>pkg/errors</code> 中提供的 <code>errors.Cause</code> 可以判断错误原因。</p>
<pre><code class="go">COPYfunc postHandler(customer Customer) Status &#123;
  err := insert(customer.Contract)
  if err != nil &#123;
    switch errors.Cause(err).(type) &#123;
    default:
      log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
      return Status&#123;ok: false&#125;
    case *db.DBError:
      return retry(customer)
    &#125;
  &#125;
  return Status&#123;ok: true&#125;
&#125;

func insert(contract Contract) error &#123;
  err := db.dbQuery(contract)
  if err != nil &#123;
    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)
  &#125;
  return nil
&#125;
</code></pre>
<p>一个常见错误是部分使用 <code>pkg/errors</code>。 例如，通过这种方式检查错误：</p>
<pre><code class="go">COPYswitch err.(type) &#123;
default:
  log.WithError(err).Errorf(&quot;unable to server HTTP POST request for customer %s&quot;, customer.ID)
  return Status&#123;ok: false&#125;
case *db.DBError:
  return retry(customer)
&#125;
</code></pre>
<p>在此示例中，如果 <code>db.DBError</code> 被 <code>wrapped</code>，它将永远不会执行 <code>retry</code>。</p>
<h2 id="传递文件名给函数"><a href="#传递文件名给函数" class="headerlink" title="传递文件名给函数"></a>传递文件名给函数</h2><p>假设实现一个函数来计算文件中的空行数。最初的实现是这样的：</p>
<pre><code class="go">COPYfunc count(filename string) (int, error) &#123;
  file, err := os.Open(filename)
  if err != nil &#123;
    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)
  &#125;
  defer file.Close()

  scanner := bufio.NewScanner(file)
  count := 0
  for scanner.Scan() &#123;
    if scanner.Text() == &quot;&quot; &#123;
      count++
    &#125;
  &#125; 
  return count, nil
&#125;
</code></pre>
<p><code>filename</code> 作为给定的参数，然后打开该文件，再实现读空白行的逻辑，嗯，没有问题。</p>
<p>假设希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。</p>
<p>此外，如果我们想对于 <code>HTTP Body</code> 实现相同的逻辑，将不得不为此创建另一个函数。</p>
<p>Go 设计了两个很棒的接口：<code>io.Reader</code> 和 <code>io.Writer</code> (常见 IO 命令行，文件，网络等)</p>
<p>所以<strong>可以传递一个抽象数据源的<code>io.Reader</code>，而不是传递文件名</strong>。</p>
<p>仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？</p>
<p>答案并不重要，重要的是无论 <code>Reader</code> 读取的是什么类型的数据，都会使用相同的 <code>Read</code> 方法。</p>
<p>在例子中，甚至可以缓冲输入以逐行读取它（使用 <code>bufio.Reader</code> 及其 <code>ReadLine</code> 方法）：</p>
<pre><code class="go">COPYfunc count(reader *bufio.Reader) (int, error) &#123;
  count := 0
  for &#123;
    line, _, err := reader.ReadLine()
    if err != nil &#123;
      switch err &#123;
      default:
        return 0, errors.Wrapf(err, &quot;unable to read&quot;)
      case io.EOF:
        return count, nil
      &#125;
    &#125;
    if len(line) == 0 &#123;
      count++
    &#125;
  &#125;
&#125;
</code></pre>
<p>打开文件的逻辑现在交给调用 <code>count</code> 方：</p>
<pre><code class="go">COPYfile, err := os.Open(filename)
if err != nil &#123;
  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)
&#125;
defer file.Close()
count, err := count(bufio.NewReader(file))
</code></pre>
<p>无论数据源如何，都可以调用 <code>count</code>。并且，还将促进单元测试，因为可以从字符串创建一个 <code>bufio.Reader</code>，这大大提高了效率。</p>
<pre><code class="go">COPYcount, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))
</code></pre>
<h2 id="int32-转-string-时，直接使用-string-强转输出为-ASCII-码"><a href="#int32-转-string-时，直接使用-string-强转输出为-ASCII-码" class="headerlink" title="int32 转 string 时，直接使用 string 强转输出为 ASCII 码"></a>int32 转 string 时，直接使用 string 强转输出为 ASCII 码</h2><p>对于 int32 类型的变量，转换为 string 时，不能直接 string 强转，应该使用 strconv 包来进行转换：</p>
<pre><code class="go">func main() &#123;
    var num int32 = 88
    fmt.Println(string(num)) // 输出为 &#39;X&#39;
    fmt.Println(strconv.Itoa(int(num))) // 输出为 &quot;88&quot;
&#125;
</code></pre>
<h2 id="Go-变量并发赋值的安全性"><a href="#Go-变量并发赋值的安全性" class="headerlink" title="Go 变量并发赋值的安全性"></a>Go 变量并发赋值的安全性</h2><h3 id="结构体并发赋值的不安全性"><a href="#结构体并发赋值的不安全性" class="headerlink" title="结构体并发赋值的不安全性"></a>结构体并发赋值的不安全性</h3><p>以下代码，在多协程的情况下，并发使用两个不同的值对结构体变量进行赋值：</p>
<pre><code class="go">type Test struct &#123;
    X int
    Y int
&#125;

func main() &#123;
    var g Test

    for i := 0; i &lt; 1000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = Test&#123;1,2&#125;
        &#125;()

        // 协程 2
        wg.Add(1)
        go func()&#123;
            defer wg.Done()
            g = Test&#123;3,4&#125;
        &#125;()
        wg.Wait()

        // 赋值异常判断
        if !((g.X == 1 &amp;&amp; g.Y == 2) || (g.X == 3 &amp;&amp; g.Y == 4)) &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v g=%+v&quot;, i, g)
            break
        &#125;
    &#125;
&#125;
</code></pre>
<p>运行一次或多次，将出现赋值异常。</p>
<pre><code class="javascript">concurrent assignment error, i=48714 g=&#123;X:1 Y:4&#125;
</code></pre>
<p>结构体中有多个字段，协程 1 赋值了字段 X，协程 2 赋值了字段 Y，此时整个结构体既不是协程 1 想要的结果，也不是协程 2 想要的结果。</p>
<p><strong>可见 struct 赋值时，并不是原子操作，各个字段的赋值是独立的，在并发操作的情况下可能会出现异常</strong>。</p>
<h3 id="哪些类型并发赋值是安全的"><a href="#哪些类型并发赋值是安全的" class="headerlink" title="哪些类型并发赋值是安全的"></a>哪些类型并发赋值是安全的</h3><p>Golang 中数据类型可以分类两大类：基本数据类型和复合数据类型。</p>
<ul>
<li><p>基本数据类型有：字节型，布尔型、整型、浮点型、字符型、复数型、字符串。</p>
</li>
<li><p>复合数据类型包括：指针、数组、切片、结构体、字典、通道、函数、接口。</p>
</li>
</ul>
<p>复合数据类又可细分为如下三类： （1）非引用类型：数组、结构体； （2）引用类型：指针、切片、字典、通道、函数； （3）接口。</p>
<h4 id="基本类型的并发赋值"><a href="#基本类型的并发赋值" class="headerlink" title="基本类型的并发赋值"></a>基本类型的并发赋值</h4><h5 id="字节型、布尔型、整型、浮点型、字符型（安全）"><a href="#字节型、布尔型、整型、浮点型、字符型（安全）" class="headerlink" title="字节型、布尔型、整型、浮点型、字符型（安全）"></a>字节型、布尔型、整型、浮点型、字符型（安全）</h5><p>由于字节型、布尔型、整型、浮点型、字符型的位宽不会超过 64 位，在 64 位的指令集架构中可以由一条机器指令完成，不存在被细分为更小的操作单位，所以这些类型的并发赋值是安全的。</p>
<h5 id="复数型（不安全）"><a href="#复数型（不安全）" class="headerlink" title="复数型（不安全）"></a>复数型（不安全）</h5><p>因为复数型分为实部和虚部，两者的赋值是分开进行的，所以复数类型并发赋值是不安全的。</p>
<pre><code class="go">func main() &#123;
    var g complex64

    for i := 0; i &lt; 1000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = complex(1,2)
        &#125;()

        // 协程 2
        wg.Add(1)
        go func()&#123;
            defer wg.Done()
            g = complex(3,4)
        &#125;()
        wg.Wait()

        // 赋值异常判断
        if g != complex(1,2) &amp;&amp; g != complex(3,4) &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v g=%+v&quot;, i, g)
            break
        &#125;
    &#125;
&#125;
</code></pre>
<p>运行输出：</p>
<pre><code class="javascript">concurrent assignment error, i=131512 g=(1+4i)
</code></pre>
<p><strong>注意：如果复数并发赋值时，有相同的虚部或实部，那么两个字段赋值就退化成一个字段，这种情况下时并发安全的</strong>。</p>
<h5 id="字符串（不安全）"><a href="#字符串（不安全）" class="headerlink" title="字符串（不安全）"></a>字符串（不安全）</h5><p>字符串在 Go 中是一个只读字节切片。</p>
<p>字符串有两个重要特点：</p>
<ol>
<li>string 可以为空（长度为 0），但不会是 nil</li>
<li>string对象不可以修改。</li>
</ol>
<p>在源码包  <code>src/runtime/string.go</code> 可以找到 string 的底层数据结构：</p>
<pre><code class="go">type stringStruct struct &#123;
    str unsafe.Pointer
    len int
&#125;
</code></pre>
<p>其数据结构很简单： str 为字符串的首地址； len 为字符串的长度（单位字节）； string 数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上 string 和字节切片间经常强制互转。</p>
<p>因为 string 底层结构是个 struct，前面已经讨论过 struct 并发赋值是不安全的，所以 string 的并发赋值同样是不安全。</p>
<p>可以说，只要底层结构是 struct 的类型，那么并发赋值都是不安全的。</p>
<p><strong>不安全不代表一定发生错误</strong>。因为是两个字段，字节指针 str 和字符串长度 len，只要保证并发赋值情况下，两个字段的赋值正确就行。前面也说了，因为 struct 多个字段的赋值是独立，所以如果两个字段中只有一个字段是不同的，那么并发赋值就变成了一个字段的并发赋值，这样就不会出现问题。</p>
<p>比如<strong>并发赋值两个等长度但内容不同的字符串</strong>，就不会有问题。验证如下：</p>
<pre><code class="go">func main() &#123;
    var s string

    for i := 0; i &lt; 1000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            s = &quot;123&quot;
        &#125;()

        // 协程 2
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            s = &quot;abc&quot;
        &#125;()
        wg.Wait()

        // 赋值异常判断
        if s != &quot;123&quot; &amp;&amp; s != &quot;abc&quot; &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v s=%v&quot;, i, s)
            break
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面的代码，因为字符串 123 和 abc 是等长的，所以并发赋值不管循环多少次都是绝对的安全。因为 struct 赋值蜕变成了一个数值型指针的赋值。</p>
<h4 id="复合数据类型的并发赋值"><a href="#复合数据类型的并发赋值" class="headerlink" title="复合数据类型的并发赋值"></a>复合数据类型的并发赋值</h4><h5 id="指针（安全）"><a href="#指针（安全）" class="headerlink" title="指针（安全）"></a>指针（安全）</h5><p>指针是保存另一个变量的内存地址的变量。指针的零值为 nil。</p>
<p>因为是内存地址，所以位宽为 32位（x86平台）或 64位（x64平台），赋值操作由一个机器指令即可完成，不能被中断，所以也不会出现并发赋值不安全的情况。</p>
<h5 id="函数（安全）"><a href="#函数（安全）" class="headerlink" title="函数（安全）"></a>函数（安全）</h5><p>Go 函数可以像值一样传递。</p>
<p>Go 函数定义形式如下：</p>
<pre><code class="go">func some_func_name(arguments) return_values
</code></pre>
<p>定义函数类型时去掉函数名：</p>
<pre><code class="go">type TypeName func(arguments) return_values
</code></pre>
<p>复制</p>
<p>其中 TypeName 是自定义的类型名称。</p>
<p>函数类型的变量赋值时，实际上赋的是函数地址，一条机器指令便可以完成，所以并发赋值是安全的。</p>
<h5 id="数组、切片、字典、通道、接口（不安全）"><a href="#数组、切片、字典、通道、接口（不安全）" class="headerlink" title="数组、切片、字典、通道、接口（不安全）"></a>数组、切片、字典、通道、接口（不安全）</h5><p>数组、切片、字典、通道、接口，这些复合类型，除了数组，其他底层数据结构都是 struct，所以并发都不是安全的，当然数组并发赋值也是不安全的。</p>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>array 是相同类型值的集合，数组的长度是其类型的一部分。</p>
<p>数组赋值和传参都会拷贝整个数组的数据，所以数组不是引用类型。</p>
<p>数组的底层数据结构就是其本身，是一个相同类型不同值的顺序排列。所以如果数组位宽不大于 64 位且是 2 的整数次幂（8，16，32，64），那么其并发赋值其实也是安全的，只不过这个大部分情况并非如此，所以其并发赋值是不安全的。</p>
<p>下面以字节数组为例，看下位宽不大于 64 位的并发赋值安全的情况。</p>
<pre><code class="go">func main() &#123;
    var g [4]byte

    var i int
    for ; i &lt; 10000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = [...]byte&#123;1, 2, 3, 4&#125;
        &#125;()

        // 协程 2
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = [...]byte&#123;3, 4, 5, 6&#125;
        &#125;()
        wg.Wait()

        // 赋值异常判断
        if !(g == [...]byte&#123;1, 2, 3, 4&#125; || g == [...]byte&#123;3, 4, 5, 6&#125;) &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v g=%+v&quot;, i, g)
            break
        &#125;
    &#125;
    if i == 10000000 &#123;
        fmt.Println(&quot;no error&quot;)
    &#125;
&#125;
</code></pre>
<p>运行输出：</p>
<pre><code class="javascript">no error
</code></pre>
<p>可以看到，位宽为 32 位的数组 [4]byte，虽然有四个元素，但是赋值时由一条机器指令完成，所以也是原子操作。</p>
<p>如果把字节数组的长度换成下面这样子，即使没有超过 64 位，也需要多条指令完成赋值，因为 CPU 中并没有这样位宽的寄存器，需要拆分为多条指令来完成。</p>
<pre><code class="javascript">[3]byte
[5]byte
[7]byte
</code></pre>
<h6 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h6><p>slice 也是相同类型值的集合，只不过切片是动态调整大小的，内部是对数组的引用，相当于动态数组。如上所述，数组的大小是固定的，因此切片为数组提供了更灵活的接口。</p>
<p>切片是一种引用类型，它内部由三个字段表示：</p>
<ul>
<li>数组地址</li>
<li>数组长度</li>
<li>容量大小</li>
</ul>
<p>在源码包<code>src/runtime/slice.go</code>可以找到切片的底层数据结构：</p>
<pre><code class="go">type slice struct &#123;
    array unsafe.Pointer
    len   int
    cap   int
&#125;
</code></pre>
<p>因为其是一个 struct，所以并发赋值是不安全的。</p>
<h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><p>map 是经常被使用的内置 key-value 型容器，是一个同类型元素的无序组，元素通过另一类型唯一键进行索引。</p>
<p>map 的底层结构也是一个 struct，定义于<code>src/runtime/map.go</code>：</p>
<pre><code class="javascript">// A header for a Go map.
type hmap struct &#123;
    // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
    // Make sure this stays in sync with the compiler&#39;s definition.
    count     int // # live cells == size of map.  Must be first (used by len() builtin)
    flags     uint8
    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
    noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
    hash0     uint32 // hash seed

    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

    extra *mapextra // optional fields
&#125;
</code></pre>
<p>map 并发读写会引发 panic，一般使用读写锁 sync.RWMutex 来保证安全。</p>
<h6 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h6><p>channel 在 goroutine 之间提供同步和通信。可以将其视为 goroutines 通过其发送值和接收值的管道。操作符<code>&lt;-</code>用于发送或接收数据，箭头方向指定数据流的方向。</p>
<pre><code class="go">ch &lt;- val    	// Sending a value present in var variable to channel
val := &lt;-cha	// Receive a value from  the channel and assign it to val variable
</code></pre>
<p>因为 channel 通常用法是初始化后作为共享变量在 goroutine 之间提供同步和通信，很少会发生赋值，就是把一个 channel 赋给另一个 channel，所以这里就不过多讨论其并发赋值的安全性。</p>
<p>如果真的有这种情况，那么只要知道其底层数据结构是个 struct，并发赋值时不安全的即可。</p>
<p>关于 channel 的底层数据接口可在 Go 源码<code>src\runtime\chan.go</code>。</p>
<pre><code class="go">type hchan struct &#123;
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
&#125;
</code></pre>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>接口是 Go 中的一个类型，它是方法的集合。实现接口的所有方法的任何类型都属于该接口类型。接口的零值为 nil。</p>
<p>定义一个接口类型的变量后，如果具体类型实现了接口的所有方法，可以将任何具体类型的值赋给这个变量。</p>
<p>实际上 Go 中的接口有个特殊情况，就是空接口，其不包含任何方法。因此，默认情况下，所有具体类型都实现空接口。</p>
<p>如果编写的函数接受空接口，则可以向该函数传递任何类型。</p>
<pre><code class="javascript">package main

import &quot;fmt&quot;

func main() &#123;
    test(&quot;thisisstring&quot;)
    test(&quot;10&quot;)
    test(true)
&#125;

func test(a interface&#123;&#125;) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, a, a)
&#125;
</code></pre>
<p>运行输出：</p>
<pre><code class="go">(thisisstring, string)
(10, string)
(true, bool)
</code></pre>
<p>因为存在两种类型的接口，包含方法的非空接口和不包含任何方法的空接口，所以在底层实现上使用<code>runtime.iface</code>表示非空接口，使用<code>runtime.eface</code>表示空接口 interface{}。</p>
<p>在 Go 源码中 runtime 包下，可以找到 runtime.iface 和 runtime.eface 的定义。</p>
<pre><code class="go">type iface struct &#123; // 16 字节
    tab  *itab
    data unsafe.Pointer
&#125;
</code></pre>
<p>这个结构体中有指向原始数据的指针 data 和 runtime.itab。</p>
<p><code>runtime.itab</code> 结构体是接口类型的核心组成部分，每一个 <code>runtime.itab</code> 都占 32 字节，可以将其看成接口类型和具体类型的组合，它们分别用 inter 和 _type 两个字段表示：</p>
<pre><code class="go">type itab struct &#123; // 32 字节
    inter *interfacetype
    _type *_type
    hash  uint32
    _     [4]byte
    fun   [1]uintptr
&#125;
</code></pre>
<p>除了 <code>inter</code> 和 <code>_type</code> 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用： hash 是对 <code>_type.hash</code> 的拷贝，当想将 interface 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>runtime._type</code> 是否一致； fun 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 fun 数组中保存的元素数量是不确定的。</p>
<pre><code class="go">type eface struct &#123; // 16 字节
    _type *_type
    data  unsafe.Pointer
&#125;
</code></pre>
<p>由于 interface{} 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构也能推断出 Go 语言的任意类型都可以转换成 interface{}。</p>
<p>其中<code>runtime._type</code>是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<pre><code class="go">type _type struct &#123;
    size       uintptr
    ptrdata    uintptr
    hash       uint32
    tflag      tflag
    align      uint8
    fieldAlign uint8
    kind       uint8
    equal      func(unsafe.Pointer, unsafe.Pointer) bool
    gcdata     *byte
    str        nameOff
    ptrToThis  typeOff
&#125;
</code></pre>
<p>size 字段存储了类型占用的内存空间，为内存空间的分配提供信息； </p>
<p>hash 字段能够帮助快速确定类型是否相等；</p>
<p> equal 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 typeAlg 结构体中迁移过来的。</p>
<p>根据上面对接口底层结构的分析，可以得出如下结论：</p>
<p><strong>接口底层数据结构包含两个字段，相互赋值时如果是相同具体类型不同值并发赋给一个接口，那么只有一个字段 data 的值是不同的，此时退化成指针的并发赋值，所以是安全的。但如果是不同具体类型的值并发赋给一个接口，那么会引发 panic</strong>。</p>
<p>不同具体类型并发赋值接口非安全验证如下：</p>
<pre><code class="go">func main() &#123;
    var g interface&#123;&#125;

    var i int
    for ; i &lt; 10000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = &quot;a&quot;
        &#125;()

        // 协程 2
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = 1
        &#125;()
        wg.Wait()

        // 赋值异常判断
        v1, _ := g.(string)
        v2, _ := g.(int)
        if !(v1 == &quot;a&quot; || v2 == 1) &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v g=%v &quot;, i, g)
            break
        &#125;
    &#125;
    if i == 10000000 &#123;
        fmt.Println(&quot;no error&quot;)
    &#125;
&#125;
</code></pre>
<p>运行输出：</p>
<pre><code>unexpected fault address 0x1fffffa8
fatal error: fault
[signal 0xc0000005 code=0x0 addr=0x1fffffa8 pc=0x5f5585]
...
</code></pre>
<p>把上面的示例代码中协议 1 中的字符串换成一个 int 值，那么并发是安全的。</p>
<pre><code class="go">func main() &#123;
    var g interface&#123;&#125;

    var i int
    for ; i &lt; 10000000; i++ &#123;
        var wg sync.WaitGroup
        // 协程 1
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = 0
        &#125;()

        // 协程 2
        wg.Add(1)
        go func() &#123;
            defer wg.Done()
            g = 1
        &#125;()
        wg.Wait()

        // 赋值异常判断
        v1, _ := g.(int)
        v2, _ := g.(int)
        if !(v1 == 0 || v2 == 1) &#123;
            fmt.Printf(&quot;concurrent assignment error, i=%v g=%v &quot;, i, g)
            break
        &#125;
    &#125;
    if i == 10000000 &#123;
        fmt.Println(&quot;no error&quot;)
    &#125;
&#125;
</code></pre>
<p>运行输出：</p>
<pre><code>no error
</code></pre>
<h3 id="如何保证并发赋值的安全性"><a href="#如何保证并发赋值的安全性" class="headerlink" title="如何保证并发赋值的安全性"></a>如何保证并发赋值的安全性</h3><p>使用 Go 提供的 atomic 包来保证原子操作。</p>
<h2 id="错误使用随机数"><a href="#错误使用随机数" class="headerlink" title="错误使用随机数"></a>错误使用随机数</h2><pre><code class="go">func IsInInvisibleProbability() bool &#123;
    rand.Seed(time.Now().UnixNano())
    randNum := rand.Uint64() % 100
    return randNum &lt;= config.MyCustomConfig.MyConfig.InvisibleProbability
&#125;
</code></pre>
<p>以上代码意在生成随机数，但是存在三个问题：</p>
<ol>
<li>频繁 seed，每次 seed 出来都是独立的随机序列，同一个纳秒访问的出来的值也是同一个，另外会带来 lock contention 的问题。 建议通过init 函数来 seed。</li>
<li>rand.Uint64() % 100  出来的概率不均等。必须采用 rand.Intn(100) 的方式。</li>
<li><code>&lt;</code> 写成了 <code>&lt;=</code>，导致有 1% 的偏移。 例如，即使配置为 0 的时候，其实还是有 1% 的概率。</li>
</ol>
<h3 id="频繁-Seed"><a href="#频繁-Seed" class="headerlink" title="频繁 Seed"></a>频繁 Seed</h3><p>平时使用的大部分随机数是伪随机数，即算术生成随机数。它的原理是通过算术运算，迭代地生成一系列统计上均匀分布的结果。即， 随机数的序列是：</p>
<pre><code>rand(Seed), rand(rand(Seed)), rand(rand(rand(Seed))), ...
</code></pre>
<p>当调用 rand 后，生成的随机数会作为新的种子。因此，正常情况下，不需要每次调用 rand 前都初始化种子。样例的代码使用时间作为初始化种子，这样做会有几个可能的问题：</p>
<ul>
<li>time.Now() 并不廉价。频繁获取时间是无谓的性能损耗。</li>
<li>重置随机数种子并没有必要。本质上，这相当于不再使用 rand 生成的随机数，而是使用<strong>时间</strong>作为随机数。如果在同一纳秒内调用这个方法，会产生完全一样的随机数。</li>
</ul>
<p>因此，只要在 main() 或者 在 init() 函数中初始化一次即可。如果不介意每次的随机数序列提确定性的，也可以跳过初始化 Seed。</p>
<p>rand.Seed 和取随机数的方法是线程安全的，但是这可能会导致性能问题。当需要高频大量生成随机数时，可能会造成大量的锁竞争。因此，应该使用新的 Source，如：</p>
<pre><code>rand.New(rand.NewSource(seed)) // Caution: not thread-safe!
</code></pre>
<p>但是要注意，NewSource 默认是并发不安全的，因此，不要在协程&#x2F;线程之间共享 NewSource 所产生的 Source。</p>
<p>另外，注意 rand 包是<strong>密码学不安全的</strong>。换言之，可能会被攻击者利用，即攻击者可能会根据生成的随机数的特征预测随机数。因此永远不要使用 rand 进行一些敏感随机数的生成。如果需要防攻击的随机数生成器，使用 <code>crypto.rand</code></p>
<h3 id="通过取余操作对离散一致分布间做映射时，因为不能除尽导致偏移，不构成一致分布。"><a href="#通过取余操作对离散一致分布间做映射时，因为不能除尽导致偏移，不构成一致分布。" class="headerlink" title="通过取余操作对离散一致分布间做映射时，因为不能除尽导致偏移，不构成一致分布。"></a>通过取余操作对离散一致分布间做映射时，因为不能除尽导致偏移，不构成一致分布。</h3><p>业务场景通常需要获取 <code>[0, M)</code> 的一致分布。但大部分随机数生成器都是在 2 的整数次幂上，即 <code>[0, 1 &lt;&lt; x)</code> 的一致分布。我们通常希望通过某些简单的算术规则将 <code>[0, 1 &lt;&lt; x)</code> 的一致分布映射至 <code>[0, M)</code> 的一致分布。</p>
<p>非常常见的做法是样例中的取余，如 <code>rand() % 100</code>， 获得 <code>[0, 100)</code> 的一致分布。这样非常简单直观，但是，有缺陷。</p>
<p>简单的数论知识告诉我们 2 的幂永远无法被 100 除尽，因此，<code>rand()</code> 的一致分布的所有值无法被均匀分配到 <code>[0, 100)</code> 这 100 个桶中。这使得前几个桶被分配的概率会比后面的桶高。当 <code>rand()</code> 的取值范围很大，如 <code>[0, 1 &lt;&lt; 64)</code> 时，影响较小。但是这仍然是一个 bug，尤其在原分布的桶较小时，如原分布是 <code>[0, 32767)</code> 时，影响更大。</p>
<p>因此，当我们希望从 <code>[0, M)</code> 的一致分布生成 <code>[0, N)</code> 的一致分布时，要小心概率偏移。一个正确的处理方案是：</p>
<p>当 <code>M &gt; N</code> 时：</p>
<ul>
<li>截取 <code>[0, M)</code> 中的部分分布 <code>[0, M&#39;)</code>，M’ 是小于 M 且能被 N 除尽的最大值。它仍然是一个一致分布。</li>
<li>就 <code>[0, M&#39;)</code> 的生成随机数对 N 取模，即可保证生成 <code>[0, N)</code> 的一致分0905布。</li>
<li>当 M 能被 N 整除时，可以直接取余。</li>
</ul>
<p>当 <code>M &lt; N</code> 时，一个可选的方案是：</p>
<ul>
<li>通过取 t 次 M 值，直到 <code>M * t &gt; N</code>，以此生成一个 <code>[0, M * t)</code> 的一致分布</li>
<li>以下处理同 <code>M &gt; N</code></li>
</ul>
<h3 id="边界处理失误，导致实际阈值比预期大-1"><a href="#边界处理失误，导致实际阈值比预期大-1" class="headerlink" title="边界处理失误，导致实际阈值比预期大 1%"></a>边界处理失误，导致实际阈值比预期大 1%</h3><p>注意返回的一致性分布是 <code>[-0, 100)</code>，也就是 0, 1, 2, …, 99 的均匀分布。例如，当使用</p>
<pre><code>return randNum &lt;= 80
</code></pre>
<p>实际上有 81 个值 (0, 1, …, 80）会被包含。这使得实际的概率为 81%。</p>
<p>一定要注意 off-by-one error。这种错误在线上难以察觉，但是在统计意义上会对业务造成明显影响。</p>
<p><code>Off-By-One</code> 是隐蔽又容易出错的问题，在离散分布里，一定要注意<strong>区间的开闭</strong>。</p>
<p>当需要一个 <code>[a, b]</code> 的离散一致性分布时，其与 <code>[a, b+1)</code> 等价。</p>
<p>因此，使用标准库时，应该先获取一个 <code>[0, b - a + 1)</code> 的一致分布，然后映射到 <code>[a, b]</code>。即：</p>
<p><code>Uniform [a, b] ==Uniform [a, b + 1) ==Uniform [0, b + 1 - a) + a</code></p>
<h1 id="出于性能考虑的最佳实践和建议"><a href="#出于性能考虑的最佳实践和建议" class="headerlink" title="出于性能考虑的最佳实践和建议"></a>出于性能考虑的最佳实践和建议</h1><p>（1）尽可能的使用 <code>:=</code> 去初始化声明一个变量（在函数内部）；</p>
<p>（2）尽可能的使用字符代替字符串；</p>
<p>（3）尽可能的使用切片代替数组；</p>
<p>（4）尽可能的使用数组和切片代替映射（详见参考文献 15）；</p>
<p>（5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用 <code>for range</code> 去遍历切片，这比必须查询切片中的每个元素要快一些；</p>
<p>（6）当数组元素是稀疏的（例如有很多 <code>0</code> 值或者空值 <code>nil</code>），使用映射会降低内存消耗；</p>
<p>（7）初始化映射时指定其容量；</p>
<p>（8）当定义一个方法时，使用指针类型作为方法的接受者；</p>
<p>（9）在代码中使用常量或者标志提取常量的值；</p>
<p>（10）尽可能在需要分配大量内存时使用缓存；</p>
<p>（11）使用缓存模板</p>
<blockquote>
<p> <strong>参考文档</strong>：</p>
<p> <a target="_blank" rel="noopener" href="https://learnku.com/docs/the-way-to-go/chapter-description/3715">《GO入门指南》第十六章 常见的陷阱与错误</a></p>
<p> <a target="_blank" rel="noopener" href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">深度解密Go语言之反射</a></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LjSlxdo5PFVJcUhH3UDU0A">不要使用 Go 默认的 HTTP 客户端（在生产环境中）</a></p>
<p> <a target="_blank" rel="noopener" href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779">Don’t use Go’s default HTTP client (in production)</a></p>
<p> <a target="_blank" rel="noopener" href="https://studygolang.com/topics/6033/comment/17800">断言的疑惑</a></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg">详解 Go 空结构体的 3 种使用场景</a></p>
<p> <a target="_blank" rel="noopener" href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/">Go 开发中的十大常见陷阱[译]</a></p>
<p> <a target="_blank" rel="noopener" href="https://tangx.in/2021/06/22/golang-block/">Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39618369/article/details/121666608">Golang函数内slice进行append时不改变外部值问题</a></p>
<p> <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1810536">Golang 并发赋值的安全性探讨</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.163.com/dy/article/HGH6ND560518R7MO.html">如何正确使用随机数？</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/18/go%E5%85%A5%E9%97%A8/" rel="prev" title="go 入门">
                  <i class="fa fa-chevron-left"></i> go 入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/19/ElasticSearch/" rel="next" title="ElasticSearch">
                  ElasticSearch <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">37:51</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
