<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>go 实用代码片段和注意事项</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">go 实用代码片段和注意事项</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常用代码段"><span class="toc-text">常用代码段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-和-make-选择"><span class="toc-text">new() 和 make() 选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串相关操作"><span class="toc-text">字符串相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改字符串的一个字符"><span class="toc-text">修改字符串的一个字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取字符串的字串"><span class="toc-text">获取字符串的字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-for-或者-for-range-遍历一个字符串"><span class="toc-text">使用 for 或者 for-range 遍历一个字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取一个字符串的字节数"><span class="toc-text">获取一个字符串的字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取一个字符串的字符数："><span class="toc-text">获取一个字符串的字符数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串拼接"><span class="toc-text">字符串拼接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印字符串"><span class="toc-text">打印字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优雅实现存储单位的常量枚举"><span class="toc-text">优雅实现存储单位的常量枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优雅的进行错误检测和处理"><span class="toc-text">优雅的进行错误检测和处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射常用示例"><span class="toc-text">反射常用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-中常用的包"><span class="toc-text">go 中常用的包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#regexp包"><span class="toc-text">regexp包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-包"><span class="toc-text">sync 包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#精密计算和big包"><span class="toc-text">精密计算和big包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见错误"><span class="toc-text">常见错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#短变量声明导致变量覆盖"><span class="toc-text">短变量声明导致变量覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#误用-defer-关闭一个文件"><span class="toc-text">误用 defer 关闭一个文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不需要将一个指向切片的指针传递给函数"><span class="toc-text">不需要将一个指向切片的指针传递给函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用指针指向接口类型"><span class="toc-text">不要使用指针指向接口类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包和协程使用"><span class="toc-text">闭包和协程使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要在生产环境使用默认的-HTTP-Client"><span class="toc-text">不要在生产环境使用默认的 HTTP Client</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-text">解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#出于性能考虑的最佳实践和建议"><span class="toc-text">出于性能考虑的最佳实践和建议</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/go"><i class="tag post-item-tag">go</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">go 实用代码片段和注意事项</h1><time class="has-text-grey" datetime="2020-08-20T03:45:18.000Z">2020-08-20</time><article class="mt-2 post-content"><h1 id="常用代码段"><a href="#常用代码段" class="headerlink" title="常用代码段"></a>常用代码段</h1><h2 id="new-和-make-选择"><a href="#new-和-make-选择" class="headerlink" title="new() 和 make() 选择"></a>new() 和 make() 选择</h2><ul>
<li><p>切片、映射和通道，使用 make </p>
</li>
<li><p>数组、结构体和所有的值类型，使用 new </p>
</li>
</ul>
<blockquote>
<p>new 出来的是一个指针</p>
</blockquote>
<h2 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h2><h3 id="修改字符串的一个字符"><a href="#修改字符串的一个字符" class="headerlink" title="修改字符串的一个字符"></a>修改字符串的一个字符</h3><pre><code class="go">str:=&quot;hello&quot;
c:=[]byte(str)
c[0]=&#39;c&#39;
s2:= string(c) // s2 == &quot;cello&quot;</code></pre>
<a id="more"></a>

<h3 id="获取字符串的字串"><a href="#获取字符串的字串" class="headerlink" title="获取字符串的字串"></a>获取字符串的字串</h3><pre><code class="go">substr := str[n:m]</code></pre>
<h3 id="使用-for-或者-for-range-遍历一个字符串"><a href="#使用-for-或者-for-range-遍历一个字符串" class="headerlink" title="使用 for 或者 for-range 遍历一个字符串"></a>使用 <code>for</code> 或者 <code>for-range</code> 遍历一个字符串</h3><pre><code class="go">// gives only the bytes:
for i:=0; i &lt; len(str); i++ {
… = str[i]
}
// gives the Unicode characters:
for ix, ch := range str {
…
}</code></pre>
<h3 id="获取一个字符串的字节数"><a href="#获取一个字符串的字节数" class="headerlink" title="获取一个字符串的字节数"></a>获取一个字符串的字节数</h3><p><code>len(str)</code></p>
<h3 id="获取一个字符串的字符数："><a href="#获取一个字符串的字符数：" class="headerlink" title="获取一个字符串的字符数："></a>获取一个字符串的字符数：</h3><p>最快速：<code>utf8.RuneCountInString(str)</code></p>
<p><code>len([]int(str))</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 <code>a += b</code> 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中</strong>。</p>
<pre><code class="go">var b bytes.Buffer
...
for condition {
    b.WriteString(str) // 将字符串str写入缓存buffer
}
    return b.String()</code></pre>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>函数 <code>Printf</code> 主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：</p>
<pre><code class="go">func Printf(format string, list of variables to be printed)</code></pre>
<p>这个格式化字符串可以含有一个或多个的格式化标识符，例如：<code>%..</code>，其中 <code>..</code> 可以被不同类型所对应的标识符替换，如 <code>%s</code> 代表字符串标识符、<code>%v</code> 代表使用类型的默认输出格式的标识符。<strong>这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加</strong>，如果参数超过 1 个则需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。</p>
<p>函数 <code>fmt.Sprintf</code> 与 <code>Printf</code> 的作用是完全相同的，<strong>不过前者将格式化后的字符串以返回值的形式返回给调用者</strong>，因此可以在程序中使用包含变量的字符串。</p>
<p>函数 <code>fmt.Print</code> 和 <code>fmt.Println</code> 会自动使用格式化标识符 <code>%v</code> 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如：</p>
<pre><code class="go">fmt.Print(&quot;Hello:&quot;, 23)</code></pre>
<p>将输出：<code>Hello: 23</code>。</p>
<p><strong>格式化说明符</strong></p>
<p>在格式化字符串里，<code>%d</code> 用于格式化整数（<code>%x</code> 和 <code>%X</code> 用于格式化 16 进制表示的数字），<code>%g</code> 用于格式化浮点型（<code>%f</code> 输出浮点数，<code>%e</code> 输出科学计数表示法），<code>%0d</code> 用于规定输出定长的整数，其中开头的数字 0 是必须的。</p>
<p><code>%n.mg</code> 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 <code>%5.2e</code> 来输出 3.4 的结果为 <code>3.40e+00</code>。</p>
<p><code>%b</code> 是用于表示位的格式化标识符。</p>
<p>格式化说明符 <code>%c</code> 用于表示字符；当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数；<code>%U</code> 输出格式为 U+hhhh 的字符串</p>
<p>指针的格式化标识符为 <code>%p</code></p>
<h2 id="优雅实现存储单位的常量枚举"><a href="#优雅实现存储单位的常量枚举" class="headerlink" title="优雅实现存储单位的常量枚举"></a>优雅实现存储单位的常量枚举</h2><p>使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：</p>
<pre><code class="go">type ByteSize float64
const (
    _ = iota // 通过赋值给空白标识符来忽略值
    KB ByteSize = 1&lt;&lt;(10*iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)</code></pre>
<h2 id="优雅的进行错误检测和处理"><a href="#优雅的进行错误检测和处理" class="headerlink" title="优雅的进行错误检测和处理"></a>优雅的进行错误检测和处理</h2><p>避免写出这样的代码：</p>
<pre><code class="go">... err1 := api.Func1()
if err1 != nil {
    fmt.Println(&quot;err: &quot; + err.Error())
    return
}
err2 := api.Func2()
if err2 != nil {
...
    return
}    </code></pre>
<p>首先，包括在一个初始化的 <code>if</code> 语句中对函数的调用。但即使代码中到处都是以 <code>if</code> 语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：</p>
<pre><code class="go">func httpRequestHandler(w http.ResponseWriter, req *http.Request) {
    err := func () error {
        if req.Method != &quot;GET&quot; {
            return errors.New(&quot;expected GET&quot;)
        }
        if input := parseInput(req); input != &quot;command&quot; {
            return errors.New(&quot;malformed command&quot;)
        }
        // 可以在此进行其他的错误检测
    } ()

        if err != nil {
            w.WriteHeader(400)
            io.WriteString(w, err)
            return
        }
        doSomething() ...</code></pre>
<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑</p>
<h2 id="反射常用示例"><a href="#反射常用示例" class="headerlink" title="反射常用示例"></a>反射常用示例</h2><pre><code class="go">type Child struct {
    Name     string
    Grade    int
    Handsome bool
}

type Adult struct {
    ID         string `qson:&quot;Name&quot;`
    Occupation string
    Handsome   bool
}

// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，
// 并且有一个字段的 tag 或者字段名是 `Name` ，
// 如果该 `Name` 字段的值是 `qcrao`，
// 就把结构体中名为 `Handsome` 的字段值设置为 true。
func handsome(i interface{}) {
    // 获取 i 的反射变量 Value
    v := reflect.ValueOf(i)

    // 确定 v 是一个 Slice
    if v.Kind() != reflect.Slice {
        return
    }

    // 确定 v 是的元素为结构体
    if e := v.Type().Elem(); e.Kind() != reflect.Struct {
        return
    }

    // 确定结构体的字段名含有 &quot;ID&quot; 或者 json tag 标签为 `name`
    // 确定结构体的字段名 &quot;Handsome&quot;
    st := v.Type().Elem()

    // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
    foundName := false
    for i := 0; i &lt; st.NumField(); i++ {
        f := st.Field(i)
        tag := f.Tag.Get(&quot;qson&quot;)

        if (tag == &quot;Name&quot; || f.Name == &quot;Name&quot;) &amp;&amp; f.Type.Kind() == reflect.String {
            foundName = true
            break
        }
    }

    if !foundName {
        return
    }

    if niceField, foundHandsome := st.FieldByName(&quot;Handsome&quot;); foundHandsome == false || niceField.Type.Kind() != reflect.Bool {
        return
    }

    // 设置名字为 &quot;qcrao&quot; 的对象的 &quot;Handsome&quot; 字段为 true
    for i := 0; i &lt; v.Len(); i++ {
        e := v.Index(i)
        handsome := e.FieldByName(&quot;Handsome&quot;)

        // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
        var name reflect.Value
        for j := 0; j &lt; st.NumField(); j++ {
            f := st.Field(j)
            tag := f.Tag.Get(&quot;qson&quot;)

            if tag == &quot;Name&quot; || f.Name == &quot;Name&quot; {
                name = v.Index(i).Field(j)
            }
        }

        if name.String() == &quot;qcrao&quot; {
            handsome.SetBool(true)
        }
    }
}

func main() {
    children := []Child{
        {Name: &quot;Ava&quot;, Grade: 3, Handsome: true},
        {Name: &quot;qcrao&quot;, Grade: 6, Handsome: false},
    }

    adults := []Adult{
        {ID: &quot;Steve&quot;, Occupation: &quot;Clerk&quot;, Handsome: true},
        {ID: &quot;qcrao&quot;, Occupation: &quot;Go Programmer&quot;, Handsome: false},
    }

    fmt.Printf(&quot;adults before handsome: %v\n&quot;, adults)
    handsome(adults)
    fmt.Printf(&quot;adults after handsome: %v\n&quot;, adults)

    fmt.Println(&quot;-------------&quot;)

    fmt.Printf(&quot;children before handsome: %v\n&quot;, children)
    handsome(children)
    fmt.Printf(&quot;children after handsome: %v\n&quot;, children)
}</code></pre>
<p>代码运行结果：</p>
<pre><code>adults before handsome: [{Steve Clerk true} {qcrao Go Programmer false}]
adults after handsome: [{Steve Clerk true} {qcrao Go Programmer true}]
-------------
children before handsome: [{Ava 3 true} {qcrao 6 false}]
children after handsome: [{Ava 3 true} {qcrao 6 true}]</code></pre><p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p>
<p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p>
<p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p>
<h1 id="go-中常用的包"><a href="#go-中常用的包" class="headerlink" title="go 中常用的包"></a>go 中常用的包</h1><h2 id="regexp包"><a href="#regexp包" class="headerlink" title="regexp包"></a>regexp包</h2><p>主要用于正则匹配。</p>
<p>如果是简单模式，使用 <code>Match</code> 方法便可：</p>
<pre><code class="go">ok, _ := regexp.Match(pat, []byte(searchIn))</code></pre>
<p>变量 ok 将返回 true 或者 false, 也可以使用 <code>MatchString</code>：</p>
<pre><code class="go">ok, _ := regexp.MatchString(pat, searchIn)</code></pre>
<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。然后我们将掌握一些匹配，查找，替换相关的功能。如下：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;regexp&quot;
    &quot;strconv&quot;
)
func main() {
    //目标字符串
    searchIn := &quot;John: 2578.34 William: 4567.23 Steve: 5632.18&quot;
    pat := &quot;[0-9]+.[0-9]+&quot; //正则

    f := func(s string) string{
        v, _ := strconv.ParseFloat(s, 32)
        return strconv.FormatFloat(v * 2, &#39;f&#39;, 2, 32)
    }

    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok {
        fmt.Println(&quot;Match Found!&quot;)
    }

    re, _ := regexp.Compile(pat)
    //将匹配到的部分替换为&quot;##.#&quot;
    str := re.ReplaceAllString(searchIn, &quot;##.#&quot;)
    fmt.Println(str)
    //参数为函数时
    str2 := re.ReplaceAllStringFunc(searchIn, f)
    fmt.Println(str2)
}</code></pre>
<p>结果如下：</p>
<pre><code>Match Found!
John: ##.# William: ##.# Steve: ##.#
John: 5156.68 William: 9134.46 Steve: 11264.36</code></pre><h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><p><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p>
<p>假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 <code>Mutex</code> 来实现的一个典型例子如下：</p>
<pre><code class="go">import  &quot;sync&quot;

type Info struct {
    mu sync.Mutex
    // ... other fields, e.g.: Str string
}</code></pre>
<p>如果一个函数想要改变这个变量可以这样写:</p>
<pre><code class="go">func Update(info *Info) {
    info.mu.Lock()
    // critical section:
    info.Str = // new value
    // end critical section
    info.mu.Unlock()
}</code></pre>
<p>还有一个很有用的例子是通过 Mutex 来实现一个可以上锁的共享缓冲器:</p>
<pre><code class="go">type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}</code></pre>
<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。</p>
<h2 id="精密计算和big包"><a href="#精密计算和big包" class="headerlink" title="精密计算和big包"></a>精密计算和big包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2/5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 <code>big.NewRat(N,D)</code> 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用于作为reciver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<pre><code class="go">// big.go
package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;math/big&quot;
)

func main() {
    // Here are some calculations with bigInts:
    im := big.NewInt(math.MaxInt64)
    in := im
    io := big.NewInt(1956)
    ip := big.NewInt(1)
    ip.Mul(im, in).Add(ip, im).Div(ip, io)
    fmt.Printf(&quot;Big Int: %v\n&quot;, ip)
    // Here are some calculations with bigRat:
    rm := big.NewRat(math.MaxInt64, 1956)
    rn := big.NewRat(-1956, math.MaxInt64)
    ro := big.NewRat(19, 56)
    rp := big.NewRat(1111, 2222)
    rq := big.NewRat(1, 1)
    rq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)
    fmt.Printf(&quot;Big Rat: %v\n&quot;, rq)
}

/* Output:
Big Int: 43492122561469640008497075573153004
Big Rat: -37/112
*/</code></pre>
<p>结果如下：</p>
<pre><code>Big Int: 43492122561469640008497075573153004
Big Rat: -37/112</code></pre><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="短变量声明导致变量覆盖"><a href="#短变量声明导致变量覆盖" class="headerlink" title="短变量声明导致变量覆盖"></a>短变量声明导致变量覆盖</h2><pre><code class="go">var remember bool = false
if something {
    remember := true //错误
}
// 使用remember</code></pre>
<p>在此代码段中，<code>remember</code> 变量永远不会在 <code>if</code> 语句外面变成 <code>true</code>，如果 <code>something</code> 为 <code>true</code>，由于使用了短声明 <code>:=</code>，<code>if</code> 语句内部的新变量 <code>remember</code> 将覆盖外面的 <code>remember</code> 变量，并且该变量的值为 <code>true</code>，但是在 <code>if</code> 语句外面，变量 <code>remember</code> 的值变成了 <code>false</code>，所以正确的写法应该是：</p>
<pre><code class="go">if something {
    remember = true
}</code></pre>
<p>此类错误也容易在 <code>for</code> 循环中出现，尤其当函数返回一个具名变量时难于察觉，例如以下的代码段：</p>
<pre><code class="go">func shadow() (err error) {
    x, err := check1() // x是新创建变量，err是被赋值
      if err != nil {
            return // 正确返回err
        }
        if y, err := check2(x); err != nil { // y和if语句中err被创建
            return // if语句中的err被外面的err覆盖，所以错误的返回nil！
        } else {
            fmt.Println(y)
        }
    return
}</code></pre>
<h2 id="误用-defer-关闭一个文件"><a href="#误用-defer-关闭一个文件" class="headerlink" title="误用 defer 关闭一个文件"></a>误用 defer 关闭一个文件</h2><p>如果在一个 for 循环内部处理一系列文件，需要使用 defer 确保文件在处理完毕后被关闭，例如：</p>
<pre><code class="go">for _, file := range files {
    if f, err = os.Open(file); err != nil {
        return
    }
    // 这是错误的方式，当循环结束时文件没有关闭，要等到整个方法执行完了才会调用
    defer f.Close()
    // 对文件进行操作
    f.Process(data)
}</code></pre>
<p>但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：</p>
<pre><code class="go">for _, file := range files {
    if f, err = os.Open(file); err != nil {
        return
    }
    // 对文件进行操作
    f.Process(data)
    // 关闭文件
    f.Close()
 }</code></pre>
<p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p>
<h2 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h2><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。</p>
<p>因此应该这样做：</p>
<pre><code class="php">   func findBiggest( listOfNumbers []int ) int {}</code></pre>
<p>而不是：</p>
<pre><code class="php">   func findBiggest( listOfNumbers *[]int ) int {}</code></pre>
<p><strong>当切片作为参数传递时，切记不要解引用切片。</strong></p>
<h2 id="不要使用指针指向接口类型"><a href="#不要使用指针指向接口类型" class="headerlink" title="不要使用指针指向接口类型"></a>不要使用指针指向接口类型</h2><p>在下面的程序中：<code>nexter</code> 是一个接口类型，并且定义了一个 <code>next()</code> 方法读取下一字节。函数 <code>nextFew1</code> 将 <code>nexter</code> 接口作为参数并读取接下来的 <code>num</code> 个字节，并返回一个切片：这是正确做法。但是 <code>nextFew2</code> 使用一个指向 <code>nexter</code> 接口类型的指针作为参数传递给函数：当使用 <code>next()</code> 函数时，系统会给出一个编译错误：</p>
<pre><code>n.next undefined (type \*nexter has no field or method next) （n.next 未定义（*nexter 类型没有 next 成员或 next 方法））</code></pre><pre><code class="go">package main
import (
    “fmt”
)
type nexter interface {
    next() byte
}
func nextFew1(n nexter, num int) []byte {
    var b []byte
    for i:=0; i &lt; num; i++ {
        b[i] = n.next()
    }
    return b
}
func nextFew2(n *nexter, num int) []byte {
    var b []byte
    for i:=0; i &lt; num; i++ {
        b[i] = n.next() // 编译错误:n.next未定义（*nexter类型没有next成员或next方法）
    }
    return b
}
func main() {
    fmt.Println(&quot;Hello World!&quot;)
}</code></pre>
<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong></p>
<h2 id="闭包和协程使用"><a href="#闭包和协程使用" class="headerlink" title="闭包和协程使用"></a>闭包和协程使用</h2><p>对于下面的代码：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var values = [5]int{10, 11, 12, 13, 14}

func main() {
    // 版本A:
    for ix := range values { // ix是索引值
        func() {
            fmt.Print(ix, &quot; &quot;)
        }() // 调用闭包打印每个索引值
    }
    fmt.Println()
    // 版本B: 和A版本类似，但是通过调用闭包作为一个协程
    for ix := range values {
        go func() {
            fmt.Print(ix, &quot; &quot;)
        }()
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本C: 正确的处理方式
    for ix := range values {
        go func(ix interface{}) {
            fmt.Print(ix, &quot; &quot;)
        }(ix)
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本D: 输出值:
    for ix := range values {
        val := values[ix]
        go func() {
            fmt.Print(val, &quot; &quot;)
        }()
    }
    time.Sleep(1e9)
}</code></pre>
<p>输出：</p>
<pre><code class="php">        0 1 2 3 4

        4 4 4 4 4

        1 0 3 4 2

        10 11 12 13 14</code></pre>
<p>版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。</p>
<p>如果阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：<code>4 4 4 4 4</code>。在版本 B 的循环中，<code>ix</code> 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当运行这段代码时，将看见每次循环都打印最后一个索引值 <code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 <code>ix</code> 值是 <code>4</code>。</p>
<p>版本 C 的循环写法才是正确的：调用每个闭包是将 <code>ix</code> 作为参数传递给闭包。<code>ix</code> 在每次循环时都被重新赋值，并将每个协程的 <code>ix</code> 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 <code>0 2 1 3 4</code> 或者 <code>0 3 1 2 4</code> 或者其他类似的序列，这主要取决于每个协程何时开始被执行。</p>
<p>在版本 D 中，能够正确输出这个数组的值，因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。</p>
<h2 id="不要在生产环境使用默认的-HTTP-Client"><a href="#不要在生产环境使用默认的-HTTP-Client" class="headerlink" title="不要在生产环境使用默认的 HTTP Client"></a>不要在生产环境使用默认的 HTTP Client</h2><p>Go 默认的 HTTP 客户端没有指定请求超时时间，允许服务劫持 goroutine。当请求外部服务时，请始终使用自定义的 <code>http.Client</code>。</p>
<p>Go 的 HTTP 包使用 <code>Client</code> 结构体来管理 HTTP(S) 通信的内部过程。<code>Clients</code> 是并发安全的对象，包含配置、管理 TCP 状态、处理 cookies 等。当使用 <code>http.Get(url)</code> 时，就会调用  <code>http.DefaultClient</code>，走的是 HTTP 默认配置，声明如下：</p>
<pre><code class="go">var DefaultClient = &amp;Client{}</code></pre>
<p>除其他配置项外，<code>http.Client</code> 有一个超时时间的配置，当请求时间超过这个数值时，请求就会自动断开。该数值默认值是 0，即没有超时时间。该默认值对于 HTTP 包来说挺合理的，同时这也是一个容易让人掉进去的坑，如果请求的对象宕机或者因为其他原因一直没有响应，就会导致发起请求的 groutine 挂起，只要发生故障的服务器没有恢复，进程就会一直挂着。因为进行 API 调用是为了服务用户请求，所以这也会导致服务用户请求的 goroutine 也挂起。一旦有足够的人发起这个 http 请求，很有可能就因为系统资源达到了极限导致应用挂掉。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决这个问题的办法就是使用 <code>http.Client</code> 时定义一个合理的超时时间，比如下面这样的：</p>
<pre><code class="go">var netClient = &amp;http.Client{
  Timeout: time.Second * 10,
}
response, _ := netClient.Get(url)</code></pre>
<p>设置了 10s 的超时时间，如果超时 <code>Get()</code> 将会返回错误：</p>
<pre><code class="go">&amp;httpError{
  err:     err.Error() + &quot; (Client.Timeout exceeded while awaiting headers)&quot;,
  timeout: true,
}</code></pre>
<p>如果需要对请求生命周期进行更细粒度的控制，还可以另外指定自定义 <code>net.Transport</code> 和 <code>net.Dialer</code>。</p>
<p><code>Transport</code> 结构体用来管理底层 TCP 连接，<code>Dialer</code> 是用来管理连接建立的结构体。Go 的 net 包使用默认的 <code>Transport</code> 和 <code>Dialer</code>。下面是一个自定义的例子：</p>
<pre><code class="go">var netTransport = &amp;http.Transport{
  Dial: (&amp;net.Dialer{
    Timeout: 5 * time.Second,
  }).Dial,
  TLSHandshakeTimeout: 5 * time.Second,
}
var netClient = &amp;http.Client{
  Timeout: time.Second * 10,
  Transport: netTransport,
}
response, _ := netClient.Get(url)</code></pre>
<p>上面代码设置了 TCP 拨号时间、TLS 握手时间和请求超时时间。如果有需要还可以设置其他选项，例如 <code>keep-alive</code> 超时时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言的 <code>net/http</code> 包是经过深思熟虑的产物，可以非常便捷地用于 HTTP(S) 通信。然而，缺少请求超时时间是一个非常容易掉进去的坑，因为这个包提供了很多诸如 http.Get(url) 等便捷的方法。请求远程服务时不设置超时时间会使应用程序依赖于该服务，如果远程服务发生故障或者有恶意程序，请求将会永远挂起，从而有可能使系统资源耗尽导致宕机。</p>
<h1 id="出于性能考虑的最佳实践和建议"><a href="#出于性能考虑的最佳实践和建议" class="headerlink" title="出于性能考虑的最佳实践和建议"></a>出于性能考虑的最佳实践和建议</h1><p>（1）尽可能的使用 <code>:=</code> 去初始化声明一个变量（在函数内部）；</p>
<p>（2）尽可能的使用字符代替字符串；</p>
<p>（3）尽可能的使用切片代替数组；</p>
<p>（4）尽可能的使用数组和切片代替映射（详见参考文献 15）；</p>
<p>（5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用 <code>for range</code> 去遍历切片，这比必须查询切片中的每个元素要快一些；</p>
<p>（6）当数组元素是稀疏的（例如有很多 <code>0</code> 值或者空值 <code>nil</code>），使用映射会降低内存消耗；</p>
<p>（7）初始化映射时指定其容量；</p>
<p>（8）当定义一个方法时，使用指针类型作为方法的接受者；</p>
<p>（9）在代码中使用常量或者标志提取常量的值；</p>
<p>（10）尽可能在需要分配大量内存时使用缓存；</p>
<p>（11）使用缓存模板</p>
<blockquote>
<p> <strong>参考文档</strong>：</p>
<p> <a href="https://learnku.com/docs/the-way-to-go/chapter-description/3715" target="_blank" rel="noopener">《GO入门指南》第十六章 常见的陷阱与错误</a></p>
<p> <a href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">深度解密Go语言之反射</a></p>
<p> <a href="https://mp.weixin.qq.com/s/LjSlxdo5PFVJcUhH3UDU0A" target="_blank" rel="noopener">不要使用 Go 默认的 HTTP 客户端（在生产环境中）</a></p>
<p> <a href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779" target="_blank" rel="noopener">Don’t use Go’s default HTTP client (in production)</a></p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/11/19/ElasticSearch/" title="ElasticSearch"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: ElasticSearch</span></a><a class="button is-default" href="/2020/07/18/go%E5%85%A5%E9%97%A8/" title="go 入门"><span class="has-text-weight-semibold">下一页: go 入门</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>