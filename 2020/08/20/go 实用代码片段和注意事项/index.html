

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="常用代码段new() 和 make() 选择
切片、映射和通道，使用 make 

数组、结构体和所有的值类型，使用 new 



new 出来的是一个指针

字符串相关操作修改字符串的一个字符1234str:=&#34;hello&#34;c:=[]byte(str)c[0]=&#39;c&#39;s2:= string(c) // s2 == &#34;cello&#34;">
  <meta name="author" content="Silverming">
  <meta name="keywords" content="">
  
  <title>go 实用代码片段和注意事项 - Silverming</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"54ebb03ad7ad5b762ac8ff7958df6d3f","google":"G-M2RT7SDT3L","gtag":"G-M2RT7SDT3L","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tFHjJkaAYKqH8BIXKnJVurUc-MdYXbMMI","app_key":"1qR5F7XyydYd5YJtIpMJBFmP","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Silverming</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="go 实用代码片段和注意事项">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-20 11:45" pubdate>
        2020年8月20日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      130
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">go 实用代码片段和注意事项</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年1月16日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="常用代码段"><a href="#常用代码段" class="headerlink" title="常用代码段"></a>常用代码段</h1><h2 id="new-和-make-选择"><a href="#new-和-make-选择" class="headerlink" title="new() 和 make() 选择"></a>new() 和 make() 选择</h2><ul>
<li><p>切片、映射和通道，使用 make </p>
</li>
<li><p>数组、结构体和所有的值类型，使用 new </p>
</li>
</ul>
<blockquote>
<p>new 出来的是一个指针</p>
</blockquote>
<h2 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h2><h3 id="修改字符串的一个字符"><a href="#修改字符串的一个字符" class="headerlink" title="修改字符串的一个字符"></a>修改字符串的一个字符</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">str:=<span class="hljs-string">"hello"</span><br>c:=[]<span class="hljs-keyword">byte</span>(str)<br>c[<span class="hljs-number">0</span>]=<span class="hljs-string">'c'</span><br>s2:= <span class="hljs-keyword">string</span>(c) <span class="hljs-comment">// s2 == "cello"</span><br></code></pre></div></td></tr></table></figure>

<a id="more"></a>

<h3 id="获取字符串的字串"><a href="#获取字符串的字串" class="headerlink" title="获取字符串的字串"></a>获取字符串的字串</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">substr := str[n:m]<br></code></pre></div></td></tr></table></figure>

<h3 id="使用-for-或者-for-range-遍历一个字符串"><a href="#使用-for-或者-for-range-遍历一个字符串" class="headerlink" title="使用 for 或者 for-range 遍历一个字符串"></a>使用 <code>for</code> 或者 <code>for-range</code> 遍历一个字符串</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// gives only the bytes:</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>… = str[i]<br>&#125;<br><span class="hljs-comment">// gives the Unicode characters:</span><br><span class="hljs-keyword">for</span> ix, ch := <span class="hljs-keyword">range</span> str &#123;<br>…<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="获取一个字符串的字节数"><a href="#获取一个字符串的字节数" class="headerlink" title="获取一个字符串的字节数"></a>获取一个字符串的字节数</h3><p><code>len(str)</code></p>
<h3 id="获取一个字符串的字符数："><a href="#获取一个字符串的字符数：" class="headerlink" title="获取一个字符串的字符数："></a>获取一个字符串的字符数：</h3><p>最快速：<code>utf8.RuneCountInString(str)</code></p>
<p><code>len([]int(str))</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 <code>a += b</code> 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b bytes.Buffer<br>...<br><span class="hljs-keyword">for</span> condition &#123;<br>    b.WriteString(str) <span class="hljs-comment">// 将字符串str写入缓存buffer</span><br>&#125;<br>    <span class="hljs-keyword">return</span> b.String()<br></code></pre></div></td></tr></table></figure>

<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>函数 <code>Printf</code> 主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Printf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, list of variables to be printed)</span></span><br></code></pre></div></td></tr></table></figure>

<p>这个格式化字符串可以含有一个或多个的格式化标识符，例如：<code>%..</code>，其中 <code>..</code> 可以被不同类型所对应的标识符替换，如 <code>%s</code> 代表字符串标识符、<code>%v</code> 代表使用类型的默认输出格式的标识符。<strong>这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加</strong>，如果参数超过 1 个则需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。</p>
<p>函数 <code>fmt.Sprintf</code> 与 <code>Printf</code> 的作用是完全相同的，<strong>不过前者将格式化后的字符串以返回值的形式返回给调用者</strong>，因此可以在程序中使用包含变量的字符串。</p>
<p>函数 <code>fmt.Print</code> 和 <code>fmt.Println</code> 会自动使用格式化标识符 <code>%v</code> 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Print(<span class="hljs-string">"Hello:"</span>, <span class="hljs-number">23</span>)<br></code></pre></div></td></tr></table></figure>

<p>将输出：<code>Hello: 23</code>。</p>
<p><strong>格式化说明符</strong></p>
<p>在格式化字符串里，<code>%d</code> 用于格式化整数（<code>%x</code> 和 <code>%X</code> 用于格式化 16 进制表示的数字），<code>%g</code> 用于格式化浮点型（<code>%f</code> 输出浮点数，<code>%e</code> 输出科学计数表示法），<code>%0d</code> 用于规定输出定长的整数，其中开头的数字 0 是必须的。</p>
<p><code>%n.mg</code> 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 <code>%5.2e</code> 来输出 3.4 的结果为 <code>3.40e+00</code>。</p>
<p><code>%b</code> 是用于表示位的格式化标识符。</p>
<p>格式化说明符 <code>%c</code> 用于表示字符；当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数；<code>%U</code> 输出格式为 U+hhhh 的字符串</p>
<p>指针的格式化标识符为 <code>%p</code></p>
<h2 id="优雅实现存储单位的常量枚举"><a href="#优雅实现存储单位的常量枚举" class="headerlink" title="优雅实现存储单位的常量枚举"></a>优雅实现存储单位的常量枚举</h2><p>使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ByteSize <span class="hljs-keyword">float64</span><br><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 通过赋值给空白标识符来忽略值</span><br>    KB ByteSize = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">10</span>*<span class="hljs-literal">iota</span>)<br>    MB<br>    GB<br>    TB<br>    PB<br>    EB<br>    ZB<br>    YB<br>)<br></code></pre></div></td></tr></table></figure>

<h2 id="优雅的进行错误检测和处理"><a href="#优雅的进行错误检测和处理" class="headerlink" title="优雅的进行错误检测和处理"></a>优雅的进行错误检测和处理</h2><p>避免写出这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">... err1 := api.Func1()<br><span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">"err: "</span> + err.Error())<br>    <span class="hljs-keyword">return</span><br>&#125;<br>err2 := api.Func2()<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>...<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>首先，包括在一个初始化的 <code>if</code> 语句中对函数的调用。但即使代码中到处都是以 <code>if</code> 语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpRequestHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    err := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>        <span class="hljs-keyword">if</span> req.Method != <span class="hljs-string">"GET"</span> &#123;<br>            <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"expected GET"</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> input := parseInput(req); input != <span class="hljs-string">"command"</span> &#123;<br>            <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"malformed command"</span>)<br>        &#125;<br>        <span class="hljs-comment">// 可以在此进行其他的错误检测</span><br>    &#125; ()<br><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            w.WriteHeader(<span class="hljs-number">400</span>)<br>            io.WriteString(w, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        doSomething() ...<br></code></pre></div></td></tr></table></figure>

<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑</p>
<h2 id="反射常用示例"><a href="#反射常用示例" class="headerlink" title="反射常用示例"></a>反射常用示例</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Child <span class="hljs-keyword">struct</span> &#123;<br>	Name     <span class="hljs-keyword">string</span><br>	Grade    <span class="hljs-keyword">int</span><br>	Handsome <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Adult <span class="hljs-keyword">struct</span> &#123;<br>	ID         <span class="hljs-keyword">string</span> <span class="hljs-string">`qson:"Name"`</span><br>	Occupation <span class="hljs-keyword">string</span><br>	Handsome   <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-comment">// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，</span><br><span class="hljs-comment">// 并且有一个字段的 tag 或者字段名是 `Name` ，</span><br><span class="hljs-comment">// 如果该 `Name` 字段的值是 `qcrao`，</span><br><span class="hljs-comment">// 就把结构体中名为 `Handsome` 的字段值设置为 true。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handsome</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-comment">// 获取 i 的反射变量 Value</span><br>	v := reflect.ValueOf(i)<br><br>	<span class="hljs-comment">// 确定 v 是一个 Slice</span><br>	<span class="hljs-keyword">if</span> v.Kind() != reflect.Slice &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-comment">// 确定 v 是的元素为结构体</span><br>	<span class="hljs-keyword">if</span> e := v.Type().Elem(); e.Kind() != reflect.Struct &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-comment">// 确定结构体的字段名含有 "ID" 或者 json tag 标签为 `name`</span><br>	<span class="hljs-comment">// 确定结构体的字段名 "Handsome"</span><br>	st := v.Type().Elem()<br><br>	<span class="hljs-comment">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段</span><br>	foundName := <span class="hljs-literal">false</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; st.NumField(); i++ &#123;<br>		f := st.Field(i)<br>		tag := f.Tag.Get(<span class="hljs-string">"qson"</span>)<br><br>		<span class="hljs-keyword">if</span> (tag == <span class="hljs-string">"Name"</span> || f.Name == <span class="hljs-string">"Name"</span>) &amp;&amp; f.Type.Kind() == reflect.String &#123;<br>			foundName = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> !foundName &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-keyword">if</span> niceField, foundHandsome := st.FieldByName(<span class="hljs-string">"Handsome"</span>); foundHandsome == <span class="hljs-literal">false</span> || niceField.Type.Kind() != reflect.Bool &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-comment">// 设置名字为 "qcrao" 的对象的 "Handsome" 字段为 true</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.Len(); i++ &#123;<br>		e := v.Index(i)<br>		handsome := e.FieldByName(<span class="hljs-string">"Handsome"</span>)<br><br>		<span class="hljs-comment">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段</span><br>		<span class="hljs-keyword">var</span> name reflect.Value<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; st.NumField(); j++ &#123;<br>			f := st.Field(j)<br>			tag := f.Tag.Get(<span class="hljs-string">"qson"</span>)<br><br>			<span class="hljs-keyword">if</span> tag == <span class="hljs-string">"Name"</span> || f.Name == <span class="hljs-string">"Name"</span> &#123;<br>				name = v.Index(i).Field(j)<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> name.String() == <span class="hljs-string">"qcrao"</span> &#123;<br>			handsome.SetBool(<span class="hljs-literal">true</span>)<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	children := []Child&#123;<br>		&#123;Name: <span class="hljs-string">"Ava"</span>, Grade: <span class="hljs-number">3</span>, Handsome: <span class="hljs-literal">true</span>&#125;,<br>		&#123;Name: <span class="hljs-string">"qcrao"</span>, Grade: <span class="hljs-number">6</span>, Handsome: <span class="hljs-literal">false</span>&#125;,<br>	&#125;<br><br>	adults := []Adult&#123;<br>		&#123;ID: <span class="hljs-string">"Steve"</span>, Occupation: <span class="hljs-string">"Clerk"</span>, Handsome: <span class="hljs-literal">true</span>&#125;,<br>		&#123;ID: <span class="hljs-string">"qcrao"</span>, Occupation: <span class="hljs-string">"Go Programmer"</span>, Handsome: <span class="hljs-literal">false</span>&#125;,<br>	&#125;<br><br>	fmt.Printf(<span class="hljs-string">"adults before handsome: %v\n"</span>, adults)<br>	handsome(adults)<br>	fmt.Printf(<span class="hljs-string">"adults after handsome: %v\n"</span>, adults)<br><br>	fmt.Println(<span class="hljs-string">"-------------"</span>)<br><br>	fmt.Printf(<span class="hljs-string">"children before handsome: %v\n"</span>, children)<br>	handsome(children)<br>	fmt.Printf(<span class="hljs-string">"children after handsome: %v\n"</span>, children)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>代码运行结果：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">adults before handsome:</span> <span class="hljs-string">[&#123;Steve</span> <span class="hljs-string">Clerk</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span> <span class="hljs-string">&#123;qcrao</span> <span class="hljs-string">Go</span> <span class="hljs-string">Programmer</span> <span class="hljs-literal">false</span><span class="hljs-string">&#125;]</span><br><span class="hljs-attr">adults after handsome:</span> <span class="hljs-string">[&#123;Steve</span> <span class="hljs-string">Clerk</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span> <span class="hljs-string">&#123;qcrao</span> <span class="hljs-string">Go</span> <span class="hljs-string">Programmer</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;]</span><br><span class="hljs-string">-------------</span><br><span class="hljs-attr">children before handsome:</span> <span class="hljs-string">[&#123;Ava</span> <span class="hljs-number">3</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span> <span class="hljs-string">&#123;qcrao</span> <span class="hljs-number">6</span> <span class="hljs-literal">false</span><span class="hljs-string">&#125;]</span><br><span class="hljs-attr">children after handsome:</span> <span class="hljs-string">[&#123;Ava</span> <span class="hljs-number">3</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span> <span class="hljs-string">&#123;qcrao</span> <span class="hljs-number">6</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;]</span><br></code></pre></div></td></tr></table></figure>

<p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p>
<p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p>
<p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p>
<h2 id="写单测相关"><a href="#写单测相关" class="headerlink" title="写单测相关"></a>写单测相关</h2><h3 id="构造带-body-的-http-Response"><a href="#构造带-body-的-http-Response" class="headerlink" title="构造带 body 的 http Response"></a>构造带 body 的 http Response</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">&#123;Values: gomonkey.Params&#123;&amp;http.Response&#123;Body: io.NopCloser(strings.NewReader(<span class="hljs-string">""</span>))&#125;, <span class="hljs-literal">nil</span>&#125;&#125;,<br></code></pre></div></td></tr></table></figure>

<h3 id="构造-http-ResponseWriter"><a href="#构造-http-ResponseWriter" class="headerlink" title="构造 http ResponseWriter"></a>构造 http ResponseWriter</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">w := <span class="hljs-built_in">new</span>(httptest.ResponseRecorder)<br></code></pre></div></td></tr></table></figure>

<h1 id="time-的时区设置"><a href="#time-的时区设置" class="headerlink" title="time 的时区设置"></a>time 的时区设置</h1><p>对于需要使用时间的场景，默认情况下会从当前系统中找时区信息，如果需要手动设置时区，最好所有的解析和格式化的操作都指定时区信息：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">t,_ := time.ParseInLocation(layout,inputTime,location)<br>dateTime := time.Unix(t.Unix(),<span class="hljs-number">0</span>).In(loacation).Format(layout)<br></code></pre></div></td></tr></table></figure>

<p>常用的 <code>Parse</code> 方法在解析时间模板时会使用读取参数中的时区信息，没有的话就采用 UTC 时间，此时如果再调用 <code>time.Unix(t.Unix(),0).In(loacation).Format(layout)</code> ，生成的时间会加上时区时间，所以最好采用上述方式，在解析的时候就把时区信息通过 <code>ParseInLocation</code> 传入，避免时区问题。</p>
<h1 id="空结构体的应用"><a href="#空结构体的应用" class="headerlink" title="空结构体的应用"></a>空结构体的应用</h1><p>在Go中，每一个基本类型都有对应的字节宽度，声明一个变量后即使不赋值，也需要占用一定的内存。但是对于空结构体来说，其字节宽度为0，因此可以用在某些场景下作为占位符而不占用存储空间。其使用场景主要有：</p>
<ul>
<li>实现方法接收者</li>
<li>实现集合类型</li>
<li>实现空通道</li>
</ul>
<h2 id="实现方法接收者"><a href="#实现方法接收者" class="headerlink" title="实现方法接收者"></a>实现方法接收者</h2><p>在某些业务场景下，需要将方法组合起来，代表一个分组，便于后续的拓展和维护。这时候就会使用空结构体，即节省内存，也便于未来针对该类型进行公共字段等的增加。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *T)</span> <span class="hljs-title">Call</span><span class="hljs-params">()</span></span> &#123;<br> fmt.Println(<span class="hljs-string">"脑子进煎鱼了"</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-keyword">var</span> s T<br> s.Call()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在该场景下，使用空结构体从多维度来考量是最合适的，易拓展，省空间，最结构化。</p>
<h2 id="实现集合类型"><a href="#实现集合类型" class="headerlink" title="实现集合类型"></a>实现集合类型</h2><p>由于 Go 中并没有提供集合（Set）的相关支持，当需要自己实现时，可以使用 map 来替代，对于其 value，使用空结构作为占位符，不会额外增加不必要的内存开销：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span> <span class="hljs-title">Append</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span></span> &#123;<br> s[k] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span></span> &#123;<br> <span class="hljs-built_in">delete</span>(s, k)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span> <span class="hljs-title">Exist</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br> _, ok := s[k]<br> <span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> set := Set&#123;&#125;<br> set.Append(<span class="hljs-string">"煎鱼"</span>)<br> set.Append(<span class="hljs-string">"咸鱼"</span>)<br> set.Append(<span class="hljs-string">"蒸鱼"</span>)<br> set.Remove(<span class="hljs-string">"煎鱼"</span>)<br><br> fmt.Println(set.Exist(<span class="hljs-string">"煎鱼"</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="实现空通道"><a href="#实现空通道" class="headerlink" title="实现空通道"></a>实现空通道</h2><p>在 Go channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只要用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br> <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>  <span class="hljs-built_in">close</span>(ch)<br> &#125;()<br><br> fmt.Println(<span class="hljs-string">"脑子好像进..."</span>)<br> &lt;-ch<br> fmt.Println(<span class="hljs-string">"煎鱼了！"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>该程序会先输出 ”脑子好像进…“ 后，再睡眠一段时间再输出 “煎鱼了！”，达到间断控制 channel 的效果。</p>
<p>由于该 channel 使用的是空结构体，因此也不会带来额外的内存开销。</p>
<h1 id="go-中常用的包"><a href="#go-中常用的包" class="headerlink" title="go 中常用的包"></a>go 中常用的包</h1><h2 id="regexp包"><a href="#regexp包" class="headerlink" title="regexp包"></a>regexp包</h2><p>主要用于正则匹配。</p>
<p>如果是简单模式，使用 <code>Match</code> 方法便可：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">ok, _ := regexp.Match(pat, []<span class="hljs-keyword">byte</span>(searchIn))<br></code></pre></div></td></tr></table></figure>

<p>变量 ok 将返回 true 或者 false, 也可以使用 <code>MatchString</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">ok, _ := regexp.MatchString(pat, searchIn)<br></code></pre></div></td></tr></table></figure>

<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。然后我们将掌握一些匹配，查找，替换相关的功能。如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"regexp"</span><br>    <span class="hljs-string">"strconv"</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//目标字符串</span><br>    searchIn := <span class="hljs-string">"John: 2578.34 William: 4567.23 Steve: 5632.18"</span><br>    pat := <span class="hljs-string">"[0-9]+.[0-9]+"</span> <span class="hljs-comment">//正则</span><br><br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span>&#123;<br>        v, _ := strconv.ParseFloat(s, <span class="hljs-number">32</span>)<br>        <span class="hljs-keyword">return</span> strconv.FormatFloat(v * <span class="hljs-number">2</span>, <span class="hljs-string">'f'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">32</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ok, _ := regexp.Match(pat, []<span class="hljs-keyword">byte</span>(searchIn)); ok &#123;<br>        fmt.Println(<span class="hljs-string">"Match Found!"</span>)<br>    &#125;<br><br>    re, _ := regexp.Compile(pat)<br>    <span class="hljs-comment">//将匹配到的部分替换为"##.#"</span><br>    str := re.ReplaceAllString(searchIn, <span class="hljs-string">"##.#"</span>)<br>    fmt.Println(str)<br>    <span class="hljs-comment">//参数为函数时</span><br>    str2 := re.ReplaceAllStringFunc(searchIn, f)<br>    fmt.Println(str2)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">Match Found!<br>John: ##.# William: ##.# Steve: ##.#<br>John: <span class="hljs-number">5156.68</span> William: <span class="hljs-number">9134.46</span> Steve: <span class="hljs-number">11264.36</span><br></code></pre></div></td></tr></table></figure>

<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><p><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p>
<p>假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 <code>Mutex</code> 来实现的一个典型例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span>  <span class="hljs-string">"sync"</span><br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>    mu sync.Mutex<br>    <span class="hljs-comment">// ... other fields, e.g.: Str string</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果一个函数想要改变这个变量可以这样写:</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Update</span><span class="hljs-params">(info *Info)</span></span> &#123;<br>    info.mu.Lock()<br>    <span class="hljs-comment">// critical section:</span><br>    info.Str = <span class="hljs-comment">// new value</span><br>    <span class="hljs-comment">// end critical section</span><br>    info.mu.Unlock()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>还有一个很有用的例子是通过 Mutex 来实现一个可以上锁的共享缓冲器:</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SyncedBuffer <span class="hljs-keyword">struct</span> &#123;<br>    lock    sync.Mutex<br>    buffer  bytes.Buffer<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。</p>
<h2 id="精密计算和big包"><a href="#精密计算和big包" class="headerlink" title="精密计算和big包"></a>精密计算和big包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2/5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 <code>big.NewRat(N,D)</code> 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用于作为reciver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// big.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"math"</span><br>    <span class="hljs-string">"math/big"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Here are some calculations with bigInts:</span><br>    im := big.NewInt(math.MaxInt64)<br>    in := im<br>    io := big.NewInt(<span class="hljs-number">1956</span>)<br>    ip := big.NewInt(<span class="hljs-number">1</span>)<br>    ip.Mul(im, in).Add(ip, im).Div(ip, io)<br>    fmt.Printf(<span class="hljs-string">"Big Int: %v\n"</span>, ip)<br>    <span class="hljs-comment">// Here are some calculations with bigRat:</span><br>    rm := big.NewRat(math.MaxInt64, <span class="hljs-number">1956</span>)<br>    rn := big.NewRat(<span class="hljs-number">-1956</span>, math.MaxInt64)<br>    ro := big.NewRat(<span class="hljs-number">19</span>, <span class="hljs-number">56</span>)<br>    rp := big.NewRat(<span class="hljs-number">1111</span>, <span class="hljs-number">2222</span>)<br>    rq := big.NewRat(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    rq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)<br>    fmt.Printf(<span class="hljs-string">"Big Rat: %v\n"</span>, rq)<br>&#125;<br><br><span class="hljs-comment">/* Output:<br>Big Int: 43492122561469640008497075573153004<br>Big Rat: -37/112<br>*/</span><br></code></pre></div></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Big Int:</span> <span class="hljs-number">43492122561469640008497075573153004</span><br><span class="hljs-attr">Big Rat:</span> <span class="hljs-number">-37</span><span class="hljs-string">/112</span><br></code></pre></div></td></tr></table></figure>



<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="短变量声明导致变量覆盖"><a href="#短变量声明导致变量覆盖" class="headerlink" title="短变量声明导致变量覆盖"></a>短变量声明导致变量覆盖</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> remember <span class="hljs-keyword">bool</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> something &#123;<br>    remember := <span class="hljs-literal">true</span> <span class="hljs-comment">//错误</span><br>&#125;<br><span class="hljs-comment">// 使用remember</span><br></code></pre></div></td></tr></table></figure>

<p>在此代码段中，<code>remember</code> 变量永远不会在 <code>if</code> 语句外面变成 <code>true</code>，如果 <code>something</code> 为 <code>true</code>，由于使用了短声明 <code>:=</code>，<code>if</code> 语句内部的新变量 <code>remember</code> 将覆盖外面的 <code>remember</code> 变量，并且该变量的值为 <code>true</code>，但是在 <code>if</code> 语句外面，变量 <code>remember</code> 的值变成了 <code>false</code>，所以正确的写法应该是：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> something &#123;<br>    remember = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此类错误也容易在 <code>for</code> 循环中出现，尤其当函数返回一个具名变量时难于察觉，例如以下的代码段：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shadow</span><span class="hljs-params">()</span> <span class="hljs-params">(err error)</span></span> &#123;<br>    x, err := check1() <span class="hljs-comment">// x是新创建变量，err是被赋值</span><br>	  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    		<span class="hljs-keyword">return</span> <span class="hljs-comment">// 正确返回err</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> y, err := check2(x); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// y和if语句中err被创建</span><br>    		<span class="hljs-keyword">return</span> <span class="hljs-comment">// if语句中的err被外面的err覆盖，所以错误的返回nil！</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>    		fmt.Println(y)<br>		&#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="不要对需要-append-的空切片使用-make-声明变量"><a href="#不要对需要-append-的空切片使用-make-声明变量" class="headerlink" title="不要对需要 append 的空切片使用 make 声明变量"></a>不要对需要 append 的空切片使用 make 声明变量</h2><p>当初始化一个数组的时候，如果需要调用 append 操作往空变量里塞数据，不要在声明变量的时候，使用带 len 声明的 make（除非 len = 0），因为这会导致 append 操作直接往数组后面添加，最后的结果是数组前面的都是空，append 往后添加数据：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	attr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">4</span>)<br>	fmt.Println(<span class="hljs-string">"len0:"</span>, <span class="hljs-built_in">len</span>(attr1)) <span class="hljs-comment">//len0: 4</span><br>	attr1 = <span class="hljs-built_in">append</span>(attr1, <span class="hljs-string">"hello"</span>)<br>	fmt.Println(<span class="hljs-string">"len1:"</span>, <span class="hljs-built_in">len</span>(attr1)) <span class="hljs-comment">//len1: 5</span><br>	attr1 = <span class="hljs-built_in">append</span>(attr1, <span class="hljs-string">"hello"</span>)<br>	fmt.Println(<span class="hljs-string">"len2:"</span>, <span class="hljs-built_in">len</span>(attr1)) <span class="hljs-comment">//len2: 6</span><br>	attr1 = <span class="hljs-built_in">append</span>(attr1, <span class="hljs-string">"hello"</span>)<br>	fmt.Println(<span class="hljs-string">"len3:"</span>, <span class="hljs-built_in">len</span>(attr1)) <span class="hljs-comment">//len3: 7</span><br><br>	<span class="hljs-keyword">var</span> attr2 []<span class="hljs-keyword">string</span><br>	attr2 = <span class="hljs-built_in">append</span>(attr2, <span class="hljs-string">"hello"</span>)<br>	attr2 = <span class="hljs-built_in">append</span>(attr2, <span class="hljs-string">"hello"</span>)<br>	attr2 = <span class="hljs-built_in">append</span>(attr2, <span class="hljs-string">"hello"</span>)<br>	fmt.Println(<span class="hljs-built_in">len</span>(attr2)) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以直接声明一个变量，或者 make 的 len 参数为 0，append 会在追加的时候自己进行初始化容量的操作。</p>
<h2 id="误用-defer-关闭一个文件"><a href="#误用-defer-关闭一个文件" class="headerlink" title="误用 defer 关闭一个文件"></a>误用 defer 关闭一个文件</h2><p>如果在一个 for 循环内部处理一系列文件，需要使用 defer 确保文件在处理完毕后被关闭，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>    <span class="hljs-keyword">if</span> f, err = os.Open(file); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 这是错误的方式，当循环结束时文件没有关闭，要等到整个方法执行完了才会调用</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br>    <span class="hljs-comment">// 对文件进行操作</span><br>    f.Process(data)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>    <span class="hljs-keyword">if</span> f, err = os.Open(file); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 对文件进行操作</span><br>    f.Process(data)<br>    <span class="hljs-comment">// 关闭文件</span><br>    f.Close()<br> &#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p>
<h2 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h2><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。</p>
<p>因此应该这样做：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">func findBiggest( listOfNumbers []int ) int &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">func findBiggest( listOfNumbers *[]int ) int &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>当切片作为参数传递时，切记不要解引用切片。</strong></p>
<h2 id="不要使用指针指向接口类型"><a href="#不要使用指针指向接口类型" class="headerlink" title="不要使用指针指向接口类型"></a>不要使用指针指向接口类型</h2><p>在下面的程序中：<code>nexter</code> 是一个接口类型，并且定义了一个 <code>next()</code> 方法读取下一字节。函数 <code>nextFew1</code> 将 <code>nexter</code> 接口作为参数并读取接下来的 <code>num</code> 个字节，并返回一个切片：这是正确做法。但是 <code>nextFew2</code> 使用一个指向 <code>nexter</code> 接口类型的指针作为参数传递给函数：当使用 <code>next()</code> 函数时，系统会给出一个编译错误：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">n.next undefined (<span class="hljs-keyword">type</span> \*nexter <span class="hljs-keyword">has</span> no field <span class="hljs-keyword">or</span> <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">next</span>) （<span class="hljs-title">n</span>.<span class="hljs-title">next</span> 未定义（*<span class="hljs-title">nexter</span> 类型没有 <span class="hljs-title">next</span> 成员或 <span class="hljs-title">next</span> 方法））</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    “fmt”<br>)<br><span class="hljs-keyword">type</span> nexter <span class="hljs-keyword">interface</span> &#123;<br>    next() <span class="hljs-keyword">byte</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextFew1</span><span class="hljs-params">(n nexter, num <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>    <span class="hljs-keyword">var</span> b []<span class="hljs-keyword">byte</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>        b[i] = n.next()<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextFew2</span><span class="hljs-params">(n *nexter, num <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>    <span class="hljs-keyword">var</span> b []<span class="hljs-keyword">byte</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>        b[i] = n.next() <span class="hljs-comment">// 编译错误:n.next未定义（*nexter类型没有next成员或next方法）</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">"Hello World!"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong></p>
<h2 id="注意循环中的协程使用"><a href="#注意循环中的协程使用" class="headerlink" title="注意循环中的协程使用"></a>注意循环中的协程使用</h2><p>对于下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"time"</span><br>)<br><br><span class="hljs-keyword">var</span> values = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 版本A:</span><br>    <span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// ix是索引值</span><br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Print(ix, <span class="hljs-string">" "</span>)<br>        &#125;() <span class="hljs-comment">// 调用闭包打印每个索引值</span><br>    &#125;<br>    fmt.Println()<br>    <span class="hljs-comment">// 版本B: 和A版本类似，但是通过调用闭包作为一个协程</span><br>    <span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Print(ix, <span class="hljs-string">" "</span>)<br>        &#125;()<br>    &#125;<br>    fmt.Println()<br>    time.Sleep(<span class="hljs-number">5e9</span>)<br>    <span class="hljs-comment">// 版本C: 正确的处理方式</span><br>    <span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ix <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            fmt.Print(ix, <span class="hljs-string">" "</span>)<br>        &#125;(ix)<br>    &#125;<br>    fmt.Println()<br>    time.Sleep(<span class="hljs-number">5e9</span>)<br>    <br>    <span class="hljs-comment">// 版本C的另外一种正确的处理方式</span><br>    <span class="hljs-comment">//for ix := range values &#123;</span><br>    <span class="hljs-comment">//	  ix := ix</span><br>    <span class="hljs-comment">//    go func() &#123;</span><br>    <span class="hljs-comment">//        fmt.Print(ix, " ")</span><br>    <span class="hljs-comment">//    &#125;()</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//fmt.Println()</span><br>    <span class="hljs-comment">//time.Sleep(5e9)</span><br>    <br>    <span class="hljs-comment">// 版本D: 输出值:</span><br>    <span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> values &#123;<br>        val := values[ix]<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Print(val, <span class="hljs-string">" "</span>)<br>        &#125;()<br>    &#125;<br>    time.Sleep(<span class="hljs-number">1e9</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><br><span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure>

<p>版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。</p>
<p>如果阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：<code>4 4 4 4 4</code>。在版本 B 的循环中，<code>ix</code> 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当运行这段代码时，将看见每次循环都打印最后一个索引值 <code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 <code>ix</code> 值是 <code>4</code>。</p>
<p>版本 C 的循环写法才是正确的：调用每个闭包是将 <code>ix</code> 作为参数传递给闭包。<code>ix</code> 在每次循环时都被重新赋值，并将每个协程的 <code>ix</code> 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 <code>0 2 1 3 4</code> 或者 <code>0 3 1 2 4</code> 或者其他类似的序列，这主要取决于每个协程何时开始被执行。</p>
<p>版本 C 的另一个处理方法，<code>ix := ix</code> 可能看起来有点奇怪，但它完全有效。因为处于循环中意味着处于另一个作用域内，所以 <code>ix := ix</code> 相当于创建了另一个名为 <code>ix</code> 的变量实例。</p>
<blockquote>
<p>用 <strong>大括号</strong> <code>{}</code> 包围的一个代码块相当于一个新的作用域，可以定义同名变量</p>
</blockquote>
<p>在版本 D 中，能够正确输出这个数组的值，因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。</p>
<h2 id="不要在生产环境使用默认的-HTTP-Client"><a href="#不要在生产环境使用默认的-HTTP-Client" class="headerlink" title="不要在生产环境使用默认的 HTTP Client"></a>不要在生产环境使用默认的 HTTP Client</h2><p>Go 默认的 HTTP 客户端没有指定请求超时时间，允许服务劫持 goroutine。当请求外部服务时，请始终使用自定义的 <code>http.Client</code>。</p>
<p>Go 的 HTTP 包使用 <code>Client</code> 结构体来管理 HTTP(S) 通信的内部过程。<code>Clients</code> 是并发安全的对象，包含配置、管理 TCP 状态、处理 cookies 等。当使用 <code>http.Get(url)</code> 时，就会调用  <code>http.DefaultClient</code>，走的是 HTTP 默认配置，声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> DefaultClient = &amp;Client&#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>除其他配置项外，<code>http.Client</code> 有一个超时时间的配置，当请求时间超过这个数值时，请求就会自动断开。该数值默认值是 0，即没有超时时间。该默认值对于 HTTP 包来说挺合理的，同时这也是一个容易让人掉进去的坑，如果请求的对象宕机或者因为其他原因一直没有响应，就会导致发起请求的 groutine 挂起，只要发生故障的服务器没有恢复，进程就会一直挂着。因为进行 API 调用是为了服务用户请求，所以这也会导致服务用户请求的 goroutine 也挂起。一旦有足够的人发起这个 http 请求，很有可能就因为系统资源达到了极限导致应用挂掉。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决这个问题的办法就是使用 <code>http.Client</code> 时定义一个合理的超时时间，比如下面这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> netClient = &amp;http.Client&#123;<br>  Timeout: time.Second * <span class="hljs-number">10</span>,<br>&#125;<br>response, _ := netClient.Get(url)<br></code></pre></div></td></tr></table></figure>

<p>设置了 10s 的超时时间，如果超时 <code>Get()</code> 将会返回错误：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">&amp;httpError&#123;<br>  err:     err.Error() + <span class="hljs-string">" (Client.Timeout exceeded while awaiting headers)"</span>,<br>  timeout: <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果需要对请求生命周期进行更细粒度的控制，还可以另外指定自定义 <code>net.Transport</code> 和 <code>net.Dialer</code>。</p>
<p><code>Transport</code> 结构体用来管理底层 TCP 连接，<code>Dialer</code> 是用来管理连接建立的结构体。Go 的 net 包使用默认的 <code>Transport</code> 和 <code>Dialer</code>。下面是一个自定义的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> netTransport = &amp;http.Transport&#123;<br>  Dial: (&amp;net.Dialer&#123;<br>    Timeout: <span class="hljs-number">5</span> * time.Second,<br>  &#125;).Dial,<br>  TLSHandshakeTimeout: <span class="hljs-number">5</span> * time.Second,<br>&#125;<br><span class="hljs-keyword">var</span> netClient = &amp;http.Client&#123;<br>  Timeout: time.Second * <span class="hljs-number">10</span>,<br>  Transport: netTransport,<br>&#125;<br>response, _ := netClient.Get(url)<br></code></pre></div></td></tr></table></figure>

<p>上面代码设置了 TCP 拨号时间、TLS 握手时间和请求超时时间。如果有需要还可以设置其他选项，例如 <code>keep-alive</code> 超时时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言的 <code>net/http</code> 包是经过深思熟虑的产物，可以非常便捷地用于 HTTP(S) 通信。然而，缺少请求超时时间是一个非常容易掉进去的坑，因为这个包提供了很多诸如 http.Get(url) 等便捷的方法。请求远程服务时不设置超时时间会使应用程序依赖于该服务，如果远程服务发生故障或者有恶意程序，请求将会永远挂起，从而有可能使系统资源耗尽导致宕机。</p>
<h2 id="map的key-value不能同时断言"><a href="#map的key-value不能同时断言" class="headerlink" title="map的key,value不能同时断言"></a>map的key,value不能同时断言</h2><p>对于一个类型为 <code>interface</code> 的变量，当其实际的值为一个 <code>map</code> 值，例如 <code>map[string]string</code>，此时如果要对该变量进行类型断言，不可以直接使用如下格式：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// v:&#123;"aa":"vv"&#125;</span><br><span class="hljs-keyword">var</span> v <span class="hljs-keyword">interface</span>&#123;&#125;<br>v2,ok := v.(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>) <span class="hljs-comment">// ok==false</span><br></code></pre></div></td></tr></table></figure>

<p>对于 map 的 key 和 value 进行断言时，一次只能断言一个数据结构的类型，因此需要分开进行断言：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v2,ok := v.(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// ok==true</span><br>v3,ok := v2[<span class="hljs-string">"aa"</span>].(<span class="hljs-keyword">string</span>) <span class="hljs-comment">// ok==true</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>断言的真正含义是让编译器应该把某个变量当成什么类型，而不是真的类型转换，不涉及内存上面的操作，真正的类型转换应该是会涉及内存上面的操作的。</p>
</blockquote>
<p>具体的实例见下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/map%E7%9A%84%E6%96%AD%E8%A8%80.png" alt="map的断言"></p>
<h2 id="未知枚举值"><a href="#未知枚举值" class="headerlink" title="未知枚举值"></a>未知枚举值</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">uint32</span><br><br><span class="hljs-keyword">const</span> (<br>  StatusOpen Status = <span class="hljs-literal">iota</span><br>  StatusClosed<br>  StatusUnknown<br>)<br></code></pre></div></td></tr></table></figure>

<p>在这里，我们使用 iota 创建了一个枚举：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">StatusOpen = <span class="hljs-number">0</span><br>StatusClosed = <span class="hljs-number">1</span><br>StatusUnknown = <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>

<p>现在，假设这个 <code>Status</code> 类型是 JSON 请求的一部分，将被 <code>marshalled/unmarshalled</code>。</p>
<p>设计了以下结构：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>  ID        <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:"Id"`</span><br>  Timestamp <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:"Timestamp"`</span><br>  Status    Status <span class="hljs-string">`json:"Status"`</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后，接收这样的请求：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"Id"</span>: <span class="hljs-number">1234</span>,<br>  <span class="hljs-attr">"Timestamp"</span>: <span class="hljs-number">1563362390</span>,<br>  <span class="hljs-attr">"Status"</span>: <span class="hljs-number">0</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样子不会有任何问题，状态会被<code>unmarshalled</code>为<code>StatusOpen</code>。</p>
<p>然而，让我们以另一个未设置状态值的请求为例:</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"Id"</span>: <span class="hljs-number">1235</span>,<br>  <span class="hljs-attr">"Timestamp"</span>: <span class="hljs-number">1563362390</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这种情况下，请求结构的 <code>Status</code> 字段将初始化为它的零值(对于<code>uint32</code>类型:0)，因此结果将是 <code>StatusOpen</code> 而不是 <code>StatusUnknown</code>。所以在这种场景下，最好的做法是<strong>将枚举的未知值设置为 0</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">uint32</span><br><br><span class="hljs-keyword">const</span> (<br>  StatusUnknown Status = <span class="hljs-literal">iota</span><br>  StatusOpen<br>  StatusClosed<br>)<br></code></pre></div></td></tr></table></figure>

<p>如果状态不是 JSON 请求的一部分，它将被初始化为<code>StatusUnknown</code>，这才符合期望。</p>
<h3 id="基准测试自动优化"><a href="#基准测试自动优化" class="headerlink" title="基准测试自动优化"></a>基准测试自动优化</h3><p>基准测试主要就是测试代码整体的吞吐量，性能等，如果编写的测试代码由于被编译器所优化，会导致测试结果不准确。</p>
<p>例如下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clear</span><span class="hljs-params">(n <span class="hljs-keyword">uint64</span>, i, j <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">uint64</span></span> &#123;<br>  <span class="hljs-keyword">return</span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number">1</span> &lt;&lt; i) - <span class="hljs-number">1</span>)) &amp; n<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此函数清除给定范围内的位。为了测试它，可能如下这样做:</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkWrong</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>    clear(<span class="hljs-number">1221892080809121</span>, <span class="hljs-number">10</span>, <span class="hljs-number">63</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个基准测试中，<code>clear</code> 不调用任何其他函数，没有<strong>副作用</strong>。所以编译器将会把 <code>clear</code> 优化成内联函数。一旦内联，将会导致不准确的测试结果。</p>
<p>一个解决方案是<strong>将函数结果设置为全局变量</strong>，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result <span class="hljs-keyword">uint64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkCorrect</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>  <span class="hljs-keyword">var</span> r <span class="hljs-keyword">uint64</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>    r = clear(<span class="hljs-number">1221892080809121</span>, <span class="hljs-number">10</span>, <span class="hljs-number">63</span>)<br>  &#125;<br>  result = r<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如此一来，编译器将不知道<code>clear</code>是否会产生副作用。</p>
<p>因此，不会将<code>clear</code>优化成内联函数。</p>
<h2 id="指针迁移到堆上导致指针传递比按值传递更慢"><a href="#指针迁移到堆上导致指针传递比按值传递更慢" class="headerlink" title="指针迁移到堆上导致指针传递比按值传递更慢"></a>指针迁移到堆上导致指针传递比按值传递更慢</h2><p>在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。</p>
<p>那么，指针传递会比按值传递更快吗？</p>
<p>对于下面这里例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">"encoding/json"</span><br>	<span class="hljs-string">"testing"</span><br>)<br><br><span class="hljs-keyword">type</span> foo <span class="hljs-keyword">struct</span> &#123;<br>	ID            <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"_id"`</span><br>	Index         <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"index"`</span><br>	GUID          <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"guid"`</span><br>	IsActive      <span class="hljs-keyword">bool</span>    <span class="hljs-string">`json:"isActive"`</span><br>	Balance       <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"balance"`</span><br>	Picture       <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"picture"`</span><br>	Age           <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"age"`</span><br>	EyeColor      <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"eyeColor"`</span><br>	Name          <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"name"`</span><br>	Gender        <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"gender"`</span><br>	Company       <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"company"`</span><br>	Email         <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"email"`</span><br>	Phone         <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"phone"`</span><br>	Address       <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"address"`</span><br>	About         <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"about"`</span><br>	Registered    <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"registered"`</span><br>	Latitude      <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"latitude"`</span><br>	Longitude     <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"longitude"`</span><br>	Greeting      <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"greeting"`</span><br>	FavoriteFruit <span class="hljs-keyword">string</span>  <span class="hljs-string">`json:"favoriteFruit"`</span><br>&#125;<br><span class="hljs-keyword">type</span> bar <span class="hljs-keyword">struct</span> &#123;<br>	ID            <span class="hljs-keyword">string</span><br>	Index         <span class="hljs-keyword">int</span><br>	GUID          <span class="hljs-keyword">string</span><br>	IsActive      <span class="hljs-keyword">bool</span><br>	Balance       <span class="hljs-keyword">string</span><br>	Picture       <span class="hljs-keyword">string</span><br>	Age           <span class="hljs-keyword">int</span><br>	EyeColor      <span class="hljs-keyword">string</span><br>	Name          <span class="hljs-keyword">string</span><br>	Gender        <span class="hljs-keyword">string</span><br>	Company       <span class="hljs-keyword">string</span><br>	Email         <span class="hljs-keyword">string</span><br>	Phone         <span class="hljs-keyword">string</span><br>	Address       <span class="hljs-keyword">string</span><br>	About         <span class="hljs-keyword">string</span><br>	Registered    <span class="hljs-keyword">string</span><br>	Latitude      <span class="hljs-keyword">float64</span><br>	Longitude     <span class="hljs-keyword">float64</span><br>	Greeting      <span class="hljs-keyword">string</span><br>	FavoriteFruit <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> input foo<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>	err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">`&#123;<br>	    "_id": "5d2f4fcf76c35513af00d47e",<br>	    "index": 1,<br>	    "guid": "ed687a14-590b-4d81-b0cb-ddaa857874ee",<br>	    "isActive": true,<br>	    "balance": "$3,837.19",<br>	    "picture": "https://placehold.it/32x32",<br>	    "age": 28,<br>	    "eyeColor": "green",<br>	    "name": "Rochelle Espinoza",<br>	    "gender": "female",<br>	    "company": "PARLEYNET",<br>	    "email": "rochelleespinoza@parleynet.com",<br>	    "phone": "+1 (969) 445-3766",<br>	    "address": "956 Little Street, Jugtown, District Of Columbia, 6396",<br>	    "about": "Excepteur exercitation labore ut cupidatat laboris mollit ad qui minim aliquip nostrud anim adipisicing est. Nisi sunt duis occaecat aliquip est irure Lorem irure nulla tempor sit sunt. Eiusmod laboris ex est velit minim ut cillum sunt laborum labore ad sunt.\r\n",<br>	    "registered": "2016-03-20T12:07:25 -00:00",<br>	    "latitude": 61.471517,<br>	    "longitude": 54.01596,<br>	    "greeting": "Hello, Rochelle Espinoza!You have 9 unread messages.",<br>	    "favoriteFruit": "banana"<br>	  &#125;`</span>), &amp;input)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(err)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">byPointer</span><span class="hljs-params">(in *foo)</span> *<span class="hljs-title">bar</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;bar&#123;<br>		ID:            in.ID,<br>		Address:       in.Address,<br>		Email:         in.Email,<br>		Index:         in.Index,<br>		Name:          in.Name,<br>		About:         in.About,<br>		Age:           in.Age,<br>		Balance:       in.Balance,<br>		Company:       in.Company,<br>		EyeColor:      in.EyeColor,<br>		FavoriteFruit: in.FavoriteFruit,<br>		Gender:        in.Gender,<br>		Greeting:      in.Greeting,<br>		GUID:          in.GUID,<br>		IsActive:      in.IsActive,<br>		Latitude:      in.Latitude,<br>		Longitude:     in.Longitude,<br>		Phone:         in.Phone,<br>		Picture:       in.Picture,<br>		Registered:    in.Registered,<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">byValue</span><span class="hljs-params">(in foo)</span> <span class="hljs-title">bar</span></span> &#123;<br>	<span class="hljs-keyword">return</span> bar&#123;<br>		ID:            in.ID,<br>		Address:       in.Address,<br>		Email:         in.Email,<br>		Index:         in.Index,<br>		Name:          in.Name,<br>		About:         in.About,<br>		Age:           in.Age,<br>		Balance:       in.Balance,<br>		Company:       in.Company,<br>		EyeColor:      in.EyeColor,<br>		FavoriteFruit: in.FavoriteFruit,<br>		Gender:        in.Gender,<br>		Greeting:      in.Greeting,<br>		GUID:          in.GUID,<br>		IsActive:      in.IsActive,<br>		Latitude:      in.Latitude,<br>		Longitude:     in.Longitude,<br>		Phone:         in.Phone,<br>		Picture:       in.Picture,<br>		Registered:    in.Registered,<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> pointerResult *bar<br><span class="hljs-keyword">var</span> valueResult bar<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkByPointer</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> r *bar<br>	b.ResetTimer()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>		r = byPointer(&amp;input)<br>	&#125;<br>	pointerResult = r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkByValue</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> r bar<br>	b.ResetTimer()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>		r = byValue(input)<br>	&#125;<br>	valueResult = r<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>通过基准测试分别测试了按值传递和指针传递的速度。</p>
<p>结果显示，按值传递比指针传递快3-4倍以上：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">goos: darwin<br>goarch: amd64<br>cpu: Intel(R) Core(TM) i5<span class="hljs-number">-7360</span>U CPU @ <span class="hljs-number">2.30</span>GHz<br>BenchmarkByPointer<br>BenchmarkByPointer<span class="hljs-number">-4</span>   	<span class="hljs-number">11838573</span>	        <span class="hljs-number">91.03</span> ns/op<br>BenchmarkByValue<br>BenchmarkByValue<span class="hljs-number">-4</span>     	<span class="hljs-number">38128300</span>	        <span class="hljs-number">31.21</span> ns/op<br>PASS<br></code></pre></div></td></tr></table></figure>

<p>测试结果与 Go 中如何管理内存有关，主要原因如下：</p>
<ol>
<li><p>下面是来自 Go 语言圣经的介绍：</p>
<p> 一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。</p>
<p> 一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。</p>
<p> 而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。</p>
</li>
<li><p>通俗的理解：</p>
<ul>
<li>栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（<strong>Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小</strong>）</li>
<li>堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。</li>
</ul>
</li>
</ol>
<p>众所周知，可以在<strong>堆</strong>或<strong>栈</strong>上分配变量。</p>
<ul>
<li>栈储存当前 <code>Goroutine</code> 的正在使用的变量（可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。</li>
<li>堆储存<strong>共享变量</strong>（全局变量等）。</li>
</ul>
<p>看一个简单的例子，返回单一的值：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFooValue</span><span class="hljs-params">()</span> <span class="hljs-title">foo</span></span> &#123;<br>  <span class="hljs-keyword">var</span> result foo<br>  <span class="hljs-comment">// Do something</span><br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而 <code>result</code> 变量自身会从当前 Goruntine 栈出栈。</p>
<p>虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。</p>
<p>现在，在看一个返回指针的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFooPointer</span><span class="hljs-params">()</span> *<span class="hljs-title">foo</span></span> &#123;<br>  <span class="hljs-keyword">var</span> result foo<br>  <span class="hljs-comment">// Do something</span><br>  <span class="hljs-keyword">return</span> &amp;result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当调用函数时，<code>result</code> 变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果 <code>result</code> 变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（此情况称为“内存逃逸”）</p>
<p>在这个场景中，Go 编译器将把 <code>result</code> 变量<strong>转义</strong>到一个可以共享变量的地方:<strong>堆</strong>。</p>
<p>不过，传递指针是另一种情况。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>  p := &amp;foo&#123;&#125;<br>  f(p)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>因为我们在同一个 Goroutine 中调用<code>f</code>，所以 <code>p</code> 变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（不需要其他 Goruntine 共享的变量就存储在栈上即可）</p>
<p>比如，<code>io.Reader</code> 中的 <code>Read</code> 方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（<strong>如果返回切片，会将切片转义到堆中</strong>。）</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>  Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>为什么栈如此之快？ 主要有两个原因：</p>
<ol>
<li><strong>堆栈不需要垃圾收集器。</strong>就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。</li>
<li><strong>储存变量不需要考虑同步。</strong>栈属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。</li>
</ol>
<p>总之，当创建一个函数时，<strong>默认行为应该是使用值</strong>而不是指针。只有在我们<strong>想要共享变量时才应使用指针。</strong></p>
<p>如果遇到性能问题，可以使用 <code>go build -gcflags &quot;-m -m&quot;</code> 命令，来显示编译器将变量转义到堆的具体操作。</p>
<p>再次重申，对于大多数日常用例来说，值传递是最合适的。</p>
<h2 id="break-逻辑不符合预期"><a href="#break-逻辑不符合预期" class="headerlink" title="break 逻辑不符合预期"></a>break 逻辑不符合预期</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-keyword">switch</span> f() &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>    <span class="hljs-comment">// Do something</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果 f 返回 true，将调用 break 语句。然而，将会 break 出 switch 语句，而不是 for 循环。</p>
<p>同样的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;-ch:<br>  <span class="hljs-comment">// Do something</span><br>  <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>    <span class="hljs-keyword">break</span><br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>break 与 select 语句有关，与 for 循环无关。</p>
<p>break 出 for/switch 或 for/select  的一种解决方案是<strong>使用带标签的 break</strong>，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">loop:<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ch:<br>    <span class="hljs-comment">// Do something</span><br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>      <span class="hljs-keyword">break</span> loop<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="缺失上下文的错误"><a href="#缺失上下文的错误" class="headerlink" title="缺失上下文的错误"></a>缺失上下文的错误</h2><p>Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。</p>
<p>当前的标准库(在 Go 1.13 之前)只提供 <code>error</code> 的构造函数，自然而然就会缺失其他信息。</p>
<p>看一下 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">pkg/errors</a> 库中错误处理的思想：</p>
<p><em>An error should be handled only</em> <strong>once</strong>. Logging an error <strong>is</strong> <em>handling an error. So an error should</em> <strong>either</strong> <em>be logged or propagated.</em></p>
<blockquote>
<p>错误应该只处理一次。记录 log 错误就是在处理错误。所以，错误应该记录或者传播</p>
</blockquote>
<p>对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。</p>
<p>例如: 所期望的<code>REST</code>调用导致数据库问题的示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">COPYunable <span class="hljs-keyword">to</span><span class="hljs-built_in"> server </span>HTTP POST request <span class="hljs-keyword">for</span><span class="hljs-built_in"> customer </span>1234<br> |_ unable <span class="hljs-keyword">to</span> insert<span class="hljs-built_in"> customer </span>contract abcd<br>     |_ unable <span class="hljs-keyword">to</span> commit transaction<br></code></pre></div></td></tr></table></figure>

<p>如果我们使用 <code>pkg/errors</code>，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYfunc postHandler(customer Customer) Status &#123;<br>  err := insert(customer.Contract)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.WithError(err).Errorf(<span class="hljs-string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)<br>    <span class="hljs-keyword">return</span> Status&#123;ok: <span class="hljs-literal">false</span>&#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Status&#123;ok: <span class="hljs-literal">true</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(contract Contract)</span> <span class="hljs-title">error</span></span> &#123;<br>  err := dbQuery(contract)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.Wrapf(err, <span class="hljs-string">"unable to insert customer contract %s"</span>, contract.ID)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dbQuery</span><span class="hljs-params">(contract Contract)</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-comment">// Do something then fail</span><br>  <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"unable to commit transaction"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果不是由外部库返回的初始 <code>error</code> 可以使用 <code>error.New</code> 创建。中间层 <code>insert</code> 对此错误添加更多上下文信息。最终通过 <code>log</code> 错误来处理错误。每个级别要么返回错误，要么处理错误。</p>
<p>我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的 <code>db</code> 包来处理数据库访问。 该库可能会返回一个名为 <code>db.DBError</code> 的临时错误。要确定是否需要重试，我们必须检查错误原因：</p>
<p>使用 <code>pkg/errors</code> 中提供的 <code>errors.Cause</code> 可以判断错误原因。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYfunc postHandler(customer Customer) Status &#123;<br>  err := insert(customer.Contract)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> errors.Cause(err).(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">default</span>:<br>      log.WithError(err).Errorf(<span class="hljs-string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)<br>      <span class="hljs-keyword">return</span> Status&#123;ok: <span class="hljs-literal">false</span>&#125;<br>    <span class="hljs-keyword">case</span> *db.DBError:<br>      <span class="hljs-keyword">return</span> retry(customer)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Status&#123;ok: <span class="hljs-literal">true</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(contract Contract)</span> <span class="hljs-title">error</span></span> &#123;<br>  err := db.dbQuery(contract)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.Wrapf(err, <span class="hljs-string">"unable to insert customer contract %s"</span>, contract.ID)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>一个常见错误是部分使用 <code>pkg/errors</code>。 例如，通过这种方式检查错误：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYswitch err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">default</span>:<br>  log.WithError(err).Errorf(<span class="hljs-string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)<br>  <span class="hljs-keyword">return</span> Status&#123;ok: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-keyword">case</span> *db.DBError:<br>  <span class="hljs-keyword">return</span> retry(customer)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在此示例中，如果 <code>db.DBError</code> 被 <code>wrapped</code>，它将永远不会执行 <code>retry</code>。</p>
<h2 id="传递文件名给函数"><a href="#传递文件名给函数" class="headerlink" title="传递文件名给函数"></a>传递文件名给函数</h2><p>假设实现一个函数来计算文件中的空行数。最初的实现是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYfunc count(filename <span class="hljs-keyword">string</span>) (<span class="hljs-keyword">int</span>, error) &#123;<br>  file, err := os.Open(filename)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.Wrapf(err, <span class="hljs-string">"unable to open %s"</span>, filename)<br>  &#125;<br>  <span class="hljs-keyword">defer</span> file.Close()<br><br>  scanner := bufio.NewScanner(file)<br>  count := <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>    <span class="hljs-keyword">if</span> scanner.Text() == <span class="hljs-string">""</span> &#123;<br>      count++<br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">return</span> count, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>filename</code> 作为给定的参数，然后打开该文件，再实现读空白行的逻辑，嗯，没有问题。</p>
<p>假设希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。</p>
<p>此外，如果我们想对于 <code>HTTP Body</code> 实现相同的逻辑，将不得不为此创建另一个函数。</p>
<p>Go 设计了两个很棒的接口：<code>io.Reader</code> 和 <code>io.Writer</code> (常见 IO 命令行，文件，网络等)</p>
<p>所以<strong>可以传递一个抽象数据源的<code>io.Reader</code>，而不是传递文件名</strong>。</p>
<p>仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？</p>
<p>答案并不重要，重要的是无论 <code>Reader</code> 读取的是什么类型的数据，都会使用相同的 <code>Read</code> 方法。</p>
<p>在例子中，甚至可以缓冲输入以逐行读取它（使用 <code>bufio.Reader</code> 及其 <code>ReadLine</code> 方法）：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYfunc count(reader *bufio.Reader) (<span class="hljs-keyword">int</span>, error) &#123;<br>  count := <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> &#123;<br>    line, _, err := reader.ReadLine()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">switch</span> err &#123;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.Wrapf(err, <span class="hljs-string">"unable to read"</span>)<br>      <span class="hljs-keyword">case</span> io.EOF:<br>        <span class="hljs-keyword">return</span> count, <span class="hljs-literal">nil</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(line) == <span class="hljs-number">0</span> &#123;<br>      count++<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>打开文件的逻辑现在交给调用 <code>count</code> 方：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYfile, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> errors.Wrapf(err, <span class="hljs-string">"unable to open %s"</span>, filename)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>count, err := count(bufio.NewReader(file))<br></code></pre></div></td></tr></table></figure>

<p>无论数据源如何，都可以调用 <code>count</code>。并且，还将促进单元测试，因为可以从字符串创建一个 <code>bufio.Reader</code>，这大大提高了效率。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">COPYcount, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string">"input"</span>)))<br></code></pre></div></td></tr></table></figure>

<h1 id="出于性能考虑的最佳实践和建议"><a href="#出于性能考虑的最佳实践和建议" class="headerlink" title="出于性能考虑的最佳实践和建议"></a>出于性能考虑的最佳实践和建议</h1><p>（1）尽可能的使用 <code>:=</code> 去初始化声明一个变量（在函数内部）；</p>
<p>（2）尽可能的使用字符代替字符串；</p>
<p>（3）尽可能的使用切片代替数组；</p>
<p>（4）尽可能的使用数组和切片代替映射（详见参考文献 15）；</p>
<p>（5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用 <code>for range</code> 去遍历切片，这比必须查询切片中的每个元素要快一些；</p>
<p>（6）当数组元素是稀疏的（例如有很多 <code>0</code> 值或者空值 <code>nil</code>），使用映射会降低内存消耗；</p>
<p>（7）初始化映射时指定其容量；</p>
<p>（8）当定义一个方法时，使用指针类型作为方法的接受者；</p>
<p>（9）在代码中使用常量或者标志提取常量的值；</p>
<p>（10）尽可能在需要分配大量内存时使用缓存；</p>
<p>（11）使用缓存模板</p>
<blockquote>
<p> <strong>参考文档</strong>：</p>
<p> <a href="https://learnku.com/docs/the-way-to-go/chapter-description/3715" target="_blank" rel="noopener">《GO入门指南》第十六章 常见的陷阱与错误</a></p>
<p> <a href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">深度解密Go语言之反射</a></p>
<p> <a href="https://mp.weixin.qq.com/s/LjSlxdo5PFVJcUhH3UDU0A" target="_blank" rel="noopener">不要使用 Go 默认的 HTTP 客户端（在生产环境中）</a></p>
<p> <a href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779" target="_blank" rel="noopener">Don’t use Go’s default HTTP client (in production)</a></p>
<p> <a href="https://studygolang.com/topics/6033/comment/17800" target="_blank" rel="noopener">断言的疑惑</a></p>
<p> <a href="https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg" target="_blank" rel="noopener">详解 Go 空结构体的 3 种使用场景</a></p>
<p> <a href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" target="_blank" rel="noopener">Go 开发中的十大常见陷阱[译]</a></p>
<p> <a href="https://tangx.in/2021/06/22/golang-block/" target="_blank" rel="noopener">Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？</a></p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/go/">go</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/19/ElasticSearch/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ElasticSearch</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/18/go%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">go 入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'xiao-ming9/xiao-ming9.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备18114217号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=粤ICP备18114217号-1"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" alt="police-icon"/>
            
            <span>粤ICP备18114217号-1</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?54ebb03ad7ad5b762ac8ff7958df6d3f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-M2RT7SDT3L', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M2RT7SDT3L"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-M2RT7SDT3L');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
