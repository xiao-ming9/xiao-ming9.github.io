<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础包按照约定，包名与导入路径的最后一个元素一致。例如，&quot;math&#x2F;rand&quot; 包中的源码均以 package rand 语句开始。 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。 pizza 和 pi 并未以大写字母开头，所以它们是未导出的。 在导入一个包时，只能引用其中已导出的名字">
<meta property="og:type" content="article">
<meta property="og:title" content="go 入门">
<meta property="og:url" content="http://yoursite.com/2020/07/18/go%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="基础包按照约定，包名与导入路径的最后一个元素一致。例如，&quot;math&#x2F;rand&quot; 包中的源码均以 package rand 语句开始。 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。 pizza 和 pi 并未以大写字母开头，所以它们是未导出的。 在导入一个包时，只能引用其中已导出的名字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/make%E5%92%8Cnew%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201912/02/1/J9S85ymhtz.png!large">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8new%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201808/27/23/o4SlYwuXqy.jpg?imageView2/2/w/1240/h/0">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201808/27/23/T9sRQUcN1b.jpg?imageView2/2/w/1240/h/0">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201808/27/23/K6NRjDiDKD.jpg?imageView2/2/w/1240/h/0">
<meta property="article:published_time" content="2020-07-17T16:15:14.000Z">
<meta property="article:modified_time" content="2021-07-17T02:15:56.016Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="http://yoursite.com/2020/07/18/go%E5%85%A5%E9%97%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/07/18/go%E5%85%A5%E9%97%A8/","path":"2020/07/18/go入门/","title":"go 入门"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go 入门 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">1.1.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%90%8D"><span class="nav-number">1.2.</span> <span class="nav-text">导出名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本变量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.3.3.</span> <span class="nav-text">类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">时间和日期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">数值常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">函数语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%80%BC"><span class="nav-number">1.5.3.</span> <span class="nav-text">函数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init-%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">init 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">变长参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85"><span class="nav-number">1.5.6.</span> <span class="nav-text">函数的闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">闭包的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.5.6.1.1.</span> <span class="nav-text">将函数作为返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.1.2.</span> <span class="nav-text">工厂函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E8%B0%83%E8%AF%95%EF%BC%88%E6%9A%82%E6%97%B6%E6%B2%A1%E6%90%9E%E6%87%82%EF%BC%89"><span class="nav-number">1.5.6.1.3.</span> <span class="nav-text">使用闭包调试（暂时没搞懂）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.6.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.6.1.</span> <span class="nav-text">一元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.6.2.</span> <span class="nav-text">二元运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.7.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">1.9.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-%E5%88%87%E7%89%87"><span class="nav-number">1.9.1.</span> <span class="nav-text">nil 切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="nav-number">1.9.2.</span> <span class="nav-text">创建切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make%EF%BC%88%EF%BC%89%E5%92%8C-new%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.3.</span> <span class="nav-text">make（）和 new（）的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%87%E7%89%87"><span class="nav-number">1.9.4.</span> <span class="nav-text">拷贝切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E5%88%87%E7%89%87%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">1.9.5.</span> <span class="nav-text">向切片追加元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#append-%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">append 函数常见操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">1.9.6.</span> <span class="nav-text">内存优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Range"><span class="nav-number">1.9.7.</span> <span class="nav-text">Range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bytes%E5%8C%85"><span class="nav-number">1.9.8.</span> <span class="nav-text">bytes包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%88%87%E7%89%87%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.9.9.</span> <span class="nav-text">搜索及排序切片的数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.10.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.10.1.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3-API"><span class="nav-number">1.10.2.</span> <span class="nav-text">String 操作相关 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#strings-%E5%8C%85"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">strings 包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80"><span class="nav-number">1.10.2.1.1.</span> <span class="nav-text">前缀和后缀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="nav-number">1.10.2.1.2.</span> <span class="nav-text">字符串包含关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%96%E5%AD%97%E7%AC%A6%E5%9C%A8%E7%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="nav-number">1.10.2.1.3.</span> <span class="nav-text">判断子字符串或字符在父字符串中出现的位置（索引）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.10.2.1.4.</span> <span class="nav-text">字符串替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="nav-number">1.10.2.1.5.</span> <span class="nav-text">统计字符串出现次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.10.2.1.6.</span> <span class="nav-text">重复字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-number">1.10.2.1.7.</span> <span class="nav-text">修改字符串大小写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E5%89%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.10.2.1.8.</span> <span class="nav-text">修剪字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.10.2.1.9.</span> <span class="nav-text">分割字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5-slice-%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.10.2.1.10.</span> <span class="nav-text">拼接 slice 到字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9"><span class="nav-number">1.10.2.1.11.</span> <span class="nav-text">从字符串中读取内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strconv-%E5%8C%85"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">strconv 包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.10.3.</span> <span class="nav-text">字符串的内部结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">1.11.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E5%AE%B9%E9%87%8F"><span class="nav-number">1.11.1.</span> <span class="nav-text">map 容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84"><span class="nav-number">1.11.2.</span> <span class="nav-text">修改映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%87%E7%89%87"><span class="nav-number">1.11.3.</span> <span class="nav-text">map 类型的切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-map"><span class="nav-number">1.11.4.</span> <span class="nav-text">遍历 map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.12.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">1.12.1.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%87%E6%B3%95"><span class="nav-number">1.12.2.</span> <span class="nav-text">结构体文法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">1.12.3.</span> <span class="nav-text">匿名字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.12.4.</span> <span class="nav-text">结构体的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E5%AD%97%E6%AE%B5%EF%BC%88Promoted-Fields%EF%BC%89"><span class="nav-number">1.12.5.</span> <span class="nav-text">提升字段（Promoted Fields）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%E6%80%A7%EF%BC%88Structs-Equality%EF%BC%89"><span class="nav-number">1.12.6.</span> <span class="nav-text">结构体相等性（Structs Equality）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.12.7.</span> <span class="nav-text">递归结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.12.7.1.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.12.7.2.</span> <span class="nav-text">二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B7%A5%E5%8E%82"><span class="nav-number">1.12.8.</span> <span class="nav-text">结构体工厂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.8.1.</span> <span class="nav-text">如何强制使用工厂方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E5%92%8C-struct-vs-new-%E5%92%8C-make"><span class="nav-number">1.12.9.</span> <span class="nav-text">map 和 struct vs new () 和 make ()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.12.10.</span> <span class="nav-text">带标签的结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.13.</span> <span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for"><span class="nav-number">1.13.1.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">1.13.2.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">1.13.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer"><span class="nav-number">1.13.4.</span> <span class="nav-text">defer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">1.14.1.</span> <span class="nav-text">指针接收者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-number">1.14.2.</span> <span class="nav-text">带指针参数的函数和指针接收者的方法对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%97%E8%80%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.14.3.</span> <span class="nav-text">选择指针作为接受者的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%B5%8C"><span class="nav-number">1.14.4.</span> <span class="nav-text">方法的内嵌</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84-String-%E6%96%B9%E6%B3%95%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.14.5.</span> <span class="nav-text">类型的 String() 方法和格式化描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C-SetFinalizer"><span class="nav-number">1.14.6.</span> <span class="nav-text">垃圾回收和 SetFinalizer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9A%90%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">接口的隐式实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">接口嵌套接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">接口值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%80%BC%EF%BC%88%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%89%E4%B8%BA-nil-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">2.3.1.</span> <span class="nav-text">底层值（调用接口方法的变量）为 nil 的接口值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">2.3.2.</span> <span class="nav-text">nil 接口值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">空接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">2.5.</span> <span class="nav-text">类型断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">2.5.1.</span> <span class="nav-text">类型选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E6%8E%A5%E5%8F%97%E8%80%85%E4%B8%8E%E5%80%BC%E6%8E%A5%E5%8F%97%E8%80%85"><span class="nav-number">2.6.</span> <span class="nav-text">接口实现中的指针接受者与值接受者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">常用接口方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Stringer"><span class="nav-number">2.7.1.</span> <span class="nav-text">Stringer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Error-%E9%94%99%E8%AF%AF"><span class="nav-number">2.7.2.</span> <span class="nav-text">Error 错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reader-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.7.3.</span> <span class="nav-text">Reader 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F-image"><span class="nav-number">2.7.4.</span> <span class="nav-text">图像 image</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9-%E8%AE%BE%E7%BD%AE-%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">通过反射修改 (设置) 值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.2.</span> <span class="nav-text">反射结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Int-%E5%92%8C-String-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">Int() 和 String() 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">读写数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5"><span class="nav-number">4.1.</span> <span class="nav-text">读取用户的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">读文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%AF%BB%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">其他读文件方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E8%AF%BB%E5%8F%96%E5%88%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">将整个文件的内容读取到一个字符串里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">带缓冲的读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%88%97%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">按列读取文件中的数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">读取压缩文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.4.</span> <span class="nav-text">文件拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fmt-Fprintf"><span class="nav-number">4.5.</span> <span class="nav-text">fmt.Fprintf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86"><span class="nav-number">4.6.</span> <span class="nav-text">数据格式处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.6.1.</span> <span class="nav-text">JSON 数据格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">反序列化：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E4%BB%BB%E6%84%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">解码任意的数据：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.1.3.</span> <span class="nav-text">解码数据到结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E6%B5%81"><span class="nav-number">4.6.1.4.</span> <span class="nav-text">编码和解码流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.6.2.</span> <span class="nav-text">XML 数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gob-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.6.3.</span> <span class="nav-text">Gob 数据格式</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/go%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go 入门 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 入门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-18 00:15:14" itemprop="dateCreated datePublished" datetime="2020-07-18T00:15:14+08:00">2020-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-07-17 10:15:56" itemprop="dateModified" datetime="2021-07-17T10:15:56+08:00">2021-07-17</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>73k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:07</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p>
<h2 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h2><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包。</p>
<p><code>pizza</code> 和 <code>pi</code> 并未以大写字母开头，所以它们是未导出的。</p>
<p>在导入一个包时，只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。</p>
<span id="more"></span>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p>
<pre><code class="go">var x int;
</code></pre>
<p>变量声明可以包含初始值，每个变量对应一个。如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

var i, j int = 1, 2

func main() &#123;
    var c, python, java = true, false, &quot;no!&quot;
    fmt.Println(i, j, c, python, java)
&#125;
</code></pre>
<p>函数内部的变量（局部变量）可以采用简洁赋值语句 <code>:=</code> 在类型明确的地方代替 <code>var</code> 声明变量：（仅限函数内部）</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var i, j int = 1, 2
    k := 3
    c, python, java := true, false, &quot;no!&quot;

    fmt.Println(i, j, k, c, python, java)
&#125;
</code></pre>
<h3 id="基本变量类型"><a href="#基本变量类型" class="headerlink" title="基本变量类型"></a>基本变量类型</h3><p>Go 的基本类型有</p>
<pre><code class="go">bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 表示一个 Unicode 码点

float32 float64

// 复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。
complex64 complex128	// 32、64 位实数和虚数
</code></pre>
<p>对于有符号整型，范围如下：</p>
<p><strong>int8</strong>：表示 8 位有符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：-128～127</p>
<p><strong>int16</strong>：表示 16 位有符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：-32768～32767</p>
<p><strong>int32</strong>：表示 32 位有符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：-2147483648～2147483647</p>
<p><strong>int64</strong>：表示 64 位有符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：-9223372036854775808～9223372036854775807</p>
<p>对于无符号整型，其范围如下：</p>
<p><strong>uint8</strong>：表示 8 位无符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：0～255</p>
<p><strong>uint16</strong>：表示 16 位无符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：0～65535</p>
<p><strong>uint32</strong>：表示 32 位无符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：0～4294967295</p>
<p><strong>uint64</strong>：表示 64 位无符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：0～18446744073709551615</p>
<p>同导入语句一样，变量声明也可以“分组”成一个语法块：</p>
<pre><code class="go">var (
    ToBe   bool       = false
    MaxInt uint64     = 1&lt;&lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)
</code></pre>
<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当需要一个整数值时应使用 <code>int</code> 类型，除非有特殊的理由使用固定大小或无符号的整数类型。int 型是计算最快的一种类型。</p>
<p>float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，在使用 <code>==</code> 或者 <code>!=</code> 来比较浮点数时应当非常小心。最好在正式使用前测试对于精确度要求较高的运算。</p>
<p>应该尽可能地使用 float64，因为 <code>math</code> 包中所有有关数学运算的函数都会要求接收这个类型。</p>
<p>可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 &#x3D; 1000，或者 6.022e23 &#x3D; 6.022 x 1e23）。</p>
<p>可以使用 <code>a := uint64(0)</code> 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。</p>
<p>当进行类似 <code>a32bitInt = int32(a32Float)</code> 的转换时，小数点后的数字将被丢弃。这种情况一般发生当从取值范围较大的类型转换为取值范围较小的类型时，或者可以写一个专门用于处理类型转换的函数来确保没有发生精度的丢失。</p>
<p>对于虚数，</p>
<pre><code class="go">var c1 complex64 = 5 + 10i
fmt.Printf(&quot;The value is: %v&quot;, c1)
// 输出： 5 + 10i
</code></pre>
<p>如果 <code>re</code> 和 <code>im</code> 的类型均为 float32，那么类型为 complex64 的复数 c 可以通过以下方式来获得：</p>
<pre><code class="go">c = complex(re, im)
</code></pre>
<p>函数 <code>real(c)</code> 和 <code>imag(c)</code> 可以分别获得相应的实数和虚数部分。</p>
<p>在使用格式化说明符时，可以使用 <code>%v</code> 来表示复数，但当希望只表示其中的一个部分的时候需要使用 <code>%f</code>。</p>
<p>复数支持和其它数字类型一样的运算。当使用等号 <code>==</code> 或者不等号 <code>!=</code> 对复数进行比较运算时，注意对精确度的把握。<code>cmath</code> 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。</p>
<p>Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用</p>
<p> 变量初始值：</p>
<ul>
<li>数值类型为 <code>0</code></li>
<li>布尔类型为 <code>false</code></li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）</li>
<li>指针为<code>nil</code></li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>
<p>例子如下：</p>
<pre><code class="go">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
</code></pre>
<p>也可以是这种形式：</p>
<pre><code class="go">i := 42
f := float64(i)
u := uint(f)
</code></pre>
<p>Go 在不同类型的项之间赋值时需要显式转换，如：</p>
<pre><code class="go">func main() &#123;
    var x, y int = 3, 4
  //这一句会报错，因为没有执行 math.Sqrt 的返回类型
    var f float64 = math.Sqrt((x*x + y*y))
  //正确做法
  var f float64 = math.Sqrt(float64(x*x + y*y))
    var z uint = uint(f)
    fmt.Println(x, y, z)
&#125;
</code></pre>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>
<p>当右值声明了类型时，新变量的类型与其相同：</p>
<pre><code class="go">var i int
j := i // j 也是一个 int
</code></pre>
<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p>
<pre><code class="go">i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
</code></pre>
<p>对于能够确定初始值的变量，推荐使用这种方式进行初始化。</p>
<h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。</p>
<p>当前时间可以使用 <code>time.Now()</code> 获取，或者使用 <code>t.Day()</code>、<code>t.Minute()</code> 等等来获取时间的一部分；甚至可以自定义时间格式化字符串，例如： <code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>21.07.2011</code>。</p>
<p>Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。</p>
<p>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。</p>
<p>一般的格式化设计是通过对于一个标准时间的格式化描述来展现的：</p>
<pre><code class="go">fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) 
</code></pre>
<p>输出：</p>
<pre><code class="php">21 Jul 2011 10:31
</code></pre>
<p>示例：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var week time.Duration
func main() &#123;
    t := time.Now()
    fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011
    fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())
    // 21.12.2011
    t = time.Now().UTC()
    fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011
    fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011
    // calculating times:
    week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec
    week_from_now := t.Add(week)
    fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011
    // formatting times:
    fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC
    fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011
    fmt.Println(t.Format(&quot;21 Dec 2011 08:52&quot;)) // 21 Dec 2011 08:52
    s := t.Format(&quot;20111221&quot;)
    fmt.Println(t, &quot;=&gt;&quot;, s)
    // Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221
&#125;
</code></pre>
<p>输出的结果已经写在每行 <code>//</code> 的后面。</p>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。另外，<code>time.Sleep（Duration d）</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量只可以是字符、字符串、布尔值或数值。</p>
<p>常量不能用 <code>:=</code> 语法声明。</p>
<p>由于常量已经初始化，所以可以不指定类型。</p>
<p>常量的值必须是能够在编译时就能够确定的。</p>
<p><strong>常量默认是无类型的</strong>，如果要创建一个有类型的常量，可以使用下面的语法：</p>
<pre><code class="go">const typedhello string = &quot;Hello World&quot;
</code></pre>
<pre><code class="go">package main

import &quot;fmt&quot;

const Pi = 3.14

func main() &#123;
    const World = &quot;世界&quot;
    fmt.Println(&quot;Hello&quot;, World)
    fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)

    const Truth = true
    fmt.Println(&quot;Go rules?&quot;, Truth)
&#125;
</code></pre>
<h3 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h3><p>数值常量是高精度的<strong>值</strong>。</p>
<p>一个未指定类型的常量由上下文来决定其类型。</p>
<p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>
<p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p>
<pre><code class="go">package main

import &quot;fmt&quot;

const (
    // 将 1 左移 100 位来创建一个非常大的数字
    // 即这个数的二进制是 1 后面跟着 100 个 0
    Big = 1 &lt;&lt; 100
    // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2
    Small = Big &gt;&gt; 99
)

func needInt(x int) int &#123; return x*10 + 1 &#125;
func needFloat(x float64) float64 &#123;
    return x * 0.1
&#125;

func main() &#123;
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
  //超过范围报错
    fmt.Println(needInt(Big))
&#125;
</code></pre>
<p>数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：</p>
<pre><code class="go">const Ln2= 0.693147180559945309417232121458\
            176568075500134360255254120680009
const Log2E= 1/Ln2 // this is a precise reciprocal
const Billion = 1e9 // float constant
const hardEight = (1 &lt;&lt; 100) &gt;&gt; 97
</code></pre>
<p>根据上面的例子可以看到，反斜杠 <code>\</code> 可以在常量表达式中作为多行的连接符使用。</p>
<p>与各种类型的数字型变量相比，无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。</p>
<p>不过需要注意的是，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。</p>
<p>常量还可以用作枚举：</p>
<pre><code class="go">const (
    Unknown = 0
    Female = 1
    Male = 2
)
</code></pre>
<p>现在，数字 0、1 和 2 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值,比如使用 switch&#x2F;case 结构 </p>
<p>在这个例子中，iota 可以被用作枚举值：</p>
<pre><code class="go">const (
    a = iota
    b = iota
    c = iota
)
</code></pre>
<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：</p>
<pre><code class="go">const (
    a = iota
    b
    c
)
</code></pre>
<p>iota 也可以用在表达式中，如：<code>iota + 50</code>。在每遇到一个新的常量块或单个常量声明时， iota 都会重置为 0（ 简单地讲，每遇到一次 const 关键字，iota 就重置为 0 ）。</p>
<p>当然，常量之所以为常量就是恒定不变的量，因此无法在程序运行过程中修改它的值；如果在代码中试图修改常量的值则会引发编译错误。</p>
<p>引用 time 包中的一段代码作为示例：一周中每天的名称。</p>
<pre><code class="go">const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
</code></pre>
<p>也可以使用某个类型作为枚举常量的类型：</p>
<pre><code class="go">type Color int

const (
    RED Color = iota // 0
    ORANGE // 1
    YELLOW // 2
    GREEN // ..
    BLUE
    INDIGO
    VIOLET // 6
)
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h3><p>方法名&#x2F;变量名在前，属性&#x2F;返回类型在后。</p>
<blockquote>
<p>官网解释是可读性更强，现在还没习惯感觉怪怪的</p>
</blockquote>
<pre><code class="go">package main

import &quot;fmt&quot;

func add(x int, y int) int &#123;
    return x + y
&#125;

//上述方式可以写成：表示 x,y 都是 int
func add(x,y int) int &#123;
  //...
&#125;

func main() &#123;
    fmt.Println(add(42, 13))
&#125;
</code></pre>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数可以返回任意数量的返回值。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func swap(x, y string) (string, string) &#123;
    return y, x
&#125;
</code></pre>
<p>返回值命名：go 的返回值可以被命名，会将是视为预先在函数里定义的变量，当直接写 <code>return</code> 时表示返回命名的返回值变量：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func split(sum int) (x, y int) &#123;
  //相当于定义了：
  // var x int;
  // var y int;
    x = sum * 4 / 9
    y = sum - x
  //相当于 return x,y
    return
&#125;
</code></pre>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>函数也是值。它们可以像其它值一样传递。</p>
<p>函数值可以用作函数的参数或返回值，然后在其它函数内调用执行，一般称之为回调。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func compute(fn func(float64, float64) float64) float64 &#123;
  //回调 fn
    return fn(3, 4)
&#125;

func main() &#123;
    hypot := func(x, y float64) float64 &#123;
        return math.Sqrt(x*x + y*y)
    &#125;
    fmt.Println(hypot(5, 12))

    fmt.Println(compute(hypot))
    fmt.Println(compute(math.Pow))
&#125;
</code></pre>
<p>Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 <code>Function(arg1)</code>。</p>
<p>如果希望函数可以直接修改参数的值，而不是对参数的副本进行操作，需要将参数的地址（变量名前面添加 &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 <code>Function(&amp;arg1)</code>，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。（<strong>译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。</strong>）</p>
<p>几乎在任何情况下，传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少。</p>
<p>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。</p>
<p>有些函数只是完成一个任务，并没有返回值。我们仅仅是利用了这种函数的副作用，就像输出文本到终端，发送一个邮件或者是记录一个错误等。</p>
<p>但是绝大部分的函数还是带有返回值的。</p>
<h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。</p>
<p>每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。</p>
<p>一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。</p>
<p>init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 <code>backend()</code>：</p>
<pre><code class="go">func init() &#123;
   // setup preparations
   go backend()
&#125;
</code></pre>
<p>包的初始化顺序如下：</p>
<ol>
<li>首先初始化包级别（Package Level）的变量</li>
<li>紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。</li>
</ol>
<p>如果一个包导入了另一个包，会先初始化被导入的包。</p>
<p>尽管一个包可能会被导入多次，但是它只会被初始化一次。</p>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>函数的最后一个参数是采用 <code>...type</code> 的形式，表示这是一个可变长参数，必须放在最后一个参数</p>
<pre><code class="go">func myFunc(a, b, arg ...int) &#123;&#125;
</code></pre>
<p><strong>可变参数函数的工作原理是把可变参数转换为一个新的切片。以下面程序为例，<code>find</code> 函数中的可变参数是 89，90，95 。 find 函数接受一个 <code>int</code> 类型的可变参数。因此这三个参数被编译器转换为一个 int 类型切片 <code>int []int&#123;89, 90, 95&#125;</code> 然后被传入 <code>find</code>函数。</strong></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func find(num int, nums ...int) &#123;
    fmt.Printf(&quot;type of nums is %T\n&quot;, nums)
    found := false
    for i, v := range nums &#123;
        if v == num &#123;
            fmt.Println(num, &quot;found at index&quot;, i, &quot;in&quot;, nums)
            found = true
        &#125;
    &#125;
    if !found &#123;
        fmt.Println(num, &quot;not found in &quot;, nums)
    &#125;
    fmt.Printf(&quot;\n&quot;)
&#125;
func main() &#123;
    find(89, 89, 90, 95)
    find(45, 56, 67, 45, 90, 109)
    find(78, 38, 56, 98)
    find(87)
&#125;
</code></pre>
<p>因为参数会转化成一个切片，所以对于变长参数，不能直接传递切片，要么一个一个传，要么就需要使用语法糖<code>...</code>：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    x := min(1, 3, 2, 0)
    fmt.Printf(&quot;The minimum is: %d\n&quot;, x)
    slice := []int&#123;7,9,3,5,1&#125;
    x = min(slice...)
    fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)
&#125;

func min(s ...int) int &#123;
    if len(s)==0 &#123;
        return 0
    &#125;
    min := s[0]
    for _, v := range s &#123;
        if v &lt; min &#123;
            min = v
        &#125;
    &#125;
    return min
&#125;
</code></pre>
<h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>
<p>闭包也叫做匿名函数，当我们不希望给函数起名字的时候，可以使用匿名函数，例如：<code>func(x, y int) int &#123; return x + y &#125;</code>。</p>
<p>这样的一个函数不能够独立存在（编译器会返回错误：<code>non-declaration statement outside function body</code>），但可以被赋值于某个变量，即保存函数的地址到变量中：<code>fplus := func(x, y int) int &#123; return x + y &#125;</code>，然后通过变量名对函数进行调用：<code>fplus(3,4)</code>。</p>
<p>当然，也可以直接对匿名函数进行调用：<code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code>。</p>
<h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><h5 id="将函数作为返回值"><a href="#将函数作为返回值" class="headerlink" title="将函数作为返回值"></a>将函数作为返回值</h5><p>例如，函数 <code>Adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 x 变量上。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var f = Adder()
    fmt.Print(f(1), &quot; - &quot;)
    fmt.Print(f(20), &quot; - &quot;)
    fmt.Print(f(300))
&#125;

func Adder() func(int) int &#123;
    var x int	// 此处 x 的值只声明了一次，值会被保留
    return func(delta int) int &#123;
        x += delta
        return x
    &#125;
&#125;
</code></pre>
<pre><code class="go">1 - 21 - 321
</code></pre>
<p>三次调用函数 f 的过程中函数 Adder () 中变量 delta 的值分别为：1、20 和 300。</p>
<p>我们可以看到，在多次调用中，变量 x 的值是被保留的，即 <code>0 + 1 = 1</code>，然后 <code>1 + 20 = 21</code>，最后 <code>21 + 300 = 321</code>：闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</p>
<p>这些局部变量同样可以是参数，例如之前例子中的 <code>Adder(as int)</code>。</p>
<p>可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，<strong>闭包捕获的变量和常量是引用传递，不是值传递</strong>。</p>
<p>对于下面的例子：</p>
<pre><code class="go">import &quot;fmt&quot;

func main() &#123;

    var a = Accumulator()
    fmt.Printf(&quot;%d\n&quot;, a(1))
    fmt.Printf(&quot;%d\n&quot;, a(10))
    fmt.Printf(&quot;%d\n&quot;, a(100))

    fmt.Println(&quot;------------------------&quot;)

    var b = Accumulator()
    fmt.Printf(&quot;%d\n&quot;, b(1))
    fmt.Printf(&quot;%d\n&quot;, b(10))
    fmt.Printf(&quot;%d\n&quot;, b(100))

&#125;

func Accumulator() func(int) int &#123;
    var x int
    return func(delta int) int &#123;
        fmt.Printf(&quot;(%+v, %+v) - &quot;, &amp;x, x)
        x += delta
        return x
    &#125;
&#125;
</code></pre>
<p>执行结果如下：</p>
<pre><code>(0xc00018c000, 0) - 1
(0xc00018c000, 1) - 11
(0xc00018c000, 11) - 111
------------------------
(0xc00018c020, 0) - 1
(0xc00018c020, 1) - 11
(0xc00018c020, 11) - 111
</code></pre>
<p>闭包引用了 x 变量，a,b 可看作 2 个不同的实例，实例之间互不影响。实例内部，x 变量是同一个地址，因此具有“累加效应”。</p>
<h5 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h5><p>一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。下面的函数演示了如何动态返回追加后缀的函数：</p>
<pre><code class="go">func MakeAddSuffix(suffix string) func(string) string &#123;
    return func(name string) string &#123;
        if !strings.HasSuffix(name, suffix) &#123;
            return name + suffix
        &#125;
        return name
    &#125;
&#125;
</code></pre>
<p>现在，可以生成如下函数：</p>
<pre><code class="go">addBmp := MakeAddSuffix(&quot;.bmp&quot;)
addJpeg := MakeAddSuffix(&quot;.jpeg&quot;)
</code></pre>
<p>然后调用它们：</p>
<pre><code class="go">addBmp(&quot;file&quot;) // returns: file.bmp
addJpeg(&quot;file&quot;) // returns: file.jpeg
</code></pre>
<h5 id="使用闭包调试（暂时没搞懂）"><a href="#使用闭包调试（暂时没搞懂）" class="headerlink" title="使用闭包调试（暂时没搞懂）"></a>使用闭包调试（暂时没搞懂）</h5><p>当在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p>
<pre><code class="go">where := func() &#123;
    _, file, line, _ := runtime.Caller(1)
    log.Printf(&quot;%s:%d&quot;, file, line)
&#125;
where()
// some code
where()
// some more code
where()
</code></pre>
<p>也可以设置 <code>log</code> 包中的 flag 参数来实现：</p>
<pre><code class="go">log.SetFlags(log.Llongfile)
log.Print(&quot;&quot;)
</code></pre>
<p>或使用一个更加简短版本的 <code>where</code> 函数：</p>
<pre><code class="go">var where = log.Print
func func1() &#123;
where()
... some code
where()
... some code
where()
&#125;
</code></pre>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>只记录不常见的以备查询：</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>按位补足 <code>^</code>：该运算符与异或运算符一同使用，即 <code>m^x</code>，对于无符号 x 使用 “全部位设置为 1”，对于有符号 x 时使用 <code>m=-1</code>。例如：</p>
<pre><code>^2 = ^10 = -01 ^ 10 = -11（二进制）
</code></pre>
<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul>
<li>位清除 <code>&amp;^</code>：将指定位置上的值设置为 0。</li>
</ul>
<blockquote>
<p>带有 <code>++</code> 和 <code>--</code> 的只能作为语句，而非表达式，<strong>因此 <code>n = i++</code> 这种写法是无效的，其它像 <code>f(i++)</code> 或者 <code>a[i]=b[i++]</code> 这些可以用于 C、C++ 和 Java 中的写法在 Go 中也是不允许的。</strong></p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p>
<p><strong>一个指针变量可以指向任何一个值的内存地址</strong>。它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；可以在指针类型前面加上 <code>*</code> 号（前缀）来获取指针所指向的内容，这里的 <code>*</code> 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p>
<p>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。</p>
<p>一个指针变量通常缩写为 <code>ptr</code>。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<pre><code>var p *int
</code></pre>
<p><strong><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</strong></p>
<pre><code>i := 42
p = &amp;i
</code></pre>
<p><code>*</code> 操作符表示指针指向的底层值。</p>
<pre><code>fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i
</code></pre>
<p>这也就是通常所说的“间接引用”或“重定向”。</p>
<p>go 中指针不能得到一个文字或常量的地址，例如：</p>
<pre><code class="go">const i = 5
ptr := &amp;i //error: cannot take the address of i
ptr2 := &amp;10 //error: cannot take the address of 10
</code></pre>
<p>与 C 不同，Go 没有指针运算。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<pre><code class="go">var a [10]int
</code></pre>
<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>当数组内容确定时，可以不指定容量，直接赋值：</p>
<pre><code class="go">[]bool&#123;true, true, false&#125;
</code></pre>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var a [2]string
    a[0] = &quot;Hello&quot;
    a[1] = &quot;World&quot;
    fmt.Println(a[0], a[1])
  //直接打印数组会有 [] 符号
  fmt.Println(a)

    primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;
    fmt.Println(primes)
&#125;
</code></pre>
<p>Go 语言中的数组是一种<strong>值类型</strong>（不像 C&#x2F;C++ 中是指向首元素的指针），所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。</p>
<p>那么这种方式和 <code>var arr2 [5]int</code> 的区别是什么呢？</p>
<p>arr1 的类型是 <code>*[5]int</code>，而 arr2 的类型是 <code>[5]int</code>。</p>
<p>此时如果把 arr1 赋值给 arr2 ，需要在做一次数组内存的拷贝操作。例如：</p>
<pre><code class="go">arr2 := *arr1	// 对数组进行一次拷贝
arr2[2] = 100
</code></pre>
<p>这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p>
<p>所以在函数中数组作为参数传入时，如 <code>func1(arr2)</code>，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（slice）是对数组一个连续片段的引用（该数组称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C&#x2F;C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。</p>
<p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<blockquote>
<p><strong>注意</strong>：切片与数组在语法上的区别在于前面的 [] 有没有指定初始大小</p>
</blockquote>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<pre><code>a[low : high]
</code></pre>
<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p>
<pre><code>a[1:4]
</code></pre>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;

    var s []int = primes[1:4]
    fmt.Println(s)
&#125;
</code></pre>
<p>切片就像数组的引用切片，并不存储任何数据，它只是描述了底层数组中的一段。<strong>更改切片的元素会修改其底层数组中对应的元素</strong>。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    names := [4]string&#123;
        &quot;John&quot;,
        &quot;Paul&quot;,
        &quot;George&quot;,
        &quot;Ringo&quot;,
    &#125;
  //[John Paul George Ringo]
    fmt.Println(names)

  //[John Paul]
    a := names[0:2]
  //[Paul George]
    b := names[1:3]
    fmt.Println(a, b)

    b[0] = &quot;XXX&quot;
  // a:[John XXX],b:[XXX George]
    fmt.Println(a, b)
  //[John XXX George Ringo]
    fmt.Println(names)
&#125;
</code></pre>
<p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>
<p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p>
<pre><code class="go">var a [10]int
//等价
a[0:10]
a[:10]
a[0:]
a[:]
</code></pre>
<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<p>切片的长度就是它所包含的元素个数。</p>
<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p><strong>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</strong></p>
<p>可以通过重新切片来扩展一个切片，给它提供足够的容量。</p>
<p>切片在内存中的组织结构：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="切片在内存中的组织结构"></p>
<h3 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h3><p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且没有底层数组。</p>
<pre><code class="go">var s []int
len(s) // 0
cap(s) // 0
fmt.Println(s) // []
s == nil // true
</code></pre>
<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h3><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<pre><code>a := make([]int, 5)  // len(a)=5
</code></pre>
<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<pre><code class="go">b := make([]int, 0, 5) // len(b)=0, cap(b)=5,[]
c := make([]int,3,10) // [0,0,0]

b = b[:cap(b)] // len(b)=5, cap(b)=5,[0,0,0,0,0]
b = b[1:]      // len(b)=4, cap(b)=4
</code></pre>
<p>切片可包含任何类型，甚至包括其它的切片:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    // 创建一个井字板（经典游戏）
    board := [][]string&#123;
        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
    &#125;

    // 两个玩家轮流打上 X 和 O
    board[0][0] = &quot;X&quot;
    board[2][2] = &quot;O&quot;
    board[1][2] = &quot;X&quot;
    board[1][0] = &quot;O&quot;
    board[0][2] = &quot;X&quot;

    for i := 0; i &lt; len(board); i++ &#123;
        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))
    &#125;
&#125;
</code></pre>
<h3 id="make（）和-new（）的区别"><a href="#make（）和-new（）的区别" class="headerlink" title="make（）和 new（）的区别"></a>make（）和 new（）的区别</h3><p>二者都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p>
<ul>
<li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法<strong>返回一个指向类型为 T，值为 0 的地址的指针</strong>，它适用于值类型如数组和结构体；它相当于 <code>&amp;T&#123;&#125;</code>。</li>
<li>make(T) <strong>返回一个类型为 T 的初始值</strong>，它只适用于 3 种内建的引用类型：切片、map 和 channel。</li>
</ul>
<p>换言之，new 函数分配内存，make 函数初始化；下图给出了区别：</p>
<p><img src="https://qiniu.xiaoming.net.cn/make%E5%92%8Cnew%E5%8C%BA%E5%88%AB.png" alt="make 和 new 区别"></p>
<h3 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h3><p><code>func copy(dst, src []T) int</code> copy 方法将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 <code>src = dst</code>。</p>
<h3 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h3><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。</p>
<pre><code>func append(s []T, vs ...T) []T
</code></pre>
<p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p>
<p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var s []int //[]

    // 添加一个空切片
    s = append(s, 0) //[0]

    // 这个切片会按需增长
    s = append(s, 1) //[0 1]

    // 可以一次性添加多个元素
    s = append(s, 2, 3, 4) //[0 1 2 3 4]
&#125;
</code></pre>
<h4 id="append-函数常见操作"><a href="#append-函数常见操作" class="headerlink" title="append 函数常见操作"></a>append 函数常见操作</h4><ol>
<li><p>将切片 b 的元素追加到切片 a 之后：<code>a = append(a, b...)</code></p>
</li>
<li><p>复制切片 a 的元素到新的切片 b 上：</p>
<pre><code class="go"> b = make([]T, len(a))
 copy(b, a)
</code></pre>
</li>
<li><p>删除位于索引 i 的元素：<code>a = append(a[:i], a[i+1:]...)</code></p>
</li>
<li><p>切除切片 a 中从索引 i 至 j 位置的元素：<code>a = append(a[:i], a[j:]...)</code></p>
</li>
<li><p>为切片 a 扩展 j 个元素长度：<code>a = append(a, make([]T, j)...)</code></p>
</li>
<li><p>在索引 i 的位置插入元素 x：<code>a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</code></p>
</li>
<li><p>在索引 i 的位置插入长度为 j 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></p>
</li>
<li><p>在索引 i 的位置插入切片 b 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></p>
</li>
<li><p>取出位于切片 a 最末尾的元素 x：<code>x, a = a[len(a)-1:], a[:len(a)-1]</code></p>
</li>
<li><p>将元素 x 追加到切片 a：<code>a = append(a, x)</code></p>
</li>
</ol>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存。在内存管理方面，这是需要注意的。假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。这里需要重点注意的是，在切片引用时数组仍然存在内存中。</p>
<p>一种解决方法是使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/builtin/#copy">copy</a> 函数 <code>func copy(dst，src[]T)int</code> 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func countries() []string &#123;
    countries := []string&#123;&quot;USA&quot;, &quot;Singapore&quot;, &quot;Germany&quot;, &quot;India&quot;, &quot;Australia&quot;&#125;
    neededCountries := countries[:len(countries)-2]
    countriesCpy := make([]string, len(neededCountries))
    copy(countriesCpy, neededCountries) //copies neededCountries to countriesCpy
    return countriesCpy
&#125;
func main() &#123;
    countriesNeeded := countries()
    fmt.Println(countriesNeeded)
&#125;
</code></pre>
<p>在上述程序的第 9 行，<code>neededCountries := countries[:len(countries)-2</code> 创建一个去掉尾部 2 个元素的切片 <code>countries</code>，在上述程序的 11 行，将 <code>neededCountries</code> 复制到 <code>countriesCpy</code> 同时在函数的下一行返回 countriesCpy。现在 <code>countries</code> 数组可以被垃圾回收, 因为 <code>neededCountries</code> 不再被引用。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;

func main() &#123;
    for i, v := range pow &#123;
        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)
    &#125;
&#125;
</code></pre>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<pre><code>for i, _ := range pow
for _, value := range pow
</code></pre>
<p>若你只需要索引，忽略第二个变量即可。</p>
<pre><code>for i := range pow
</code></pre>
<h3 id="bytes包"><a href="#bytes包" class="headerlink" title="bytes包"></a>bytes包</h3><p>类型 <code>[]byte</code> 的切片十分常见，Go 语言有一个 bytes 包专门用来解决这种类型的操作方法。</p>
<p>bytes 包和字符串包十分类似（参见第 4.7 节）。而且它还包含一个十分有用的类型 Buffer:</p>
<pre><code class="go">import &quot;bytes&quot;

type Buffer struct &#123;
    ...
&#125;
</code></pre>
<p>这是一个长度可变的 bytes 的 buffer，提供 Read 和 Write 方法，因为读写长度未知的 bytes 最好使用 buffer。</p>
<p>Buffer 可以这样定义：<code>var buffer bytes.Buffer</code>。</p>
<p>或者使用 new 获得一个指针：<code>var r *bytes.Buffer = new(bytes.Buffer)</code>。</p>
<p>或者通过函数：<code>func NewBuffer(buf []byte) *Buffer</code>，创建一个 Buffer 对象并且用 buf 初始化好；NewBuffer 最好用在从 buf 读取的时候使用。</p>
<p><strong>通过 buffer 串联字符串</strong></p>
<p>类似于 Java 的 StringBuilder 类。</p>
<p>在下面的代码段中，创建一个 buffer，通过 <code>buffer.WriteString(s)</code> 方法将字符串 s 追加到后面，最后再通过 <code>buffer.String()</code> 方法转换为 <code>string</code>：</p>
<pre><code class="go">var buffer bytes.Buffer
for &#123;
    if s, ok := getNextString(); ok &#123; //method getNextString() not shown here
        buffer.WriteString(s)
    &#125; else &#123;
        break
    &#125;
&#125;
fmt.Print(buffer.String(), &quot;\n&quot;)
</code></pre>
<p>这种实现方式比使用 <code>+=</code> 要更节省内存和 CPU，尤其是要串联的字符串数目特别多的时候。</p>
<h3 id="搜索及排序切片的数组"><a href="#搜索及排序切片的数组" class="headerlink" title="搜索及排序切片的数组"></a>搜索及排序切片的数组</h3><p>标准库提供了 <code>sort</code> 包来实现常见的搜索和排序操作。可以使用 <code>sort</code> 包中的函数 <code>func Ints(a []int)</code> 来实现对 int 类型的切片排序。例如 <code>sort.Ints(arri)</code>，其中变量 arri 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可以通过函数 <code>IntsAreSorted(a []int) bool</code> 来检查，如果返回 true 则表示已经被排序。</p>
<p>类似的，可以使用函数 <code>func Float64s(a []float64)</code> 来排序 float64 的元素，或使用函数 <code>func Strings(a []string)</code> 排序字符串元素。</p>
<p>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，就可以使用函数 <code>func SearchInts(a []int, n int) int</code> 进行搜索，并返回对应结果的索引值。</p>
<p>当然，还可以搜索 float64 和字符串：</p>
<pre><code class="go">func SearchFloat64s(a []float64, x float64) int
func SearchStrings(a []string, x string) int
</code></pre>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一种值类型，且值不可变，即创建某个文本后无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p>
<p>Go 语言中的字符串是一个字节切片。把内容放在双引号””之间，可以创建一个字符串。由于字符串是一个字节切片，所以可以获取字符串的每一个字节。</p>
<p>字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节。</p>
<p>因此，字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 <code>[]</code> 内写入索引，索引从 0 开始计数：</p>
<ul>
<li>字符串 str 的第 1 个字节：<code>str[0]</code></li>
<li>第 i 个字节：<code>str[i - 1]</code></li>
<li>最后 1 个字节：<code>str[len(str)-1]</code></li>
</ul>
<p>但需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效，对于其他编码，由于使用 UTF-8 编码，一些字符可能占用不止一个字节，这会导致获取单个字节打印出来的字符与实际不符，例子如下：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func printBytes(s string) &#123;
    for i:= 0; i &lt; len(s); i++ &#123;
        fmt.Printf(&quot;%x &quot;, s[i])
    &#125;
&#125;

func printChars(s string) &#123;
    for i:= 0; i &lt; len(s); i++ &#123;
        fmt.Printf(&quot;%c &quot;,s[i])
    &#125;
&#125;

func main() &#123;
    name := &quot;Hello World&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
    fmt.Printf(&quot;\n&quot;)
    name = &quot;Señor&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
&#125;
</code></pre>
<p>上面打印的结果是：</p>
<pre><code>48 65 6c 6c 6f 20 57 6f 72 6c 64  
H e l l o   W o r l d  
53 65 c3 b1 6f 72  
S e Ã ± o r
</code></pre>
<p>所以当需要使用遍历字符串的字符时，可以使用 <code>rune</code> ，<code>trune</code> 是Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。用 <code>rune</code> 来打印字符如下：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func printBytes(s string) &#123;
    for i:= 0; i &lt; len(s); i++ &#123;
        fmt.Printf(&quot;%x &quot;, s[i])
    &#125;
&#125;

func printChars(s string) &#123;
    runes := []rune(s)
    for i:= 0; i &lt; len(runes); i++ &#123;
        fmt.Printf(&quot;%c &quot;,runes[i])
    &#125;
&#125;

func main() &#123;
    name := &quot;Hello World&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
    fmt.Printf(&quot;\n\n&quot;)
    name = &quot;Señor&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
&#125;
</code></pre>
<p>另一种比较方便的方式是直接使用 <code>range</code> 遍历字符串。</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><strong>字符串拼接符 <code>+</code></strong></p>
<p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。</p>
<p><code>s2</code> 追加在 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p>
<p>你可以通过以下方式来对代码中多行的字符串进行拼接：</p>
<pre><code class="go">str := &quot;Beginning of the string &quot; +
    &quot;second part of the string&quot;
</code></pre>
<p>由于编译器行尾自动补全分号的缘故，加号 <code>+</code> 必须放在第一行。</p>
<p>拼接的简写形式 <code>+=</code> 也可以用于字符串：</p>
<pre><code class="go">s := &quot;hel&quot; + &quot;lo,&quot;
s += &quot;world!&quot;
fmt.Println(s) //输出 “hello, world!”
</code></pre>
<p>在循环中使用加号 <code>+</code> 拼接字符串并不是最高效的做法，<strong>更好的办法是使用函数 <code>strings.Join()</code><strong>，最优的方式是</strong>使用字节缓冲（<code>bytes.Buffer</code>）拼接</strong></p>
<h3 id="String-操作相关-API"><a href="#String-操作相关-API" class="headerlink" title="String 操作相关 API"></a>String 操作相关 API</h3><h4 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a>strings 包</h4><p>strings 包定义了一些对字符串的操作。</p>
<h5 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h5><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：</p>
<pre><code class="go">strings.HasPrefix(s, prefix string) bool
</code></pre>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：</p>
<pre><code class="go">strings.HasSuffix(s, suffix string) bool
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    var str string = &quot;This is an example of a string&quot;
    fmt.Printf(&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;, str, &quot;Th&quot;)
    fmt.Printf(&quot;%t\n&quot;, strings.HasPrefix(str, &quot;Th&quot;))
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true
</code></pre>
<p>这个例子同样演示了转义字符 <code>\</code> 和格式化字符串的使用。</p>
<h5 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h5><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code>：</p>
<pre><code class="php">strings.Contains(s, substr string) bool
</code></pre>
<h5 id="判断子字符串或字符在父字符串中出现的位置（索引）"><a href="#判断子字符串或字符在父字符串中出现的位置（索引）" class="headerlink" title="判断子字符串或字符在父字符串中出现的位置（索引）"></a>判断子字符串或字符在父字符串中出现的位置（索引）</h5><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>
<pre><code class="go">strings.Index(s, str string) int
</code></pre>
<p><code>LastIndex</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>
<pre><code class="go">strings.LastIndex(s, str string) int
</code></pre>
<p>如果 <code>ch</code> 是非 ASCII 编码的字符，建议使用以下函数来对字符进行定位：</p>
<pre><code class="go">strings.IndexRune(s string, r rune) int
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    var str string = &quot;Hi, I&#39;m Marc, Hi.&quot;

    fmt.Printf(&quot;The position of \&quot;Marc\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Marc&quot;))

    fmt.Printf(&quot;The position of the first instance of \&quot;Hi\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Hi&quot;))
    fmt.Printf(&quot;The position of the last instance of \&quot;Hi\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.LastIndex(str, &quot;Hi&quot;))

    fmt.Printf(&quot;The position of \&quot;Burger\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Burger&quot;))
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">The position of &quot;Marc&quot; is: 8
The position of the first instance of &quot;Hi&quot; is: 0
The position of the last instance of &quot;Hi&quot; is: 14
The position of &quot;Burger&quot; is: -1
</code></pre>
<h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所有字符串 <code>old</code> 为字符串 <code>new</code>：</p>
<pre><code class="go">strings.Replace(str, old, new, n) string
</code></pre>
<h5 id="统计字符串出现次数"><a href="#统计字符串出现次数" class="headerlink" title="统计字符串出现次数"></a>统计字符串出现次数</h5><p><code>Count</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数：</p>
<pre><code class="go">strings.Count(s, str string) int
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    var str string = &quot;Hello, how is it going, Hugo?&quot;
    var manyG = &quot;gggggggggg&quot;

    fmt.Printf(&quot;Number of H&#39;s in %s is: &quot;, str)
    fmt.Printf(&quot;%d\n&quot;, strings.Count(str, &quot;H&quot;))

    fmt.Printf(&quot;Number of double g&#39;s in %s is: &quot;, manyG)
    fmt.Printf(&quot;%d\n&quot;, strings.Count(manyG, &quot;gg&quot;))
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Number of H&#39;s in Hello, how is it going, Hugo? is: 2
Number of double g’s in gggggggggg is: 5
</code></pre>
<h5 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h5><p><code>Repeat</code> 用于重复拼接 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<pre><code class="go">strings.Repeat(s, count int) string
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    var origS string = &quot;Hi there! &quot;
    var newS string

    newS = strings.Repeat(origS, 3)
    fmt.Printf(&quot;The new repeated string is: %s\n&quot;, newS)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">The new repeated string is: Hi there! Hi there! Hi there!
</code></pre>
<h5 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h5><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<pre><code class="go">strings.ToLower(s) string
</code></pre>
<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<pre><code class="go">strings.ToUpper(s) string
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    var orig string = &quot;Hey, how are you George?&quot;
    var lower string
    var upper string

    fmt.Printf(&quot;The original string is: %s\n&quot;, orig)
    lower = strings.ToLower(orig)
    fmt.Printf(&quot;The lowercase string is: %s\n&quot;, lower)
    upper = strings.ToUpper(orig)
    fmt.Printf(&quot;The uppercase string is: %s\n&quot;, upper)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">The original string is: Hey, how are you George?
The lowercase string is: hey, how are you george?
The uppercase string is: HEY, HOW ARE YOU GEORGE?
</code></pre>
<h5 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h5><p>可以使用 <code>strings.TrimSpace(s)</code> 来剔除字符串开头和结尾的空白符号；如果想要剔除指定字符，则可以使用 <code>strings.Trim(s, &quot;cut&quot;)</code> 来将开头和结尾的 <code>cut</code> 去除掉。该函数的第二个参数可以包含任何字符，如果只想剔除开头或者结尾的字符串，则可以使用 <code>TrimLeft</code> 或者 <code>TrimRight</code> 来实现。</p>
<h5 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h5><p><code>strings.Fields(s)</code> 利用空白作为分隔符将字符串分割为若干块，并返回一个 slice 。如果字符串只包含空白符号，返回一个长度为 0 的 slice 。</p>
<p><code>strings.Split(s, sep)</code> 自定义分割符号对字符串分割，返回 slice 。</p>
<p>因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理。</p>
<h5 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h5><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：</p>
<pre><code class="go">strings.Join(sl []string, sep string) string
</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() &#123;
    str := &quot;The quick brown fox jumps over the lazy dog&quot;
    sl := strings.Fields(str)
    fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl)
    for _, val := range sl &#123;
        fmt.Printf(&quot;%s - &quot;, val)
    &#125;
    fmt.Println()
    str2 := &quot;GO1|The ABC of Go|25&quot;
    sl2 := strings.Split(str2, &quot;|&quot;)
    fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl2)
    for _, val := range sl2 &#123;
        fmt.Printf(&quot;%s - &quot;, val)
    &#125;
    fmt.Println()
    str3 := strings.Join(sl2,&quot;;&quot;)
    fmt.Printf(&quot;sl2 joined by ;: %s\n&quot;, str3)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">Splitted in slice: [The quick brown fox jumps over the lazy dog]
The - quick - brown - fox - jumps - over - the - lazy - dog -
Splitted in slice: [GO1 The ABC of Go 25]
GO1 - The ABC of Go - 25 -
sl2 joined by ;: GO1;The ABC of Go;25
</code></pre>
<h5 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h5><p>函数 <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取内容的函数还有：</p>
<ul>
<li><code>Read()</code> 从 [] byte 中读取内容。</li>
<li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。</li>
</ul>
<h4 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a>strconv 包</h4><p>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的。</p>
<p>该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。</p>
<p>任何类型 <strong>T</strong> 转换为字符串总是成功的。</p>
<p>针对从数字类型转换到字符串，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。</li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。</li>
</ul>
<p>将字符串转换为其它类型 <strong>tp</strong> 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。</p>
<p>针对从字符串类型转换为数字类型，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。</li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。</li>
</ul>
<p>利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换：</p>
<pre><code class="php">val, err = strconv.Atoi(s)
</code></pre>
<p>在下面这个示例中，忽略可能出现的转换错误：</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() &#123;
    var orig string = &quot;666&quot;
    var an int
    var newS string

    fmt.Printf(&quot;The size of ints is: %d\n&quot;, strconv.IntSize)      

    an, _ = strconv.Atoi(orig)
    fmt.Printf(&quot;The integer is: %d\n&quot;, an) 
    an = an + 5
    newS = strconv.Itoa(an)
    fmt.Printf(&quot;The new string is: %s\n&quot;, newS)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">64 位系统：
The size of ints is: 64
32 位系统：
The size of ints is: 32
The integer is: 666
The new string is: 671
</code></pre>
<h3 id="字符串的内部结构"><a href="#字符串的内部结构" class="headerlink" title="字符串的内部结构"></a>字符串的内部结构</h3><p>内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。因为指针对用户来说是完全不可见，因此我们可以依旧把字符串看做是一个值类型，也就是一个字符数组。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201912/02/1/J9S85ymhtz.png!large" alt="img"></p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键映射到值。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p>在声明的时候不需要知道 map 的长度，map 是可以动态增长的。</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<p>映射的文法与结构体相似，不过必须有键名。</p>
<p>若顶级类型只是一个类型名，可以在文法的元素中省略它。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct &#123;
    Lat, Long float64
&#125;

var m = map[string]Vertex&#123;
    &quot;Bell Labs&quot;: Vertex&#123;
        40.68433, -74.39967,
    &#125;,
    &quot;Google&quot;: Vertex&#123;
        37.42202, -122.08408,
    &#125;,
  
  //也可以这样
  &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,
    &quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,
&#125;

func main() &#123;
    fmt.Println(m)
&#125;
</code></pre>
<p>map 的初始化：<code>var map1 = make(map[keytype]valuetype)</code>。</p>
<p>或者简写为：<code>map1 := make(map[keytype]valuetype)</code>。</p>
<p>例如：<code>mapCreated := make(map[string]float32)</code>，相当于：<code>mapCreated := map[string]float32&#123;&#125;</code>。</p>
<p><strong>不要使用 new，永远用 make 来构造 map</strong></p>
<p><strong>注意</strong> 如果你错误的使用 new () 分配了一个引用对，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p>
<pre><code class="go">mapCreated := new(map[string]float32)
</code></pre>
<p>接下来当调用：<code>mapCreated[&quot;key1&quot;] = 4.5</code> 的时候，编译器会报错：</p>
<pre><code class="php">invalid operation: mapCreated[&quot;key1&quot;] (index of type *map[string]float32).
</code></pre>
<h3 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h3><p>和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。但是也可以选择标明 map 的初始容量 <code>capacity</code>，就像这样：<code>make(map[keytype]valuetype, cap)</code>。例如：</p>
<pre><code class="go">map2 := make(map[string]float32, 100)
</code></pre>
<p>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p>
<h3 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h3><p>在映射 <code>m</code> 中插入或修改元素：</p>
<pre><code>m[key] = elem
</code></pre>
<p>获取元素：</p>
<pre><code>elem = m[key]
</code></pre>
<p>删除元素：</p>
<pre><code>delete(m, key)
</code></pre>
<p>通过双赋值检测某个键是否存在：</p>
<pre><code>elem, ok = m[key]
</code></pre>
<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<pre><code>elem, ok := m[key]
</code></pre>
<h3 id="map-类型的切片"><a href="#map-类型的切片" class="headerlink" title="map 类型的切片"></a>map 类型的切片</h3><p> 如果希望得到 map 类型的切片，我们必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中每个 map 元素</p>
<pre><code class="go">package main
import &quot;fmt&quot;

func main() &#123;
    // Version A:
    items := make([]map[int]int, 5)
    for i:= range items &#123;
        items[i] = make(map[int]int, 1)
        items[i][1] = 2
    &#125;
    fmt.Printf(&quot;Version A: Value of items: %v\n&quot;, items)

    // Version B: NOT GOOD!
    items2 := make([]map[int]int, 5)
    for _, item := range items2 &#123;
        item = make(map[int]int, 1) // item is only a copy of the slice element.
        item[1] = 2 // This &#39;item&#39; will be lost on the next iteration.
    &#125;
    fmt.Printf(&quot;Version B: Value of items: %v\n&quot;, items2)
&#125;
</code></pre>
<pre><code class="go">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]
Version B: Value of items: [map[] map[] map[] map[] map[]]
</code></pre>
<p>应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。</p>
<h3 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h3><p>可以使用 for 循环构造 map：</p>
<pre><code class="go">for key, value := range map1 &#123;
    ...
&#125;
</code></pre>
<p>第一个返回值 key 是 map 中的 key 值，第二个返回值则是该 key 对应的 value 值；这两个都是仅 for 循环内部可见的局部变量。其中第一个返回值 key 值是一个可选元素。如果你关心值，可以这么使用：</p>
<pre><code class="go">for _, value := range map1 &#123;
    ...
&#125;
</code></pre>
<p>如果只想获取 key，可以这么使用：</p>
<pre><code class="go">for key := range map1 &#123;
    fmt.Printf(&quot;key is: %d\n&quot;, key)
&#125;
</code></pre>
<p><strong>注意 map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的。</strong></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一个结构体（<code>struct</code>）就是一组字段（field）。结构体字段使用点号来访问。</p>
<blockquote>
<p><code>type</code>关键字用于定义别名</p>
</blockquote>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct &#123;
    X int
    Y int
&#125;

func main() &#123;
    v := Vertex&#123;1, 2&#125;
    v.X = 4
    fmt.Println(v.X)
&#125;
</code></pre>
<p>声明结构体有两种方式：</p>
<pre><code class="go">type T struct &#123;a, b int&#125;

//第一种方式
var s T
s.a = 5
s.b = 8

//第二种方式
var t *T
t = new(T)
</code></pre>
<p>使用 <code>t := new(T)</code>，变量 <code>t</code> 是一个指向 <code>T</code> 的指针，此时结构体字段的值是它们所属类型的零值。</p>
<p>声明 <code>var t T</code> 也会给 <code>t</code> 分配内存，并零值化内存，但是这个时候 <code>t</code> 是类型 T。</p>
<p>在这两种方式中，<code>t</code> 通常被称做类型 T 的一个实例（instance）或对象（object）。</p>
<p>初始化结构体的方式有以下几种：</p>
<pre><code class="go">type Interval struct &#123;
    start int
    end   int
&#125;

//可以在 Interval 前加 &amp;
intr := Interval&#123;0, 3&#125;            (A)
intr := Interval&#123;end:5, start:1&#125;  (B)
intr := Interval&#123;end:5&#125;           (C)
</code></pre>
<p>混合字面量语法（composite literal syntax）<code>&amp;struct1&#123;a, b, c&#125;</code> 是一种简写，底层仍然会调用 <code>new ()</code>，这里值的顺序必须按照字段顺序来写。表达式 <code>new(Type)</code> 和 <code>&amp;Type&#123;&#125;</code> 是等价的。</p>
<p>使用 new 初始化：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8new%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="使用new初始化"></p>
<p>作为结构体字面量初始化：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="使用结构体字面量初始化"></p>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>结构体字段可以通过结构体指针来访问。</p>
<p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。语言也允许使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct &#123;
    X int
    Y int
&#125;

func main() &#123;
    v := Vertex&#123;1, 2&#125;
    p := &amp;v
  //表示的是(*p).X
    p.X = 1e9
    fmt.Println(v)
&#125;
</code></pre>
<h3 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h3><p>通过直接列出字段的值来新分配一个结构体。</p>
<p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct &#123;
    X, Y int
&#125;

var (
    v1 = Vertex&#123;1, 2&#125;  // 创建一个 Vertex 类型的结构体
    v2 = Vertex&#123;X: 1&#125;  // Y:0 被隐式地赋予
    v3 = Vertex&#123;&#125;      // X:0 Y:0
    p  = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）
)

func main() &#123;
    fmt.Println(v1, p, v2, v3)
&#125;
</code></pre>
<h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>当创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。</p>
<p>以下代码创建一个 <code>Person</code> 结构体，它含有两个匿名字段 <code>string</code> 和 <code>int</code>。</p>
<pre><code class="go">type Person struct &#123;  
    string
    int
&#125;
</code></pre>
<p>接下来使用匿名字段来编写一个程序。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type Person struct &#123;  
    string
    int
&#125;

func main() &#123;  
    p := Person&#123;&quot;Naveen&quot;, 50&#125;
    fmt.Println(p)
&#125;
</code></pre>
<p>在上面的程序中，结构体 <code>Person</code> 有两个匿名字段。<code>p := Person&#123;&quot;Naveen&quot;, 50&#125;</code> 定义了一个 <code>Person</code> 类型的变量。该程序输出 <code>&#123;Naveen 50&#125;</code>。</p>
<p><strong>虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型</strong>。比如在上面的 <code>Person</code> 结构体里，虽说字段是匿名的，但 Go 默认这些字段名是它们各自的类型。所以 <code>Person</code> 结构体有两个名为 <code>string</code> 和 <code>int</code> 的字段。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type Person struct &#123;  
    string
    int
&#125;

func main() &#123;  
    var p1 Person
    p1.string = &quot;naveen&quot;
    p1.int = 50
    fmt.Println(p1)
&#125;
</code></pre>
<p>在上面程序的第 14 行和第 15 行，我们访问了 <code>Person</code> 结构体的匿名字段，我们把字段类型作为字段名，分别为 “string” 和 “int”。上面程序的输出如下：</p>
<pre><code>&#123;naveen 50&#125;
</code></pre>
<h3 id="结构体的内存布局"><a href="#结构体的内存布局" class="headerlink" title="结构体的内存布局"></a>结构体的内存布局</h3><p>Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。</p>
<pre><code class="go">type Rect1 struct &#123;Min, Max Point &#125;
type Rect2 struct &#123;Min, Max *Point &#125;
</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/o4SlYwuXqy.jpg?imageView2/2/w/1240/h/0" alt="结构体内存布局"></p>
<h3 id="提升字段（Promoted-Fields）"><a href="#提升字段（Promoted-Fields）" class="headerlink" title="提升字段（Promoted Fields）"></a>提升字段（Promoted Fields）</h3><p>如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。</p>
<pre><code class="go">type Address struct &#123;  
    city, state string
&#125;
type Person struct &#123;  
    name string
    age  int
    Address
&#125;
</code></pre>
<p>在上面的代码片段中，<code>Person</code> 结构体有一个匿名字段 <code>Address</code>，而 <code>Address</code> 是一个结构体。现在结构体 <code>Address</code> 有 <code>city</code> 和 <code>state</code> 两个字段，访问这两个字段就像在 <code>Person</code> 里直接声明的一样，因此我们称之为提升字段。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

type Address struct &#123;
    city, state string
&#125;
type Person struct &#123;
    name string
    age  int
    Address
&#125;

func main() &#123;  
    var p Person
    p.name = &quot;Naveen&quot;
    p.age = 50
    p.Address = Address&#123;
        city:  &quot;Chicago&quot;,
        state: &quot;Illinois&quot;,
    &#125;
    fmt.Println(&quot;Name:&quot;, p.name)
    fmt.Println(&quot;Age:&quot;, p.age)
    fmt.Println(&quot;City:&quot;, p.city) //city is promoted field
    fmt.Println(&quot;State:&quot;, p.state) //state is promoted field
&#125;
</code></pre>
<p>在上面代码中的第 26 行和第 27 行使用了语法 <code>p.city</code> 和 <code>p.state</code>，访问提升字段 <code>city</code> 和 <code>state</code> 就像它们是在结构体 <code>p</code> 中声明的一样。该程序会输出：</p>
<pre><code>Name: Naveen  
Age: 50  
City: Chicago  
State: Illinois
</code></pre>
<h3 id="结构体相等性（Structs-Equality）"><a href="#结构体相等性（Structs-Equality）" class="headerlink" title="结构体相等性（Structs Equality）"></a>结构体相等性（Structs Equality）</h3><p><strong>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的</strong>。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type name struct &#123;  
    firstName string
    lastName string
&#125;


func main() &#123;  
    name1 := name&#123;&quot;Steve&quot;, &quot;Jobs&quot;&#125;
    name2 := name&#123;&quot;Steve&quot;, &quot;Jobs&quot;&#125;
    if name1 == name2 &#123;
        fmt.Println(&quot;name1 and name2 are equal&quot;)
    &#125; else &#123;
        fmt.Println(&quot;name1 and name2 are not equal&quot;)
    &#125;

    name3 := name&#123;firstName:&quot;Steve&quot;, lastName:&quot;Jobs&quot;&#125;
    name4 := name&#123;&#125;
    name4.firstName = &quot;Steve&quot;
    if name3 == name4 &#123;
        fmt.Println(&quot;name3 and name4 are equal&quot;)
    &#125; else &#123;
        fmt.Println(&quot;name3 and name4 are not equal&quot;)
    &#125;
&#125;
</code></pre>
<p>在上面的代码中，结构体类型 <code>name</code> 包含两个 <code>string</code> 类型。由于字符串是可比较的，因此可以比较两个 <code>name</code> 类型的结构体变量。</p>
<p>上面代码中 <code>name1</code> 和 <code>name2</code> 相等，而 <code>name3</code> 和 <code>name4</code> 不相等。该程序会输出：</p>
<pre><code>name1 and name2 are equal  
name3 and name4 are not equal
</code></pre>
<p><strong>如果结构体包含不可比较的字段，则结构体变量也不可比较。</strong></p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type image struct &#123;  
    data map[int]int
&#125;

func main() &#123;  
    image1 := image&#123;data: map[int]int&#123;
        0: 155,
    &#125;&#125;
    image2 := image&#123;data: map[int]int&#123;
        0: 155,
    &#125;&#125;
    if image1 == image2 &#123;
        fmt.Println(&quot;image1 and image2 are equal&quot;)
    &#125;
&#125;
</code></pre>
<p>在上面代码中，结构体类型 <code>image</code> 包含一个 <code>map</code> 类型的字段。由于 <code>map</code> 类型是不可比较的，因此 <code>image1</code> 和 <code>image2</code> 也不可比较。如果运行该程序，编译器会报错：**<code>main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)</code>**。</p>
<h3 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h3><p>结构体类型可以通过引用自身来定义。可以用于实现链表和树的结构。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><pre><code class="go">type Node struct &#123;
    data    float64
    su      *Node
&#125;
</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/T9sRQUcN1b.jpg?imageView2/2/w/1240/h/0" alt="go实现链表"></p>
<p>链表中的第一个元素叫 <code>head</code>，它指向第二个元素；最后一个元素叫 <code>tail</code>，它没有后继元素，所以它的 <code>su</code> 为 nil 值。当然真实的链接会有很多数据节点，并且链表可以动态增长或收缩。</p>
<p>同样地可以定义一个双向链表，它有一个前趋节点 <code>pr</code> 和一个后继节点 <code>su</code>：</p>
<pre><code class="go">type Node struct &#123;
    pr      *Node
    data    float64
    su      *Node
&#125;
</code></pre>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><pre><code class="go">type Tree strcut &#123;
    le      *Tree
    data    float64
    ri      *Tree
&#125;
</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/K6NRjDiDKD.jpg?imageView2/2/w/1240/h/0" alt="go实现二叉树"></p>
<h3 id="结构体工厂"><a href="#结构体工厂" class="headerlink" title="结构体工厂"></a>结构体工厂</h3><p>Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new 或 New 开头。假设定义了如下的 File 结构体类型：</p>
<pre><code class="go">type File struct &#123;
    fd      int     // 文件描述符
    name    string  // 文件名
&#125;
</code></pre>
<p>下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</p>
<pre><code class="go">func NewFile(fd int, name string) *File &#123;
    if fd &lt; 0 &#123;
        return nil
    &#125;

    return &amp;File&#123;fd, name&#125;
&#125;
</code></pre>
<p>然后这样调用它：</p>
<pre><code class="go">f := NewFile(10, &quot;./test.txt&quot;)
</code></pre>
<p>在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</p>
<p>如果 <code>File</code> 是一个结构体类型，那么表达式 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的。</p>
<p>这可以和大多数面向对象编程语言中笨拙的初始化方式做个比较：<code>File f = new File(...)</code>。</p>
<p>可以说是工厂实例化了类型的一个对象，就像在基于类的 OO 语言中那样。</p>
<p>如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：<code>size := unsafe.Sizeof(T&#123;&#125;)</code>。</p>
<h4 id="如何强制使用工厂方法"><a href="#如何强制使用工厂方法" class="headerlink" title="如何强制使用工厂方法"></a>如何强制使用工厂方法</h4><p>通过应用可见性规则就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。</p>
<pre><code class="go">type matrix struct &#123;
    ...
&#125;

func NewMatrix(params) *matrix &#123;
    m := new(matrix) // 初始化 m
    return m
&#125;
</code></pre>
<p>在其他包里使用工厂方法：</p>
<pre><code class="go">package main
import &quot;matrix&quot;
...
wrong := new(matrix.matrix)     // 编译失败（matrix 是私有的）
right := matrix.NewMatrix(...)  // 实例化 matrix 的唯一方式
</code></pre>
<h3 id="map-和-struct-vs-new-和-make"><a href="#map-和-struct-vs-new-和-make" class="headerlink" title="map 和 struct vs new () 和 make ()"></a>map 和 struct vs new () 和 make ()</h3><p>现在为止已经见到了可以使用 <code>make()</code> 的三种类型中的其中两个：</p>
<pre><code class="php">slices  /  maps / channels（后面）
</code></pre>
<p>下面的例子说明了在映射上使用 new 和 make 的区别以及可能发生的错误：</p>
<pre><code class="go">package main

type Foo map[string]string
type Bar struct &#123;
    thingOne string
    thingTwo int
&#125;

func main() &#123;
    // OK
    y := new(Bar)
    (*y).thingOne = &quot;hello&quot;
    (*y).thingTwo = 1

    // NOT OK
    z := make(Bar) // 编译错误：cannot make type Bar
    (*z).thingOne = &quot;hello&quot;
    (*z).thingTwo = 1

    // OK
    x := make(Foo)
    x[&quot;x&quot;] = &quot;goodbye&quot;
    x[&quot;y&quot;] = &quot;world&quot;

    // NOT OK
    u := new(Foo)
    (*u)[&quot;x&quot;] = &quot;goodbye&quot; // 运行时错误!! panic: assignment to entry in nil map
    (*u)[&quot;y&quot;] = &quot;world&quot;
&#125;
</code></pre>
<p>试图 <code>make()</code> 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 <code>new()</code> 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 <code>new(Foo)</code> 返回的是一个指向 <code>nil</code> 的指针，它尚未被分配内存。所以在使用 <code>map</code> 时要特别谨慎。</p>
<h3 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type TagType struct &#123; // tags
    field1 bool   &quot;An important answer&quot;
    field2 string &quot;The name of the thing&quot;
    field3 int    &quot;How much there are&quot;
&#125;

func main() &#123;
    tt := TagType&#123;true, &quot;Barak Obama&quot;, 1&#125;
    for i := 0; i &lt; 3; i++ &#123;
        refTag(tt, i)
    &#125;
&#125;

func refTag(tt TagType, ix int) &#123;
    ttType := reflect.TypeOf(tt)
    ixField := ttType.Field(ix)
    fmt.Printf(&quot;%v\n&quot;, ixField.Tag)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="go">An important answer
The name of the thing
How much there are
</code></pre>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Go 只有一种循环结构：<code>for</code> 循环。</p>
<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>
<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>
<p><strong>注意</strong>：Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    sum := 0
    for i := 0; i &lt; 10; i++ &#123;
        sum += i
    &#125;
    fmt.Println(sum)
&#125;
</code></pre>
<p>初始化语句和后置语句是可选的：即相当于 <code>while</code> 循环</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    sum := 1
    for ; sum &lt; 1000; &#123;
        sum += sum
    &#125;
  //可以写成
  for sum &lt; 100 &#123;
    //...
  &#125;
  //无限循环
  for &#123;
    //...
  &#125;
    fmt.Println(sum)
&#125;
</code></pre>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>同样不需要括号。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func sqrt(x float64) string &#123;
    if x &lt; 0 &#123;
        return sqrt(-x) + &quot;i&quot;
    &#125;
    return fmt.Sprint(math.Sqrt(x))
&#125;

func main() &#123;
    fmt.Println(sqrt(2), sqrt(-4))
&#125;
</code></pre>
<p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句，但是该语句声明的变量作用域仅在 <code>if</code> 和 <code>else</code> 之内。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func pow(x, n, lim float64) float64 &#123;
    //v 局部变量，只在if语句块中使用
    if v := math.Pow(x, n); v &lt; lim &#123;
        return v
  //这一行中 else 与两个括号都必须在同一行，否则非法
  &#125; else &#123;
    //此处 v 也可以使用
  &#125;
  //会出错
    //return v
  return lim;
&#125;

func main() &#123;
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
&#125;
</code></pre>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>
<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 </p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func main() &#123;
    fmt.Print(&quot;Go runs on &quot;)
    switch os := runtime.GOOS; os &#123;
    case &quot;darwin&quot;:
        fmt.Println(&quot;OS X.&quot;)
    case &quot;linux&quot;:
        fmt.Println(&quot;Linux.&quot;)
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf(&quot;%s.\n&quot;, os)
    &#125;
&#125;
</code></pre>
<p>没有条件的 switch 同 <code>switch true</code> 一样。这种形式能将一长串 if-then-else 写得更加清晰。</p>
<pre><code class="go">func main() &#123;
    t := time.Now()
    switch &#123;
    case t.Hour() &lt; 12:
        fmt.Println(&quot;Good morning!&quot;)
    case t.Hour() &lt; 17:
        fmt.Println(&quot;Good afternoon.&quot;)
    default:
        fmt.Println(&quot;Good evening.&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    defer fmt.Println(&quot;world&quot;)

    fmt.Println(&quot;hello&quot;)
&#125;
</code></pre>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用:</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

func printA(a int) &#123;  
    fmt.Println(&quot;value of a in deferred function&quot;, a)
&#125;
func main() &#123;  
    a := 5
    defer printA(a)
    a = 10
    fmt.Println(&quot;value of a before deferred function call&quot;, a)

&#125;
</code></pre>
<p>在上面的程序里，<code>a</code> 的初始值为 5。在执行 <code>defer</code> 语句的时候，由于 <code>a</code> 等于 5，因此延迟函数 <code>printA</code> 的实参也等于 5。接着在将 <code>a</code> 的值修改为 10。下一行会打印出 <code>a</code> 的值。该程序输出：</p>
<pre><code>value of a before deferred function call 10  
value of a in deferred function 5
</code></pre>
<p>从上面的输出，可以看出，在调用了 <code>defer</code> 语句后，虽然将 <code>a</code> 修改为 10，但调用延迟函数 <code>printA(a)</code>后，仍然打印的是 5。</p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;counting&quot;)

    for i := 0; i &lt; 10; i++ &#123;
        defer fmt.Println(i)
    &#125;

    fmt.Println(&quot;done&quot;)
&#125;
</code></pre>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过可以为结构体类型定义方法。</p>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：<strong>invalid receiver type…</strong>。</p>
<p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。</p>
<p><strong>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</strong></p>
<p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<pre><code class="go">type Vertex struct &#123;
    X, Y float64
&#125;

func (v Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;

func main() &#123;
    v := Vertex&#123;3, 4&#125;
    fmt.Println(v.Abs())
&#125;
</code></pre>
<p>方法只是个带接收者参数的函数。</p>
<p>也可以为非结构体类型声明方法。</p>
<p>在此例中，可以看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p>
<p><strong>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法</strong>。</p>
<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 &#123;
    if f &lt; 0 &#123;
        return float64(-f)
    &#125;
    return float64(f)
&#125;

func main() &#123;
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
&#125;
</code></pre>
<h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>可以为指针接收者声明方法。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p>
<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作，不会改变原始 <code>Vertes</code> 的值。（对于函数的其它参数也是如此。）采用指针接收者则会直接对原始数据进行修改。 <code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct &#123;
    X, Y float64
&#125;

func (v Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;

//如果把 * 号去掉则只是修改副本，打印出来还是5
func (v *Vertex) Scale(f float64) &#123;
    v.X = v.X * f
    v.Y = v.Y * f
&#125;

func main() &#123;
    v := Vertex&#123;3, 4&#125;
    v.Scale(10)
    fmt.Println(v.Abs())
&#125;
</code></pre>
<h3 id="带指针参数的函数和指针接收者的方法对比"><a href="#带指针参数的函数和指针接收者的方法对比" class="headerlink" title="带指针参数的函数和指针接收者的方法对比"></a>带指针参数的函数和指针接收者的方法对比</h3><p>带指针参数的函数必须接受一个指针：</p>
<pre><code class="go">func Scale(v *Vertex, f float64) &#123;
    v.X = v.X * f
    v.Y = v.Y * f
&#125;

var v Vertex
ScaleFunc(v, 5)  // 编译错误！
ScaleFunc(&amp;v, 5) // OK
</code></pre>
<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<pre><code>func (v *Vertex) Scale(f float64) &#123;
    v.X = v.X * f
    v.Y = v.Y * f
&#125;

var v Vertex
v.Scale(5)  // OK
p := &amp;v
p.Scale(10) // OK
</code></pre>
<p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>（也就是说自动转换）。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct &#123;
    X, Y float64
&#125;

func (v *Vertex) Scale(f float64) &#123;
    v.X = v.X * f
    v.Y = v.Y * f
&#125;

func ScaleFunc(v *Vertex, f float64) &#123;
    v.X = v.X * f
    v.Y = v.Y * f
&#125;

func main() &#123;
    v := Vertex&#123;3, 4&#125;
    v.Scale(2)
    ScaleFunc(&amp;v, 10)

  //此处已经使用了指针
    p := &amp;Vertex&#123;3, 4&#125;
    p.Scale(2)
    ScaleFunc(p, 10)

    fmt.Println(v, p)
&#125;
</code></pre>
<p>同样的，对于下面的代码示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct &#123;
    X, Y float64
&#125;

func (v Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;

func AbsFunc(v Vertex) float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;

func main() &#123;
    v := Vertex&#123;3, 4&#125;
    fmt.Println(v.Abs())
    fmt.Println(AbsFunc(v))

    p := &amp;Vertex&#123;4, 3&#125;
    fmt.Println(p.Abs())
    fmt.Println(AbsFunc(*p))
&#125;
</code></pre>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<pre><code>var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&amp;v)) // 编译错误！
</code></pre>
<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<pre><code>var v Vertex
fmt.Println(v.Abs()) // OK
p := &amp;v
fmt.Println(p.Abs()) // OK
</code></pre>
<p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
<h3 id="选择指针作为接受者的好处"><a href="#选择指针作为接受者的好处" class="headerlink" title="选择指针作为接受者的好处"></a>选择指针作为接受者的好处</h3><p>使用指针接收者的原因有二：</p>
<p>首先，方法能够修改其接收者指向的值。</p>
<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>
<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>
<h3 id="方法的内嵌"><a href="#方法的内嵌" class="headerlink" title="方法的内嵌"></a>方法的内嵌</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型<strong>继承</strong>了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</p>
<p>假定有一个 <code>Engine</code> 接口类型，一个 <code>Car</code> 结构体类型，它包含一个 <code>Engine</code> 类型的匿名字段：</p>
<pre><code class="go">type Engine interface &#123;
    Start()
    Stop()
&#125;

type Car struct &#123;
    Engine
&#125;
</code></pre>
<p>可以构建如下的代码：</p>
<pre><code class="go">func (c *Car) GoToWorkIn() &#123;
    // get in car
    c.Start()
    // drive to work
    c.Stop()
    // get out of car
&#125;
</code></pre>
<p>下面的例子它展示了内嵌结构体上的方法可以直接在外层类型的实例上调用：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Point struct &#123;
    x, y float64
&#125;

func (p *Point) Abs() float64 &#123;
    return math.Sqrt(p.x*p.x + p.y*p.y)
&#125;

type NamedPoint struct &#123;
    Point
    name string
&#125;

func main() &#123;
    n := &amp;NamedPoint&#123;Point&#123;3, 4&#125;, &quot;Pythagoras&quot;&#125;
    fmt.Println(n.Abs()) // 打印5
&#125;
</code></pre>
<p>内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法 “晋升” 成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌 “父” 类型上的方法，</p>
<p>可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p>
<p>如下所示：</p>
<pre><code class="go">func (n *NamedPoint) Abs() float64 &#123;
    return n.Point.Abs() * 100.
&#125;
</code></pre>
<p>现在 <code>fmt.Println(n.Abs())</code> 会打印 <code>500</code>。</p>
<p>因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的多重继承，就像：<code>type Child struct &#123; Father; Mother&#125;</code>。在第 10.6.7 节中会进一步讨论这个问题。</p>
<p>结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</p>
<h3 id="类型的-String-方法和格式化描述符"><a href="#类型的-String-方法和格式化描述符" class="headerlink" title="类型的 String() 方法和格式化描述符"></a>类型的 String() 方法和格式化描述符</h3><p>当定义了一个有很多方法的类型时，可能会使用 <code>String()</code> 方法来定制类型的字符串形式的输出，换句话说：一种可阅读性和打印性的输出。<strong>如果类型定义了 <code>String()</code> 方法，它会被用在 <code>fmt.Printf()</code> 中生成默认的输出</strong>：等同于使用格式化描述符 <code>%v</code> 产生的输出。还有 <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法。</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

type TwoInts struct &#123;
    a int
    b int
&#125;

func main() &#123;
    two1 := new(TwoInts)
    two1.a = 12
    two1.b = 10
    fmt.Printf(&quot;two1 is: %v\n&quot;, two1)
    fmt.Println(&quot;two1 is:&quot;, two1)
    fmt.Printf(&quot;two1 is: %T\n&quot;, two1)
    fmt.Printf(&quot;two1 is: %#v\n&quot;, two1)
&#125;

func (tn *TwoInts) String() string &#123;
    return &quot;(&quot; + strconv.Itoa(tn.a) + &quot;/&quot; + strconv.Itoa(tn.b) + &quot;)&quot;
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">two1 is: (12/10)
two1 is: (12/10)
two1 is: *main.TwoInts
two1 is: &amp;main.TwoInts&#123;a:12, b:10&#125;
</code></pre>
<p>当广泛使用一个自定义类型时，最好为它定义 <code>String()</code> 方法。从上面的例子也可以看到，格式化描述符 <code>%T</code> 会给出类型的完全规格，<code>%#v</code> 会给出实例的完整输出，包括它的字段（在程序自动生成 <code>Go</code> 代码时也很有用）。</p>
<p><strong>备注</strong></p>
<p>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误，比如下面的例子，它导致了一个无限迭代（递归）调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导致内存溢出：</p>
<pre><code class="go">type TT float64

func (t TT) String() string &#123;
    return fmt.Sprintf(&quot;%v&quot;, t)
&#125;
t. String()
</code></pre>
<h3 id="垃圾回收和-SetFinalizer"><a href="#垃圾回收和-SetFinalizer" class="headerlink" title="垃圾回收和 SetFinalizer"></a>垃圾回收和 SetFinalizer</h3><p>Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。可以通过 <code>runtime</code> 包访问 GC 进程。</p>
<p>通过调用 <code>runtime.GC()</code> 函数可以显式的触发 GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用 <code>runtime.GC()</code>，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为 <code>GC</code> 进程在执行）。</p>
<p>如果想知道当前的内存状态，可以使用：</p>
<pre><code class="go">// fmt.Printf(&quot;%d\n&quot;, runtime.MemStats.Alloc/1024)
// 此处代码在 Go 1.5.1下不再有效，更正为
var m runtime.MemStats
runtime.ReadMemStats(&amp;m)
fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc / 1024)
</code></pre>
<p>上面的程序会给出已分配内存的总量，单位是 Kb。</p>
<p>如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p>
<pre><code class="go">runtime.SetFinalizer(obj, func(obj *typeObj))
</code></pre>
<p><code>func(obj *typeObj)</code> 需要一个 <code>typeObj</code> 类型的指针参数 <code>obj</code>，特殊操作会在它上面执行。<code>func</code> 也可以是一个匿名函数。</p>
<p>在对象被 GC 进程选中并从内存中移除以前，<code>SetFinalizer</code> 都不会执行，即使程序正常结束或者发生错误。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口类型</strong>是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值。</p>
<p>（按照约定，只包含一个方法的）接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像 <code>.NET</code> 或 <code>Java</code> 中那样）。</p>
<p><strong>注意:</strong> 示例代码存在一个错误。由于 <code>Abs</code> 方法只为 <code>*Vertex</code> （指针类型）定义，因此 <code>Vertex</code>（值类型）并未实现 <code>Abser</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Abser interface &#123;
    Abs() float64
&#125;

func main() &#123;
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex&#123;3, 4&#125;

    a = f  // a MyFloat 实现了 Abser
    a = &amp;v // a *Vertex 实现了 Abser

    // 下面一行，v 是一个 Vertex（而不是 *Vertex）
    // 所以没有实现 Abser,会报错
    a = v

    fmt.Println(a.Abs())
&#125;

type MyFloat float64

func (f MyFloat) Abs() float64 &#123;
    if f &lt; 0 &#123;
        return float64(-f)
    &#125;
    return float64(f)
&#125;

type Vertex struct &#123;
    X, Y float64
&#125;

func (v *Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;
</code></pre>
<h2 id="接口的隐式实现"><a href="#接口的隐式实现" class="headerlink" title="接口的隐式实现"></a>接口的隐式实现</h2><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
func (t T) M() &#123;
    fmt.Println(t.S)
&#125;

func main() &#123;
    var i I = T&#123;&quot;hello&quot;&#125;
    i.M()
&#125;
</code></pre>
<h2 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h2><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p>
<p>比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p>
<pre><code class="go">type ReadWrite interface &#123;
    Read(b Buffer) bool
    Write(b Buffer) bool
&#125;

type Lock interface &#123;
    Lock()
    Unlock()
&#125;

type File interface &#123;
    ReadWrite
    Lock
    Close()
&#125;
</code></pre>
<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>接口也是值。它们可以像其它值一样传递。</p>
<p>接口值可以用作函数的参数或返回值。</p>
<p>在内部，接口值可以看做包含值和具体类型的元组：</p>
<pre><code>(value, type)
</code></pre>
<p>接口值保存了一个具体底层类型的具体值。</p>
<p>接口值调用方法时会执行其底层类型的同名方法。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

func (t *T) M() &#123;
    fmt.Println(t.S)
&#125;

type F float64

func (f F) M() &#123;
    fmt.Println(f)
&#125;

func main() &#123;
    var i I

    i = &amp;T&#123;&quot;Hello&quot;&#125;
  //(&amp;&#123;Hello&#125;, *main.T)
    describe(i)
    i.M()

    i = F math.Pi
  //(3.141592653589793, main.F)
    describe(i)
    i.M()
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;
</code></pre>
<h3 id="底层值（调用接口方法的变量）为-nil-的接口值"><a href="#底层值（调用接口方法的变量）为-nil-的接口值" class="headerlink" title="底层值（调用接口方法的变量）为 nil 的接口值"></a>底层值（调用接口方法的变量）为 nil 的接口值</h3><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p>
<p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p>
<p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

func (t *T) M() &#123;
    if t == nil &#123;
        fmt.Println(&quot;&lt;nil&gt;&quot;)
        return
    &#125;
    fmt.Println(t.S)
&#125;

func main() &#123;
    var i I

    var t *T
    i = t
  //(&lt;nil&gt;, *main.T)
    describe(i)
    i.M()

    i = &amp;T&#123;&quot;hello&quot;&#125;
  //(&amp;&#123;hello&#125;, *main.T)
    describe(i)
    i.M()
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;
</code></pre>
<h3 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h3><p>nil 接口值既不保存值也不保存具体类型。</p>
<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个<strong>具体</strong>方法的类型。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface &#123;
    M()
&#125;

func main() &#123;
    var i I
  //(&lt;nil&gt;, &lt;nil&gt;)
    describe(i)
  //会报错
    i.M()
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;
</code></pre>
<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>指定了零个方法的接口值被称为空接口：</p>
<pre><code class="go">interface&#123;&#125;
</code></pre>
<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p>
<p>每个 <code>interface &#123;&#125;</code> 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var i interface&#123;&#125;
    describe(i)

    i = 42
    describe(i)

    i = &quot;hello&quot;
    describe(i)
&#125;

func describe(i interface&#123;&#125;) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;
</code></pre>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。类型断言提供了访问接口值底层具体值的方式。</p>
<pre><code>t := i.(T)
</code></pre>
<p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p>
<p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p>
<p>为了<strong>判断</strong>一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<pre><code>t, ok := i.(T)
</code></pre>
<p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p>
<p>请注意这种语法和读取一个映射时的相同之处。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    var i interface&#123;&#125; = &quot;hello&quot;

    s := i.(string)
    fmt.Println(s)

    s, ok := i.(string)
    fmt.Println(s, ok)

    f, ok := i.(float64)
    fmt.Println(f, ok)

    f = i.(float64) // 报错(panic)
    fmt.Println(f)
&#125;
</code></pre>
<pre><code class="go">hello
hello true
0 false
panic: interface conversion: interface &#123;&#125; is string, not float64
</code></pre>
<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p><strong>类型选择</strong>是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<pre><code class="go">switch v := i.(type) &#123;
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
&#125;
</code></pre>
<p><strong>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</strong></p>
<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
<h2 id="接口实现中的指针接受者与值接受者"><a href="#接口实现中的指针接受者与值接受者" class="headerlink" title="接口实现中的指针接受者与值接受者"></a>接口实现中的指针接受者与值接受者</h2><pre><code class="go">package main

import &quot;fmt&quot;

type Describer interface &#123;  
    Describe()
&#125;
type Person struct &#123;  
    name string
    age  int
&#125;

func (p Person) Describe() &#123; // 使用值接受者实现  
    fmt.Printf(&quot;%s is %d years old\n&quot;, p.name, p.age)
&#125;

type Address struct &#123;
    state   string
    country string
&#125;

func (a *Address) Describe() &#123; // 使用指针接受者实现
    fmt.Printf(&quot;State %s Country %s&quot;, a.state, a.country)
&#125;

func main() &#123;  
    var d1 Describer
    p1 := Person&#123;&quot;Sam&quot;, 25&#125;
    d1 = p1
    d1.Describe()
    p2 := Person&#123;&quot;James&quot;, 32&#125;
    d1 = &amp;p2
    d1.Describe()

    var d2 Describer
    a := Address&#123;&quot;Washington&quot;, &quot;USA&quot;&#125;

    /* 如果下面一行取消注释会导致编译错误：
       cannot use a (type Address) as type Describer
       in assignment: Address does not implement
       Describer (Describe method has pointer
       receiver)
    */
    //d2 = a

    d2 = &amp;a // 这是合法的
    // 因为在第 22 行，Address 类型的指针实现了 Describer 接口
    d2.Describe()

&#125;
</code></pre>
<p><strong>对于使用指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口中存储的具体值（Concrete Value）并不能取到地址，因此在上面的例子中，对于编译器无法自动获取 <code>a</code> 的地址，于是程序报错</strong>。</p>
<p><strong>总结</strong></p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接可以辨识的：</p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p>
<p><strong>译注</strong></p>
<p>Go 语言规范定义了接口方法集的调用规则：</p>
<ul>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li>
</ul>
<h2 id="常用接口方法"><a href="#常用接口方法" class="headerlink" title="常用接口方法"></a>常用接口方法</h2><h3 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h3><p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p>
<pre><code class="go">type Stringer interface &#123;
    String() string
&#125;
</code></pre>
<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Person struct &#123;
    Name string
    Age  int
&#125;

func (p Person) String() string &#123;
    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
&#125;

func main() &#123;
    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;
    z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;
    fmt.Println(a, z)
&#125;
</code></pre>
<h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error 错误"></a>Error 错误</h3><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<pre><code class="go">type error interface &#123;
    Error() string
&#125;
</code></pre>
<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<pre><code class="go">i, err := strconv.Atoi(&quot;42&quot;)
if err != nil &#123;
    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)
    returnf
&#125;
fmt.Println(&quot;Converted integer:&quot;, i)
</code></pre>
<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的<a target="_blank" rel="noopener" href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<pre><code>func (T) Read(b []byte) (n int, err error)
</code></pre>
<p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strings&quot;
)

func main() &#123;
    r := strings.NewReader(&quot;Hello, Reader!&quot;)

    b := make([]byte, 8)
    for &#123;
        n, err := r.Read(b)
        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])
        if err == io.EOF &#123;
            break
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]
b[:n] = &quot;Hello, R&quot;
n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;eader!&quot;
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;&quot;
</code></pre>
<h3 id="图像-image"><a href="#图像-image" class="headerlink" title="图像 image"></a>图像 image</h3><p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p>
<pre><code class="go">package image

type Image interface &#123;
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
&#125;
</code></pre>
<p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p>
<p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；反射可以在运行时检查类型和变量，例如它的大小、方法和动态的调用这些方法。这对于没有源代码的包尤其有用。</p>
<p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。</p>
<p>两个简单的函数，<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，返回被检查对象的类型和值。例如，x 被定义为：<code>var x float64 = 3.4</code>，那么 <code>reflect.TypeOf(x)</code> 返回 <code>float64</code>，<code>reflect.ValueOf(x)</code> 返回 <code>3.4</code>。</p>
<p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。这从下面两个函数签名能够很明显的看出来：</p>
<pre><code class="go">func TypeOf(i interface&#123;&#125;) Type
func ValueOf(i interface&#123;&#125;) Value
</code></pre>
<p>接口的值包含一个 type 和 value。</p>
<p>反射可以从接口值反射到对象，也可以从对象反射回接口值。</p>
<p>此外，<code>reflect</code>包中还有一个重要的类型：<code>Kind</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type order struct &#123;
    ordId      int
    customerId int
&#125;

func createQuery(q interface&#123;&#125;) &#123;
    t := reflect.TypeOf(q)
    k := t.Kind()
    fmt.Println(&quot;Type &quot;, t) //Type main.order
    fmt.Println(&quot;Kind &quot;, k) //Kind struct


&#125;
func main() &#123;
    o := order&#123;
        ordId:      456,
        customerId: 56,
    &#125;
    createQuery(o)
&#125;
</code></pre>
<p><code>Type</code> 表示 <code>interface&#123;&#125;</code> 的实际类型（在这里是 <strong><code>main.Order</code></strong>)，而 <code>Kind</code> 表示该类型的特定类别（在这里是 **<code>struct</code>**）。 </p>
<p>对于 float64 类型的变量 x，如果 <code>v:=reflect.ValueOf(x)</code>，那么 <code>v.Kind()</code> 返回 <code>reflect.Float64</code> ，所以下面的表达式是 <code>true</code><br><code>v.Kind() == reflect.Float64</code></p>
<p><code>Kind</code> 总是返回底层类型：</p>
<pre><code class="go">type MyInt int
var m MyInt = 5
v := reflect.ValueOf(m)
</code></pre>
<p>方法 <code>v.Kind()</code> 返回 <code>reflect.Int</code>。</p>
<p>变量 v 的 <code>Interface()</code> 方法可以得到还原（接口）值，所以可以这样打印 v 的值：<code>fmt.Println(v.Interface())</code></p>
<p><code>reflect.Type</code> 和 <code>reflect.Value</code> 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 <code>Value</code> 有叫做 <code>Int</code> 和 <code>Float</code> 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）</p>
<pre><code class="go">const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
</code></pre>
<p>下面的例子使用 <code>Int()</code> 和 <code>String()</code> 将取的 <code>reflect.Value</code> 转换为相应的内部值类型</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() &#123;
    a := 56
      //reflect.value -&gt; int64
    x := reflect.ValueOf(a).Int()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
    b := &quot;Naveen&quot;
      //reflect.value -&gt; string
    y := reflect.ValueOf(b).String()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, y, y)

&#125;
</code></pre>
<p>示例代码：</p>
<pre><code class="go">// blog: Laws of Reflection
package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() &#123;
    var x float64 = 3.4
    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
    v := reflect.ValueOf(x)
    fmt.Println(&quot;value:&quot;, v)
    fmt.Println(&quot;type:&quot;, v.Type())
    fmt.Println(&quot;kind:&quot;, v.Kind())
    fmt.Println(&quot;value:&quot;, v.Float())
    fmt.Println(v.Interface())
    fmt.Printf(&quot;value is %5.2e\n&quot;, v.Interface())
    y := v.Interface().(float64)
    fmt.Println(y)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">type: float64
value: 3.4
type: float64
kind: float64
value: 3.4
3.4
value is 3.40e+00
3.4
</code></pre>
<p>x 是一个 float64 类型的值，<code>reflect.ValueOf(x).Float()</code> 返回这个 float64 类型的实际值；同样的适用于 <code>Int(), Bool(), Complex(), String()</code></p>
<h2 id="通过反射修改-设置-值"><a href="#通过反射修改-设置-值" class="headerlink" title="通过反射修改 (设置) 值"></a>通过反射修改 (设置) 值</h2><p>假设要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：<code>v.SetFloat(3.1415)</code>。</p>
<p>这将产生一个错误：<code>reflect.Value.SetFloat using unaddressable value</code>。</p>
<p>问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 <code>CanSet()</code> 方法测试是否可设置。</p>
<p>在例子中可以看到 <code>v.CanSet()</code> 返回 false： <code>settability of v: false</code></p>
<p>当 <code>v := reflect.ValueOf(x)</code> 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 <code>v = reflect.ValueOf(&amp;x)</code>。</p>
<p>通过 Type () 我们看到 v 现在的类型是 <code>*float64</code> 并且仍然是不可设置的。</p>
<p>要想让其可设置我们需要使用 <code>Elem()</code> 函数，这间接的使用指针：<code>v = v.Elem()</code></p>
<p>现在 <code>v.CanSet()</code> 返回 true 并且 <code>v.SetFloat(3.1415)</code> 设置成功了！</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() &#123;
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    // setting a value:
    // v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v = reflect.ValueOf(&amp;x) // Note: take the address of x.
    fmt.Println(&quot;type of v:&quot;, v.Type())
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v = v.Elem()
    fmt.Println(&quot;The Elem of v is: &quot;, v)
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v.SetFloat(3.1415) // this works!
    fmt.Println(v.Interface())
    fmt.Println(v)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">settability of v: false
type of v: *float64
settability of v: false
The Elem of v is:  &lt;float64 Value&gt;
settability of v: true
3.1415
&lt;float64 Value&gt;
</code></pre>
<p>反射中有些内容是需要用地址去改变它的状态的。</p>
<h2 id="反射结构体"><a href="#反射结构体" class="headerlink" title="反射结构体"></a>反射结构体</h2><p>有些时候需要反射一个结构体类型。<code>NumField()</code> 方法返回结构体内的字段数量；通过一个 for 循环用索引取得每个字段的值 <code>Field(i)</code>。</p>
<p>同样能够调用签名在结构体上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code>。</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type NotknownType struct &#123;
    s1, s2, s3 string
&#125;

func (n NotknownType) String() string &#123;
    return n.s1 + &quot; - &quot; + n.s2 + &quot; - &quot; + n.s3
&#125;

// variable to investigate:
var secret interface&#123;&#125; = NotknownType&#123;&quot;Ada&quot;, &quot;Go&quot;, &quot;Oberon&quot;&#125;

func main() &#123;
    value := reflect.ValueOf(secret) // &lt;main.NotknownType Value&gt;
    typ := reflect.TypeOf(secret)    // main.NotknownType
    // alternative:
    //typ := value.Type()  // main.NotknownType
    fmt.Println(typ)
    knd := value.Kind() // struct
    fmt.Println(knd)

    // iterate through the fields of the struct:
    for i := 0; i &lt; value.NumField(); i++ &#123;
        fmt.Printf(&quot;Field %d: %v\n&quot;, i, value.Field(i))
        // error: panic: reflect.Value.SetString using value obtained using unexported field
        //value.Field(i).SetString(&quot;C#&quot;)
    &#125;

    // call the first method, which is String():
    results := value.Method(0).Call(nil)
    fmt.Println(results) // [Ada - Go - Oberon]
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">main.NotknownType
struct
Field 0: Ada
Field 1: Go
Field 2: Oberon
[Ada - Go - Oberon]
</code></pre>
<p>但是如果尝试更改一个值，会得到一个错误：</p>
<pre><code class="php">panic: reflect.Value.SetString using value obtained using unexported field
</code></pre>
<p>这是因为结构体中只有被导出字段（首字母大写）才是可设置的；来看下面的例子：</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type T struct &#123;
    A int
    B string
&#125;

func main() &#123;
    t := T&#123;23, &quot;skidoo&quot;&#125;
    s := reflect.ValueOf(&amp;t).Elem()
    typeOfT := s.Type()
    for i := 0; i &lt; s.NumField(); i++ &#123;
        f := s.Field(i)
        fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,
            typeOfT.Field(i).Name, f.Type(), f.Interface())
    &#125;
    s.Field(0).SetInt(77)
    s.Field(1).SetString(&quot;Sunset Strip&quot;)
    fmt.Println(&quot;t is now&quot;, t)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">0: A int = 23
1: B string = skidoo
t is now &#123;77 Sunset Strip&#125;
</code></pre>
<h3 id="Int-和-String-方法"><a href="#Int-和-String-方法" class="headerlink" title="Int() 和 String() 方法"></a>Int() 和 String() 方法</h3><p><a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/#Value.Int"><code>Int</code></a> 和 <a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/#Value.String"><code>String</code></a> 可以帮助分别取出 <code>reflect.Value</code> 作为 <code>int64</code> 和 <code>string</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() &#123;
    a := 56
    x := reflect.ValueOf(a).Int()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
    b := &quot;Naveen&quot;
    y := reflect.ValueOf(b).String()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, y, y)

&#125;
</code></pre>
<p>在上面程序中取出 <code>reflect.Value</code>，并转换为 <code>int64</code>，接着取出 <code>reflect.Value</code> 并将其转换为 <code>string</code>。该程序会输出：</p>
<pre><code>type:int64 value:56
type:string value:Naveen
</code></pre>
<h1 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h1><h2 id="读取用户的输入"><a href="#读取用户的输入" class="headerlink" title="读取用户的输入"></a>读取用户的输入</h2><p>从键盘和标准输入 <code>os.Stdin</code> 读取输入，最简单的办法是使用 <code>fmt</code> 包提供的 Scan 和 Sscan 开头的函数。</p>
<pre><code class="go">// 从控制台读取输入:
package main
import &quot;fmt&quot;

var (
   firstName, lastName, s string
   i int
   f float32
   input = &quot;56.12 / 5212 / Go&quot;
   format = &quot;%f / %d / %s&quot;
)

func main() &#123;
   fmt.Println(&quot;Please enter your full name: &quot;)
   fmt.Scanln(&amp;firstName, &amp;lastName)
   // fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)
   fmt.Printf(&quot;Hi %s %s!\n&quot;, firstName, lastName) // Hi Chris Naegels
   fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)
   fmt.Println(&quot;From the string we read: &quot;, f, i, s)
    // 输出结果: From the string we read: 56.12 5212 Go
&#125;
</code></pre>
<p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。</p>
<p><code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果和预想的不同，可以检查成功读入数据的个数和返回的错误。</p>
<p>也可以使用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

var inputReader *bufio.Reader
var input string
var err error

func main() &#123;
    inputReader = bufio.NewReader(os.Stdin)
    fmt.Println(&quot;Please enter some input: &quot;)
    input, err = inputReader.ReadString(&#39;\n&#39;)
    if err == nil &#123;
        fmt.Printf(&quot;The input was: %s\n&quot;, input)
    &#125;
&#125;
</code></pre>
<p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针。<code>inputReader := bufio.NewReader(os.Stdin)</code> 这行代码，将会创建一个读取器，并将其与标准输入绑定。</p>
<p><code>bufio.NewReader()</code> 构造函数的签名为：<code>func NewReader(rd io.Reader) *Reader</code></p>
<p>该函数的实参可以是满足 <code>io.Reader</code> 接口的任意对象（任意包含有适当的 <code>Read()</code> 方法的对象），函数返回一个新的带缓冲的 <code>io.Reader</code> 对象，它将从指定读取器（例如 <code>os.Stdin</code>）读取内容。</p>
<p>返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code>，该方法从输入中读取内容，直到碰到 <code>delim</code> 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区。</p>
<p><code>ReadString</code> 返回读取到的字符串，如果碰到错误则返回 <code>nil</code>。如果它一直读到文件结束，则返回读取到的字符串和 <code>io.EOF</code>。如果读取过程中没有碰到 <code>delim</code> 字符，将返回错误 <code>err != nil</code>。</p>
<p>在上面的例子中，会读取键盘输入，直到回车键（\n）被按下。</p>
<p>屏幕是标准输出 <code>os.Stdout</code>；<code>os.Stderr</code> 用于显示错误信息，大多数情况下等同于 <code>os.Stdout</code>。</p>
<p>一般情况下，会省略变量声明，而使用 <code>:=</code>，例如：</p>
<pre><code class="go">inputReader := bufio.NewReader(os.Stdin)
input, err := inputReader.ReadString(&#39;\n&#39;)
</code></pre>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。在前面使用到过标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>，他们的类型都是 <code>*os.File</code>。</p>
<pre><code class="go">package main
import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() &#123;
    inputFile, inputError := os.Open(&quot;input.dat&quot;)
    if inputError != nil &#123;
        fmt.Printf(&quot;An error occurred on opening the inputfile\n&quot; +
            &quot;Does the file exist?\n&quot; +
            &quot;Have you got acces to it?\n&quot;)
        return // exit the function on error
    &#125;
    defer inputFile.Close()

    inputReader := bufio.NewReader(inputFile)
    for &#123;
        inputString, readerError := inputReader.ReadString(&#39;\n&#39;)
    fmt.Printf(&quot;The input was: %s&quot;, inputString)
        if readerError == io.EOF &#123;
            return
        &#125;      
    &#125;
&#125;
</code></pre>
<p>变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 <code>os</code> 包里的 <code>Open</code> 函数来打开一个文件。该函数的参数是文件名，类型为 <code>string</code>。在上面的程序中，以只读模式打开 <code>input.dat</code> 文件。</p>
<p>如果文件不存在或者程序没有足够的权限打开这个文件，Open 函数会返回一个错误：<code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code>。如果文件打开正常，就使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。然后，使用 <code>bufio.NewReader</code> 来获得一个读取器变量。</p>
<p>通过使用 <code>bufio</code> 包提供的读取器（写入器也类似），如上面程序所示，可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。</p>
<p>接着，在一个无限循环中使用 <code>ReadString(&#39;\n&#39;)</code> 或 <code>ReadBytes(&#39;\n&#39;)</code> 将文件的内容逐行（行结束符 <code>\n</code>）读取出来。</p>
<p><strong>注意</strong>：在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，不需要关心操作系统的类型，直接使用 <code>\n</code> 就可以了。另外，也可以使用 <code>ReadLine()</code> 方法来实现相同的功能。</p>
<p>一旦读取到文件末尾，变量 <code>readerError</code> 的值将变成非空（事实上，常量 <code>io.EOF</code> 的值是 true），就会执行 <code>return</code> 语句从而退出循环。</p>
<h3 id="其他读文件方式"><a href="#其他读文件方式" class="headerlink" title="其他读文件方式"></a>其他读文件方式</h3><h4 id="将整个文件的内容读取到一个字符串里"><a href="#将整个文件的内容读取到一个字符串里" class="headerlink" title="将整个文件的内容读取到一个字符串里"></a>将整个文件的内容读取到一个字符串里</h4><p>可以使用 <code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
)

func main() &#123;
    inputFile := &quot;products.txt&quot;
    outputFile := &quot;products_copy.txt&quot;
    buf, err := ioutil.ReadFile(inputFile)
    if err != nil &#123;
        fmt.Fprintf(os.Stderr, &quot;File Error: %s\n&quot;, err)
        // panic(err.Error())
        &#125;
    fmt.Printf(&quot;%s\n&quot;, string(buf))
    err = ioutil.WriteFile(outputFile, buf, 0644) // oct, not hex
    if err != nil &#123;
        panic(err.Error())
    &#125;
&#125;
</code></pre>
<h4 id="带缓冲的读取"><a href="#带缓冲的读取" class="headerlink" title="带缓冲的读取"></a>带缓冲的读取</h4><p>在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，<code>ReadString()</code> 就无法使用了，可以使用 <code>bufio.Reader</code> 的 <code>Read()</code>，它只接收一个参数：</p>
<pre><code class="go">buf := make([]byte, 1024)
...
n, err := inputReader.Read(buf)
if (n == 0) &#123; break&#125;
</code></pre>
<p>变量 n 的值表示读取到的字节数。</p>
<h4 id="按列读取文件中的数据"><a href="#按列读取文件中的数据" class="headerlink" title="按列读取文件中的数据"></a>按列读取文件中的数据</h4><p>如果数据是按列排列并用空格分隔的，可以使用 <code>fmt</code> 包提供的以 FScan 开头的一系列函数来读取他们。下面的程序将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    file, err := os.Open(&quot;products2.txt&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    defer file.Close()

    var col1, col2, col3 []string
    for &#123;
        var v1, v2, v3 string
        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)
        // scans until newline
        if err != nil &#123;
            break
        &#125;
        col1 = append(col1, v1)
        col2 = append(col2, v2)
        col3 = append(col3, v3)
    &#125;

    fmt.Println(col1)
    fmt.Println(col2)
    fmt.Println(col3)
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code class="php">[ABC FUNC GO]
[40 56 45]
[150 280 356]
</code></pre>
<p><strong>注意：</strong> <code>path</code> 包里包含一个子包叫 <code>filepath</code>，这个子包提供了跨平台的函数，用于处理文件名和路径。例如 Base () 函数用于获得路径中的最后一个元素（不包含后面的分隔符）：</p>
<pre><code class="go">import &quot;path/filepath&quot;
filename := filepath.Base(path)
</code></pre>
<h3 id="读取压缩文件"><a href="#读取压缩文件" class="headerlink" title="读取压缩文件"></a>读取压缩文件</h3><p><code>compress</code> 包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
    &quot;compress/gzip&quot;
)

func main() &#123;
    fName := &quot;MyFile.gz&quot;
    var r *bufio.Reader
    fi, err := os.Open(fName)
    if err != nil &#123;
        fmt.Fprintf(os.Stderr, &quot;%v, Can&#39;t open %s: error: %s\n&quot;, os.Args[0], fName,
            err)
        os.Exit(1)
    &#125;
    fz, err := gzip.NewReader(fi)
    if err != nil &#123;
        r = bufio.NewReader(fi)
    &#125; else &#123;
        r = bufio.NewReader(fz)
    &#125;

    for &#123;
        line, err := r.ReadString(&#39;\n&#39;)
        if err != nil &#123;
            fmt.Println(&quot;Done reading file&quot;)
            os.Exit(0)
        &#125;
        fmt.Println(line)
    &#125;
&#125;
</code></pre>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><pre><code class="go">package main

import (
    &quot;os&quot;
    &quot;bufio&quot;
    &quot;fmt&quot;
)

func main () &#123;
    // var outputWriter *bufio.Writer
    // var outputFile *os.File
    // var outputError os.Error
    // var outputString string
    outputFile, outputError := os.OpenFile(&quot;output.dat&quot;, os.O_WRONLY|os.O_CREATE, 0666)
    if outputError != nil &#123;
        fmt.Printf(&quot;An error occurred with file opening or creation\n&quot;)
        return  
    &#125;
    defer outputFile.Close()

    outputWriter := bufio.NewWriter(outputFile)
    outputString := &quot;hello world!\n&quot;

    for i:=0; i&lt;10; i++ &#123;
        outputWriter.WriteString(outputString)
    &#125;
    outputWriter.Flush()
&#125;
</code></pre>
<p>首先以只写模式打开文件 <code>output.dat</code>，如果文件不存在则自动创建：</p>
<pre><code class="go">outputFile, outputError := os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666)
</code></pre>
<p>可以看到，<code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 “|” 连接），使用的文件权限。</p>
<p>通常会用到以下标志：</p>
<ul>
<li><code>os.O_RDONLY</code>：只读</li>
<li><code>os.O_WRONLY</code>：只写</li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为 0。</li>
</ul>
<p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用 0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p>
<p>然后，创建一个写入器（缓冲区）对象：</p>
<pre><code class="go">outputWriter := bufio.NewWriter(outputFile)
</code></pre>
<p>接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：<code>outputWriter.WriteString(outputString)</code></p>
<p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code></p>
<p>如果写入的东西很简单，可以使用 <code>fmt.Fprintf(outputFile, “Some test data.\n”)</code> 直接将内容写入文件。**<code>fmt</code> 包里的 F 开头的 Print 函数可以直接写入任何 <code>io.Writer</code>，包括文件。**</p>
<p>下面的例子展示了不使用 <code>fmt.FPrintf</code> 函数，使用其他函数如何写文件：</p>
<pre><code class="go">package main

import &quot;os&quot;

func main() &#123;
    os.Stdout.WriteString(&quot;hello, world\n&quot;)
    f, _ := os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0)
    defer f.Close()
    f.WriteString(&quot;hello, world in a file\n&quot;)
&#125;
</code></pre>
<p>使用 <code>os.Stdout.WriteString(“hello, world\n”)</code>，我们可以输出到屏幕。</p>
<p>以只写模式创建或打开文件 “test”，并且忽略了可能发生的错误：<code>f, _ := os.OpenFile(“test”, os.O_CREATE|os.O_WRONLY, 0)</code></p>
<p>不使用缓冲区，直接将内容写入文件：<code>f.WriteString( )</code></p>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><pre><code class="go">// filecopy.go
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() &#123;
    CopyFile(&quot;target.txt&quot;, &quot;source.txt&quot;)
    fmt.Println(&quot;Copy done!&quot;)
&#125;

func CopyFile(dstName, srcName string) (written int64, err error) &#123;
    src, err := os.Open(srcName)
    if err != nil &#123;
        return
    &#125;
    defer src.Close()

    dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
    if err != nil &#123;
        return
    &#125;
    defer dst.Close()

    return io.Copy(dst, src)
&#125;
</code></pre>
<p>注意 <code>defer</code> 的使用：当打开目标文件时发生了错误，那么 <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p>
<h2 id="fmt-Fprintf"><a href="#fmt-Fprintf" class="headerlink" title="fmt.Fprintf"></a>fmt.Fprintf</h2><pre><code class="go">// interfaces being used in the GO-package fmt
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    // unbuffered
    fmt.Fprintf(os.Stdout, &quot;%s\n&quot;, &quot;hello world! - unbuffered&quot;)
    // buffered: os.Stdout implements io.Writer
    buf := bufio.NewWriter(os.Stdout)
    // and now so does buf.
    fmt.Fprintf(buf, &quot;%s\n&quot;, &quot;hello world! - buffered&quot;)
    buf.Flush()
&#125;
</code></pre>
<pre><code class="php">hello world! - unbuffered
hello world! - buffered
</code></pre>
<p>下面是 <code>fmt.Fprintf()</code> 函数的实际签名</p>
<pre><code class="go">func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)
</code></pre>
<p>其不是写入一个文件，而是写入一个 <code>io.Writer</code> 接口类型的变量，下面是 <code>Writer</code> 接口在 io 包中的定义：</p>
<pre><code class="go">type Writer interface &#123;
    Write(p []byte) (n int, err error)
&#125;
</code></pre>
<p><code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 <code>io.Writer</code> 接口。<code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>Write</code> 方法，包括 <code>os.Stdout</code>, 文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。bufio 包中定义了 <code>type Writer struct&#123;...&#125;</code>。</p>
<p><code>bufio.Writer</code> 实现了 Write 方法：</p>
<pre><code class="go">func (b *Writer) Write(p []byte) (nn int, err error)
</code></pre>
<p>它还有一个工厂函数：传给它一个 <code>io.Writer</code> 类型的参数，它会返回一个缓冲的 <code>bufio.Writer</code> 类型的 <code>io.Writer</code>:</p>
<pre><code class="go">func NewWriter(wr io.Writer) (b *Writer)
</code></pre>
<p>其适合任何形式的缓冲写入。</p>
<p>在缓冲写入的最后要使用 <code>Flush()</code>，否则最后的输出不会被写入。</p>
<h2 id="数据格式处理"><a href="#数据格式处理" class="headerlink" title="数据格式处理"></a>数据格式处理</h2><p>数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式。</p>
<p>结构可能包含二进制数据，如果将其作为文本打印，那么可读性是很差的。另外结构内部可能包含匿名字段，而不清楚数据的用意。</p>
<p>通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。</p>
<p>下面是一些术语说明：</p>
<ul>
<li>数据结构 –&gt; 指定格式 &#x3D; <code>序列化</code> 或 <code>编码</code>（传输之前）</li>
<li>指定格式 –&gt; 数据格式 &#x3D; <code>反序列化</code> 或 <code>解码</code>（传输之后）</li>
</ul>
<p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p>
<p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p>
<p>通常 JSON 被用于 web 后端和浏览器之间的通讯，但是在其它场景也同样的有用。</p>
<h3 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h3><pre><code class="go">// json.go
package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
)

type Address struct &#123;
    Type    string
    City    string
    Country string
&#125;

type VCard struct &#123;
    FirstName string
    LastName  string
    Addresses []*Address
    Remark    string
&#125;

func main() &#123;
    pa := &amp;Address&#123;&quot;private&quot;, &quot;Aartselaar&quot;, &quot;Belgium&quot;&#125;
    wa := &amp;Address&#123;&quot;work&quot;, &quot;Boom&quot;, &quot;Belgium&quot;&#125;
    vc := VCard&#123;&quot;Jan&quot;, &quot;Kersschot&quot;, []*Address&#123;pa, wa&#125;, &quot;none&quot;&#125;
    // fmt.Printf(&quot;%v: \n&quot;, vc) // &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;:
    // JSON format:
    js, _ := json.Marshal(vc)
    fmt.Printf(&quot;JSON format: %s&quot;, js)
    // using an encoder:
    file, _ := os.OpenFile(&quot;vcard.json&quot;, os.O_CREATE|os.O_WRONLY, 0666)
    defer file.Close()
    enc := json.NewEncoder(file)
    err := enc.Encode(vc)
    if err != nil &#123;
        log.Println(&quot;Error in encoding json&quot;)
    &#125;
&#125;
</code></pre>
<p><code>json.Marshal()</code> 的函数签名是 <code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code>，下面是数据编码后的 JSON 文本（实际上是一个 [] byte）：</p>
<pre><code class="javascript">&#123;
    &quot;FirstName&quot;: &quot;Jan&quot;,
    &quot;LastName&quot;: &quot;Kersschot&quot;,
    &quot;Addresses&quot;: [&#123;
        &quot;Type&quot;: &quot;private&quot;,
        &quot;City&quot;: &quot;Aartselaar&quot;,
        &quot;Country&quot;: &quot;Belgium&quot;
    &#125;, &#123;
        &quot;Type&quot;: &quot;work&quot;,
        &quot;City&quot;: &quot;Boom&quot;,
        &quot;Country&quot;: &quot;Belgium&quot;
    &#125;],
    &quot;Remark&quot;: &quot;none&quot;
&#125;
</code></pre>
<p>出于安全考虑，在 web 应用中最好使用 <code>json.MarshalforHTML()</code> 函数，其对数据执行 HTML 转码，所以文本可以被安全地嵌在 HTML <code>&lt;script&gt;</code> 标签中。</p>
<p><code>json.NewEncoder()</code> 的函数签名是 <code>func NewEncoder(w io.Writer) *Encoder</code>，返回的 Encoder 类型的指针可调用方法 <code>Encode(v interface&#123;&#125;)</code>，将数据对象 v 的 json 编码写入 <code>io.Writer</code> w 中。</p>
<p>JSON 与 Go 类型对应如下：</p>
<ul>
<li>bool 对应 JSON 的 booleans</li>
<li>float64 对应 JSON 的 numbers</li>
<li>string 对应 JSON 的 strings</li>
<li>nil 对应 JSON 的 null</li>
</ul>
<p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p>
<ul>
<li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map [string] T（T 是 <code>json</code> 包中支持的任何类型）</li>
<li>Channel，复杂类型和函数类型不能被编码</li>
<li>不支持循环数据结构；它将引起序列化进入一个无限循环</li>
<li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li>
</ul>
<h4 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h4><p><code>UnMarshal()</code> 的函数签名是 <code>func Unmarshal(data []byte, v interface&#123;&#125;) error</code> 把 JSON 解码为数据结构。</p>
<p>示例中对 vc 编码后的数据为 <code>js</code> ，对其解码时，首先创建结构 VCard 用来保存解码的数据：<code>var v VCard</code> 并调用 <code>json.Unmarshal(js, &amp;v)</code>，解析 [] byte 中的 JSON 数据并将结果存入指针 &amp;v 指向的值。</p>
<p>虽然反射能够让 JSON 字段去尝试匹配目标结构字段；但是只有真正匹配上的字段才会填充数据。字段没有匹配不会报错，而是直接忽略掉。</p>
<h4 id="解码任意的数据："><a href="#解码任意的数据：" class="headerlink" title="解码任意的数据："></a>解码任意的数据：</h4><p>json 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中。</p>
<p>假设有一个 JSON 数据，被存储在变量 b 中：</p>
<pre><code class="go">b := []byte(`&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;`)
</code></pre>
<p>不用理解这个数据的结构，可以直接使用 Unmarshal 把这个数据编码并保存在接口值中：</p>
<pre><code class="go">var f interface&#123;&#125;
err := json.Unmarshal(b, &amp;f)
</code></pre>
<p>f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：</p>
<pre><code class="go">map[string]interface&#123;&#125; &#123;
    &quot;Name&quot;: &quot;Wednesday&quot;,
    &quot;Age&quot;:  6,
    &quot;Parents&quot;: []interface&#123;&#125; &#123;
        &quot;Gomez&quot;,
        &quot;Morticia&quot;,
    &#125;,
&#125;
</code></pre>
<p>要访问这个数据，可以使用类型断言</p>
<pre><code class="go">m := f.(map[string]interface&#123;&#125;)
</code></pre>
<p>可以通过 for range 语法和 type switch 来访问其实际类型：</p>
<pre><code class="go">for k, v := range m &#123;
    switch vv := v.(type) &#123;
    case string:
        fmt.Println(k, &quot;is string&quot;, vv)
    case int:
        fmt.Println(k, &quot;is int&quot;, vv)

    case []interface&#123;&#125;:
        fmt.Println(k, &quot;is an array:&quot;)
        for i, u := range vv &#123;
            fmt.Println(i, u)
        &#125;
    default:
        fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)
    &#125;
&#125;
</code></pre>
<p>通过这种方式，可以处理未知的 JSON 数据，同时可以确保类型安全。</p>
<h4 id="解码数据到结构"><a href="#解码数据到结构" class="headerlink" title="解码数据到结构"></a>解码数据到结构</h4><p>如果事先知道 JSON 数据，可以定义一个适当的结构并对 JSON 数据反序列化。下面的例子中，将定义：</p>
<pre><code class="go">type FamilyMember struct &#123;
    Name    string
    Age     int
    Parents []string
&#125;
</code></pre>
<p>并对其反序列化：</p>
<pre><code class="go">var m FamilyMember
err := json.Unmarshal(b, &amp;m)
</code></pre>
<p>程序实际上是分配了一个新的切片。这是一个典型的反序列化引用类型（指针、切片和 map）的例子。</p>
<h4 id="编码和解码流"><a href="#编码和解码流" class="headerlink" title="编码和解码流"></a>编码和解码流</h4><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p>
<pre><code class="go">func NewDecoder(r io.Reader) *Decoder
func NewEncoder(w io.Writer) *Encoder
</code></pre>
<p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode ()；反过来与其对应的是使用 json.Decoder 和 Decode () 函数：</p>
<pre><code class="go">func NewDecoder(r io.Reader) *Decoder
func (dec *Decoder) Decode(v interface&#123;&#125;) error
</code></pre>
<p>来看下接口是如何对实现进行抽象的：数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。</p>
<h3 id="XML-数据格式"><a href="#XML-数据格式" class="headerlink" title="XML 数据格式"></a>XML 数据格式</h3><pre><code class="xml">&lt;Person&gt;
    &lt;FirstName&gt;Laura&lt;/FirstName&gt;
    &lt;LastName&gt;Lynn&lt;/LastName&gt;
&lt;/Person&gt;
</code></pre>
<p>如同 json 包一样，也有 <code>Marshal()</code> 和 <code>UnMarshal()</code> 从 XML 中编码和解码数据；但这个更通用，可以从文件中读取和写入（或者任何实现了 io.Reader 和 io.Writer 接口的类型）</p>
<p>和 JSON 的方式一样，XML 数据可以序列化为结构，或者从结构反序列化为 XML 数据；</p>
<p><code>encoding/xml</code> 包实现了一个简单的 XML 解析器（SAX），用来解析 XML 数据内容。</p>
<pre><code class="go">// xml.go
package main

import (
    &quot;encoding/xml&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)

var t, token xml.Token
var err error

func main() &#123;
    input := &quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;/FirstName&gt;&lt;LastName&gt;Lynn&lt;/LastName&gt;&lt;/Person&gt;&quot;
    inputReader := strings.NewReader(input)
    p := xml.NewDecoder(inputReader)

    for t, err = p.Token(); err == nil; t, err = p.Token() &#123;
        switch token := t.(type) &#123;
        case xml.StartElement:
            name := token.Name.Local
            fmt.Printf(&quot;Token name: %s\n&quot;, name)
            for _, attr := range token.Attr &#123;
                attrName := attr.Name.Local
                attrValue := attr.Value
                fmt.Printf(&quot;An attribute is: %s %s\n&quot;, attrName, attrValue)
                // ...
            &#125;
        case xml.EndElement:
            fmt.Println(&quot;End of token&quot;)
        case xml.CharData:
            content := string([]byte(token))
            fmt.Printf(&quot;This is the content: %v\n&quot;, content)
            // ...
        default:
            // ...
        &#125;
    &#125;
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="php">Token name: Person
Token name: FirstName
This is the content: Laura
End of token
Token name: LastName
This is the content: Lynn
End of token
End of token
</code></pre>
<p>包中定义了若干 XML 标签类型：StartElement，Chardata（这是从开始标签到结束标签之间的实际文本），EndElement，Comment，Directive 或 ProcInst。</p>
<p>包中同样定义了一个结构解析器：<code>NewParser</code> 方法持有一个 io.Reader（这里具体类型是 strings.NewReader）并生成一个解析器类型的对象。还有一个 <code>Token()</code> 方法返回输入流里的下一个 XML token。在输入流的结尾处，会返回（nil，io.EOF）</p>
<p>XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 <code>[] byte</code>，通过字符串转换让其变得可读性强一些。</p>
<h3 id="Gob-数据格式"><a href="#Gob-数据格式" class="headerlink" title="Gob 数据格式"></a>Gob 数据格式</h3><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 <code>encoding</code> 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。</p>
<p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。</p>
<p>它和 JSON 或 XML 有什么不同呢？Gob 特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</p>
<p>Gob 不是可外部定义，语言无关的编码方式。因此它的首选格式是二进制，而不是像 JSON 和 XML 那样的文本格式。<br>Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</p>
<p>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p>
<p>只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</p>
<p>假如在发送者这边有一个有结构 T：</p>
<pre><code class="go">type T struct &#123; X, Y, Z int &#125;
var t = T&#123;X: 7, Y: 0, Z: 8&#125;
</code></pre>
<p>而在接收者这边可以用一个结构体 U 类型的变量 u 来接收这个值：</p>
<pre><code class="go">type U struct &#123; X, Y *int8 &#125;
var u U
</code></pre>
<p>在接收者中，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）</p>
<p>和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode</code>。</p>
<p>&#96;&#96;&#96;go<br>&#x2F;&#x2F; gob1.go<br>package main</p>
<p>import (<br>    “bytes”<br>    “fmt”<br>    “encoding&#x2F;gob”<br>    “log”<br>)</p>
<p>type P struct {<br>    X, Y, Z int<br>    Name    string<br>}</p>
<p>type Q struct {<br>    X, Y *int32<br>    Name string<br>}</p>
<p>func main() {<br>    &#x2F;&#x2F; Initialize the encoder and decoder.  Normally enc and dec would be<br>    &#x2F;&#x2F; bound to network connections and the encoder and decoder would<br>    &#x2F;&#x2F; run in different processes.<br>    var network bytes.Buffer   &#x2F;&#x2F; Stand-in for a network connection<br>    enc :&#x3D; gob.NewEncoder(&amp;network) &#x2F;&#x2F; Will write to network.<br>    dec :&#x3D; gob.NewDecoder(&amp;network) &#x2F;&#x2F; Will read from network.<br>    &#x2F;&#x2F; Encode (send) the value.<br>    err :&#x3D; enc.Encode(P{3, 4, 5, “Pythagoras”})<br>    if err !&#x3D; nil {<br>        log.Fatal(“encode error:”, err)<br>    }<br>    &#x2F;&#x2F; Decode (receive) the value.<br>    var q Q<br>    err &#x3D; dec.Decode(&amp;q)<br>    if err !&#x3D; nil {<br>        log.Fatal(“decode error:”, err)<br>    }<br>    fmt.Printf(“%q: </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/11/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="Dubbo源码解析">
                  <i class="fa fa-chevron-left"></i> Dubbo源码解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:03</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
