<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>go 入门</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">go 入门</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包"><span class="toc-text">包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出名"><span class="toc-text">导出名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本变量类型"><span class="toc-text">基本变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型推导"><span class="toc-text">类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间和日期"><span class="toc-text">时间和日期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数值常量"><span class="toc-text">数值常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数语法"><span class="toc-text">函数语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回值"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数值"><span class="toc-text">函数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-函数"><span class="toc-text">init 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变长参数"><span class="toc-text">变长参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的闭包"><span class="toc-text">函数的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的应用"><span class="toc-text">闭包的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#将函数作为返回值"><span class="toc-text">将函数作为返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用闭包调试（暂时没搞懂）"><span class="toc-text">使用闭包调试（暂时没搞懂）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一元运算符"><span class="toc-text">一元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二元运算符"><span class="toc-text">二元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片"><span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nil-切片"><span class="toc-text">nil 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建切片"><span class="toc-text">创建切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make（）和-new（）的区别"><span class="toc-text">make（）和 new（）的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝切片"><span class="toc-text">拷贝切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向切片追加元素"><span class="toc-text">向切片追加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#append-函数常见操作"><span class="toc-text">append 函数常见操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存优化"><span class="toc-text">内存优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range"><span class="toc-text">Range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes包"><span class="toc-text">bytes包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#搜索及排序切片的数组"><span class="toc-text">搜索及排序切片的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串拼接"><span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-操作相关-API"><span class="toc-text">String 操作相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#strings-包"><span class="toc-text">strings 包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#前缀和后缀"><span class="toc-text">前缀和后缀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串包含关系"><span class="toc-text">字符串包含关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#判断子字符串或字符在父字符串中出现的位置（索引）"><span class="toc-text">判断子字符串或字符在父字符串中出现的位置（索引）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串替换"><span class="toc-text">字符串替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#统计字符串出现次数"><span class="toc-text">统计字符串出现次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重复字符串"><span class="toc-text">重复字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改字符串大小写"><span class="toc-text">修改字符串大小写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修剪字符串"><span class="toc-text">修剪字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分割字符串"><span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拼接-slice-到字符串"><span class="toc-text">拼接 slice 到字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从字符串中读取内容"><span class="toc-text">从字符串中读取内容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strconv-包"><span class="toc-text">strconv 包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的内部结构"><span class="toc-text">字符串的内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射"><span class="toc-text">映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-容量"><span class="toc-text">map 容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改映射"><span class="toc-text">修改映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-类型的切片"><span class="toc-text">map 类型的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历-map"><span class="toc-text">遍历 map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体指针"><span class="toc-text">结构体指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体文法"><span class="toc-text">结构体文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名字段"><span class="toc-text">匿名字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体的内存布局"><span class="toc-text">结构体的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提升字段（Promoted-Fields）"><span class="toc-text">提升字段（Promoted Fields）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体相等性（Structs-Equality）"><span class="toc-text">结构体相等性（Structs Equality）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归结构体"><span class="toc-text">递归结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树"><span class="toc-text">二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体工厂"><span class="toc-text">结构体工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何强制使用工厂方法"><span class="toc-text">如何强制使用工厂方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-和-struct-vs-new-和-make"><span class="toc-text">map 和 struct vs new () 和 make ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带标签的结构体"><span class="toc-text">带标签的结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制语句"><span class="toc-text">流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针接收者"><span class="toc-text">指针接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带指针参数的函数和指针接收者的方法对比"><span class="toc-text">带指针参数的函数和指针接收者的方法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择指针作为接受者的好处"><span class="toc-text">选择指针作为接受者的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的内嵌"><span class="toc-text">方法的内嵌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型的-String-方法和格式化描述符"><span class="toc-text">类型的 String() 方法和格式化描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收和-SetFinalizer"><span class="toc-text">垃圾回收和 SetFinalizer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口的隐式实现"><span class="toc-text">接口的隐式实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口嵌套接口"><span class="toc-text">接口嵌套接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口值"><span class="toc-text">接口值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#底层值（调用接口方法的变量）为-nil-的接口值"><span class="toc-text">底层值（调用接口方法的变量）为 nil 的接口值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nil-接口值"><span class="toc-text">nil 接口值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空接口"><span class="toc-text">空接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型断言"><span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型选择"><span class="toc-text">类型选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口实现中的指针接受者与值接受者"><span class="toc-text">接口实现中的指针接受者与值接受者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用接口方法"><span class="toc-text">常用接口方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stringer"><span class="toc-text">Stringer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-错误"><span class="toc-text">Error 错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader-接口"><span class="toc-text">Reader 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图像-image"><span class="toc-text">图像 image</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过反射修改-设置-值"><span class="toc-text">通过反射修改 (设置) 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射结构体"><span class="toc-text">反射结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Int-和-String-方法"><span class="toc-text">Int() 和 String() 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写数据"><span class="toc-text">读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取用户的输入"><span class="toc-text">读取用户的输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读文件"><span class="toc-text">读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#其他读文件方式"><span class="toc-text">其他读文件方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将整个文件的内容读取到一个字符串里"><span class="toc-text">将整个文件的内容读取到一个字符串里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带缓冲的读取"><span class="toc-text">带缓冲的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按列读取文件中的数据"><span class="toc-text">按列读取文件中的数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取压缩文件"><span class="toc-text">读取压缩文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写文件"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件拷贝"><span class="toc-text">文件拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fmt-Fprintf"><span class="toc-text">fmt.Fprintf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据格式处理"><span class="toc-text">数据格式处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-数据格式"><span class="toc-text">JSON 数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反序列化："><span class="toc-text">反序列化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解码任意的数据："><span class="toc-text">解码任意的数据：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解码数据到结构"><span class="toc-text">解码数据到结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编码和解码流"><span class="toc-text">编码和解码流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML-数据格式"><span class="toc-text">XML 数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gob-数据格式"><span class="toc-text">Gob 数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密"><span class="toc-text">加密</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误异常处理"><span class="toc-text">错误异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义错误"><span class="toc-text">定义错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用-fmt-创建错误对象"><span class="toc-text">用 fmt 创建错误对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从-panic-恢复（Recover）"><span class="toc-text">从 panic 恢复（Recover）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义包中的错误处理和-panicking"><span class="toc-text">自定义包中的错误处理和 panicking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-中的单元测试和基准测试"><span class="toc-text">Go 中的单元测试和基准测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#测试的具体例子"><span class="toc-text">测试的具体例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-程"><span class="toc-text">go 程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信道"><span class="toc-text">信道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单向信道"><span class="toc-text">单向信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带缓冲的信道"><span class="toc-text">带缓冲的信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭信道"><span class="toc-text">关闭信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup"><span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作池的实现"><span class="toc-text">工作池的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-语句"><span class="toc-text">select 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁和通道应用场景"><span class="toc-text">锁和通道应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络应用"><span class="toc-text">网络应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-服务器"><span class="toc-text">tcp 服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http服务器"><span class="toc-text">Http服务器</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/go"><i class="tag post-item-tag">go</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">go 入门</h1><time class="has-text-grey" datetime="2020-07-17T16:15:14.000Z">2020-07-18</time><article class="mt-2 post-content"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p>
<h2 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h2><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包。</p>
<p><code>pizza</code> 和 <code>pi</code> 并未以大写字母开头，所以它们是未导出的。</p>
<p>在导入一个包时，只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。</p>
<a id="more"></a>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p>
<pre><code class="go">var x int;</code></pre>
<p>变量声明可以包含初始值，每个变量对应一个。如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, &quot;no!&quot;
    fmt.Println(i, j, c, python, java)
}</code></pre>
<p>函数内部的变量（局部变量）可以采用简洁赋值语句 <code>:=</code> 在类型明确的地方代替 <code>var</code> 声明变量：（仅限函数内部）</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var i, j int = 1, 2
    k := 3
    c, python, java := true, false, &quot;no!&quot;

    fmt.Println(i, j, k, c, python, java)
}</code></pre>
<h3 id="基本变量类型"><a href="#基本变量类型" class="headerlink" title="基本变量类型"></a>基本变量类型</h3><p>Go 的基本类型有</p>
<pre><code class="go">bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 表示一个 Unicode 码点

float32 float64

// 复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。
complex64 complex128    // 32、64 位实数和虚数</code></pre>
<p>对于有符号整型，范围如下：</p>
<p><strong>int8</strong>：表示 8 位有符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：-128～127</p>
<p><strong>int16</strong>：表示 16 位有符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：-32768～32767</p>
<p><strong>int32</strong>：表示 32 位有符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：-2147483648～2147483647</p>
<p><strong>int64</strong>：表示 64 位有符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：-9223372036854775808～9223372036854775807</p>
<p>对于无符号整型，其范围如下：</p>
<p><strong>uint8</strong>：表示 8 位无符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：0～255</p>
<p><strong>uint16</strong>：表示 16 位无符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：0～65535</p>
<p><strong>uint32</strong>：表示 32 位无符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：0～4294967295</p>
<p><strong>uint64</strong>：表示 64 位无符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：0～18446744073709551615</p>
<p>同导入语句一样，变量声明也可以“分组”成一个语法块：</p>
<pre><code class="go">var (
    ToBe   bool       = false
    MaxInt uint64     = 1&lt;&lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)</code></pre>
<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当需要一个整数值时应使用 <code>int</code> 类型，除非有特殊的理由使用固定大小或无符号的整数类型。int 型是计算最快的一种类型。</p>
<p>float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，在使用 <code>==</code> 或者 <code>!=</code> 来比较浮点数时应当非常小心。最好在正式使用前测试对于精确度要求较高的运算。</p>
<p>应该尽可能地使用 float64，因为 <code>math</code> 包中所有有关数学运算的函数都会要求接收这个类型。</p>
<p>可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。</p>
<p>可以使用 <code>a := uint64(0)</code> 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。</p>
<p>当进行类似 <code>a32bitInt = int32(a32Float)</code> 的转换时，小数点后的数字将被丢弃。这种情况一般发生当从取值范围较大的类型转换为取值范围较小的类型时，或者可以写一个专门用于处理类型转换的函数来确保没有发生精度的丢失。</p>
<p>对于虚数，</p>
<pre><code class="go">var c1 complex64 = 5 + 10i
fmt.Printf(&quot;The value is: %v&quot;, c1)
// 输出： 5 + 10i</code></pre>
<p>如果 <code>re</code> 和 <code>im</code> 的类型均为 float32，那么类型为 complex64 的复数 c 可以通过以下方式来获得：</p>
<pre><code class="go">c = complex(re, im)</code></pre>
<p>函数 <code>real(c)</code> 和 <code>imag(c)</code> 可以分别获得相应的实数和虚数部分。</p>
<p>在使用格式化说明符时，可以使用 <code>%v</code> 来表示复数，但当希望只表示其中的一个部分的时候需要使用 <code>%f</code>。</p>
<p>复数支持和其它数字类型一样的运算。当使用等号 <code>==</code> 或者不等号 <code>!=</code> 对复数进行比较运算时，注意对精确度的把握。<code>cmath</code> 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。</p>
<p>Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用</p>
<p> 变量初始值：</p>
<ul>
<li>数值类型为 <code>0</code></li>
<li>布尔类型为 <code>false</code></li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）</li>
<li>指针为<code>nil</code></li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>
<p>例子如下：</p>
<pre><code class="go">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)</code></pre>
<p>也可以是这种形式：</p>
<pre><code class="go">i := 42
f := float64(i)
u := uint(f)</code></pre>
<p>Go 在不同类型的项之间赋值时需要显式转换，如：</p>
<pre><code class="go">func main() {
    var x, y int = 3, 4
  //这一句会报错，因为没有执行 math.Sqrt 的返回类型
    var f float64 = math.Sqrt((x*x + y*y))
  //正确做法
  var f float64 = math.Sqrt(float64(x*x + y*y))
    var z uint = uint(f)
    fmt.Println(x, y, z)
}</code></pre>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>
<p>当右值声明了类型时，新变量的类型与其相同：</p>
<pre><code class="go">var i int
j := i // j 也是一个 int</code></pre>
<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p>
<pre><code class="go">i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128</code></pre>
<p>对于能够确定初始值的变量，推荐使用这种方式进行初始化。</p>
<h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。</p>
<p>当前时间可以使用 <code>time.Now()</code> 获取，或者使用 <code>t.Day()</code>、<code>t.Minute()</code> 等等来获取时间的一部分；甚至可以自定义时间格式化字符串，例如： <code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>21.07.2011</code>。</p>
<p>Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。</p>
<p>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。</p>
<p>一般的格式化设计是通过对于一个标准时间的格式化描述来展现的：</p>
<pre><code class="go">fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) </code></pre>
<p>输出：</p>
<pre><code class="php">21 Jul 2011 10:31</code></pre>
<p>示例：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var week time.Duration
func main() {
    t := time.Now()
    fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011
    fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())
    // 21.12.2011
    t = time.Now().UTC()
    fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011
    fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011
    // calculating times:
    week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec
    week_from_now := t.Add(week)
    fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011
    // formatting times:
    fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC
    fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011
    fmt.Println(t.Format(&quot;21 Dec 2011 08:52&quot;)) // 21 Dec 2011 08:52
    s := t.Format(&quot;20111221&quot;)
    fmt.Println(t, &quot;=&gt;&quot;, s)
    // Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221
}</code></pre>
<p>输出的结果已经写在每行 <code>//</code> 的后面。</p>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。另外，<code>time.Sleep（Duration d）</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量只可以是字符、字符串、布尔值或数值。</p>
<p>常量不能用 <code>:=</code> 语法声明。</p>
<p>由于常量已经初始化，所以可以不指定类型。</p>
<p>常量的值必须是能够在编译时就能够确定的。</p>
<p><strong>常量默认是无类型的</strong>，如果要创建一个有类型的常量，可以使用下面的语法：</p>
<pre><code class="go">const typedhello string = &quot;Hello World&quot;</code></pre>
<pre><code class="go">package main

import &quot;fmt&quot;

const Pi = 3.14

func main() {
    const World = &quot;世界&quot;
    fmt.Println(&quot;Hello&quot;, World)
    fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)

    const Truth = true
    fmt.Println(&quot;Go rules?&quot;, Truth)
}</code></pre>
<h3 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h3><p>数值常量是高精度的<strong>值</strong>。</p>
<p>一个未指定类型的常量由上下文来决定其类型。</p>
<p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>
<p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p>
<pre><code class="go">package main

import &quot;fmt&quot;

const (
    // 将 1 左移 100 位来创建一个非常大的数字
    // 即这个数的二进制是 1 后面跟着 100 个 0
    Big = 1 &lt;&lt; 100
    // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2
    Small = Big &gt;&gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
  //超过范围报错
    fmt.Println(needInt(Big))
}</code></pre>
<p>数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：</p>
<pre><code class="go">const Ln2= 0.693147180559945309417232121458\
            176568075500134360255254120680009
const Log2E= 1/Ln2 // this is a precise reciprocal
const Billion = 1e9 // float constant
const hardEight = (1 &lt;&lt; 100) &gt;&gt; 97</code></pre>
<p>根据上面的例子可以看到，反斜杠 <code>\</code> 可以在常量表达式中作为多行的连接符使用。</p>
<p>与各种类型的数字型变量相比，无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。</p>
<p>不过需要注意的是，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。</p>
<p>常量还可以用作枚举：</p>
<pre><code class="go">const (
    Unknown = 0
    Female = 1
    Male = 2
)</code></pre>
<p>现在，数字 0、1 和 2 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值,比如使用 switch/case 结构 </p>
<p>在这个例子中，iota 可以被用作枚举值：</p>
<pre><code class="go">const (
    a = iota
    b = iota
    c = iota
)</code></pre>
<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<pre><code class="go">const (
    a = iota
    b
    c
)</code></pre>
<p>iota 也可以用在表达式中，如：<code>iota + 50</code>。在每遇到一个新的常量块或单个常量声明时， iota 都会重置为 0（ 简单地讲，每遇到一次 const 关键字，iota 就重置为 0 ）。</p>
<p>当然，常量之所以为常量就是恒定不变的量，因此无法在程序运行过程中修改它的值；如果在代码中试图修改常量的值则会引发编译错误。</p>
<p>引用 time 包中的一段代码作为示例：一周中每天的名称。</p>
<pre><code class="go">const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)</code></pre>
<p>也可以使用某个类型作为枚举常量的类型：</p>
<pre><code class="go">type Color int

const (
    RED Color = iota // 0
    ORANGE // 1
    YELLOW // 2
    GREEN // ..
    BLUE
    INDIGO
    VIOLET // 6
)</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h3><p>方法名/变量名在前，属性/返回类型在后。</p>
<blockquote>
<p>官网解释是可读性更强，现在还没习惯感觉怪怪的</p>
</blockquote>
<pre><code class="go">package main

import &quot;fmt&quot;

func add(x int, y int) int {
    return x + y
}

//上述方式可以写成：表示 x,y 都是 int
func add(x,y int) int {
  //...
}

func main() {
    fmt.Println(add(42, 13))
}
</code></pre>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数可以返回任意数量的返回值。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func swap(x, y string) (string, string) {
    return y, x
}</code></pre>
<p>返回值命名：go 的返回值可以被命名，会将是视为预先在函数里定义的变量，当直接写 <code>return</code> 时表示返回命名的返回值变量：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
  //相当于定义了：
  // var x int;
  // var y int;
    x = sum * 4 / 9
    y = sum - x
  //相当于 return x,y
    return
}</code></pre>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>函数也是值。它们可以像其它值一样传递。</p>
<p>函数值可以用作函数的参数或返回值，然后在其它函数内调用执行，一般称之为回调。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func compute(fn func(float64, float64) float64) float64 {
  //回调 fn
    return fn(3, 4)
}

func main() {
    hypot := func(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }
    fmt.Println(hypot(5, 12))

    fmt.Println(compute(hypot))
    fmt.Println(compute(math.Pow))
}</code></pre>
<p>Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 <code>Function(arg1)</code>。</p>
<p>如果希望函数可以直接修改参数的值，而不是对参数的副本进行操作，需要将参数的地址（变量名前面添加 &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 <code>Function(&amp;arg1)</code>，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。（<strong>译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。</strong>）</p>
<p>几乎在任何情况下，传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少。</p>
<p>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。</p>
<p>有些函数只是完成一个任务，并没有返回值。我们仅仅是利用了这种函数的副作用，就像输出文本到终端，发送一个邮件或者是记录一个错误等。</p>
<p>但是绝大部分的函数还是带有返回值的。</p>
<h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。</p>
<p>每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。</p>
<p>一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。</p>
<p>init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 <code>backend()</code>：</p>
<pre><code class="go">func init() {
   // setup preparations
   go backend()
}</code></pre>
<p>包的初始化顺序如下：</p>
<ol>
<li>首先初始化包级别（Package Level）的变量</li>
<li>紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。</li>
</ol>
<p>如果一个包导入了另一个包，会先初始化被导入的包。</p>
<p>尽管一个包可能会被导入多次，但是它只会被初始化一次。</p>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>函数的最后一个参数是采用 <code>...type</code> 的形式，表示这是一个可变长参数，必须放在最后一个参数</p>
<pre><code class="go">func myFunc(a, b, arg ...int) {}</code></pre>
<p><strong>可变参数函数的工作原理是把可变参数转换为一个新的切片。以下面程序为例，<code>find</code> 函数中的可变参数是 89，90，95 。 find 函数接受一个 <code>int</code> 类型的可变参数。因此这三个参数被编译器转换为一个 int 类型切片 <code>int []int{89, 90, 95}</code> 然后被传入 <code>find</code>函数。</strong></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func find(num int, nums ...int) {
    fmt.Printf(&quot;type of nums is %T\n&quot;, nums)
    found := false
    for i, v := range nums {
        if v == num {
            fmt.Println(num, &quot;found at index&quot;, i, &quot;in&quot;, nums)
            found = true
        }
    }
    if !found {
        fmt.Println(num, &quot;not found in &quot;, nums)
    }
    fmt.Printf(&quot;\n&quot;)
}
func main() {
    find(89, 89, 90, 95)
    find(45, 56, 67, 45, 90, 109)
    find(78, 38, 56, 98)
    find(87)
}</code></pre>
<p>因为参数会转化成一个切片，所以对于变长参数，不能直接传递切片，要么一个一个传，要么就需要使用语法糖<code>...</code>：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    x := min(1, 3, 2, 0)
    fmt.Printf(&quot;The minimum is: %d\n&quot;, x)
    slice := []int{7,9,3,5,1}
    x = min(slice...)
    fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)
}

func min(s ...int) int {
    if len(s)==0 {
        return 0
    }
    min := s[0]
    for _, v := range s {
        if v &lt; min {
            min = v
        }
    }
    return min
}</code></pre>
<h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>
<p>闭包也叫做匿名函数，当我们不希望给函数起名字的时候，可以使用匿名函数，例如：<code>func(x, y int) int { return x + y }</code>。</p>
<p>这样的一个函数不能够独立存在（编译器会返回错误：<code>non-declaration statement outside function body</code>），但可以被赋值于某个变量，即保存函数的地址到变量中：<code>fplus := func(x, y int) int { return x + y }</code>，然后通过变量名对函数进行调用：<code>fplus(3,4)</code>。</p>
<p>当然，也可以直接对匿名函数进行调用：<code>func(x, y int) int { return x + y } (3, 4)</code>。</p>
<h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><h5 id="将函数作为返回值"><a href="#将函数作为返回值" class="headerlink" title="将函数作为返回值"></a>将函数作为返回值</h5><p>例如，函数 <code>Adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 x 变量上。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var f = Adder()
    fmt.Print(f(1), &quot; - &quot;)
    fmt.Print(f(20), &quot; - &quot;)
    fmt.Print(f(300))
}

func Adder() func(int) int {
    var x int    // 此处 x 的值只声明了一次，值会被保留
    return func(delta int) int {
        x += delta
        return x
    }
}</code></pre>
<pre><code class="go">1 - 21 - 321</code></pre>
<p>三次调用函数 f 的过程中函数 Adder () 中变量 delta 的值分别为：1、20 和 300。</p>
<p>我们可以看到，在多次调用中，变量 x 的值是被保留的，即 <code>0 + 1 = 1</code>，然后 <code>1 + 20 = 21</code>，最后 <code>21 + 300 = 321</code>：闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</p>
<p>这些局部变量同样可以是参数，例如之前例子中的 <code>Adder(as int)</code>。</p>
<p>一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。下面的函数演示了如何动态返回追加后缀的函数：</p>
<pre><code class="go">func MakeAddSuffix(suffix string) func(string) string {
    return func(name string) string {
        if !strings.HasSuffix(name, suffix) {
            return name + suffix
        }
        return name
    }
}</code></pre>
<p>现在，可以生成如下函数：</p>
<pre><code class="go">addBmp := MakeAddSuffix(&quot;.bmp&quot;)
addJpeg := MakeAddSuffix(&quot;.jpeg&quot;)</code></pre>
<p>然后调用它们：</p>
<pre><code class="go">addBmp(&quot;file&quot;) // returns: file.bmp
addJpeg(&quot;file&quot;) // returns: file.jpeg</code></pre>
<h5 id="使用闭包调试（暂时没搞懂）"><a href="#使用闭包调试（暂时没搞懂）" class="headerlink" title="使用闭包调试（暂时没搞懂）"></a>使用闭包调试（暂时没搞懂）</h5><p>当在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p>
<pre><code class="go">where := func() {
    _, file, line, _ := runtime.Caller(1)
    log.Printf(&quot;%s:%d&quot;, file, line)
}
where()
// some code
where()
// some more code
where()</code></pre>
<p>也可以设置 <code>log</code> 包中的 flag 参数来实现：</p>
<pre><code class="go">log.SetFlags(log.Llongfile)
log.Print(&quot;&quot;)</code></pre>
<p>或使用一个更加简短版本的 <code>where</code> 函数：</p>
<pre><code class="go">var where = log.Print
func func1() {
where()
... some code
where()
... some code
where()
}</code></pre>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>只记录不常见的以备查询：</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>按位补足 <code>^</code>：该运算符与异或运算符一同使用，即 <code>m^x</code>，对于无符号 x 使用 “全部位设置为 1”，对于有符号 x 时使用 <code>m=-1</code>。例如：</p>
<pre><code>^2 = ^10 = -01 ^ 10 = -11（二进制）</code></pre><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul>
<li>位清除 <code>&amp;^</code>：将指定位置上的值设置为 0。</li>
</ul>
<blockquote>
<p>带有 <code>++</code> 和 <code>--</code> 的只能作为语句，而非表达式，<strong>因此 <code>n = i++</code> 这种写法是无效的，其它像 <code>f(i++)</code> 或者 <code>a[i]=b[i++]</code> 这些可以用于 C、C++ 和 Java 中的写法在 Go 中也是不允许的。</strong></p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p>
<p><strong>一个指针变量可以指向任何一个值的内存地址</strong>。它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；可以在指针类型前面加上 <code>*</code> 号（前缀）来获取指针所指向的内容，这里的 <code>*</code> 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p>
<p>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。</p>
<p>一个指针变量通常缩写为 <code>ptr</code>。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<pre><code>var p *int</code></pre><p><strong><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</strong></p>
<pre><code>i := 42
p = &amp;i</code></pre><p><code>*</code> 操作符表示指针指向的底层值。</p>
<pre><code>fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i</code></pre><p>这也就是通常所说的“间接引用”或“重定向”。</p>
<p>go 中指针不能得到一个文字或常量的地址，例如：</p>
<pre><code class="go">const i = 5
ptr := &amp;i //error: cannot take the address of i
ptr2 := &amp;10 //error: cannot take the address of 10</code></pre>
<p>与 C 不同，Go 没有指针运算。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<pre><code class="go">var a [10]int</code></pre>
<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>当数组内容确定时，可以不指定容量，直接赋值：</p>
<pre><code class="go">[]bool{true, true, false}</code></pre>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var a [2]string
    a[0] = &quot;Hello&quot;
    a[1] = &quot;World&quot;
    fmt.Println(a[0], a[1])
  //直接打印数组会有 [] 符号
  fmt.Println(a)

    primes := [6]int{2, 3, 5, 7, 11, 13}
    fmt.Println(primes)
}</code></pre>
<p>Go 语言中的数组是一种<strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。</p>
<p>那么这种方式和 <code>var arr2 [5]int</code> 的区别是什么呢？</p>
<p>arr1 的类型是 <code>*[5]int</code>，而 arr2 的类型是 <code>[5]int</code>。</p>
<p>此时如果把 arr1 赋值给 arr2 ，需要在做一次数组内存的拷贝操作。例如：</p>
<pre><code class="go">arr2 := *arr1    // 对数组进行一次拷贝
arr2[2] = 100</code></pre>
<p>这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p>
<p>所以在函数中数组作为参数传入时，如 <code>func1(arr2)</code>，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（slice）是对数组一个连续片段的引用（该数组称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。</p>
<p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<blockquote>
<p><strong>注意</strong>：切片与数组在语法上的区别在于前面的 [] 有没有指定初始大小</p>
</blockquote>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<pre><code>a[low : high]</code></pre><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p>
<pre><code>a[1:4]</code></pre><pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    primes := [6]int{2, 3, 5, 7, 11, 13}

    var s []int = primes[1:4]
    fmt.Println(s)
}</code></pre>
<p>切片就像数组的引用切片，并不存储任何数据，它只是描述了底层数组中的一段。<strong>更改切片的元素会修改其底层数组中对应的元素</strong>。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    names := [4]string{
        &quot;John&quot;,
        &quot;Paul&quot;,
        &quot;George&quot;,
        &quot;Ringo&quot;,
    }
  //[John Paul George Ringo]
    fmt.Println(names)

  //[John Paul]
    a := names[0:2]
  //[Paul George]
    b := names[1:3]
    fmt.Println(a, b)

    b[0] = &quot;XXX&quot;
  // a:[John XXX],b:[XXX George]
    fmt.Println(a, b)
  //[John XXX George Ringo]
    fmt.Println(names)
}</code></pre>
<p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>
<p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p>
<pre><code class="go">var a [10]int
//等价
a[0:10]
a[:10]
a[0:]
a[:]</code></pre>
<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<p>切片的长度就是它所包含的元素个数。</p>
<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p><strong>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</strong></p>
<p>可以通过重新切片来扩展一个切片，给它提供足够的容量。</p>
<p>切片在内存中的组织结构：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="切片在内存中的组织结构"></p>
<h3 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h3><p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且没有底层数组。</p>
<pre><code class="go">var s []int
len(s) // 0
cap(s) // 0
fmt.Println(s) // []
s == nil // true</code></pre>
<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h3><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<pre><code>a := make([]int, 5)  // len(a)=5</code></pre><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<pre><code class="go">b := make([]int, 0, 5) // len(b)=0, cap(b)=5,[]
c := make([]int,3,10) // [0,0,0]

b = b[:cap(b)] // len(b)=5, cap(b)=5,[0,0,0,0,0]
b = b[1:]      // len(b)=4, cap(b)=4</code></pre>
<p>切片可包含任何类型，甚至包括其它的切片:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    // 创建一个井字板（经典游戏）
    board := [][]string{
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
    }

    // 两个玩家轮流打上 X 和 O
    board[0][0] = &quot;X&quot;
    board[2][2] = &quot;O&quot;
    board[1][2] = &quot;X&quot;
    board[1][0] = &quot;O&quot;
    board[0][2] = &quot;X&quot;

    for i := 0; i &lt; len(board); i++ {
        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))
    }
}</code></pre>
<h3 id="make（）和-new（）的区别"><a href="#make（）和-new（）的区别" class="headerlink" title="make（）和 new（）的区别"></a>make（）和 new（）的区别</h3><p>二者都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p>
<ul>
<li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法<strong>返回一个指向类型为 T，值为 0 的地址的指针</strong>，它适用于值类型如数组和结构体；它相当于 <code>&amp;T{}</code>。</li>
<li>make(T) <strong>返回一个类型为 T 的初始值</strong>，它只适用于 3 种内建的引用类型：切片、map 和 channel。</li>
</ul>
<p>换言之，new 函数分配内存，make 函数初始化；下图给出了区别：</p>
<p><img src="https://qiniu.xiaoming.net.cn/make%E5%92%8Cnew%E5%8C%BA%E5%88%AB.png" alt="make 和 new 区别"></p>
<h3 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h3><p><code>func copy(dst, src []T) int</code> copy 方法将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 <code>src = dst</code>。</p>
<h3 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h3><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。</p>
<pre><code>func append(s []T, vs ...T) []T</code></pre><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p>
<p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var s []int //[]

    // 添加一个空切片
    s = append(s, 0) //[0]

    // 这个切片会按需增长
    s = append(s, 1) //[0 1]

    // 可以一次性添加多个元素
    s = append(s, 2, 3, 4) //[0 1 2 3 4]
}</code></pre>
<h4 id="append-函数常见操作"><a href="#append-函数常见操作" class="headerlink" title="append 函数常见操作"></a>append 函数常见操作</h4><ol>
<li><p>将切片 b 的元素追加到切片 a 之后：<code>a = append(a, b...)</code></p>
</li>
<li><p>复制切片 a 的元素到新的切片 b 上：</p>
<pre><code class="go"> b = make([]T, len(a))
 copy(b, a)</code></pre>
</li>
<li><p>删除位于索引 i 的元素：<code>a = append(a[:i], a[i+1:]...)</code></p>
</li>
<li><p>切除切片 a 中从索引 i 至 j 位置的元素：<code>a = append(a[:i], a[j:]...)</code></p>
</li>
<li><p>为切片 a 扩展 j 个元素长度：<code>a = append(a, make([]T, j)...)</code></p>
</li>
<li><p>在索引 i 的位置插入元素 x：<code>a = append(a[:i], append([]T{x}, a[i:]...)...)</code></p>
</li>
<li><p>在索引 i 的位置插入长度为 j 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></p>
</li>
<li><p>在索引 i 的位置插入切片 b 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></p>
</li>
<li><p>取出位于切片 a 最末尾的元素 x：<code>x, a = a[len(a)-1:], a[:len(a)-1]</code></p>
</li>
<li><p>将元素 x 追加到切片 a：<code>a = append(a, x)</code></p>
</li>
</ol>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存。在内存管理方面，这是需要注意的。假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。这里需要重点注意的是，在切片引用时数组仍然存在内存中。</p>
<p>一种解决方法是使用 <a href="https://golang.org/pkg/builtin/#copy" target="_blank" rel="noopener">copy</a> 函数 <code>func copy(dst，src[]T)int</code> 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func countries() []string {
    countries := []string{&quot;USA&quot;, &quot;Singapore&quot;, &quot;Germany&quot;, &quot;India&quot;, &quot;Australia&quot;}
    neededCountries := countries[:len(countries)-2]
    countriesCpy := make([]string, len(neededCountries))
    copy(countriesCpy, neededCountries) //copies neededCountries to countriesCpy
    return countriesCpy
}
func main() {
    countriesNeeded := countries()
    fmt.Println(countriesNeeded)
}</code></pre>
<p>在上述程序的第 9 行，<code>neededCountries := countries[:len(countries)-2</code> 创建一个去掉尾部 2 个元素的切片 <code>countries</code>，在上述程序的 11 行，将 <code>neededCountries</code> 复制到 <code>countriesCpy</code> 同时在函数的下一行返回 countriesCpy。现在 <code>countries</code> 数组可以被垃圾回收, 因为 <code>neededCountries</code> 不再被引用。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)
    }
}</code></pre>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<pre><code>for i, _ := range pow
for _, value := range pow</code></pre><p>若你只需要索引，忽略第二个变量即可。</p>
<pre><code>for i := range pow</code></pre><h3 id="bytes包"><a href="#bytes包" class="headerlink" title="bytes包"></a>bytes包</h3><p>类型 <code>[]byte</code> 的切片十分常见，Go 语言有一个 bytes 包专门用来解决这种类型的操作方法。</p>
<p>bytes 包和字符串包十分类似（参见第 4.7 节）。而且它还包含一个十分有用的类型 Buffer:</p>
<pre><code class="go">import &quot;bytes&quot;

type Buffer struct {
    ...
}</code></pre>
<p>这是一个长度可变的 bytes 的 buffer，提供 Read 和 Write 方法，因为读写长度未知的 bytes 最好使用 buffer。</p>
<p>Buffer 可以这样定义：<code>var buffer bytes.Buffer</code>。</p>
<p>或者使用 new 获得一个指针：<code>var r *bytes.Buffer = new(bytes.Buffer)</code>。</p>
<p>或者通过函数：<code>func NewBuffer(buf []byte) *Buffer</code>，创建一个 Buffer 对象并且用 buf 初始化好；NewBuffer 最好用在从 buf 读取的时候使用。</p>
<p><strong>通过 buffer 串联字符串</strong></p>
<p>类似于 Java 的 StringBuilder 类。</p>
<p>在下面的代码段中，创建一个 buffer，通过 <code>buffer.WriteString(s)</code> 方法将字符串 s 追加到后面，最后再通过 <code>buffer.String()</code> 方法转换为 <code>string</code>：</p>
<pre><code class="go">var buffer bytes.Buffer
for {
    if s, ok := getNextString(); ok { //method getNextString() not shown here
        buffer.WriteString(s)
    } else {
        break
    }
}
fmt.Print(buffer.String(), &quot;\n&quot;)</code></pre>
<p>这种实现方式比使用 <code>+=</code> 要更节省内存和 CPU，尤其是要串联的字符串数目特别多的时候。</p>
<h3 id="搜索及排序切片的数组"><a href="#搜索及排序切片的数组" class="headerlink" title="搜索及排序切片的数组"></a>搜索及排序切片的数组</h3><p>标准库提供了 <code>sort</code> 包来实现常见的搜索和排序操作。可以使用 <code>sort</code> 包中的函数 <code>func Ints(a []int)</code> 来实现对 int 类型的切片排序。例如 <code>sort.Ints(arri)</code>，其中变量 arri 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可以通过函数 <code>IntsAreSorted(a []int) bool</code> 来检查，如果返回 true 则表示已经被排序。</p>
<p>类似的，可以使用函数 <code>func Float64s(a []float64)</code> 来排序 float64 的元素，或使用函数 <code>func Strings(a []string)</code> 排序字符串元素。</p>
<p>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，就可以使用函数 <code>func SearchInts(a []int, n int) int</code> 进行搜索，并返回对应结果的索引值。</p>
<p>当然，还可以搜索 float64 和字符串：</p>
<pre><code class="go">func SearchFloat64s(a []float64, x float64) int
func SearchStrings(a []string, x string) int</code></pre>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一种值类型，且值不可变，即创建某个文本后无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p>
<p>Go 语言中的字符串是一个字节切片。把内容放在双引号””之间，可以创建一个字符串。由于字符串是一个字节切片，所以可以获取字符串的每一个字节。</p>
<p>字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节。</p>
<p>因此，字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 <code>[]</code> 内写入索引，索引从 0 开始计数：</p>
<ul>
<li>字符串 str 的第 1 个字节：<code>str[0]</code></li>
<li>第 i 个字节：<code>str[i - 1]</code></li>
<li>最后 1 个字节：<code>str[len(str)-1]</code></li>
</ul>
<p>但需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效，对于其他编码，由于使用 UTF-8 编码，一些字符可能占用不止一个字节，这会导致获取单个字节打印出来的字符与实际不符，例子如下：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func printBytes(s string) {
    for i:= 0; i &lt; len(s); i++ {
        fmt.Printf(&quot;%x &quot;, s[i])
    }
}

func printChars(s string) {
    for i:= 0; i &lt; len(s); i++ {
        fmt.Printf(&quot;%c &quot;,s[i])
    }
}

func main() {
    name := &quot;Hello World&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
    fmt.Printf(&quot;\n&quot;)
    name = &quot;Señor&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
}</code></pre>
<p>上面打印的结果是：</p>
<pre><code>48 65 6c 6c 6f 20 57 6f 72 6c 64  
H e l l o   W o r l d  
53 65 c3 b1 6f 72  
S e Ã ± o r</code></pre><p>所以当需要使用遍历字符串的字符时，可以使用 <code>rune</code> ，<code>trune</code> 是Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。用 <code>rune</code> 来打印字符如下：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func printBytes(s string) {
    for i:= 0; i &lt; len(s); i++ {
        fmt.Printf(&quot;%x &quot;, s[i])
    }
}

func printChars(s string) {
    runes := []rune(s)
    for i:= 0; i &lt; len(runes); i++ {
        fmt.Printf(&quot;%c &quot;,runes[i])
    }
}

func main() {
    name := &quot;Hello World&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
    fmt.Printf(&quot;\n\n&quot;)
    name = &quot;Señor&quot;
    printBytes(name)
    fmt.Printf(&quot;\n&quot;)
    printChars(name)
}</code></pre>
<p>另一种比较方便的方式是直接使用 <code>range</code> 遍历字符串。</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><strong>字符串拼接符 <code>+</code></strong></p>
<p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。</p>
<p><code>s2</code> 追加在 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p>
<p>你可以通过以下方式来对代码中多行的字符串进行拼接：</p>
<pre><code class="go">str := &quot;Beginning of the string &quot; +
    &quot;second part of the string&quot;</code></pre>
<p>由于编译器行尾自动补全分号的缘故，加号 <code>+</code> 必须放在第一行。</p>
<p>拼接的简写形式 <code>+=</code> 也可以用于字符串：</p>
<pre><code class="go">s := &quot;hel&quot; + &quot;lo,&quot;
s += &quot;world!&quot;
fmt.Println(s) //输出 “hello, world!”</code></pre>
<p>在循环中使用加号 <code>+</code> 拼接字符串并不是最高效的做法，<strong>更好的办法是使用函数 <code>strings.Join()</code></strong>，最优的方式是<strong>使用字节缓冲（<code>bytes.Buffer</code>）拼接</strong></p>
<h3 id="String-操作相关-API"><a href="#String-操作相关-API" class="headerlink" title="String 操作相关 API"></a>String 操作相关 API</h3><h4 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a>strings 包</h4><p>strings 包定义了一些对字符串的操作。</p>
<h5 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h5><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：</p>
<pre><code class="go">strings.HasPrefix(s, prefix string) bool</code></pre>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：</p>
<pre><code class="go">strings.HasSuffix(s, suffix string) bool</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var str string = &quot;This is an example of a string&quot;
    fmt.Printf(&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;, str, &quot;Th&quot;)
    fmt.Printf(&quot;%t\n&quot;, strings.HasPrefix(str, &quot;Th&quot;))
}</code></pre>
<p>输出：</p>
<pre><code class="php">T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true</code></pre>
<p>这个例子同样演示了转义字符 <code>\</code> 和格式化字符串的使用。</p>
<h5 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h5><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code>：</p>
<pre><code class="php">strings.Contains(s, substr string) bool</code></pre>
<h5 id="判断子字符串或字符在父字符串中出现的位置（索引）"><a href="#判断子字符串或字符在父字符串中出现的位置（索引）" class="headerlink" title="判断子字符串或字符在父字符串中出现的位置（索引）"></a>判断子字符串或字符在父字符串中出现的位置（索引）</h5><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>
<pre><code class="go">strings.Index(s, str string) int</code></pre>
<p><code>LastIndex</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>
<pre><code class="go">strings.LastIndex(s, str string) int</code></pre>
<p>如果 <code>ch</code> 是非 ASCII 编码的字符，建议使用以下函数来对字符进行定位：</p>
<pre><code class="go">strings.IndexRune(s string, r rune) int</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var str string = &quot;Hi, I&#39;m Marc, Hi.&quot;

    fmt.Printf(&quot;The position of \&quot;Marc\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Marc&quot;))

    fmt.Printf(&quot;The position of the first instance of \&quot;Hi\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Hi&quot;))
    fmt.Printf(&quot;The position of the last instance of \&quot;Hi\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.LastIndex(str, &quot;Hi&quot;))

    fmt.Printf(&quot;The position of \&quot;Burger\&quot; is: &quot;)
    fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Burger&quot;))
}</code></pre>
<p>输出：</p>
<pre><code class="php">The position of &quot;Marc&quot; is: 8
The position of the first instance of &quot;Hi&quot; is: 0
The position of the last instance of &quot;Hi&quot; is: 14
The position of &quot;Burger&quot; is: -1</code></pre>
<h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所有字符串 <code>old</code> 为字符串 <code>new</code>：</p>
<pre><code class="go">strings.Replace(str, old, new, n) string</code></pre>
<h5 id="统计字符串出现次数"><a href="#统计字符串出现次数" class="headerlink" title="统计字符串出现次数"></a>统计字符串出现次数</h5><p><code>Count</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数：</p>
<pre><code class="go">strings.Count(s, str string) int</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var str string = &quot;Hello, how is it going, Hugo?&quot;
    var manyG = &quot;gggggggggg&quot;

    fmt.Printf(&quot;Number of H&#39;s in %s is: &quot;, str)
    fmt.Printf(&quot;%d\n&quot;, strings.Count(str, &quot;H&quot;))

    fmt.Printf(&quot;Number of double g&#39;s in %s is: &quot;, manyG)
    fmt.Printf(&quot;%d\n&quot;, strings.Count(manyG, &quot;gg&quot;))
}</code></pre>
<p>输出：</p>
<pre><code>Number of H&#39;s in Hello, how is it going, Hugo? is: 2
Number of double g’s in gggggggggg is: 5</code></pre><h5 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h5><p><code>Repeat</code> 用于重复拼接 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<pre><code class="go">strings.Repeat(s, count int) string</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var origS string = &quot;Hi there! &quot;
    var newS string

    newS = strings.Repeat(origS, 3)
    fmt.Printf(&quot;The new repeated string is: %s\n&quot;, newS)
}</code></pre>
<p>输出：</p>
<pre><code class="php">The new repeated string is: Hi there! Hi there! Hi there!</code></pre>
<h5 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h5><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<pre><code class="go">strings.ToLower(s) string</code></pre>
<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<pre><code class="go">strings.ToUpper(s) string</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    var orig string = &quot;Hey, how are you George?&quot;
    var lower string
    var upper string

    fmt.Printf(&quot;The original string is: %s\n&quot;, orig)
    lower = strings.ToLower(orig)
    fmt.Printf(&quot;The lowercase string is: %s\n&quot;, lower)
    upper = strings.ToUpper(orig)
    fmt.Printf(&quot;The uppercase string is: %s\n&quot;, upper)
}</code></pre>
<p>输出：</p>
<pre><code class="php">The original string is: Hey, how are you George?
The lowercase string is: hey, how are you george?
The uppercase string is: HEY, HOW ARE YOU GEORGE?</code></pre>
<h5 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h5><p>可以使用 <code>strings.TrimSpace(s)</code> 来剔除字符串开头和结尾的空白符号；如果想要剔除指定字符，则可以使用 <code>strings.Trim(s, &quot;cut&quot;)</code> 来将开头和结尾的 <code>cut</code> 去除掉。该函数的第二个参数可以包含任何字符，如果只想剔除开头或者结尾的字符串，则可以使用 <code>TrimLeft</code> 或者 <code>TrimRight</code> 来实现。</p>
<h5 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h5><p><code>strings.Fields(s)</code> 利用空白作为分隔符将字符串分割为若干块，并返回一个 slice 。如果字符串只包含空白符号，返回一个长度为 0 的 slice 。</p>
<p><code>strings.Split(s, sep)</code> 自定义分割符号对字符串分割，返回 slice 。</p>
<p>因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理。</p>
<h5 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h5><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：</p>
<pre><code class="go">strings.Join(sl []string, sep string) string</code></pre>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    str := &quot;The quick brown fox jumps over the lazy dog&quot;
    sl := strings.Fields(str)
    fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl)
    for _, val := range sl {
        fmt.Printf(&quot;%s - &quot;, val)
    }
    fmt.Println()
    str2 := &quot;GO1|The ABC of Go|25&quot;
    sl2 := strings.Split(str2, &quot;|&quot;)
    fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl2)
    for _, val := range sl2 {
        fmt.Printf(&quot;%s - &quot;, val)
    }
    fmt.Println()
    str3 := strings.Join(sl2,&quot;;&quot;)
    fmt.Printf(&quot;sl2 joined by ;: %s\n&quot;, str3)
}</code></pre>
<p>输出：</p>
<pre><code class="php">Splitted in slice: [The quick brown fox jumps over the lazy dog]
The - quick - brown - fox - jumps - over - the - lazy - dog -
Splitted in slice: [GO1 The ABC of Go 25]
GO1 - The ABC of Go - 25 -
sl2 joined by ;: GO1;The ABC of Go;25</code></pre>
<h5 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h5><p>函数 <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取内容的函数还有：</p>
<ul>
<li><code>Read()</code> 从 [] byte 中读取内容。</li>
<li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。</li>
</ul>
<h4 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a>strconv 包</h4><p>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的。</p>
<p>该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。</p>
<p>任何类型 <strong>T</strong> 转换为字符串总是成功的。</p>
<p>针对从数字类型转换到字符串，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。</li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。</li>
</ul>
<p>将字符串转换为其它类型 <strong>tp</strong> 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。</p>
<p>针对从字符串类型转换为数字类型，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。</li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。</li>
</ul>
<p>利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换：</p>
<pre><code class="php">val, err = strconv.Atoi(s)</code></pre>
<p>在下面这个示例中，忽略可能出现的转换错误：</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    var orig string = &quot;666&quot;
    var an int
    var newS string

    fmt.Printf(&quot;The size of ints is: %d\n&quot;, strconv.IntSize)      

    an, _ = strconv.Atoi(orig)
    fmt.Printf(&quot;The integer is: %d\n&quot;, an) 
    an = an + 5
    newS = strconv.Itoa(an)
    fmt.Printf(&quot;The new string is: %s\n&quot;, newS)
}</code></pre>
<p>输出：</p>
<pre><code class="php">64 位系统：
The size of ints is: 64
32 位系统：
The size of ints is: 32
The integer is: 666
The new string is: 671</code></pre>
<h3 id="字符串的内部结构"><a href="#字符串的内部结构" class="headerlink" title="字符串的内部结构"></a>字符串的内部结构</h3><p>内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。因为指针对用户来说是完全不可见，因此我们可以依旧把字符串看做是一个值类型，也就是一个字符数组。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201912/02/1/J9S85ymhtz.png!large" alt="img"></p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键映射到值。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p>在声明的时候不需要知道 map 的长度，map 是可以动态增长的。</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<p>映射的文法与结构体相似，不过必须有键名。</p>
<p>若顶级类型只是一个类型名，可以在文法的元素中省略它。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct {
    Lat, Long float64
}

var m = map[string]Vertex{
    &quot;Bell Labs&quot;: Vertex{
        40.68433, -74.39967,
    },
    &quot;Google&quot;: Vertex{
        37.42202, -122.08408,
    },

  //也可以这样
  &quot;Bell Labs&quot;: {40.68433, -74.39967},
    &quot;Google&quot;:    {37.42202, -122.08408},
}

func main() {
    fmt.Println(m)
}</code></pre>
<p>map 的初始化：<code>var map1 = make(map[keytype]valuetype)</code>。</p>
<p>或者简写为：<code>map1 := make(map[keytype]valuetype)</code>。</p>
<p>例如：<code>mapCreated := make(map[string]float32)</code>，相当于：<code>mapCreated := map[string]float32{}</code>。</p>
<p><strong>不要使用 new，永远用 make 来构造 map</strong></p>
<p><strong>注意</strong> 如果你错误的使用 new () 分配了一个引用对，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p>
<pre><code class="go">mapCreated := new(map[string]float32)</code></pre>
<p>接下来当调用：<code>mapCreated[&quot;key1&quot;] = 4.5</code> 的时候，编译器会报错：</p>
<pre><code class="php">invalid operation: mapCreated[&quot;key1&quot;] (index of type *map[string]float32).</code></pre>
<h3 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h3><p>和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。但是也可以选择标明 map 的初始容量 <code>capacity</code>，就像这样：<code>make(map[keytype]valuetype, cap)</code>。例如：</p>
<pre><code class="go">map2 := make(map[string]float32, 100)</code></pre>
<p>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p>
<h3 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h3><p>在映射 <code>m</code> 中插入或修改元素：</p>
<pre><code>m[key] = elem</code></pre><p>获取元素：</p>
<pre><code>elem = m[key]</code></pre><p>删除元素：</p>
<pre><code>delete(m, key)</code></pre><p>通过双赋值检测某个键是否存在：</p>
<pre><code>elem, ok = m[key]</code></pre><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<pre><code>elem, ok := m[key]</code></pre><h3 id="map-类型的切片"><a href="#map-类型的切片" class="headerlink" title="map 类型的切片"></a>map 类型的切片</h3><p> 如果希望得到 map 类型的切片，我们必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中每个 map 元素</p>
<pre><code class="go">package main
import &quot;fmt&quot;

func main() {
    // Version A:
    items := make([]map[int]int, 5)
    for i:= range items {
        items[i] = make(map[int]int, 1)
        items[i][1] = 2
    }
    fmt.Printf(&quot;Version A: Value of items: %v\n&quot;, items)

    // Version B: NOT GOOD!
    items2 := make([]map[int]int, 5)
    for _, item := range items2 {
        item = make(map[int]int, 1) // item is only a copy of the slice element.
        item[1] = 2 // This &#39;item&#39; will be lost on the next iteration.
    }
    fmt.Printf(&quot;Version B: Value of items: %v\n&quot;, items2)
}</code></pre>
<pre><code class="go">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]
Version B: Value of items: [map[] map[] map[] map[] map[]]</code></pre>
<p>应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。</p>
<h3 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h3><p>可以使用 for 循环构造 map：</p>
<pre><code class="go">for key, value := range map1 {
    ...
}</code></pre>
<p>第一个返回值 key 是 map 中的 key 值，第二个返回值则是该 key 对应的 value 值；这两个都是仅 for 循环内部可见的局部变量。其中第一个返回值 key 值是一个可选元素。如果你关心值，可以这么使用：</p>
<pre><code class="go">for _, value := range map1 {
    ...
}</code></pre>
<p>如果只想获取 key，可以这么使用：</p>
<pre><code class="go">for key := range map1 {
    fmt.Printf(&quot;key is: %d\n&quot;, key)
}</code></pre>
<p><strong>注意 map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的。</strong></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一个结构体（<code>struct</code>）就是一组字段（field）。结构体字段使用点号来访问。</p>
<blockquote>
<p><code>type</code>关键字用于定义别名</p>
</blockquote>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}</code></pre>
<p>声明结构体有两种方式：</p>
<pre><code class="go">type T struct {a, b int}

//第一种方式
var s T
s.a = 5
s.b = 8

//第二种方式
var t *T
t = new(T)</code></pre>
<p>使用 <code>t := new(T)</code>，变量 <code>t</code> 是一个指向 <code>T</code> 的指针，此时结构体字段的值是它们所属类型的零值。</p>
<p>声明 <code>var t T</code> 也会给 <code>t</code> 分配内存，并零值化内存，但是这个时候 <code>t</code> 是类型 T。</p>
<p>在这两种方式中，<code>t</code> 通常被称做类型 T 的一个实例（instance）或对象（object）。</p>
<p>初始化结构体的方式有以下几种：</p>
<pre><code class="go">type Interval struct {
    start int
    end   int
}

//可以在 Interval 前加 &amp;
intr := Interval{0, 3}            (A)
intr := Interval{end:5, start:1}  (B)
intr := Interval{end:5}           (C)</code></pre>
<p>混合字面量语法（composite literal syntax）<code>&amp;struct1{a, b, c}</code> 是一种简写，底层仍然会调用 <code>new ()</code>，这里值的顺序必须按照字段顺序来写。表达式 <code>new(Type)</code> 和 <code>&amp;Type{}</code> 是等价的。</p>
<p>使用 new 初始化：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8new%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="使用new初始化"></p>
<p>作为结构体字面量初始化：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="使用结构体字面量初始化"></p>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>结构体字段可以通过结构体指针来访问。</p>
<p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。语言也允许使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    p := &amp;v
  //表示的是(*p).X
    p.X = 1e9
    fmt.Println(v)
}</code></pre>
<h3 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h3><p>通过直接列出字段的值来新分配一个结构体。</p>
<p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct {
    X, Y int
}

var (
    v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
    v2 = Vertex{X: 1}  // Y:0 被隐式地赋予
    v3 = Vertex{}      // X:0 Y:0
    p  = &amp;Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
)

func main() {
    fmt.Println(v1, p, v2, v3)
}</code></pre>
<h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>当创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。</p>
<p>以下代码创建一个 <code>Person</code> 结构体，它含有两个匿名字段 <code>string</code> 和 <code>int</code>。</p>
<pre><code class="go">type Person struct {  
    string
    int
}</code></pre>
<p>接下来使用匿名字段来编写一个程序。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type Person struct {  
    string
    int
}

func main() {  
    p := Person{&quot;Naveen&quot;, 50}
    fmt.Println(p)
}</code></pre>
<p>在上面的程序中，结构体 <code>Person</code> 有两个匿名字段。<code>p := Person{&quot;Naveen&quot;, 50}</code> 定义了一个 <code>Person</code> 类型的变量。该程序输出 <code>{Naveen 50}</code>。</p>
<p><strong>虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型</strong>。比如在上面的 <code>Person</code> 结构体里，虽说字段是匿名的，但 Go 默认这些字段名是它们各自的类型。所以 <code>Person</code> 结构体有两个名为 <code>string</code> 和 <code>int</code> 的字段。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type Person struct {  
    string
    int
}

func main() {  
    var p1 Person
    p1.string = &quot;naveen&quot;
    p1.int = 50
    fmt.Println(p1)
}</code></pre>
<p>在上面程序的第 14 行和第 15 行，我们访问了 <code>Person</code> 结构体的匿名字段，我们把字段类型作为字段名，分别为 “string” 和 “int”。上面程序的输出如下：</p>
<pre><code>{naveen 50}</code></pre><h3 id="结构体的内存布局"><a href="#结构体的内存布局" class="headerlink" title="结构体的内存布局"></a>结构体的内存布局</h3><p>Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。</p>
<pre><code class="go">type Rect1 struct {Min, Max Point }
type Rect2 struct {Min, Max *Point }</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/o4SlYwuXqy.jpg?imageView2/2/w/1240/h/0" alt="结构体内存布局"></p>
<h3 id="提升字段（Promoted-Fields）"><a href="#提升字段（Promoted-Fields）" class="headerlink" title="提升字段（Promoted Fields）"></a>提升字段（Promoted Fields）</h3><p>如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。</p>
<pre><code class="go">type Address struct {  
    city, state string
}
type Person struct {  
    name string
    age  int
    Address
}</code></pre>
<p>在上面的代码片段中，<code>Person</code> 结构体有一个匿名字段 <code>Address</code>，而 <code>Address</code> 是一个结构体。现在结构体 <code>Address</code> 有 <code>city</code> 和 <code>state</code> 两个字段，访问这两个字段就像在 <code>Person</code> 里直接声明的一样，因此我们称之为提升字段。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

type Address struct {
    city, state string
}
type Person struct {
    name string
    age  int
    Address
}

func main() {  
    var p Person
    p.name = &quot;Naveen&quot;
    p.age = 50
    p.Address = Address{
        city:  &quot;Chicago&quot;,
        state: &quot;Illinois&quot;,
    }
    fmt.Println(&quot;Name:&quot;, p.name)
    fmt.Println(&quot;Age:&quot;, p.age)
    fmt.Println(&quot;City:&quot;, p.city) //city is promoted field
    fmt.Println(&quot;State:&quot;, p.state) //state is promoted field
}</code></pre>
<p>在上面代码中的第 26 行和第 27 行使用了语法 <code>p.city</code> 和 <code>p.state</code>，访问提升字段 <code>city</code> 和 <code>state</code> 就像它们是在结构体 <code>p</code> 中声明的一样。该程序会输出：</p>
<pre><code>Name: Naveen  
Age: 50  
City: Chicago  
State: Illinois</code></pre><h3 id="结构体相等性（Structs-Equality）"><a href="#结构体相等性（Structs-Equality）" class="headerlink" title="结构体相等性（Structs Equality）"></a>结构体相等性（Structs Equality）</h3><p><strong>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的</strong>。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type name struct {  
    firstName string
    lastName string
}


func main() {  
    name1 := name{&quot;Steve&quot;, &quot;Jobs&quot;}
    name2 := name{&quot;Steve&quot;, &quot;Jobs&quot;}
    if name1 == name2 {
        fmt.Println(&quot;name1 and name2 are equal&quot;)
    } else {
        fmt.Println(&quot;name1 and name2 are not equal&quot;)
    }

    name3 := name{firstName:&quot;Steve&quot;, lastName:&quot;Jobs&quot;}
    name4 := name{}
    name4.firstName = &quot;Steve&quot;
    if name3 == name4 {
        fmt.Println(&quot;name3 and name4 are equal&quot;)
    } else {
        fmt.Println(&quot;name3 and name4 are not equal&quot;)
    }
}</code></pre>
<p>在上面的代码中，结构体类型 <code>name</code> 包含两个 <code>string</code> 类型。由于字符串是可比较的，因此可以比较两个 <code>name</code> 类型的结构体变量。</p>
<p>上面代码中 <code>name1</code> 和 <code>name2</code> 相等，而 <code>name3</code> 和 <code>name4</code> 不相等。该程序会输出：</p>
<pre><code>name1 and name2 are equal  
name3 and name4 are not equal</code></pre><p><strong>如果结构体包含不可比较的字段，则结构体变量也不可比较。</strong></p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

type image struct {  
    data map[int]int
}

func main() {  
    image1 := image{data: map[int]int{
        0: 155,
    }}
    image2 := image{data: map[int]int{
        0: 155,
    }}
    if image1 == image2 {
        fmt.Println(&quot;image1 and image2 are equal&quot;)
    }
}</code></pre>
<p>在上面代码中，结构体类型 <code>image</code> 包含一个 <code>map</code> 类型的字段。由于 <code>map</code> 类型是不可比较的，因此 <code>image1</code> 和 <code>image2</code> 也不可比较。如果运行该程序，编译器会报错：<strong><code>main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)</code></strong>。</p>
<h3 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h3><p>结构体类型可以通过引用自身来定义。可以用于实现链表和树的结构。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><pre><code class="go">type Node struct {
    data    float64
    su      *Node
}</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/T9sRQUcN1b.jpg?imageView2/2/w/1240/h/0" alt="go实现链表"></p>
<p>链表中的第一个元素叫 <code>head</code>，它指向第二个元素；最后一个元素叫 <code>tail</code>，它没有后继元素，所以它的 <code>su</code> 为 nil 值。当然真实的链接会有很多数据节点，并且链表可以动态增长或收缩。</p>
<p>同样地可以定义一个双向链表，它有一个前趋节点 <code>pr</code> 和一个后继节点 <code>su</code>：</p>
<pre><code class="go">type Node struct {
    pr      *Node
    data    float64
    su      *Node
}</code></pre>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><pre><code class="go">type Tree strcut {
    le      *Tree
    data    float64
    ri      *Tree
}</code></pre>
<p><img src="https://cdn.learnku.com/uploads/images/201808/27/23/K6NRjDiDKD.jpg?imageView2/2/w/1240/h/0" alt="go实现二叉树"></p>
<h3 id="结构体工厂"><a href="#结构体工厂" class="headerlink" title="结构体工厂"></a>结构体工厂</h3><p>Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new 或 New 开头。假设定义了如下的 File 结构体类型：</p>
<pre><code class="go">type File struct {
    fd      int     // 文件描述符
    name    string  // 文件名
}</code></pre>
<p>下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</p>
<pre><code class="go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }

    return &amp;File{fd, name}
}</code></pre>
<p>然后这样调用它：</p>
<pre><code class="go">f := NewFile(10, &quot;./test.txt&quot;)</code></pre>
<p>在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</p>
<p>如果 <code>File</code> 是一个结构体类型，那么表达式 <code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。</p>
<p>这可以和大多数面向对象编程语言中笨拙的初始化方式做个比较：<code>File f = new File(...)</code>。</p>
<p>可以说是工厂实例化了类型的一个对象，就像在基于类的 OO 语言中那样。</p>
<p>如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：<code>size := unsafe.Sizeof(T{})</code>。</p>
<h4 id="如何强制使用工厂方法"><a href="#如何强制使用工厂方法" class="headerlink" title="如何强制使用工厂方法"></a>如何强制使用工厂方法</h4><p>通过应用可见性规则就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。</p>
<pre><code class="go">type matrix struct {
    ...
}

func NewMatrix(params) *matrix {
    m := new(matrix) // 初始化 m
    return m
}</code></pre>
<p>在其他包里使用工厂方法：</p>
<pre><code class="go">package main
import &quot;matrix&quot;
...
wrong := new(matrix.matrix)     // 编译失败（matrix 是私有的）
right := matrix.NewMatrix(...)  // 实例化 matrix 的唯一方式</code></pre>
<h3 id="map-和-struct-vs-new-和-make"><a href="#map-和-struct-vs-new-和-make" class="headerlink" title="map 和 struct vs new () 和 make ()"></a>map 和 struct vs new () 和 make ()</h3><p>现在为止已经见到了可以使用 <code>make()</code> 的三种类型中的其中两个：</p>
<pre><code class="php">slices  /  maps / channels（后面）</code></pre>
<p>下面的例子说明了在映射上使用 new 和 make 的区别以及可能发生的错误：</p>
<pre><code class="go">package main

type Foo map[string]string
type Bar struct {
    thingOne string
    thingTwo int
}

func main() {
    // OK
    y := new(Bar)
    (*y).thingOne = &quot;hello&quot;
    (*y).thingTwo = 1

    // NOT OK
    z := make(Bar) // 编译错误：cannot make type Bar
    (*z).thingOne = &quot;hello&quot;
    (*z).thingTwo = 1

    // OK
    x := make(Foo)
    x[&quot;x&quot;] = &quot;goodbye&quot;
    x[&quot;y&quot;] = &quot;world&quot;

    // NOT OK
    u := new(Foo)
    (*u)[&quot;x&quot;] = &quot;goodbye&quot; // 运行时错误!! panic: assignment to entry in nil map
    (*u)[&quot;y&quot;] = &quot;world&quot;
}</code></pre>
<p>试图 <code>make()</code> 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 <code>new()</code> 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 <code>new(Foo)</code> 返回的是一个指向 <code>nil</code> 的指针，它尚未被分配内存。所以在使用 <code>map</code> 时要特别谨慎。</p>
<h3 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type TagType struct { // tags
    field1 bool   &quot;An important answer&quot;
    field2 string &quot;The name of the thing&quot;
    field3 int    &quot;How much there are&quot;
}

func main() {
    tt := TagType{true, &quot;Barak Obama&quot;, 1}
    for i := 0; i &lt; 3; i++ {
        refTag(tt, i)
    }
}

func refTag(tt TagType, ix int) {
    ttType := reflect.TypeOf(tt)
    ixField := ttType.Field(ix)
    fmt.Printf(&quot;%v\n&quot;, ixField.Tag)
}</code></pre>
<p>输出：</p>
<pre><code class="go">An important answer
The name of the thing
How much there are</code></pre>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Go 只有一种循环结构：<code>for</code> 循环。</p>
<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>
<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>
<p><strong>注意</strong>：Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>{ }</code> 则是必须的。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    sum := 0
    for i := 0; i &lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}</code></pre>
<p>初始化语句和后置语句是可选的：即相当于 <code>while</code> 循环</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    sum := 1
    for ; sum &lt; 1000; {
        sum += sum
    }
  //可以写成
  for sum &lt; 100 {
    //...
  }
  //无限循环
  for {
    //...
  }
    fmt.Println(sum)
}</code></pre>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>同样不需要括号。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func sqrt(x float64) string {
    if x &lt; 0 {
        return sqrt(-x) + &quot;i&quot;
    }
    return fmt.Sprint(math.Sqrt(x))
}

func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}</code></pre>
<p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句，但是该语句声明的变量作用域仅在 <code>if</code> 和 <code>else</code> 之内。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func pow(x, n, lim float64) float64 {
    //v 局部变量，只在if语句块中使用
    if v := math.Pow(x, n); v &lt; lim {
        return v
  //这一行中 else 与两个括号都必须在同一行，否则非法
  } else {
    //此处 v 也可以使用
  }
  //会出错
    //return v
  return lim;
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
</code></pre>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>
<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 </p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func main() {
    fmt.Print(&quot;Go runs on &quot;)
    switch os := runtime.GOOS; os {
    case &quot;darwin&quot;:
        fmt.Println(&quot;OS X.&quot;)
    case &quot;linux&quot;:
        fmt.Println(&quot;Linux.&quot;)
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf(&quot;%s.\n&quot;, os)
    }
}</code></pre>
<p>没有条件的 switch 同 <code>switch true</code> 一样。这种形式能将一长串 if-then-else 写得更加清晰。</p>
<pre><code class="go">func main() {
    t := time.Now()
    switch {
    case t.Hour() &lt; 12:
        fmt.Println(&quot;Good morning!&quot;)
    case t.Hour() &lt; 17:
        fmt.Println(&quot;Good afternoon.&quot;)
    default:
        fmt.Println(&quot;Good evening.&quot;)
    }
}</code></pre>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    defer fmt.Println(&quot;world&quot;)

    fmt.Println(&quot;hello&quot;)
}</code></pre>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用:</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
)

func printA(a int) {  
    fmt.Println(&quot;value of a in deferred function&quot;, a)
}
func main() {  
    a := 5
    defer printA(a)
    a = 10
    fmt.Println(&quot;value of a before deferred function call&quot;, a)

}</code></pre>
<p>在上面的程序里，<code>a</code> 的初始值为 5。在执行 <code>defer</code> 语句的时候，由于 <code>a</code> 等于 5，因此延迟函数 <code>printA</code> 的实参也等于 5。接着在将 <code>a</code> 的值修改为 10。下一行会打印出 <code>a</code> 的值。该程序输出：</p>
<pre><code>value of a before deferred function call 10  
value of a in deferred function 5</code></pre><p>从上面的输出，可以看出，在调用了 <code>defer</code> 语句后，虽然将 <code>a</code> 修改为 10，但调用延迟函数 <code>printA(a)</code>后，仍然打印的是 5。</p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;counting&quot;)

    for i := 0; i &lt; 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println(&quot;done&quot;)
}</code></pre>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过可以为结构体类型定义方法。</p>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：<strong>invalid receiver type…</strong>。</p>
<p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。</p>
<p><strong>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</strong></p>
<p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<pre><code class="go">type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := Vertex{3, 4}
    fmt.Println(v.Abs())
}</code></pre>
<p>方法只是个带接收者参数的函数。</p>
<p>也可以为非结构体类型声明方法。</p>
<p>在此例中，可以看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p>
<p><strong>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法</strong>。</p>
<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}</code></pre>
<h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>可以为指针接收者声明方法。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p>
<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作，不会改变原始 <code>Vertes</code> 的值。（对于函数的其它参数也是如此。）采用指针接收者则会直接对原始数据进行修改。 <code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

//如果把 * 号去掉则只是修改副本，打印出来还是5
func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func main() {
    v := Vertex{3, 4}
    v.Scale(10)
    fmt.Println(v.Abs())
}</code></pre>
<h3 id="带指针参数的函数和指针接收者的方法对比"><a href="#带指针参数的函数和指针接收者的方法对比" class="headerlink" title="带指针参数的函数和指针接收者的方法对比"></a>带指针参数的函数和指针接收者的方法对比</h3><p>带指针参数的函数必须接受一个指针：</p>
<pre><code class="go">func Scale(v *Vertex, f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

var v Vertex
ScaleFunc(v, 5)  // 编译错误！
ScaleFunc(&amp;v, 5) // OK</code></pre>
<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<pre><code>func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

var v Vertex
v.Scale(5)  // OK
p := &amp;v
p.Scale(10) // OK</code></pre><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>（也就是说自动转换）。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func main() {
    v := Vertex{3, 4}
    v.Scale(2)
    ScaleFunc(&amp;v, 10)

  //此处已经使用了指针
    p := &amp;Vertex{3, 4}
    p.Scale(2)
    ScaleFunc(p, 10)

    fmt.Println(v, p)
}</code></pre>
<p>同样的，对于下面的代码示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := Vertex{3, 4}
    fmt.Println(v.Abs())
    fmt.Println(AbsFunc(v))

    p := &amp;Vertex{4, 3}
    fmt.Println(p.Abs())
    fmt.Println(AbsFunc(*p))
}</code></pre>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<pre><code>var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&amp;v)) // 编译错误！</code></pre><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<pre><code>var v Vertex
fmt.Println(v.Abs()) // OK
p := &amp;v
fmt.Println(p.Abs()) // OK</code></pre><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
<h3 id="选择指针作为接受者的好处"><a href="#选择指针作为接受者的好处" class="headerlink" title="选择指针作为接受者的好处"></a>选择指针作为接受者的好处</h3><p>使用指针接收者的原因有二：</p>
<p>首先，方法能够修改其接收者指向的值。</p>
<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>
<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>
<h3 id="方法的内嵌"><a href="#方法的内嵌" class="headerlink" title="方法的内嵌"></a>方法的内嵌</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型<strong>继承</strong>了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</p>
<p>假定有一个 <code>Engine</code> 接口类型，一个 <code>Car</code> 结构体类型，它包含一个 <code>Engine</code> 类型的匿名字段：</p>
<pre><code class="go">type Engine interface {
    Start()
    Stop()
}

type Car struct {
    Engine
}</code></pre>
<p>可以构建如下的代码：</p>
<pre><code class="go">func (c *Car) GoToWorkIn() {
    // get in car
    c.Start()
    // drive to work
    c.Stop()
    // get out of car
}</code></pre>
<p>下面的例子它展示了内嵌结构体上的方法可以直接在外层类型的实例上调用：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Point struct {
    x, y float64
}

func (p *Point) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y)
}

type NamedPoint struct {
    Point
    name string
}

func main() {
    n := &amp;NamedPoint{Point{3, 4}, &quot;Pythagoras&quot;}
    fmt.Println(n.Abs()) // 打印5
}</code></pre>
<p>内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法 “晋升” 成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌 “父” 类型上的方法，</p>
<p>可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p>
<p>如下所示：</p>
<pre><code class="go">func (n *NamedPoint) Abs() float64 {
    return n.Point.Abs() * 100.
}</code></pre>
<p>现在 <code>fmt.Println(n.Abs())</code> 会打印 <code>500</code>。</p>
<p>因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的多重继承，就像：<code>type Child struct { Father; Mother}</code>。在第 10.6.7 节中会进一步讨论这个问题。</p>
<p>结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</p>
<h3 id="类型的-String-方法和格式化描述符"><a href="#类型的-String-方法和格式化描述符" class="headerlink" title="类型的 String() 方法和格式化描述符"></a>类型的 String() 方法和格式化描述符</h3><p>当定义了一个有很多方法的类型时，可能会使用 <code>String()</code> 方法来定制类型的字符串形式的输出，换句话说：一种可阅读性和打印性的输出。<strong>如果类型定义了 <code>String()</code> 方法，它会被用在 <code>fmt.Printf()</code> 中生成默认的输出</strong>：等同于使用格式化描述符 <code>%v</code> 产生的输出。还有 <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法。</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

type TwoInts struct {
    a int
    b int
}

func main() {
    two1 := new(TwoInts)
    two1.a = 12
    two1.b = 10
    fmt.Printf(&quot;two1 is: %v\n&quot;, two1)
    fmt.Println(&quot;two1 is:&quot;, two1)
    fmt.Printf(&quot;two1 is: %T\n&quot;, two1)
    fmt.Printf(&quot;two1 is: %#v\n&quot;, two1)
}

func (tn *TwoInts) String() string {
    return &quot;(&quot; + strconv.Itoa(tn.a) + &quot;/&quot; + strconv.Itoa(tn.b) + &quot;)&quot;
}</code></pre>
<p>输出：</p>
<pre><code class="php">two1 is: (12/10)
two1 is: (12/10)
two1 is: *main.TwoInts
two1 is: &amp;main.TwoInts{a:12, b:10}</code></pre>
<p>当广泛使用一个自定义类型时，最好为它定义 <code>String()</code> 方法。从上面的例子也可以看到，格式化描述符 <code>%T</code> 会给出类型的完全规格，<code>%#v</code> 会给出实例的完整输出，包括它的字段（在程序自动生成 <code>Go</code> 代码时也很有用）。</p>
<p><strong>备注</strong></p>
<p>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误，比如下面的例子，它导致了一个无限迭代（递归）调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导致内存溢出：</p>
<pre><code class="go">type TT float64

func (t TT) String() string {
    return fmt.Sprintf(&quot;%v&quot;, t)
}
t. String()</code></pre>
<h3 id="垃圾回收和-SetFinalizer"><a href="#垃圾回收和-SetFinalizer" class="headerlink" title="垃圾回收和 SetFinalizer"></a>垃圾回收和 SetFinalizer</h3><p>Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。可以通过 <code>runtime</code> 包访问 GC 进程。</p>
<p>通过调用 <code>runtime.GC()</code> 函数可以显式的触发 GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用 <code>runtime.GC()</code>，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为 <code>GC</code> 进程在执行）。</p>
<p>如果想知道当前的内存状态，可以使用：</p>
<pre><code class="go">// fmt.Printf(&quot;%d\n&quot;, runtime.MemStats.Alloc/1024)
// 此处代码在 Go 1.5.1下不再有效，更正为
var m runtime.MemStats
runtime.ReadMemStats(&amp;m)
fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc / 1024)</code></pre>
<p>上面的程序会给出已分配内存的总量，单位是 Kb。</p>
<p>如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p>
<pre><code class="go">runtime.SetFinalizer(obj, func(obj *typeObj))</code></pre>
<p><code>func(obj *typeObj)</code> 需要一个 <code>typeObj</code> 类型的指针参数 <code>obj</code>，特殊操作会在它上面执行。<code>func</code> 也可以是一个匿名函数。</p>
<p>在对象被 GC 进程选中并从内存中移除以前，<code>SetFinalizer</code> 都不会执行，即使程序正常结束或者发生错误。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口类型</strong>是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值。</p>
<p>（按照约定，只包含一个方法的）接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像 <code>.NET</code> 或 <code>Java</code> 中那样）。</p>
<p><strong>注意:</strong> 示例代码存在一个错误。由于 <code>Abs</code> 方法只为 <code>*Vertex</code> （指针类型）定义，因此 <code>Vertex</code>（值类型）并未实现 <code>Abser</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Abser interface {
    Abs() float64
}

func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}

    a = f  // a MyFloat 实现了 Abser
    a = &amp;v // a *Vertex 实现了 Abser

    // 下面一行，v 是一个 Vertex（而不是 *Vertex）
    // 所以没有实现 Abser,会报错
    a = v

    fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</code></pre>
<h2 id="接口的隐式实现"><a href="#接口的隐式实现" class="headerlink" title="接口的隐式实现"></a>接口的隐式实现</h2><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface {
    M()
}

type T struct {
    S string
}

// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
func (t T) M() {
    fmt.Println(t.S)
}

func main() {
    var i I = T{&quot;hello&quot;}
    i.M()
}</code></pre>
<h2 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h2><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p>
<p>比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p>
<pre><code class="go">type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}</code></pre>
<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>接口也是值。它们可以像其它值一样传递。</p>
<p>接口值可以用作函数的参数或返回值。</p>
<p>在内部，接口值可以看做包含值和具体类型的元组：</p>
<pre><code>(value, type)</code></pre><p>接口值保存了一个具体底层类型的具体值。</p>
<p>接口值调用方法时会执行其底层类型的同名方法。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    fmt.Println(t.S)
}

type F float64

func (f F) M() {
    fmt.Println(f)
}

func main() {
    var i I

    i = &amp;T{&quot;Hello&quot;}
  //(&amp;{Hello}, *main.T)
    describe(i)
    i.M()

    i = F math.Pi
  //(3.141592653589793, main.F)
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}</code></pre>
<h3 id="底层值（调用接口方法的变量）为-nil-的接口值"><a href="#底层值（调用接口方法的变量）为-nil-的接口值" class="headerlink" title="底层值（调用接口方法的变量）为 nil 的接口值"></a>底层值（调用接口方法的变量）为 nil 的接口值</h3><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p>
<p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p>
<p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    if t == nil {
        fmt.Println(&quot;&lt;nil&gt;&quot;)
        return
    }
    fmt.Println(t.S)
}

func main() {
    var i I

    var t *T
    i = t
  //(&lt;nil&gt;, *main.T)
    describe(i)
    i.M()

    i = &amp;T{&quot;hello&quot;}
  //(&amp;{hello}, *main.T)
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}</code></pre>
<h3 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h3><p>nil 接口值既不保存值也不保存具体类型。</p>
<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个<strong>具体</strong>方法的类型。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type I interface {
    M()
}

func main() {
    var i I
  //(&lt;nil&gt;, &lt;nil&gt;)
    describe(i)
  //会报错
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
</code></pre>
<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>指定了零个方法的接口值被称为空接口：</p>
<pre><code class="go">interface{}</code></pre>
<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface{}</code> 的任意数量的参数。</p>
<p>每个 <code>interface {}</code> 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var i interface{}
    describe(i)

    i = 42
    describe(i)

    i = &quot;hello&quot;
    describe(i)
}

func describe(i interface{}) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}</code></pre>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。类型断言提供了访问接口值底层具体值的方式。</p>
<pre><code>t := i.(T)</code></pre><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p>
<p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p>
<p>为了<strong>判断</strong>一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<pre><code>t, ok := i.(T)</code></pre><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p>
<p>请注意这种语法和读取一个映射时的相同之处。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    var i interface{} = &quot;hello&quot;

    s := i.(string)
    fmt.Println(s)

    s, ok := i.(string)
    fmt.Println(s, ok)

    f, ok := i.(float64)
    fmt.Println(f, ok)

    f = i.(float64) // 报错(panic)
    fmt.Println(f)
}</code></pre>
<pre><code class="go">hello
hello true
0 false
panic: interface conversion: interface {} is string, not float64</code></pre>
<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p><strong>类型选择</strong>是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<pre><code class="go">switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}</code></pre>
<p><strong>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</strong></p>
<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
<h2 id="接口实现中的指针接受者与值接受者"><a href="#接口实现中的指针接受者与值接受者" class="headerlink" title="接口实现中的指针接受者与值接受者"></a>接口实现中的指针接受者与值接受者</h2><pre><code class="go">package main

import &quot;fmt&quot;

type Describer interface {  
    Describe()
}
type Person struct {  
    name string
    age  int
}

func (p Person) Describe() { // 使用值接受者实现  
    fmt.Printf(&quot;%s is %d years old\n&quot;, p.name, p.age)
}

type Address struct {
    state   string
    country string
}

func (a *Address) Describe() { // 使用指针接受者实现
    fmt.Printf(&quot;State %s Country %s&quot;, a.state, a.country)
}

func main() {  
    var d1 Describer
    p1 := Person{&quot;Sam&quot;, 25}
    d1 = p1
    d1.Describe()
    p2 := Person{&quot;James&quot;, 32}
    d1 = &amp;p2
    d1.Describe()

    var d2 Describer
    a := Address{&quot;Washington&quot;, &quot;USA&quot;}

    /* 如果下面一行取消注释会导致编译错误：
       cannot use a (type Address) as type Describer
       in assignment: Address does not implement
       Describer (Describe method has pointer
       receiver)
    */
    //d2 = a

    d2 = &amp;a // 这是合法的
    // 因为在第 22 行，Address 类型的指针实现了 Describer 接口
    d2.Describe()

}</code></pre>
<p><strong>对于使用指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口中存储的具体值（Concrete Value）并不能取到地址，因此在上面的例子中，对于编译器无法自动获取 <code>a</code> 的地址，于是程序报错</strong>。</p>
<p><strong>总结</strong></p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接可以辨识的：</p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p>
<p><strong>译注</strong></p>
<p>Go 语言规范定义了接口方法集的调用规则：</p>
<ul>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li>
</ul>
<h2 id="常用接口方法"><a href="#常用接口方法" class="headerlink" title="常用接口方法"></a>常用接口方法</h2><h3 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h3><p><a href="https://go-zh.org/pkg/fmt/" target="_blank" rel="noopener"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer" target="_blank" rel="noopener"><code>Stringer</code></a> 是最普遍的接口之一。</p>
<pre><code class="go">type Stringer interface {
    String() string
}</code></pre>
<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
}

func main() {
    a := Person{&quot;Arthur Dent&quot;, 42}
    z := Person{&quot;Zaphod Beeblebrox&quot;, 9001}
    fmt.Println(a, z)
}</code></pre>
<h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error 错误"></a>Error 错误</h3><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<pre><code class="go">type error interface {
    Error() string
}</code></pre>
<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<pre><code class="go">i, err := strconv.Atoi(&quot;42&quot;)
if err != nil {
    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)
    returnf
}
fmt.Println(&quot;Converted integer:&quot;, i)</code></pre>
<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global" target="_blank" rel="noopener">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<pre><code>func (T) Read(b []byte) (n int, err error)</code></pre><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader" target="_blank" rel="noopener"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strings&quot;
)

func main() {
    r := strings.NewReader(&quot;Hello, Reader!&quot;)

    b := make([]byte, 8)
    for {
        n, err := r.Read(b)
        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])
        if err == io.EOF {
            break
        }
    }
}</code></pre>
<pre><code>n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]
b[:n] = &quot;Hello, R&quot;
n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;eader!&quot;
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;&quot;</code></pre><h3 id="图像-image"><a href="#图像-image" class="headerlink" title="图像 image"></a>图像 image</h3><p><a href="https://go-zh.org/pkg/image/#Image" target="_blank" rel="noopener"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p>
<pre><code class="go">package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}</code></pre>
<p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://go-zh.org/pkg/image/#Rectangle" target="_blank" rel="noopener"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p>
<p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://go-zh.org/pkg/image/color/" target="_blank" rel="noopener"><code>image/color</code></a> 包定义。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；反射可以在运行时检查类型和变量，例如它的大小、方法和动态的调用这些方法。这对于没有源代码的包尤其有用。</p>
<p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。</p>
<p>两个简单的函数，<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，返回被检查对象的类型和值。例如，x 被定义为：<code>var x float64 = 3.4</code>，那么 <code>reflect.TypeOf(x)</code> 返回 <code>float64</code>，<code>reflect.ValueOf(x)</code> 返回 <code>3.4</code>。</p>
<p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。这从下面两个函数签名能够很明显的看出来：</p>
<pre><code class="go">func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value</code></pre>
<p>接口的值包含一个 type 和 value。</p>
<p>反射可以从接口值反射到对象，也可以从对象反射回接口值。</p>
<p>此外，<code>reflect</code>包中还有一个重要的类型：<code>Kind</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type order struct {
    ordId      int
    customerId int
}

func createQuery(q interface{}) {
    t := reflect.TypeOf(q)
    k := t.Kind()
    fmt.Println(&quot;Type &quot;, t) //Type main.order
    fmt.Println(&quot;Kind &quot;, k) //Kind struct


}
func main() {
    o := order{
        ordId:      456,
        customerId: 56,
    }
    createQuery(o)
}</code></pre>
<p><code>Type</code> 表示 <code>interface{}</code> 的实际类型（在这里是 <strong><code>main.Order</code></strong>)，而 <code>Kind</code> 表示该类型的特定类别（在这里是 <strong><code>struct</code></strong>）。 </p>
<p>对于 float64 类型的变量 x，如果 <code>v:=reflect.ValueOf(x)</code>，那么 <code>v.Kind()</code> 返回 <code>reflect.Float64</code> ，所以下面的表达式是 <code>true</code><br><code>v.Kind() == reflect.Float64</code></p>
<p><code>Kind</code> 总是返回底层类型：</p>
<pre><code class="go">type MyInt int
var m MyInt = 5
v := reflect.ValueOf(m)</code></pre>
<p>方法 <code>v.Kind()</code> 返回 <code>reflect.Int</code>。</p>
<p>变量 v 的 <code>Interface()</code> 方法可以得到还原（接口）值，所以可以这样打印 v 的值：<code>fmt.Println(v.Interface())</code></p>
<p><code>reflect.Type</code> 和 <code>reflect.Value</code> 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 <code>Value</code> 有叫做 <code>Int</code> 和 <code>Float</code> 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）</p>
<pre><code class="go">const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)</code></pre>
<p>下面的例子使用 <code>Int()</code> 和 <code>String()</code> 将取的 <code>reflect.Value</code> 转换为相应的内部值类型</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    a := 56
      //reflect.value -&gt; int64
    x := reflect.ValueOf(a).Int()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
    b := &quot;Naveen&quot;
      //reflect.value -&gt; string
    y := reflect.ValueOf(b).String()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, y, y)

}</code></pre>
<p>示例代码：</p>
<pre><code class="go">// blog: Laws of Reflection
package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    var x float64 = 3.4
    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
    v := reflect.ValueOf(x)
    fmt.Println(&quot;value:&quot;, v)
    fmt.Println(&quot;type:&quot;, v.Type())
    fmt.Println(&quot;kind:&quot;, v.Kind())
    fmt.Println(&quot;value:&quot;, v.Float())
    fmt.Println(v.Interface())
    fmt.Printf(&quot;value is %5.2e\n&quot;, v.Interface())
    y := v.Interface().(float64)
    fmt.Println(y)
}</code></pre>
<p>输出：</p>
<pre><code class="php">type: float64
value: 3.4
type: float64
kind: float64
value: 3.4
3.4
value is 3.40e+00
3.4</code></pre>
<p>x 是一个 float64 类型的值，<code>reflect.ValueOf(x).Float()</code> 返回这个 float64 类型的实际值；同样的适用于 <code>Int(), Bool(), Complex(), String()</code></p>
<h2 id="通过反射修改-设置-值"><a href="#通过反射修改-设置-值" class="headerlink" title="通过反射修改 (设置) 值"></a>通过反射修改 (设置) 值</h2><p>假设要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：<code>v.SetFloat(3.1415)</code>。</p>
<p>这将产生一个错误：<code>reflect.Value.SetFloat using unaddressable value</code>。</p>
<p>问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 <code>CanSet()</code> 方法测试是否可设置。</p>
<p>在例子中可以看到 <code>v.CanSet()</code> 返回 false： <code>settability of v: false</code></p>
<p>当 <code>v := reflect.ValueOf(x)</code> 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 <code>v = reflect.ValueOf(&amp;x)</code>。</p>
<p>通过 Type () 我们看到 v 现在的类型是 <code>*float64</code> 并且仍然是不可设置的。</p>
<p>要想让其可设置我们需要使用 <code>Elem()</code> 函数，这间接的使用指针：<code>v = v.Elem()</code></p>
<p>现在 <code>v.CanSet()</code> 返回 true 并且 <code>v.SetFloat(3.1415)</code> 设置成功了！</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    // setting a value:
    // v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v = reflect.ValueOf(&amp;x) // Note: take the address of x.
    fmt.Println(&quot;type of v:&quot;, v.Type())
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v = v.Elem()
    fmt.Println(&quot;The Elem of v is: &quot;, v)
    fmt.Println(&quot;settability of v:&quot;, v.CanSet())
    v.SetFloat(3.1415) // this works!
    fmt.Println(v.Interface())
    fmt.Println(v)
}</code></pre>
<p>输出：</p>
<pre><code class="php">settability of v: false
type of v: *float64
settability of v: false
The Elem of v is:  &lt;float64 Value&gt;
settability of v: true
3.1415
&lt;float64 Value&gt;</code></pre>
<p>反射中有些内容是需要用地址去改变它的状态的。</p>
<h2 id="反射结构体"><a href="#反射结构体" class="headerlink" title="反射结构体"></a>反射结构体</h2><p>有些时候需要反射一个结构体类型。<code>NumField()</code> 方法返回结构体内的字段数量；通过一个 for 循环用索引取得每个字段的值 <code>Field(i)</code>。</p>
<p>同样能够调用签名在结构体上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code>。</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type NotknownType struct {
    s1, s2, s3 string
}

func (n NotknownType) String() string {
    return n.s1 + &quot; - &quot; + n.s2 + &quot; - &quot; + n.s3
}

// variable to investigate:
var secret interface{} = NotknownType{&quot;Ada&quot;, &quot;Go&quot;, &quot;Oberon&quot;}

func main() {
    value := reflect.ValueOf(secret) // &lt;main.NotknownType Value&gt;
    typ := reflect.TypeOf(secret)    // main.NotknownType
    // alternative:
    //typ := value.Type()  // main.NotknownType
    fmt.Println(typ)
    knd := value.Kind() // struct
    fmt.Println(knd)

    // iterate through the fields of the struct:
    for i := 0; i &lt; value.NumField(); i++ {
        fmt.Printf(&quot;Field %d: %v\n&quot;, i, value.Field(i))
        // error: panic: reflect.Value.SetString using value obtained using unexported field
        //value.Field(i).SetString(&quot;C#&quot;)
    }

    // call the first method, which is String():
    results := value.Method(0).Call(nil)
    fmt.Println(results) // [Ada - Go - Oberon]
}</code></pre>
<p>输出：</p>
<pre><code class="php">main.NotknownType
struct
Field 0: Ada
Field 1: Go
Field 2: Oberon
[Ada - Go - Oberon]</code></pre>
<p>但是如果尝试更改一个值，会得到一个错误：</p>
<pre><code class="php">panic: reflect.Value.SetString using value obtained using unexported field</code></pre>
<p>这是因为结构体中只有被导出字段（首字母大写）才是可设置的；来看下面的例子：</p>
<p>示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type T struct {
    A int
    B string
}

func main() {
    t := T{23, &quot;skidoo&quot;}
    s := reflect.ValueOf(&amp;t).Elem()
    typeOfT := s.Type()
    for i := 0; i &lt; s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,
            typeOfT.Field(i).Name, f.Type(), f.Interface())
    }
    s.Field(0).SetInt(77)
    s.Field(1).SetString(&quot;Sunset Strip&quot;)
    fmt.Println(&quot;t is now&quot;, t)
}</code></pre>
<p>输出：</p>
<pre><code class="php">0: A int = 23
1: B string = skidoo
t is now {77 Sunset Strip}</code></pre>
<h3 id="Int-和-String-方法"><a href="#Int-和-String-方法" class="headerlink" title="Int() 和 String() 方法"></a>Int() 和 String() 方法</h3><p><a href="https://golang.org/pkg/reflect/#Value.Int" target="_blank" rel="noopener"><code>Int</code></a> 和 <a href="https://golang.org/pkg/reflect/#Value.String" target="_blank" rel="noopener"><code>String</code></a> 可以帮助分别取出 <code>reflect.Value</code> 作为 <code>int64</code> 和 <code>string</code>。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    a := 56
    x := reflect.ValueOf(a).Int()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
    b := &quot;Naveen&quot;
    y := reflect.ValueOf(b).String()
    fmt.Printf(&quot;type:%T value:%v\n&quot;, y, y)

}</code></pre>
<p>在上面程序中取出 <code>reflect.Value</code>，并转换为 <code>int64</code>，接着取出 <code>reflect.Value</code> 并将其转换为 <code>string</code>。该程序会输出：</p>
<pre><code>type:int64 value:56
type:string value:Naveen</code></pre><h1 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h1><h2 id="读取用户的输入"><a href="#读取用户的输入" class="headerlink" title="读取用户的输入"></a>读取用户的输入</h2><p>从键盘和标准输入 <code>os.Stdin</code> 读取输入，最简单的办法是使用 <code>fmt</code> 包提供的 Scan 和 Sscan 开头的函数。</p>
<pre><code class="go">// 从控制台读取输入:
package main
import &quot;fmt&quot;

var (
   firstName, lastName, s string
   i int
   f float32
   input = &quot;56.12 / 5212 / Go&quot;
   format = &quot;%f / %d / %s&quot;
)

func main() {
   fmt.Println(&quot;Please enter your full name: &quot;)
   fmt.Scanln(&amp;firstName, &amp;lastName)
   // fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)
   fmt.Printf(&quot;Hi %s %s!\n&quot;, firstName, lastName) // Hi Chris Naegels
   fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)
   fmt.Println(&quot;From the string we read: &quot;, f, i, s)
    // 输出结果: From the string we read: 56.12 5212 Go
}</code></pre>
<p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。</p>
<p><code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果和预想的不同，可以检查成功读入数据的个数和返回的错误。</p>
<p>也可以使用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据：</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

var inputReader *bufio.Reader
var input string
var err error

func main() {
    inputReader = bufio.NewReader(os.Stdin)
    fmt.Println(&quot;Please enter some input: &quot;)
    input, err = inputReader.ReadString(&#39;\n&#39;)
    if err == nil {
        fmt.Printf(&quot;The input was: %s\n&quot;, input)
    }
}</code></pre>
<p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针。<code>inputReader := bufio.NewReader(os.Stdin)</code> 这行代码，将会创建一个读取器，并将其与标准输入绑定。</p>
<p><code>bufio.NewReader()</code> 构造函数的签名为：<code>func NewReader(rd io.Reader) *Reader</code></p>
<p>该函数的实参可以是满足 <code>io.Reader</code> 接口的任意对象（任意包含有适当的 <code>Read()</code> 方法的对象），函数返回一个新的带缓冲的 <code>io.Reader</code> 对象，它将从指定读取器（例如 <code>os.Stdin</code>）读取内容。</p>
<p>返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code>，该方法从输入中读取内容，直到碰到 <code>delim</code> 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区。</p>
<p><code>ReadString</code> 返回读取到的字符串，如果碰到错误则返回 <code>nil</code>。如果它一直读到文件结束，则返回读取到的字符串和 <code>io.EOF</code>。如果读取过程中没有碰到 <code>delim</code> 字符，将返回错误 <code>err != nil</code>。</p>
<p>在上面的例子中，会读取键盘输入，直到回车键（\n）被按下。</p>
<p>屏幕是标准输出 <code>os.Stdout</code>；<code>os.Stderr</code> 用于显示错误信息，大多数情况下等同于 <code>os.Stdout</code>。</p>
<p>一般情况下，会省略变量声明，而使用 <code>:=</code>，例如：</p>
<pre><code class="go">inputReader := bufio.NewReader(os.Stdin)
input, err := inputReader.ReadString(&#39;\n&#39;)</code></pre>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。在前面使用到过标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>，他们的类型都是 <code>*os.File</code>。</p>
<pre><code class="go">package main
import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    inputFile, inputError := os.Open(&quot;input.dat&quot;)
    if inputError != nil {
        fmt.Printf(&quot;An error occurred on opening the inputfile\n&quot; +
            &quot;Does the file exist?\n&quot; +
            &quot;Have you got acces to it?\n&quot;)
        return // exit the function on error
    }
    defer inputFile.Close()

    inputReader := bufio.NewReader(inputFile)
    for {
        inputString, readerError := inputReader.ReadString(&#39;\n&#39;)
    fmt.Printf(&quot;The input was: %s&quot;, inputString)
        if readerError == io.EOF {
            return
        }      
    }
}</code></pre>
<p>变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 <code>os</code> 包里的 <code>Open</code> 函数来打开一个文件。该函数的参数是文件名，类型为 <code>string</code>。在上面的程序中，以只读模式打开 <code>input.dat</code> 文件。</p>
<p>如果文件不存在或者程序没有足够的权限打开这个文件，Open 函数会返回一个错误：<code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code>。如果文件打开正常，就使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。然后，使用 <code>bufio.NewReader</code> 来获得一个读取器变量。</p>
<p>通过使用 <code>bufio</code> 包提供的读取器（写入器也类似），如上面程序所示，可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。</p>
<p>接着，在一个无限循环中使用 <code>ReadString(&#39;\n&#39;)</code> 或 <code>ReadBytes(&#39;\n&#39;)</code> 将文件的内容逐行（行结束符 <code>\n</code>）读取出来。</p>
<p><strong>注意</strong>：在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，不需要关心操作系统的类型，直接使用 <code>\n</code> 就可以了。另外，也可以使用 <code>ReadLine()</code> 方法来实现相同的功能。</p>
<p>一旦读取到文件末尾，变量 <code>readerError</code> 的值将变成非空（事实上，常量 <code>io.EOF</code> 的值是 true），就会执行 <code>return</code> 语句从而退出循环。</p>
<h3 id="其他读文件方式"><a href="#其他读文件方式" class="headerlink" title="其他读文件方式"></a>其他读文件方式</h3><h4 id="将整个文件的内容读取到一个字符串里"><a href="#将整个文件的内容读取到一个字符串里" class="headerlink" title="将整个文件的内容读取到一个字符串里"></a>将整个文件的内容读取到一个字符串里</h4><p>可以使用 <code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
)

func main() {
    inputFile := &quot;products.txt&quot;
    outputFile := &quot;products_copy.txt&quot;
    buf, err := ioutil.ReadFile(inputFile)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;File Error: %s\n&quot;, err)
        // panic(err.Error())
        }
    fmt.Printf(&quot;%s\n&quot;, string(buf))
    err = ioutil.WriteFile(outputFile, buf, 0644) // oct, not hex
    if err != nil {
        panic(err.Error())
    }
}</code></pre>
<h4 id="带缓冲的读取"><a href="#带缓冲的读取" class="headerlink" title="带缓冲的读取"></a>带缓冲的读取</h4><p>在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，<code>ReadString()</code> 就无法使用了，可以使用 <code>bufio.Reader</code> 的 <code>Read()</code>，它只接收一个参数：</p>
<pre><code class="go">buf := make([]byte, 1024)
...
n, err := inputReader.Read(buf)
if (n == 0) { break}</code></pre>
<p>变量 n 的值表示读取到的字节数。</p>
<h4 id="按列读取文件中的数据"><a href="#按列读取文件中的数据" class="headerlink" title="按列读取文件中的数据"></a>按列读取文件中的数据</h4><p>如果数据是按列排列并用空格分隔的，可以使用 <code>fmt</code> 包提供的以 FScan 开头的一系列函数来读取他们。下面的程序将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。</p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    file, err := os.Open(&quot;products2.txt&quot;)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    var col1, col2, col3 []string
    for {
        var v1, v2, v3 string
        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)
        // scans until newline
        if err != nil {
            break
        }
        col1 = append(col1, v1)
        col2 = append(col2, v2)
        col3 = append(col3, v3)
    }

    fmt.Println(col1)
    fmt.Println(col2)
    fmt.Println(col3)
}</code></pre>
<p>输出结果：</p>
<pre><code class="php">[ABC FUNC GO]
[40 56 45]
[150 280 356]</code></pre>
<p><strong>注意：</strong> <code>path</code> 包里包含一个子包叫 <code>filepath</code>，这个子包提供了跨平台的函数，用于处理文件名和路径。例如 Base () 函数用于获得路径中的最后一个元素（不包含后面的分隔符）：</p>
<pre><code class="go">import &quot;path/filepath&quot;
filename := filepath.Base(path)</code></pre>
<h3 id="读取压缩文件"><a href="#读取压缩文件" class="headerlink" title="读取压缩文件"></a>读取压缩文件</h3><p><code>compress</code> 包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
    &quot;compress/gzip&quot;
)

func main() {
    fName := &quot;MyFile.gz&quot;
    var r *bufio.Reader
    fi, err := os.Open(fName)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;%v, Can&#39;t open %s: error: %s\n&quot;, os.Args[0], fName,
            err)
        os.Exit(1)
    }
    fz, err := gzip.NewReader(fi)
    if err != nil {
        r = bufio.NewReader(fi)
    } else {
        r = bufio.NewReader(fz)
    }

    for {
        line, err := r.ReadString(&#39;\n&#39;)
        if err != nil {
            fmt.Println(&quot;Done reading file&quot;)
            os.Exit(0)
        }
        fmt.Println(line)
    }
}</code></pre>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><pre><code class="go">package main

import (
    &quot;os&quot;
    &quot;bufio&quot;
    &quot;fmt&quot;
)

func main () {
    // var outputWriter *bufio.Writer
    // var outputFile *os.File
    // var outputError os.Error
    // var outputString string
    outputFile, outputError := os.OpenFile(&quot;output.dat&quot;, os.O_WRONLY|os.O_CREATE, 0666)
    if outputError != nil {
        fmt.Printf(&quot;An error occurred with file opening or creation\n&quot;)
        return  
    }
    defer outputFile.Close()

    outputWriter := bufio.NewWriter(outputFile)
    outputString := &quot;hello world!\n&quot;

    for i:=0; i&lt;10; i++ {
        outputWriter.WriteString(outputString)
    }
    outputWriter.Flush()
}</code></pre>
<p>首先以只写模式打开文件 <code>output.dat</code>，如果文件不存在则自动创建：</p>
<pre><code class="go">outputFile, outputError := os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666)</code></pre>
<p>可以看到，<code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 “|” 连接），使用的文件权限。</p>
<p>通常会用到以下标志：</p>
<ul>
<li><code>os.O_RDONLY</code>：只读</li>
<li><code>os.O_WRONLY</code>：只写</li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为 0。</li>
</ul>
<p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用 0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p>
<p>然后，创建一个写入器（缓冲区）对象：</p>
<pre><code class="go">outputWriter := bufio.NewWriter(outputFile)</code></pre>
<p>接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：<code>outputWriter.WriteString(outputString)</code></p>
<p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code></p>
<p>如果写入的东西很简单，可以使用 <code>fmt.Fprintf(outputFile, “Some test data.\n”)</code> 直接将内容写入文件。<strong><code>fmt</code> 包里的 F 开头的 Print 函数可以直接写入任何 <code>io.Writer</code>，包括文件。</strong></p>
<p>下面的例子展示了不使用 <code>fmt.FPrintf</code> 函数，使用其他函数如何写文件：</p>
<pre><code class="go">package main

import &quot;os&quot;

func main() {
    os.Stdout.WriteString(&quot;hello, world\n&quot;)
    f, _ := os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0)
    defer f.Close()
    f.WriteString(&quot;hello, world in a file\n&quot;)
}</code></pre>
<p>使用 <code>os.Stdout.WriteString(“hello, world\n”)</code>，我们可以输出到屏幕。</p>
<p>以只写模式创建或打开文件 “test”，并且忽略了可能发生的错误：<code>f, _ := os.OpenFile(“test”, os.O_CREATE|os.O_WRONLY, 0)</code></p>
<p>不使用缓冲区，直接将内容写入文件：<code>f.WriteString( )</code></p>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><pre><code class="go">// filecopy.go
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    CopyFile(&quot;target.txt&quot;, &quot;source.txt&quot;)
    fmt.Println(&quot;Copy done!&quot;)
}

func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()

    dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
    if err != nil {
        return
    }
    defer dst.Close()

    return io.Copy(dst, src)
}</code></pre>
<p>注意 <code>defer</code> 的使用：当打开目标文件时发生了错误，那么 <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p>
<h2 id="fmt-Fprintf"><a href="#fmt-Fprintf" class="headerlink" title="fmt.Fprintf"></a>fmt.Fprintf</h2><pre><code class="go">// interfaces being used in the GO-package fmt
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // unbuffered
    fmt.Fprintf(os.Stdout, &quot;%s\n&quot;, &quot;hello world! - unbuffered&quot;)
    // buffered: os.Stdout implements io.Writer
    buf := bufio.NewWriter(os.Stdout)
    // and now so does buf.
    fmt.Fprintf(buf, &quot;%s\n&quot;, &quot;hello world! - buffered&quot;)
    buf.Flush()
}</code></pre>
<pre><code class="php">hello world! - unbuffered
hello world! - buffered</code></pre>
<p>下面是 <code>fmt.Fprintf()</code> 函数的实际签名</p>
<pre><code class="go">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</code></pre>
<p>其不是写入一个文件，而是写入一个 <code>io.Writer</code> 接口类型的变量，下面是 <code>Writer</code> 接口在 io 包中的定义：</p>
<pre><code class="go">type Writer interface {
    Write(p []byte) (n int, err error)
}</code></pre>
<p><code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 <code>io.Writer</code> 接口。<code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>Write</code> 方法，包括 <code>os.Stdout</code>, 文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。bufio 包中定义了 <code>type Writer struct{...}</code>。</p>
<p><code>bufio.Writer</code> 实现了 Write 方法：</p>
<pre><code class="go">func (b *Writer) Write(p []byte) (nn int, err error)</code></pre>
<p>它还有一个工厂函数：传给它一个 <code>io.Writer</code> 类型的参数，它会返回一个缓冲的 <code>bufio.Writer</code> 类型的 <code>io.Writer</code>:</p>
<pre><code class="go">func NewWriter(wr io.Writer) (b *Writer)</code></pre>
<p>其适合任何形式的缓冲写入。</p>
<p>在缓冲写入的最后要使用 <code>Flush()</code>，否则最后的输出不会被写入。</p>
<h2 id="数据格式处理"><a href="#数据格式处理" class="headerlink" title="数据格式处理"></a>数据格式处理</h2><p>数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式。</p>
<p>结构可能包含二进制数据，如果将其作为文本打印，那么可读性是很差的。另外结构内部可能包含匿名字段，而不清楚数据的用意。</p>
<p>通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。</p>
<p>下面是一些术语说明：</p>
<ul>
<li>数据结构 –&gt; 指定格式 = <code>序列化</code> 或 <code>编码</code>（传输之前）</li>
<li>指定格式 –&gt; 数据格式 = <code>反序列化</code> 或 <code>解码</code>（传输之后）</li>
</ul>
<p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p>
<p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p>
<p>通常 JSON 被用于 web 后端和浏览器之间的通讯，但是在其它场景也同样的有用。</p>
<h3 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h3><pre><code class="go">// json.go
package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
)

type Address struct {
    Type    string
    City    string
    Country string
}

type VCard struct {
    FirstName string
    LastName  string
    Addresses []*Address
    Remark    string
}

func main() {
    pa := &amp;Address{&quot;private&quot;, &quot;Aartselaar&quot;, &quot;Belgium&quot;}
    wa := &amp;Address{&quot;work&quot;, &quot;Boom&quot;, &quot;Belgium&quot;}
    vc := VCard{&quot;Jan&quot;, &quot;Kersschot&quot;, []*Address{pa, wa}, &quot;none&quot;}
    // fmt.Printf(&quot;%v: \n&quot;, vc) // {Jan Kersschot [0x126d2b80 0x126d2be0] none}:
    // JSON format:
    js, _ := json.Marshal(vc)
    fmt.Printf(&quot;JSON format: %s&quot;, js)
    // using an encoder:
    file, _ := os.OpenFile(&quot;vcard.json&quot;, os.O_CREATE|os.O_WRONLY, 0666)
    defer file.Close()
    enc := json.NewEncoder(file)
    err := enc.Encode(vc)
    if err != nil {
        log.Println(&quot;Error in encoding json&quot;)
    }
}</code></pre>
<p><code>json.Marshal()</code> 的函数签名是 <code>func Marshal(v interface{}) ([]byte, error)</code>，下面是数据编码后的 JSON 文本（实际上是一个 [] byte）：</p>
<pre><code class="javascript">{
    &quot;FirstName&quot;: &quot;Jan&quot;,
    &quot;LastName&quot;: &quot;Kersschot&quot;,
    &quot;Addresses&quot;: [{
        &quot;Type&quot;: &quot;private&quot;,
        &quot;City&quot;: &quot;Aartselaar&quot;,
        &quot;Country&quot;: &quot;Belgium&quot;
    }, {
        &quot;Type&quot;: &quot;work&quot;,
        &quot;City&quot;: &quot;Boom&quot;,
        &quot;Country&quot;: &quot;Belgium&quot;
    }],
    &quot;Remark&quot;: &quot;none&quot;
}</code></pre>
<p>出于安全考虑，在 web 应用中最好使用 <code>json.MarshalforHTML()</code> 函数，其对数据执行 HTML 转码，所以文本可以被安全地嵌在 HTML <code>&lt;script&gt;</code> 标签中。</p>
<p><code>json.NewEncoder()</code> 的函数签名是 <code>func NewEncoder(w io.Writer) *Encoder</code>，返回的 Encoder 类型的指针可调用方法 <code>Encode(v interface{})</code>，将数据对象 v 的 json 编码写入 <code>io.Writer</code> w 中。</p>
<p>JSON 与 Go 类型对应如下：</p>
<ul>
<li>bool 对应 JSON 的 booleans</li>
<li>float64 对应 JSON 的 numbers</li>
<li>string 对应 JSON 的 strings</li>
<li>nil 对应 JSON 的 null</li>
</ul>
<p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p>
<ul>
<li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map [string] T（T 是 <code>json</code> 包中支持的任何类型）</li>
<li>Channel，复杂类型和函数类型不能被编码</li>
<li>不支持循环数据结构；它将引起序列化进入一个无限循环</li>
<li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li>
</ul>
<h4 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h4><p><code>UnMarshal()</code> 的函数签名是 <code>func Unmarshal(data []byte, v interface{}) error</code> 把 JSON 解码为数据结构。</p>
<p>示例中对 vc 编码后的数据为 <code>js</code> ，对其解码时，首先创建结构 VCard 用来保存解码的数据：<code>var v VCard</code> 并调用 <code>json.Unmarshal(js, &amp;v)</code>，解析 [] byte 中的 JSON 数据并将结果存入指针 &amp;v 指向的值。</p>
<p>虽然反射能够让 JSON 字段去尝试匹配目标结构字段；但是只有真正匹配上的字段才会填充数据。字段没有匹配不会报错，而是直接忽略掉。</p>
<h4 id="解码任意的数据："><a href="#解码任意的数据：" class="headerlink" title="解码任意的数据："></a>解码任意的数据：</h4><p>json 包使用 <code>map[string]interface{}</code> 和 <code>[]interface{}</code> 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中。</p>
<p>假设有一个 JSON 数据，被存储在变量 b 中：</p>
<pre><code class="go">b := []byte(`{&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]}`)</code></pre>
<p>不用理解这个数据的结构，可以直接使用 Unmarshal 把这个数据编码并保存在接口值中：</p>
<pre><code class="go">var f interface{}
err := json.Unmarshal(b, &amp;f)</code></pre>
<p>f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：</p>
<pre><code class="go">map[string]interface{} {
    &quot;Name&quot;: &quot;Wednesday&quot;,
    &quot;Age&quot;:  6,
    &quot;Parents&quot;: []interface{} {
        &quot;Gomez&quot;,
        &quot;Morticia&quot;,
    },
}</code></pre>
<p>要访问这个数据，可以使用类型断言</p>
<pre><code class="go">m := f.(map[string]interface{})</code></pre>
<p>可以通过 for range 语法和 type switch 来访问其实际类型：</p>
<pre><code class="go">for k, v := range m {
    switch vv := v.(type) {
    case string:
        fmt.Println(k, &quot;is string&quot;, vv)
    case int:
        fmt.Println(k, &quot;is int&quot;, vv)

    case []interface{}:
        fmt.Println(k, &quot;is an array:&quot;)
        for i, u := range vv {
            fmt.Println(i, u)
        }
    default:
        fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)
    }
}</code></pre>
<p>通过这种方式，可以处理未知的 JSON 数据，同时可以确保类型安全。</p>
<h4 id="解码数据到结构"><a href="#解码数据到结构" class="headerlink" title="解码数据到结构"></a>解码数据到结构</h4><p>如果事先知道 JSON 数据，可以定义一个适当的结构并对 JSON 数据反序列化。下面的例子中，将定义：</p>
<pre><code class="go">type FamilyMember struct {
    Name    string
    Age     int
    Parents []string
}</code></pre>
<p>并对其反序列化：</p>
<pre><code class="go">var m FamilyMember
err := json.Unmarshal(b, &amp;m)</code></pre>
<p>程序实际上是分配了一个新的切片。这是一个典型的反序列化引用类型（指针、切片和 map）的例子。</p>
<h4 id="编码和解码流"><a href="#编码和解码流" class="headerlink" title="编码和解码流"></a>编码和解码流</h4><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p>
<pre><code class="go">func NewDecoder(r io.Reader) *Decoder
func NewEncoder(w io.Writer) *Encoder</code></pre>
<p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode ()；反过来与其对应的是使用 json.Decoder 和 Decode () 函数：</p>
<pre><code class="go">func NewDecoder(r io.Reader) *Decoder
func (dec *Decoder) Decode(v interface{}) error</code></pre>
<p>来看下接口是如何对实现进行抽象的：数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。</p>
<h3 id="XML-数据格式"><a href="#XML-数据格式" class="headerlink" title="XML 数据格式"></a>XML 数据格式</h3><pre><code class="xml">&lt;Person&gt;
    &lt;FirstName&gt;Laura&lt;/FirstName&gt;
    &lt;LastName&gt;Lynn&lt;/LastName&gt;
&lt;/Person&gt;</code></pre>
<p>如同 json 包一样，也有 <code>Marshal()</code> 和 <code>UnMarshal()</code> 从 XML 中编码和解码数据；但这个更通用，可以从文件中读取和写入（或者任何实现了 io.Reader 和 io.Writer 接口的类型）</p>
<p>和 JSON 的方式一样，XML 数据可以序列化为结构，或者从结构反序列化为 XML 数据；</p>
<p><code>encoding/xml</code> 包实现了一个简单的 XML 解析器（SAX），用来解析 XML 数据内容。</p>
<pre><code class="go">// xml.go
package main

import (
    &quot;encoding/xml&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)

var t, token xml.Token
var err error

func main() {
    input := &quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;/FirstName&gt;&lt;LastName&gt;Lynn&lt;/LastName&gt;&lt;/Person&gt;&quot;
    inputReader := strings.NewReader(input)
    p := xml.NewDecoder(inputReader)

    for t, err = p.Token(); err == nil; t, err = p.Token() {
        switch token := t.(type) {
        case xml.StartElement:
            name := token.Name.Local
            fmt.Printf(&quot;Token name: %s\n&quot;, name)
            for _, attr := range token.Attr {
                attrName := attr.Name.Local
                attrValue := attr.Value
                fmt.Printf(&quot;An attribute is: %s %s\n&quot;, attrName, attrValue)
                // ...
            }
        case xml.EndElement:
            fmt.Println(&quot;End of token&quot;)
        case xml.CharData:
            content := string([]byte(token))
            fmt.Printf(&quot;This is the content: %v\n&quot;, content)
            // ...
        default:
            // ...
        }
    }
}</code></pre>
<p>输出：</p>
<pre><code class="php">Token name: Person
Token name: FirstName
This is the content: Laura
End of token
Token name: LastName
This is the content: Lynn
End of token
End of token</code></pre>
<p>包中定义了若干 XML 标签类型：StartElement，Chardata（这是从开始标签到结束标签之间的实际文本），EndElement，Comment，Directive 或 ProcInst。</p>
<p>包中同样定义了一个结构解析器：<code>NewParser</code> 方法持有一个 io.Reader（这里具体类型是 strings.NewReader）并生成一个解析器类型的对象。还有一个 <code>Token()</code> 方法返回输入流里的下一个 XML token。在输入流的结尾处，会返回（nil，io.EOF）</p>
<p>XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 <code>[] byte</code>，通过字符串转换让其变得可读性强一些。</p>
<h3 id="Gob-数据格式"><a href="#Gob-数据格式" class="headerlink" title="Gob 数据格式"></a>Gob 数据格式</h3><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 <code>encoding</code> 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。</p>
<p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。</p>
<p>它和 JSON 或 XML 有什么不同呢？Gob 特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</p>
<p>Gob 不是可外部定义，语言无关的编码方式。因此它的首选格式是二进制，而不是像 JSON 和 XML 那样的文本格式。<br>Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</p>
<p>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p>
<p>只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</p>
<p>假如在发送者这边有一个有结构 T：</p>
<pre><code class="go">type T struct { X, Y, Z int }
var t = T{X: 7, Y: 0, Z: 8}</code></pre>
<p>而在接收者这边可以用一个结构体 U 类型的变量 u 来接收这个值：</p>
<pre><code class="go">type U struct { X, Y *int8 }
var u U</code></pre>
<p>在接收者中，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）</p>
<p>和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode</code>。</p>
<pre><code class="go">// gob1.go
package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;encoding/gob&quot;
    &quot;log&quot;
)

type P struct {
    X, Y, Z int
    Name    string
}

type Q struct {
    X, Y *int32
    Name string
}

func main() {
    // Initialize the encoder and decoder.  Normally enc and dec would be      
    // bound to network connections and the encoder and decoder would      
    // run in different processes.      
    var network bytes.Buffer   // Stand-in for a network connection      
    enc := gob.NewEncoder(&amp;network) // Will write to network.      
    dec := gob.NewDecoder(&amp;network) // Will read from network.      
    // Encode (send) the value.      
    err := enc.Encode(P{3, 4, 5, &quot;Pythagoras&quot;})
    if err != nil {
        log.Fatal(&quot;encode error:&quot;, err)
    }
    // Decode (receive) the value.      
    var q Q
    err = dec.Decode(&amp;q)
    if err != nil {
        log.Fatal(&quot;decode error:&quot;, err)
    }
    fmt.Printf(&quot;%q: {%d,%d}\n&quot;, q.Name, *q.X, *q.Y)
}
// Output:   &quot;Pythagoras&quot;: {3,4}</code></pre>
<p>编码到文件：</p>
<pre><code class="go">// gob2.go
package main

import (
    &quot;encoding/gob&quot;
    &quot;log&quot;
    &quot;os&quot;
)

type Address struct {
    Type             string
    City             string
    Country          string
}

type VCard struct {
    FirstName   string
    LastName    string
    Addresses   []*Address
    Remark      string
}

var content string

func main() {
    pa := &amp;Address{&quot;private&quot;, &quot;Aartselaar&quot;,&quot;Belgium&quot;}
    wa := &amp;Address{&quot;work&quot;, &quot;Boom&quot;, &quot;Belgium&quot;}
    vc := VCard{&quot;Jan&quot;, &quot;Kersschot&quot;, []*Address{pa,wa}, &quot;none&quot;}
    // fmt.Printf(&quot;%v: \n&quot;, vc) // {Jan Kersschot [0x126d2b80 0x126d2be0] none}:
    // using an encoder:
    file, _ := os.OpenFile(&quot;vcard.gob&quot;, os.O_CREATE|os.O_WRONLY, 0666)
    defer file.Close()
    enc := gob.NewEncoder(file)
    err := enc.Encode(vc)
    if err != nil {
        log.Println(&quot;Error in encoding gob&quot;)
    }
}</code></pre>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>通过网络传输的数据必须加密，以防止被 hacker（黑客）读取或篡改，并且保证发出的数据和收到的数据检验和一致。<br>鉴于 Go 母公司的业务， Go 的标准库为该领域提供了超过 30 个的包：</p>
<ul>
<li><code>hash</code> 包：实现了 <code>adler32</code>、<code>crc32</code>、<code>crc64</code> 和 <code>fnv</code> 校验；</li>
<li><code>crypto</code> 包：实现了其它的 hash 算法，比如 <code>md4</code>、<code>md5</code>、<code>sha1</code> 等。以及完整地实现了 <code>aes</code>、<code>blowfish</code>、<code>rc4</code>、<code>rsa</code>、<code>xtea</code> 等加密算法。</li>
</ul>
<p>下面的示例用 <code>sha1</code> 和 <code>md5</code> 计算并输出了一些校验值。</p>
<pre><code class="go">// hash_sha1.go
package main

import (
    &quot;fmt&quot;
    &quot;crypto/sha1&quot;
    &quot;io&quot;
    &quot;log&quot;
)

func main() {
    hasher := sha1.New()
    io.WriteString(hasher, &quot;test&quot;)
    b := []byte{}
    fmt.Printf(&quot;Result: %x\n&quot;, hasher.Sum(b))
    fmt.Printf(&quot;Result: %d\n&quot;, hasher.Sum(b))
    //
    hasher.Reset()
    data := []byte(&quot;We shall overcome!&quot;)
    n, err := hasher.Write(data)
    if n!=len(data) || err!=nil {
        log.Printf(&quot;Hash write error: %v / %v&quot;, n, err)
    }
    checksum := hasher.Sum(b)
    fmt.Printf(&quot;Result: %x\n&quot;, checksum)
}</code></pre>
<p>输出：</p>
<pre><code class="php">Result: a94a8fe5ccb19ba61c4c0873d391e987982fbbd3
Result: [169 74 143 229 204 177 155 166 28 76 8 115 211 145 233 135 152 47 187 211]
Result: e2222bfc59850bbb00a722e764a555603bb59b2a</code></pre>
<p>通过调用 <code>sha1.New()</code> 创建了一个新的 <code>hash.Hash</code> 对象，用来计算 SHA1 校验值。<code>Hash</code> 类型实际上是一个接口，它实现了 <code>io.Writer</code> 接口：</p>
<pre><code class="go">type Hash interface {
    // Write (via the embedded io.Writer interface) adds more data to the running hash.
    // It never returns an error.
    io.Writer

    // Sum appends the current hash to b and returns the resulting slice.
    // It does not change the underlying hash state.
    Sum(b []byte) []byte

    // Reset resets the Hash to its initial state.
    Reset()

    // Size returns the number of bytes Sum will return.
    Size() int

    // BlockSize returns the hash&#39;s underlying block size.
    // The Write method must be able to accept any amount
    // of data, but it may operate more efficiently if all writes
    // are a multiple of the block size.
    BlockSize() int
}</code></pre>
<p>通过 io.WriteString 或 hasher.Write 将给定的 [] byte 附加到当前的 <code>hash.Hash</code> 对象中。</p>
<h1 id="错误异常处理"><a href="#错误异常处理" class="headerlink" title="错误异常处理"></a>错误异常处理</h1><p>Go 没有像 Java 和 .NET 那样的 <code>try/catch</code> 异常机制：不能执行抛异常操作。但是有一套 <code>defer-panic-and-recover</code> 机制。</p>
<p>Go 的设计者觉得 <code>try/catch</code> 机制的使用太泛滥了，而且从底层向更高的层级抛异常太耗费资源。他们给 Go 设计的机制也可以 “捕捉” 异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。</p>
<p>Go 是怎么处理普通错误的呢？通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 —— 如果返回 nil，则没有错误发生 —— 并且主调（calling）函数总是应该检查收到的错误。</p>
<p><strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong></p>
<p>处理错误并且在函数发生错误的地方给用户返回错误信息：照这样处理就算真的出了问题，程序也能继续运行并且通知给用户。<code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p>
<p>库函数通常必须返回某种错误提示给主调（calling）函数。</p>
<p>Go 检查和报告错误条件的惯有方式：</p>
<ul>
<li>产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误。</li>
<li>为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。</li>
</ul>
<p>下面这段来自 pack1 包的代码 Func1 测试了它的返回值：</p>
<pre><code class="go">if value, err := pack1.Func1(param1); err != nil {
    fmt.Printf(“Error %s in pack1.Func1 with parameter %v”, err.Error(), param1)
    return    // or: return err
} else {
    // Process(value)
}</code></pre>
<p><em>为了更清晰的代码，应该总是使用包含错误值变量的 if 复合语句</em></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 有一个预先定义的 error 接口类型</p>
<pre><code class="go">type error interface {
    Error() string
}</code></pre>
<p>错误值用来表示异常状态；errors 包中有一个 <code>errorString</code> 结构体实现了 error 接口。当程序处于错误状态时可以用 <code>os.Exit(1)</code> 来中止运行。</p>
<h3 id="定义错误"><a href="#定义错误" class="headerlink" title="定义错误"></a>定义错误</h3><p>任何时候当需要一个新的错误类型，都可以用 <code>errors</code>（必须先 import）包的 <code>errors.New</code> 函数接收合适的错误信息来创建，像下面这样：</p>
<pre><code class="go">err := errors.New(“math - square root of negative number”)</code></pre>
<p>一个简单的用例：</p>
<pre><code class="go">// errors.go
package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

var errNotFound error = errors.New(&quot;Not found error&quot;)

func main() {
    fmt.Printf(&quot;error: %v&quot;, errNotFound)
}
// error: Not found error</code></pre>
<p>可以把它用于计算平方根函数的参数测试：</p>
<pre><code class="go">func Sqrt(f float64) (float64, error) {
    if f &lt; 0 {
        return 0, errors.New (&quot;math - square root of negative number&quot;)
    }
   // implementation of Sqrt
}</code></pre>
<p>可以像下面这样调用 Sqrt 函数：</p>
<pre><code class="go">if f, err := Sqrt(-1); err != nil {
    fmt.Printf(&quot;Error: %s\n&quot;, err)
}</code></pre>
<p>由于 <code>fmt.Printf</code> 会自动调用 <code>String()</code> 方法 ，所以错误信息 “Error: math - square root of negative number” 会打印出来。通常（错误信息）都会有像 “Error:” 这样的前缀，所以错误信息不要以大写字母开头。</p>
<p>在大部分情况下自定义错误结构类型很有意义的，可以包含除了（低层级的）错误信息以外的其它有用信息，例如，正在进行的操作（打开文件等），全路径或名字。看下面例子中 os.Open 操作触发的 PathError 错误：</p>
<pre><code class="go">// PathError records an error and the operation and file path that caused it.
type PathError struct {
    Op string    // &quot;open&quot;, &quot;unlink&quot;, etc.
    Path string  // The associated file.
    Err error  // Returned by the system call.
}

func (e *PathError) String() string {
    return e.Op + &quot; &quot; + e.Path + &quot;: &quot;+ e.Err.Error()
}</code></pre>
<p>如果有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断（type-switch）是很有用的，并且可以根据错误场景做一些补救和恢复操作。</p>
<pre><code class="go">//  err != nil
if e, ok := err.(*os.PathError); ok {
    // remedy situation
}</code></pre>
<p>或：</p>
<pre><code class="go">switch err := err.(type) {
    case ParseError:
        PrintParseError(err)
    case PathError:
        PrintPathError(err)
    ...
    default:
        fmt.Printf(&quot;Not a special error, just %s\n&quot;, err)
}</code></pre>
<p>作为第二个例子考虑用 json 包的情况。当 json.Decode 在解析 JSON 文档发生语法错误时，指定返回一个 SyntaxError 类型的错误：</p>
<pre><code class="go">type SyntaxError struct {
    msg    string // description of error
// error occurred after reading Offset bytes, from which line and columnnr can be obtained
    Offset int64
}

func (e *SyntaxError) String() string { return e.msg }</code></pre>
<p>在调用代码中可以像这样用类型断言测试错误是不是上面的类型：</p>
<pre><code class="go">if serr, ok := err.(*json.SyntaxError); ok {
    line, col := findLine(f, serr.Offset)
    return fmt.Errorf(&quot;%s:%d:%d: %v&quot;, f.Name(), line, col, err)
}</code></pre>
<p>包也可以用额外的方法（methods）定义特定的错误，比如 net.Error：</p>
<pre><code class="go">package net
type Error interface {
    Timeout() bool   // Is the error a timeout?
    Temporary() bool // Is the error temporary?
}</code></pre>
<p>正如所看到的一样，所有的例子都遵循同一种命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</p>
<p>syscall 是低阶外部包，用来提供系统基本调用的原始接口。它们返回整数的错误码；类型 syscall.Errno 实现了 Error 接口。</p>
<p>大部分 syscall 函数都返回一个结果和可能的错误，比如：</p>
<pre><code class="go">r, err := syscall.Open(name, mode, perm)
if err != 0 {
    fmt.Println(err.Error())
}</code></pre>
<p>os 包也提供了一套像 os.EINAL 这样的标准错误，它们基于 syscall 错误：</p>
<pre><code class="go">var (
    EPERM       Error = Errno(syscall.EPERM)
    ENOENT      Error = Errno(syscall.ENOENT)
    ESRCH       Error = Errno(syscall.ESRCH)
    EINTR       Error = Errno(syscall.EINTR)
    EIO         Error = Errno(syscall.EIO)
    ...
)</code></pre>
<h3 id="用-fmt-创建错误对象"><a href="#用-fmt-创建错误对象" class="headerlink" title="用 fmt 创建错误对象"></a>用 fmt 创建错误对象</h3><p>通常想要返回包含错误参数的更有信息量的字符串，例如：可以用 <code>fmt.Errorf()</code> 来实现：它和 fmt.Printf () 完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。</p>
<p>比如在前面的平方根例子中使用：</p>
<pre><code class="go">if f &lt; 0 {
    return 0, fmt.Errorf(&quot;math: square root of negative number %g&quot;, f)
}</code></pre>
<p>第二个例子：从命令行读取输入时，如果加了 help 标志，可以用有用的信息产生一个错误：</p>
<pre><code class="go">if len(os.Args) &gt; 1 &amp;&amp; (os.Args[1] == &quot;-h&quot; || os.Args[1] == &quot;--help&quot;) {
    err = fmt.Errorf(&quot;usage: %s infile.txt outfile.txt&quot;, filepath.Base(os.Args[0]))
    return
}</code></pre>
<h2 id="从-panic-恢复（Recover）"><a href="#从-panic-恢复（Recover）" class="headerlink" title="从 panic 恢复（Recover）"></a>从 panic 恢复（Recover）</h2><p>内建函数被用于从 panic 或错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。</p>
<p><strong><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。</strong></p>
<p>总结：<code>panic</code> 会导致栈被展开直到 defer 修饰的 <code>recover ()</code> 被调用或者程序中止。</p>
<pre><code class="go">func protect(g func()) {
    defer func() {
        log.Println(&quot;done&quot;)
        // Println executes normally even if there is a panic
        if err := recover(); err != nil {
        log.Printf(&quot;run time panic: %v&quot;, err)
        }
    }()
    log.Println(&quot;start&quot;)
    g() //   possible runtime-error
}</code></pre>
<p><strong>需要注意的是，应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制</strong>。</p>
<p>panic 有两个合理的用例。</p>
<ol>
<li><strong>发生了一个不能恢复的错误，此时程序不能继续运行</strong>。 一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。</li>
<li><strong>发生了一个编程上的错误</strong>。 假如我们有一个接收指针参数的方法，而其他人使用 <code>nil</code> 作为参数调用了它。在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 <code>nil</code> 参数调用了一个只能接收合法指针的方法。</li>
</ol>
<h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>这是所有自定义包实现者应该遵守的最佳实践：</p>
<ol>
<li><p>在包内部，总是应该从 <code>panic</code> 中 <code>recover</code>：不允许显式的超出包范围的 <code>panic ()</code></p>
</li>
<li><p>向包的调用者返回错误值（而不是 panic）。</p>
</li>
</ol>
<p>在包内部，特别是在非导出函数中有很深层次的嵌套调用时，对主调函数来说用 <code>panic</code> 来表示应该被翻译成错误的错误场景是很有用的（并且提高了代码可读性）。</p>
<p>这在下面的代码中被很好地阐述了。有一个简单的 parse 包用来把输入的字符串解析为整数切片；这个包有自己特殊的 <code>ParseError</code>。</p>
<p>当没有东西需要转换或者转换成整数失败时，这个包会 panic（在函数 fields2numbers 中）。<strong>但是可导出的 Parse 函数会从 panic 中 recover 并用所有这些信息返回一个错误给调用者。</strong></p>
<pre><code class="go">// parse.go
package parse

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;strconv&quot;
)

// A ParseError indicates an error in converting a word into an integer.
type ParseError struct {
    Index int      // The index into the space-separated list of words.
    Word  string   // The word that generated the parse error.
    Err error // The raw error that precipitated this error, if any.
}

// String returns a human-readable error message.
func (e *ParseError) String() string {
    return fmt.Sprintf(&quot;pkg parse: error parsing %q as int&quot;, e.Word)
}

// Parse parses the space-separated words in in put as integers.
func Parse(input string) (numbers []int, err error) {
    defer func() {
        if r := recover(); r != nil {
            var ok bool
            err, ok = r.(error)
            if !ok {
                err = fmt.Errorf(&quot;pkg: %v&quot;, r)
            }
        }
    }()

    fields := strings.Fields(input)
    numbers = fields2numbers(fields)
    return
}

func fields2numbers(fields []string) (numbers []int) {
    if len(fields) == 0 {
        panic(&quot;no words to parse&quot;)
    }
    for idx, field := range fields {
        num, err := strconv.Atoi(field)
        if err != nil {
            panic(&amp;ParseError{idx, field, err})
        }
        numbers = append(numbers, num)
    }
    return
}</code></pre>
<h1 id="Go-中的单元测试和基准测试"><a href="#Go-中的单元测试和基准测试" class="headerlink" title="Go 中的单元测试和基准测试"></a>Go 中的单元测试和基准测试</h1><p>首先所有的包都应该有一定的必要文档，然后同样重要的是对包的测试。</p>
<p>名为 testing 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。</p>
<p>对一个包做（单元）测试，需要写一些可以频繁（每次更新后）执行的小块测试单元来检查代码的正确性。所以必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足这种形式 <code>*_test.go</code>，所以测试代码和包中的业务代码是分开的。</p>
<p><code>_test</code> 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。</p>
<p>测试文件中必须导入 “testing” 包，并写一些名字以 <code>TestZzz</code> 打头的全局函数，这里的 <code>Zzz</code> 是被测试函数的字母描述，如 TestFmtInterface，TestPayEmployees 等。</p>
<p>测试函数必须有这种形式的头部：</p>
<pre><code class="go">func TestAbcde(t *testing.T)</code></pre>
<p>T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误。成功的测试则直接返回。</p>
<p>用下面这些函数来通知测试失败：</p>
<p>1）<code>func (t *T) Fail()</code></p>
<pre><code class="php">    标记测试函数为失败，然后继续执行（剩下的测试）。</code></pre>
<p>2）<code>func (t *T) FailNow()</code></p>
<pre><code class="php">    标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。</code></pre>
<p>3）<code>func (t *T) Log(args ...interface{})</code></p>
<pre><code class="php">    args 被用默认的格式格式化并打印到错误日志中。</code></pre>
<p>4）<code>func (t *T) Fatal(args ...interface{})</code></p>
<pre><code class="php">    结合 先执行 3），然后执行 2）的效果。</code></pre>
<p>运行 go test 来编译测试程序，并执行程序中所有的 TestZZZ 函数。如果所有的测试都通过会打印出 PASS。</p>
<p>gotest 可以接收一个或多个函数程序作为参数，并指定一些选项。</p>
<p>结合 –chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。</p>
<p>例如：</p>
<pre><code class="bash">go test fmt_test.go --chatty
=== RUN fmt.TestFlagParser
--- PASS: fmt.TestFlagParser
=== RUN fmt.TestArrayPrinter
--- PASS: fmt.TestArrayPrinter
...</code></pre>
<p>testing 包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 <code>BenchmarkZzz</code> 打头的函数并接收一个 <code>*testing.B</code> 类型的参数，比如：</p>
<pre><code class="go">func BenchmarkReverse(b *testing.B) {
    ...
}</code></pre>
<p>命令 <code>go test –test.bench=.*</code> 会运行所有的基准测试函数；代码中的函数会被调用 N 次（N 是非常大的数，如 N = 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns/op）。如果是用 testing.Benchmark 调用这些函数，直接运行程序即可。</p>
<h2 id="测试的具体例子"><a href="#测试的具体例子" class="headerlink" title="测试的具体例子"></a>测试的具体例子</h2><p>例如用一个程序用来测试前 100 个整数是否是偶数。</p>
<p>下面是一种可能的方案：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;even/even&quot;
)

func main() {
    for i:=0; i&lt;=100; i++ {
        fmt.Printf(&quot;Is the integer %d even? %v\n&quot;, i, even.Even(i))
    }
}</code></pre>
<p>上面使用了 even.go 中的 even 包：</p>
<pre><code class="go">package even

func Even(i int) bool {     // Exported function
    return i%2 == 0
}

func Odd(i int) bool {      // Exported function
    return i%2 != 0
}</code></pre>
<p>在 even 包的路径下，创建一个名为 oddeven_test.go 的测试程序：</p>
<pre><code class="go">package even

import &quot;testing&quot;

func TestEven(t *testing.T) {
    if !Even(10) {
        t.Log(&quot; 10 must be even!&quot;)
        t.Fail()
    }
    if Even(7) {
        t.Log(&quot; 7 is not even!&quot;)
        t.Fail()
    }

}

func TestOdd(t *testing.T) {
    if !Odd(11) {
        t.Log(&quot; 11 must be odd!&quot;)
        t.Fail()
    }
    if Odd(10) {
        t.Log(&quot; 10 is not odd!&quot;)
        t.Fail()
    }
}</code></pre>
<p>由于测试需要具体的输入用例且不可能测试到所有的用例（非常像一个无穷的数），所以必须对要使用的测试用例思考再三。</p>
<p>至少应该包括：</p>
<ul>
<li>正常的用例</li>
<li>反面的用例（错误的输入，如用负数或字母代替数字，没有输入等）</li>
<li>边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况）</li>
</ul>
<p>可以直接执行 go install 安装 even 或者创建一个 以下内容的 Makefile：</p>
<pre><code class="bash">include $(GOROOT)/src/Make.inc
TARG=even
GOFILES=\
       even.go\
include $(GOROOT)/src/Make.pkg</code></pre>
<p>然后执行 make（或 gomake）命令来构建归档文件 even.a</p>
<p>测试代码不能在 GOFILES 参数中引用，因为我们不希望生成的程序中有测试代码。如果包含了测试代码，go test 会给出错误提示！go test 会生成一个单独的包含测试代码的 <code>_test</code> 程序。</p>
<p>现在可以用命令：<code>go test</code>（或 <code>make test</code>）来测试 even 包。</p>
<p>为了看到失败时的输出，把函数 TestEven 改为：</p>
<pre><code class="go">func TestEven(t *testing.T) {
    if Even(10) {
        t.Log(“Everything OK: 10 is even, just a test to see failed output!”)
        t.Fail()
    }
}</code></pre>
<p>现在会调用 t.Log 和 t.Fail，得到的结果如下：</p>
<pre><code class="go">--- FAIL: even.TestEven (0.00 seconds)
Everything OK: 10 is even, just a test to see failed output!
FAIL</code></pre>
<p>编写测试代码时，一个较好的办法是把测试的输入数据和期望的结果写在一起组成一个数据表：表中的每条记录都是一个含有输入和期望值的完整测试用例，有时还可以结合像测试名字这样的额外信息来让测试输出更多的信息。</p>
<p>实际测试时简单迭代表中的每条记录，并执行必要的测试。</p>
<p>可以抽象为下面的代码段：</p>
<pre><code class="go">var tests = []struct{   // Test table
    in  string
    out string

}{
    {“in1”, “exp1”},
    {“in2”, “exp2”},
    {“in3”, “exp3”},
...
}

func TestFunction(t *testing.T) {
    for i, tt := range tests {
        s := FuncToBeTested(tt.in)
        if s != tt.out {
            t.Errorf(“%d. %q =&gt; %q, wanted: %q”, i, tt.in, s, tt.out)
        }
    }
}</code></pre>
<p>如果大部分函数都可以写成这种形式，那么写一个帮助函数 verify 对实际测试会很有帮助：</p>
<pre><code class="go">func verify(t *testing.T, testnum int, testcase, input, output, expected string) {
    if expected != output {
        t.Errorf(&quot;%d. %s with input = %s: output %s != %s&quot;, testnum, testcase, input, output, expected)
    }
}</code></pre>
<p>TestFunction 则变为：</p>
<pre><code class="go">func TestFunction(t *testing.T) {
    for i, tt := range tests {
        s := FuncToBeTested(tt.in)
        verify(t, i, “FuncToBeTested: “, tt.in, s, tt.out)
    }
}</code></pre>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="go-程"><a href="#go-程" class="headerlink" title="go 程"></a>go 程</h2><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p>
<pre><code>go f(x, y, z)</code></pre><p>会启动一个新的 Go 程并执行</p>
<pre><code>f(x, y, z)</code></pre><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p>
<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href="https://go-zh.org/pkg/sync/" target="_blank" rel="noopener"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>协程是独立执行的，他们之间没有通信。他们必须通信才会变得更有用：彼此之间发送和接收信息并且协调 / 同步他们的工作。协程可以使用共享变量来通信，但是很不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。</p>
<p>而 Go 有一个特殊的类型，<code>通道（channel）</code>，像是通道（管道），可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。数据通过通道：同一时间只有一个协程可以访问数据：所以不会出现数据竞争，设计如此。数据的归属（可以读写数据的能力）被传递。</p>
<p>工厂的传送带是个很有用的例子。一个机器（生产者协程）在传送带上放置物品，另外一个机器（消费者协程）拿到物品并打包。</p>
<p>通道服务于通信的两个目的：值的交换，同步的，保证了两个计算（协程）任何时候都是可知状态。</p>
<p>声明信道可以采用：</p>
<pre><code class="go">var identifier chan datatype</code></pre>
<p>信道是带有类型的管道，可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<pre><code>ch &lt;- v    // 将 v 发送至信道 ch。
v := &lt;-ch  // 从 ch 接收值并赋予 v。</code></pre><p>（“箭头”就是数据流的方向。）</p>
<p>通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。通道也是引用类型，所以我们使用 <code>make()</code> 函数来给它分配内存。</p>
<p>和映射与切片一样，信道在使用前必须创建：</p>
<pre><code>ch := make(chan int)</code></pre><p>默认情况下，<strong>发送和接收操作在另一端准备好之前都会阻塞</strong>。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func sum(s []int, c chan int) {
    sum := 0
    for _, v := range s {
        sum += v
    }
    c &lt;- sum // 将和送入 c
}

func main() {
    s := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(s[:len(s)/2], c) //17
    go sum(s[len(s)/2:], c) //-5
    x, y := &lt;-c, &lt;-c // 从 c 中接收

    fmt.Println(x, y, x+y) //-5 17 12（由此推断信道先进后出）
}</code></pre>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>使用信道需要考虑的一个重点是死锁。当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。<strong>如果没有的话，程序就会在运行时触发 panic，形成死锁。</strong></p>
<p>同理，<strong>当有 Go 协程等着从一个信道接收数据时，我们期望其他的 Go 协程会向该信道写入数据，要不然程序就会触发 panic</strong>。</p>
<pre><code class="go">package main

func main() {  
    ch := make(chan int)
    ch &lt;- 5
}</code></pre>
<p>在上述程序中，创建了一个信道 <code>ch</code>，接着在下一行 <code>ch &lt;- 5</code>，我们把 <code>5</code> 发送到这个信道。对于本程序，没有其他的协程从 <code>ch</code> 接收数据。于是程序触发 panic，出现如下运行时错误。</p>
<pre><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:  
main.main()  
    /tmp/sandbox249677995/main.go:6 +0x80</code></pre><h3 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h3><p>信道有双向信道，即通过信道既能发送数据，又能接收数据。其实也可以创建单向信道，这种信道只能发送或者接收数据。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func sendData(sendch chan&lt;- int) {  
    sendch &lt;- 10
}

func main() {  
    sendch := make(chan&lt;- int)
    go sendData(sendch)
      //会报错
    fmt.Println(&lt;-sendch)
}</code></pre>
<p>上面程序的中，创建了唯送（Send Only）信道 <code>sendch</code>。<code>chan&lt;- int</code> 定义了唯送信道，因为箭头指向了 <code>chan</code>。当程序试图通过唯送信道接收数据，于是编译器报错：</p>
<pre><code>main.go:11: invalid operation: &lt;-sendch (receive from send-only type chan&lt;- int)</code></pre><p>单向信道可以用于信道转换：</p>
<p>把一个双向信道转换成唯送信道或者唯收（Receive Only）信道都是行得通的，但是反过来就不行。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func sendData(sendch chan&lt;- int) {  
    sendch &lt;- 10
}

func main() {  
    cha1 := make(chan int)
    go sendData(cha1)
    fmt.Println(&lt;-cha1)
}</code></pre>
<p>在上述程序中，创建了一个双向信道 <code>cha1</code>。<code>cha1</code> 作为参数传递给了 <code>sendData</code> 协程。函数 <code>sendData</code> 里的参数 <code>sendch chan&lt;- int</code> 把 <code>cha1</code> 转换为一个唯送信道。于是该信道在 <code>sendData</code> 协程里是一个唯送信道，而在 Go 主协程里是一个双向信道。该程序最终打印输出 <code>10</code>。</p>
<h3 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h3><p>信道可以是带缓冲的。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p>
<pre><code>ch := make(chan int, 100)</code></pre><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<h3 id="关闭信道"><a href="#关闭信道" class="headerlink" title="关闭信道"></a>关闭信道</h3><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<pre><code>v, ok := &lt;-ch</code></pre><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
</li>
<li><p>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
</li>
</ul>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i &lt; n; i++ {
        c &lt;- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    //不断接受不了直到 c close（并发）
    for i := range c {
        fmt.Println(i)
    }
}</code></pre>
<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p><code>WaitGroup</code> 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。假设有 3 个并发执行的 Go 协程（由 Go 主协程生成）。Go 主协程需要等待这 3 个协程执行结束后，才会终止。这就可以用 <code>WaitGroup</code> 来实现。</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func process(i int, wg *sync.WaitGroup) {  
    fmt.Println(&quot;started Goroutine &quot;, i)
    time.Sleep(2 * time.Second)
    fmt.Printf(&quot;Goroutine %d ended\n&quot;, i)
    wg.Done()
}

func main() {  
    no := 3
    var wg sync.WaitGroup
    for i := 0; i &lt; no; i++ {
        wg.Add(1)
        go process(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(&quot;All go routines finished executing&quot;)
}</code></pre>
<p>WaitGroup 是一个结构体类型，创建了 <code>WaitGroup</code> 类型的变量，其初始值为零值。<code>WaitGroup</code> 使用计数器来工作。当调用 <code>WaitGroup</code> 的 <code>Add</code> 并传递一个 <code>int</code> 时，<code>WaitGroup</code> 的计数器会加上 <code>Add</code> 的传参。要减少计数器，可以调用 <code>WaitGroup</code> 的 <code>Done()</code> 方法。<code>Wait()</code> 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。</p>
<p>上述程序里，for 循环迭代了 3 次，在循环内调用了 <code>wg.Add(1)</code>。因此计数器变为 3。for 循环同样创建了 3 个 <code>process</code> 协程，然后在调用了 <code>wg.Wait()</code>，确保 Go 主协程等待计数器变为 0。<code>process</code> 协程内调用了 <code>wg.Done</code>，可以让计数器递减。一旦 3 个子协程都执行完毕（即 <code>wg.Done()</code> 调用了 3 次），那么计数器就变为 0，于是主协程会解除阻塞。</p>
<p><strong>传递 <code>wg</code> 的地址是很重要的。如果没有传递 <code>wg</code> 的地址，那么每个 Go 协程将会得到一个 <code>WaitGroup</code> 值的拷贝，因而当它们执行结束时，<code>main</code> 函数并不会知道</strong>。</p>
<p>该程序输出：</p>
<pre><code>started Goroutine  2  
started Goroutine  0  
started Goroutine  1  
Goroutine 0 ended  
Goroutine 2 ended  
Goroutine 1 ended  
All go routines finished executing</code></pre><p>由于 Go 协程的执行顺序不一定，所以输出具有随机性。</p>
<h3 id="工作池的实现"><a href="#工作池的实现" class="headerlink" title="工作池的实现"></a>工作池的实现</h3><p>缓冲信道的重要应用之一就是实现工作池。</p>
<p>一般而言，工作池就是一组等待任务分配的线程。一旦完成了所分配的任务，这些线程可继续等待任务的分配。</p>
<p>可以通过使用缓冲信道来实现工作池。假设工作池的任务是计算所输入数字的每一位的和。例如，如果输入 234，结果会是 9（即 2 + 3 + 4）。向工作池输入的是一列伪随机数。</p>
<p>该工作池的核心功能如下：</p>
<ul>
<li>创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。</li>
<li>将作业添加到该输入型缓冲信道中。</li>
<li>作业完成后，再将结果写入一个输出型缓冲信道。</li>
<li>从输出型缓冲信道读取并打印结果。</li>
</ul>
<p>第一步就是创建一个结构体，表示作业和结果。</p>
<pre><code class="go">type Job struct {  
    id       int
    randomno int
}
type Result struct {  
    job         Job
    sumofdigits int
}</code></pre>
<p>所有 <code>Job</code> 结构体变量都会有 <code>id</code> 和 <code>randomno</code> 两个字段，<code>randomno</code> 表示将要用于计算的数字。</p>
<p>而 <code>Result</code> 结构体有一个 <code>job</code> 字段，表示所对应的作业，还有一个 <code>sumofdigits</code> 字段，表示计算的结果（每位数字之和）。</p>
<p>第二步是分别创建用于接收作业和写入结果的缓冲信道。</p>
<pre><code class="go">var jobs = make(chan Job, 10)  
var results = make(chan Result, 10)</code></pre>
<p>工作协程（Worker Goroutine）会监听缓冲信道 <code>jobs</code> 里更新的作业。一旦工作协程完成了作业，其结果会写入缓冲信道 <code>results</code>。</p>
<p>如下所示，<code>digits</code> 函数的任务实际上就是计算整数的每一位之和，最后返回该结果。为了模拟出 <code>digits</code> 在计算过程中花费了一段时间，在函数内添加了两秒的休眠时间。</p>
<pre><code class="go">func digits(number int) int {  
    sum := 0
    no := number
    for no != 0 {
        digit := no % 10
        sum += digit
        no /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}</code></pre>
<p>然后，写一个创建工作协程的函数。</p>
<pre><code class="go">func worker(wg *sync.WaitGroup) {  
    for job := range jobs {
        output := Result{job, digits(job.randomno)}
        results &lt;- output
    }
    wg.Done()
}</code></pre>
<p>上面的函数创建了一个工作者（Worker），读取 <code>jobs</code> 信道的数据，根据当前的 <code>job</code> 和 <code>digits</code> 函数的返回值，创建了一个 <code>Result</code> 结构体变量，然后将结果写入 <code>results</code> 缓冲信道。<code>worker</code> 函数接收了一个 <code>WaitGroup</code> 类型的 <code>wg</code> 作为参数，当所有的 <code>jobs</code> 完成的时候，调用了 <code>Done()</code> 方法。</p>
<p><code>createWorkerPool</code> 函数创建了一个 Go 协程的工作池。</p>
<pre><code class="go">func createWorkerPool(noOfWorkers int) {  
    var wg sync.WaitGroup
    for i := 0; i &lt; noOfWorkers; i++ {
        wg.Add(1)
        go worker(&amp;wg)
    }
    wg.Wait()
    close(results)
}</code></pre>
<p>上面函数的参数是需要创建的工作协程的数量。在创建 Go 协程之前，它调用了 <code>wg.Add(1)</code> 方法，于是 <code>WaitGroup</code> 计数器递增。接下来，创建工作协程，并向 <code>worker</code> 函数传递 <code>wg</code> 的地址。创建了需要的工作协程后，函数调用 <code>wg.Wait()</code>，等待所有的 Go 协程执行完毕。所有协程完成执行之后，函数会关闭 <code>results</code> 信道。因为所有协程都已经执行完毕，于是不再需要向 <code>results</code> 信道写入数据了。</p>
<p>现在已经有了工作池，继续编写一个函数，把作业分配给工作者。</p>
<pre><code class="go">func allocate(noOfJobs int) {  
    for i := 0; i &lt; noOfJobs; i++ {
        randomno := rand.Intn(999)
        job := Job{i, randomno}
        jobs &lt;- job
    }
    close(jobs)
}</code></pre>
<p>上面的 <code>allocate</code> 函数接收所需创建的作业数量作为输入参数，生成了最大值为 998 的伪随机数，并使用该随机数创建了 <code>Job</code> 结构体变量。这个函数把 for 循环的计数器 <code>i</code> 作为 id，最后把创建的结构体变量写入 <code>jobs</code> 信道。当写入所有的 <code>job</code> 时，它关闭了 <code>jobs</code> 信道。</p>
<p>下一步是创建一个读取 <code>results</code> 信道和打印输出的函数。</p>
<pre><code class="go">func result(done chan bool) {  
    for result := range results {
        fmt.Printf(&quot;Job id %d, input random no %d , sum of digits %d\n&quot;, result.job.id, result.job.randomno, result.sumofdigits)
    }
    done &lt;- true
}</code></pre>
<p><code>result</code> 函数读取 <code>results</code> 信道，并打印出 <code>job</code> 的 <code>id</code>、输入的随机数、该随机数的每位数之和。<code>result</code> 函数也接受 <code>done</code> 信道作为参数，当打印所有结果时，<code>done</code> 会被写入 true。</p>
<p>现在一切准备充分了。继续完成最后一步，在 <code>main()</code> 函数中调用上面所有的函数。</p>
<pre><code class="go">func main() {  
    startTime := time.Now()
    noOfJobs := 100
    go allocate(noOfJobs)
    done := make(chan bool)
    go result(done)
    noOfWorkers := 10
    createWorkerPool(noOfWorkers)
    &lt;-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)
}</code></pre>
<p>首先在 <code>main</code> 函数的第 2 行，保存了程序的起始时间，并在最后一行（第 12 行）计算了 <code>endTime</code> 和 <code>startTime</code> 的差值，显示出程序运行的总时间。由于想要通过改变协程数量，来做一点基准指标（Benchmark），所以需要这么做。</p>
<p>接着把 <code>noOfJobs</code> 设置为 100，接下来调用了 <code>allocate</code>，向 <code>jobs</code> 信道添加作业。</p>
<p>然后创建了 <code>done</code> 信道，并将其传递给 <code>result</code> 协程。于是该协程会开始打印结果，并在完成打印时发出通知。</p>
<p>通过调用 <code>createWorkerPool</code> 函数，最终创建了一个有 10 个协程的工作池。<code>main</code> 函数会监听 <code>done</code> 信道的通知，等待所有结果打印结束。</p>
<p>整体代码如下：</p>
<pre><code class="go">package main

import (  
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Job struct {  
    id       int
    randomno int
}
type Result struct {  
    job         Job
    sumofdigits int
}

var jobs = make(chan Job, 10)  
var results = make(chan Result, 10)

func digits(number int) int {  
    sum := 0
    no := number
    for no != 0 {
        digit := no % 10
        sum += digit
        no /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}
func worker(wg *sync.WaitGroup) {  
    for job := range jobs {
        output := Result{job, digits(job.randomno)}
        results &lt;- output
    }
    wg.Done()
}
func createWorkerPool(noOfWorkers int) {  
    var wg sync.WaitGroup
    for i := 0; i &lt; noOfWorkers; i++ {
        wg.Add(1)
        go worker(&amp;wg)
    }
    wg.Wait()
    close(results)
}
func allocate(noOfJobs int) {  
    for i := 0; i &lt; noOfJobs; i++ {
        randomno := rand.Intn(999)
        job := Job{i, randomno}
        jobs &lt;- job
    }
    close(jobs)
}
func result(done chan bool) {  
    for result := range results {
        fmt.Printf(&quot;Job id %d, input random no %d , sum of digits %d\n&quot;, result.job.id, result.job.randomno, result.sumofdigits)
    }
    done &lt;- true
}
func main() {  
    startTime := time.Now()
    noOfJobs := 100
    go allocate(noOfJobs)
    done := make(chan bool)
    go result(done)
    noOfWorkers := 10
    createWorkerPool(noOfWorkers)
    &lt;-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)
}</code></pre>
<h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p>
<p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<pre><code class="go">select {
case u:= &lt;- ch1:
        ...
case v:= &lt;- ch2:
        ...
        ...
default: // no value ready to be received
        ...
}</code></pre>
<p><code>default</code> 语句是可选的；<code>fallthrough</code> 行为，和普通的 <code>switch</code> 相似，是不允许的。在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，<code>select</code> 就结束了。</p>
<p><code>select</code> 做的就是：选择处理列出的多个通信情况中的一个。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）。</li>
</ul>
<p>在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</p>
<p><code>select</code> 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 <code>break</code> 语句使循环退出。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &lt;- x:
            x, y = y, x+y
        case &lt;-quit:
            fmt.Println(&quot;quit&quot;)
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &lt; 10; i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }()
    fibonacci(c, quit)
}</code></pre>
<p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p>
<p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<pre><code class="go">select {
case i := &lt;-c:
    // 使用 i
default:
    // 从 c 中接收会阻塞时执行
}</code></pre>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>sync.Mutex</code></p>
<p>可以到信道非常适合在各个 Go 程间进行通信。</p>
<p>但是如果并不需要通信呢？比如说，若只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>
<p>这里涉及的概念叫做互斥（mutualexclusion） ，我们通常使用互斥锁（Mutex）这一数据结构来提供这种机制。</p>
<p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex" target="_blank" rel="noopener"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p>
<ul>
<li><code>Lock</code></li>
<li><code>Unlock</code></li>
</ul>
<p>可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p>
<p>也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。</p>
<h2 id="锁和通道应用场景"><a href="#锁和通道应用场景" class="headerlink" title="锁和通道应用场景"></a>锁和通道应用场景</h2><ul>
<li>使用锁的情景：<ul>
<li>访问共享数据结构中的缓存信息</li>
<li>保存应用程序上下文和状态信息数据</li>
</ul>
</li>
<li>使用通道的情景：<ul>
<li>与异步操作的结果进行交互</li>
<li>分发任务</li>
<li>传递数据所有权</li>
</ul>
</li>
</ul>
<h1 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h1><h2 id="tcp-服务器"><a href="#tcp-服务器" class="headerlink" title="tcp 服务器"></a>tcp 服务器</h2><p>一个（web）服务器应用需要响应众多客户端的并发请求：go 会为每一个客户端产生一个协程用来处理请求。需要使用 net 包中网络通信的功能。它包含了用于 TCP/IP 以及 UDP 协议、域名解析等方法。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
)

func main() {
    fmt.Println(&quot;Starting the server ...&quot;)
    // 创建 listener
    listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:50000&quot;)
    if err != nil {
        fmt.Println(&quot;Error listening&quot;, err.Error())
        return //终止程序
    }
    // 监听并接受来自客户端的连接
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println(&quot;Error accepting&quot;, err.Error())
            return // 终止程序
        }
        go doServerStuff(conn)
    }
}

func doServerStuff(conn net.Conn) {
    for {
        buf := make([]byte, 512)
        len, err := conn.Read(buf)
        if err != nil {
            fmt.Println(&quot;Error reading&quot;, err.Error())
            return //终止程序
        }
        fmt.Printf(&quot;Received data: %v&quot;, string(buf[:len]))
    }
}</code></pre>
<p>在 <code>main()</code> 创建了一个 <code>net.Listener</code> 的变量，它是一个服务器的基本函数：用来监听和接收来自客户端的请求（来自 localhost 即 IP 地址为 127.0.0.1 端口为 50000 基于 TCP 协议）。这个 <code>Listen()</code> 函数可以返回一个 <code>error</code> 类型的错误变量。用一个无限 for 循环的 <code>listener.Accept()</code> 来等待客户端的请求。客户端的请求将产生一个 <code>net.Conn</code> 类型的连接变量。然后一个独立的协程使用这个连接执行 <code>doServerStuff()</code>，开始使用一个 512 字节的缓冲  <code>data</code>  来读取客户端发送来的数据并且把它们打印到服务器的终端，<code>len</code>  获取客户端发送的数据字节数；当客户端发送的所有数据都被读取完成时，协程就结束了。这段程序会为每一个客户端连接创建一个独立的协程。</p>
<p>下面的是客户端代码：</p>
<pre><code class="go">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() {
    //打开连接:
    conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:50000&quot;)
    if err != nil {
        //由于目标计算机积极拒绝而无法创建连接
        fmt.Println(&quot;Error dialing&quot;, err.Error())
        return // 终止程序
    }

    inputReader := bufio.NewReader(os.Stdin)
    fmt.Println(&quot;First, what is your name?&quot;)
    clientName, _ := inputReader.ReadString(&#39;\n&#39;)
    // fmt.Printf(&quot;CLIENTNAME %s&quot;, clientName)
    trimmedClient := strings.Trim(clientName, &quot;\n&quot;) // Windows 平台下用 &quot;\r\n&quot;，Linux平台下使用 &quot;\n&quot;
    // 给服务器发送信息直到程序退出：
    for {
        fmt.Println(&quot;What to send to the server? Type Q to quit.&quot;)
        input, _ := inputReader.ReadString(&#39;\n&#39;)
        trimmedInput := strings.Trim(input, &quot;\n&quot;)
        // fmt.Printf(&quot;input:--s%--&quot;, input)
        // fmt.Printf(&quot;trimmedInput:--s%--&quot;, trimmedInput)
        if trimmedInput == &quot;Q&quot; {
            return
        }
        _, err = conn.Write([]byte(trimmedClient + &quot; says: &quot; + trimmedInput))
    }
}</code></pre>
<p>客户端通过 <code>net.Dial</code> 创建了一个和服务器之间的连接</p>
<p>它通过无限循环中的 os.Stdin 接收来自键盘的输入直到输入了 “Q”。注意使用 <code>\r</code> 和 <code>\n</code> 换行符分割字符串（在 windows 平台下使用 <code>\r\n</code>）。接下来分割后的输入通过 <code>connection</code> 的 <code>Write</code> 方法被发送到服务器。</p>
<p>当然，服务器必须先启动好，如果服务器并未开始监听，客户端是无法成功连接的。</p>
<p>如果在服务器没有开始监听的情况下运行客户端程序，客户端会停止并打印出以下错误信息：<code>对tcp 127.0.0.1:50000发起连接时产生错误：由于目标计算机的积极拒绝而无法创建连接</code>。</p>
<p>打开控制台并转到服务器和客户端可执行程序所在的目录，Linux 系统下输入 <code>./server。</code></p>
<p>接下来控制台出现以下信息：<code>Starting the server ...</code></p>
<p>然后开启 2 个或者 3 个独立的控制台窗口，然后分别输入 client 回车启动客户端程序</p>
<p>在网络编程中 <code>net.Dial</code> 函数是非常重要的，一旦你连接到远程系统，就会返回一个 Conn 类型接口，可以用它发送和接收数据。<code>Dial</code> 函数巧妙的抽象了网络结构及传输。所以 IPv4 或者 IPv6，TCP 或者 UDP 都可以使用这个公用接口。</p>
<h2 id="Http服务器"><a href="#Http服务器" class="headerlink" title="Http服务器"></a>Http服务器</h2><p>Http 是一个比 tcp 更高级的协议，它描述了客户端浏览器如何与网页服务器进行通信。Go 有自己的 <code>net/http</code> 包。</p>
<p>下面是一个示例：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {
    fmt.Println(&quot;Inside HelloServer handler&quot;)
    fmt.Fprintf(w, &quot;Hello,&quot;+req.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, HelloServer)
    err := http.ListenAndServe(&quot;localhost:8080&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err.Error())
    }
}</code></pre>
<p>引入了  <code>http</code>  包并启动了网页服务器，使用 <code>http.ListenAndServe(&quot;localhost:8080&quot;, nil)</code> 函数，如果成功会返回空，否则会返回一个错误（可以指定 localhost 为其他地址，8080 是指定的端口号）</p>
<p><code>http.URL</code> 描述了 web 服务器的地址，内含存放了 url 字符串的 <code>Path</code> 属性；<code>http.Request</code> 描述了客户端请求，内含一个 <code>URL</code> 属性</p>
<p>如果 <code>req</code> 请求是一个 POST 类型的 html 表单，“var1” 就是 html 表单中一个输入属性的名称，然后用户输入的值就可以通过 GO 代码：<code>req.FormValue(&quot;var1&quot;)</code> 获取到。还有一种方法就是先执行 <code>request.ParseForm()</code> 然后再获取 <code>request.Form [&quot;var1&quot;]</code> 的第一个返回参数，就像这样：</p>
<pre><code class="go">var1, found := request.Form[&quot;var1&quot;]</code></pre>
<p>第二个参数 <code>found</code> 就是 <code>true</code>，如果 <code>var1</code> 并未出现在表单中，<code>found</code> 就是 <code>false</code></p>
<p>表单属性实际上是一个 <code>map[string][]string</code> 类型。网页服务器返回了一个 <code>http.Response</code>，它是通过 <code>http.ResponseWriter</code> 对象输出的，这个对象整合了 HTTP 服务器的返回结果；通过对它写入内容，就将数据发送给了 HTTP 客户端。</p>
<p>现在还需要编写网页服务器必须执行的程序，它是如何处理请求的呢。这是在 <code>http.HandleFunc</code> 函数中完成的，就是在这个例子中当根路径 “/”（url 地址是 <code>localhost:8080</code> ）被请求的时候（或者这个服务器上的其他地址），<code>HelloServer</code> 函数就被执行了。这个函数是 <code>http.HandlerFunc</code> 类型的，它们通常用使用 Prehandler 来命名，在前边加了一个 Pref 前缀。</p>
<p><code>http.HandleFunc</code> 注册了一个处理函数 (这里是 <code>HelloServer</code>) 来处理对应 <code>/</code> 的请求。</p>
<p><code>/</code> 可以被替换为其他特定的 url 比如 <code>/create</code>，<code>/edit</code> 等等；</p>
<p>可以为每一个特定的 url 定义一个单独的处理函数。这个函数需要两个参数：第一个是 <code>ReponseWriter</code> 类型的 <code>w</code>；第二个是请求 <code>req</code>。程序向 <code>w</code> 写入了 <code>Hello</code> 和 <code>r.URL.Path[1:]</code> 组成的字符串后边的 <code>[1:]</code> 表示“创建一个从第一个字符到结尾的子切片”，用来丢弃掉路径开头的 “/”；另外一种写法是 <code>io.WriteString(w, &quot;hello, world!\n&quot;)</code></p>
<p>总结：第一个参数是请求的路径，第二个参数是处理这个路径请求的函数的引用。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {
    fmt.Println(&quot;Inside HelloServer handler&quot;)
    fmt.Fprintf(w, &quot;Hello,&quot;+req.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, HelloServer)
    err := http.ListenAndServe(&quot;localhost:8080&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err.Error())
    }
}</code></pre>
<p>使用命令行启动程序，会打开一个命令窗口显示如下文字：</p>
<pre><code class="php">Starting Process E:/Go/GoBoek/code_examples/chapter_14/hello_world_webserver.exe
...</code></pre>
<p>然后打开你的浏览器并输入 url 地址：<code>http://localhost:8080/world</code>，浏览器就会出现文字：<code>Hello, world</code>，网页服务器会响应你在<code>:8080/</code> 后边输入的内容</p>
<p>使用 <code>fmt.Println</code> 在控制台打印状态，在每个 handler 被请求的时候，在他们内部打印日志会很有帮助</p>
<p>注：<br>1）前两行（没有错误处理代码）可以替换成以下写法：</p>
<pre><code class="go">http.ListenAndServe(&quot;:8080&quot;, http.HandlerFunc(HelloServer))</code></pre>
<p>2）<code>fmt.Fprint</code> 和 <code>fmt.Fprintf</code> 都是用来写入 <code>http.ResponseWriter</code> 的不错的函数（他们实现了 <code>io.Writer</code>）。<br>比如我们可以使用</p>
<pre><code class="go">fmt.Fprintf(w, &quot;&lt;h1&gt;%s&lt;h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;, title, body)</code></pre>
<p>来构建一个非常简单的网页并插入 <code>title</code> 和 <code>body</code> 的值</p>
<p>如果你需要更多复杂的替换，使用模板包：<br>3）如果你需要使用安全的 https 连接，使用 <code>http.ListenAndServeTLS()</code> 代替 <code>http.ListenAndServe()</code><br>4）<code>http.HandleFunc(&quot;/&quot;, Hfunc)</code> 中的 <code>HFunc</code> 是一个处理函数，如下：</p>
<pre><code class="go">func HFunc(w http.ResponseWriter, req *http.Request) {
    ...
}</code></pre>
<p>也可以使用这种方式：<code>http.Handle(&quot;/&quot;, http.HandlerFunc(HFunc))</code></p>
<p>上边的 <code>HandlerFunc</code> 只是一个类型名称，它定义如下：</p>
<pre><code class="go">type HandlerFunc func(ResponseWriter, *Request)</code></pre>
<p>它是一个可以把普通的函数当做 HTTP 处理器的适配器。如果 <code>f</code> 函数声明的合适，<code>HandlerFunc(f)</code> 就是一个执行了 <code>f</code> 函数的处理器对象。</p>
<p><code>http.Handle</code> 的第二个参数也可以是 <code>T</code> 的一个 obj 对象：<code>http.Handle(&quot;/&quot;, obj)</code> 给 T 提供了 <code>ServeHTTP</code> 方法，实现了 http 的 <code>Handler</code> 接口：</p>
<pre><code class="go">func (obj *Typ) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ...
}</code></pre>
<p><strong>参考文档</strong>：</p>
<blockquote>
<p><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">go 语言之旅</a></p>
<p><a href="https://studygolang.com/subject/2" target="_blank" rel="noopener">go 语言中文网：Go 系列教程</a></p>
<p><a href="https://learnku.com/docs/the-way-to-go" target="_blank" rel="noopener">go入门指南</a></p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/08/20/go%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="go 实用代码片段和注意事项"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: go 实用代码片段和注意事项</span></a><a class="button is-default" href="/2020/05/11/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Dubbo源码解析"><span class="has-text-weight-semibold">下一页: Dubbo源码解析</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>