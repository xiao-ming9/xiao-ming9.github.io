<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Protobuf 概述Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。 2001年初，Protobuf 首先在 Google 内部创建， 我们把它称之为 proto1，一直以来在 Google 的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个 Google 的开发者都会使用到它。 Goog">
<meta name="keywords" content="protobuf">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;11&#x2F;27&#x2F;Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="Protobuf 概述Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。 2001年初，Protobuf 首先在 Google 内部创建， 我们把它称之为 proto1，一直以来在 Google 的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个 Google 的开发者都会使用到它。 Goog">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-01T09:55:56.595Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/11/27/Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Protobuf | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/27/Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Protobuf
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 15:36:18" itemprop="dateCreated datePublished" datetime="2020-11-27T15:36:18+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-01 17:55:56" itemprop="dateModified" datetime="2020-12-01T17:55:56+08:00">2020-12-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Protobuf-概述"><a href="#Protobuf-概述" class="headerlink" title="Protobuf 概述"></a>Protobuf 概述</h1><p>Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。</p>
<p>2001年初，Protobuf 首先在 Google 内部创建， 我们把它称之为 <code>proto1</code>，一直以来在 Google 的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个 Google 的开发者都会使用到它。</p>
<p>Google 开始开源它的内部项目时，因为依赖的关系，所以他们决定首先把 Protobuf 开源出去。 proto1 在演化的过程中有些混乱，所以Protobuf 的开发者重写了 Protobuf 的实现，保留了 proto1 的大部分设计，以及 proto1 的很多的想法。但是开源的 proto2 不依赖任何的 Google 的库，代码也相当的清晰。2008年7月7日，Protobuf 开始公布出来。</p>
<p>Protobuf 公布出来也得到了大家的广泛的关注， 逐步地也得到了大家的认可，很多项目也采用 Protobuf 进行消息的通讯，还有基于 Protobuf 的微服务框架 GRPC。在使用的过程中，大家也提出了很多的意见和建议，Protobuf 也在演化，于 2016 年推出了 Proto3。 Proto3 简化了 proto2 的开发，提高了开发的效能，但是也带来了版本不兼容的问题。</p>
<p>Protocol Buffer 名称来自于初期一个主要的类的名称 <code>ProtocolBuffer</code>。</p>
<a id="more"></a>

<p>官方的发布日志中列举了 proto3 的改变：</p>
<ul>
<li>移除了原始值字段的出现逻辑。</li>
<li>移除了<code>required</code>字段</li>
<li>移除了缺省值</li>
<li>移除了<code>unknown</code>字段 （3.5中又加上了）</li>
<li>移除了扩展，使用<code>Any</code>代替</li>
<li>修复了未知的枚举值的语义</li>
<li>添加了map类型</li>
<li>添加了一些标准类似，比如time、动态数据的呈现</li>
<li>可以使用 JSON 编码代替二进制 proto 编码</li>
</ul>
<h2 id="Protobuf-与-XML-比较"><a href="#Protobuf-与-XML-比较" class="headerlink" title="Protobuf 与 XML 比较"></a>Protobuf 与 XML 比较</h2><p>相比xml, Protocol buffer在序列化结构化数据方面有很多优势:</p>
<ul>
<li>更简单</li>
<li>小3 到 10 倍</li>
<li>快 20 到 100 倍</li>
<li>更清晰</li>
<li>生成数据访问类, 更容易编程使用</li>
</ul>
<p>例如，假设想要用 name 和 email 来构建一个 Person。在XML中，需要这样做：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>jdoe@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而对应的 protocol buffer 消息(使用 protocol buffer 文本格式):</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protocol buffer的文本展示</span></span><br><span class="line"><span class="comment">// 这不是实际使用的二进制格式。</span></span><br><span class="line">person &#123;</span><br><span class="line">  name: <span class="string">"John Doe"</span></span><br><span class="line">  email: <span class="string">"jdoe@example.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这个消息被编码为 protocol buffer 二进制格式(上面的文本格式仅仅是在调试和编辑时方便人阅读的表示方式)，它将可能是长 28 个字节并花费 100-200 纳秒来解析。XML版本至少需要 69 个字节，如果删除空白字符，并将花费 5000 - 10000 纳秒来解析。</p>
<p>另外，操作 protocol buffer 也更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; person.name() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"E-mail: "</span> &lt;&lt; person.email() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>而使用XML，将不得不做类似的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"Name: "</span></span><br><span class="line">   &lt;&lt; person.getElementsByTagName(<span class="string">"name"</span>)-&gt;item(<span class="number">0</span>)-&gt;innerText()</span><br><span class="line">   &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"E-mail: "</span></span><br><span class="line">   &lt;&lt; person.getElementsByTagName(<span class="string">"email"</span>)-&gt;item(<span class="number">0</span>)-&gt;innerText()</span><br><span class="line">   &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>当然，Protocol buffer 也不总是比 XML 更合适。例如，Protocol buffer 不适合建模基于文本的标志(如 HTML)文档，因为无法轻易的使用文本交替结构。此外，XML 是 human-readable 和 human-editable 的。Protocol buffer，至少他们原生的格式不是。XML 也是某种程度上的自描述。Protocol buffer 只有当有消息定义(.proto文件)时才有意义。</p>
<h1 id="Protobuf-语法"><a href="#Protobuf-语法" class="headerlink" title="Protobuf 语法"></a>Protobuf 语法</h1><h2 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h2><p>假设现在要定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的 <code>.proto</code> 文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里：</p>
<ol>
<li><p>第一行指明当前使用的是 proto3 语法, 如果不指定则默认为proto2。<strong>必须是 .proto 文件的除空行和注释内容之外的第一行</strong></p>
</li>
<li><p>SearchRequest 消息定义指明了 3 个字段，每个字段有名字和类型。</p>
</li>
</ol>
<h2 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h2><p>在上面的例子中，所有的字段都是标量类型：两个整型和一个字符串类型，此外还有其他字段类型（下面会总结）。</p>
<h2 id="分配标识号"><a href="#分配标识号" class="headerlink" title="分配标识号"></a>分配标识号</h2><p>可以看到消息定义的每个字段都有一个唯一的数字标识符。这个标识符用于在消息的二进制格式中标识字段, 一旦消息类型被使用后不可以再修改。</p>
<p>注意标识符的值在 1 和 15 之间时，编码只需一个字节。标识符 在16 到 2047 之间将占用两个字节。<strong>因此应该将从 1 到 15 的标识符分派给最频繁出现的消息元素</strong>。记得保留一些空间给未来可能添加的频繁出现的元素。</p>
<p>最小的标识号可以从 1 开始，最大到 2 的 29 次方 - 1（536,870,911）,另外 19000 到 19999(F<code>ieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber</code>)不能使用，Protobuf协议实现中对这些进行了预留。</p>
<h2 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h2><p>消息字段有以下两种属性：</p>
<ul>
<li>singular：一个格式良好的消息应该有 0 个或者 1 个这种字段（但是不能超过 1 个）。（没有使用 repeated 默认属于这种属性）</li>
<li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括 0 次）。重复的值的顺序会被保留。（<strong>在 go 里面会被转化为数组</strong>）</li>
</ul>
<p>在 proto3 中，repeated 的标量域默认情况下会使用 packed 编码（后面说）。</p>
<h2 id="定义多个消息类型"><a href="#定义多个消息类型" class="headerlink" title="定义多个消息类型"></a>定义多个消息类型</h2><p>在一个 .proto 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 SearchResponse消息类型对应的回复消息格式的话，可以将它添加到相同的 .proto 文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>向 .proto 文件添加注释，可以使用 C/C++/Java 风格的双斜杠（//） 语法格式，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留标识符（Reserved）"><a href="#保留标识符（Reserved）" class="headerlink" title="保留标识符（Reserved）"></a>保留标识符（Reserved）</h2><p>当更新消息类型，需要彻底删除或者注释掉一个字段时，以后的用户在更新这个类型的时候可以重用这些标识号。如果他们后来使用同一个文件的旧版本加载，会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段 tag（reserved name 可能会 JSON 序列化的问题）指定 <code>reserved</code> 标识符，protocol buffer 的编译器会警告未来尝试使用这些域标识符的用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<strong>不要在同一行 reserved 声明中同时声明名字和标签数字</strong>。</p>
<h1 id="从-proto-生成的文件"><a href="#从-proto-生成的文件" class="headerlink" title="从 .proto 生成的文件"></a>从 .proto 生成的文件</h1><p>当用 protocol buffer 编译器来运行 .proto 文件时，编译器将选择的编程语言，生成相应的代码，这些代码可以操作在 .proto 文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对 C++ 来说，编译器会为每个 .proto 文件生成一个 .h 文件和一个 .cc 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对 Java 来说，编译器为每一个消息类型生成了一个 .java 文件，以及一个特殊的 Builder 类（该类是用来创建消息类接口的）。</li>
<li>对 Python 来说，有点不太一样——Python 编译器为 .proto 文件中的每个消息类型生成一个含有静态描述符的模块，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的 Python 数据访问类。</li>
<li>对 Go 来说，编译器会位每个消息类型生成了一个 .pd.go 文件。</li>
<li>对于 Ruby 来说，编译器会为每个消息类型生成了一个 .rb 文件。</li>
<li>对 javaNano 来说，编译器输出类似于 java 但是没有 Builder 类</li>
<li>对于 Objective-C 来说，编译器会为每个消息类型生成了一个 pbobjc.h 文件和 pbobjcm 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对于 C# 来说，编译器会为每个消息类型生成了一个 .cs 文件，.proto 文件中的每一个消息有一个对应的类。</li>
</ul>
<h1 id="Protobuf-的类型与编程语言的对应"><a href="#Protobuf-的类型与编程语言的对应" class="headerlink" title="Protobuf 的类型与编程语言的对应"></a>Protobuf 的类型与编程语言的对应</h1><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th align="left">.proto 类型</th>
<th align="left">备注</th>
<th align="left">C++ 类型</th>
<th align="left">Java 类型</th>
<th align="left">Python 类型</th>
<th align="left">Go 类型</th>
<th align="left">Ruby 类型</th>
<th align="left">C# 类型</th>
<th align="left">PHP 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">double</td>
<td align="left"></td>
<td align="left">double</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">float64</td>
<td align="left">Float</td>
<td align="left">double</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left"></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float32</td>
<td align="left">Float</td>
<td align="left">float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint32替代</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum 或者 Bignum（根据需要）</td>
<td align="left">int</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint64替代</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int/long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer/string</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">使用变长编码</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int/long</td>
<td align="left">uint32</td>
<td align="left">Fixnum 或者 Bignum（根据需要）</td>
<td align="left">uint</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">使用变长编码</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int/long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer/string</td>
</tr>
<tr>
<td align="left">sint32</td>
<td align="left">使用变长编码，这些编码在负值时比int32高效的多</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum 或者 Bignum（根据需要）</td>
<td align="left">int</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">sint64</td>
<td align="left">使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int/long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer/string</td>
</tr>
<tr>
<td align="left">fixed32</td>
<td align="left">总是4个字节，如果数值总是比228大的话，这个类型会比uint32高效。</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">uint32</td>
<td align="left">Fixnum 或者 Bignum（根据需要）</td>
<td align="left">uint</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">fixed64</td>
<td align="left">总是8个字节，如果数值总是比256大的话，这个类型会比uint64高效。</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int/long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer/string</td>
</tr>
<tr>
<td align="left">sfixed32</td>
<td align="left">总是4个字节</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum 或者 Bignum（根据需要）</td>
<td align="left">int</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">sfixed64</td>
<td align="left">总是8个字节</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int/long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer/string</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left"></td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
<td align="left">bool</td>
<td align="left">TrueClass/FalseClass</td>
<td align="left">bool</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">str/unicode</td>
<td align="left">string</td>
<td align="left">String (UTF-8)</td>
<td align="left">string</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">可能包含任意顺序的字节数据。</td>
<td align="left">string</td>
<td align="left">ByteString</td>
<td align="left">str</td>
<td align="left">[]byte</td>
<td align="left">String (ASCII-8BIT)</td>
<td align="left">ByteString</td>
<td align="left">string</td>
</tr>
</tbody></table>
<ol>
<li>在 java 中，无符号 32 位和 64 位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64 位或者无符号 32 位整型在解码时被表示成为 long，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中 string 被表示成在解码时表示成 unicode。但是一个 ASCII string 可以被表示成 str 类型。</li>
<li>Integer 在 64 位的机器上使用，string 在 32 位机器上使用</li>
</ol>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的简单元素，被解析的对象所对应的字段被设置为默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空 string</li>
<li>对于bytes，默认是一个空的 bytes</li>
<li>对于 bool，默认是 false</li>
<li>对于数值类型，默认是 0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为 0;</li>
<li>对于消息类型（message），如果没有被设置，确切的消息是根据语言确定的。</li>
</ul>
<p>对于可重复的字段，默认值是空（通常情况下是对应语言中空数组）。</p>
<blockquote>
<p>对于简单字段，一旦消息被解析，<strong>就无法判断这个字段时有设置值但是恰巧是默认值，还是根本没有被设置</strong>（例如 boolean 值是否被设置为 false）。另外，<strong>如果一个简单消息字段被设置为默认值，这个值不会被序列化传输</strong>。</p>
</blockquote>
<h1 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h1><p>如果一个已有的消息格式已无法满足新的需求。例如，要在消息中添加一个额外的字段，但是同时旧版本写的代码仍然可用。不用担心，更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可：</p>
<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>如果增加新的字段，使用旧格式的字段仍然可以被新产生的代码所解析。应该记住这些元素的默认值，这样新代码就可以以适当的方式和旧代码生成的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和 proto2 中的行为是不同的，在 proto2 中未定义的域依然会随着消息被序列化）</li>
<li>非 required 的字段可以移除，只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的 .proto 文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>int32, uint32, int64, uint64, 和 bool 是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在 C++ 中对它进行了强制类型转换一样（例如，如果把一个 64 位数字当作 int32 来读取，那么它就会被截断为 32 位的数字）。</li>
<li>sint32 和 sint64 是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string 和 bytes 是兼容的（只要 bytes 是有效的 UTF-8 编码）。</li>
<li>嵌套消息与 bytes 是兼容的（只要 bytes 包含该消息的一个编码过的版本）。</li>
<li>fixed32 与 sfixed32 是兼容的，fixed64 与 sfixed64 是兼容的。</li>
<li>枚举类型与 int32，uint32，int64 和 uint64 相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的 proto3 枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int 类型的字段总会被保留。</li>
</ul>
<h1 id="字段的类型"><a href="#字段的类型" class="headerlink" title="字段的类型"></a>字段的类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个 SearchRequest 消息添加一个 corpus 字段，而 corpus 的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO 中的一个。 这时通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做 Corpus 的枚举类型——它含有所有可能的值 ——以及一个类型为 Corpus 的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Corpus 枚举的第一个常量映射为 0：<strong>每个枚举类型必须将其第一个类型映射为0</strong>，这是因为：</p>
<ul>
<li>必须有一个 0 值，可以用这个 0 值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容 proto2 语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>可以通过将相同值赋值给不同的枚举常量来定义别名. 为此需要设置allow_alias选项为true, 否则当发现别名时protocol编译器会生成错误消息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 此时 RUNNING 是 STATRTED 的别名</span></span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>&#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数。</p>
<p>如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在 .proto 文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同的消息中使用它——采用 <code>MessageType.EnumType</code> 的语法格式。</p>
<p>当对一个使用了枚举的 .proto 文件运行 protocol buffer 编译器的时候，生成的代码中将有一个对应的 enum（对Java或C++来说），或者一个特殊的 EnumDescriptor 类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），在 GO 中，因为枚举类型以 int32 来表示，所以对应的值依然用 int32 解析出来，只不过没有对应的枚举值而已。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>可以将其他消息类型用作自定义的字段类型。例如，假设在每一个 SearchResponse 消息中包含 Result 消息，此时可以在相同的 .proto 文件中定义一个 Result 消息类型，然后在SearchResponse 消息中指定一个 Result 类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入其他文件中的类型"><a href="#导入其他文件中的类型" class="headerlink" title="导入其他文件中的类型"></a>导入其他文件中的类型</h3><p>如果是希望导入其他 .proto 文件中的类型定义，可以在文件中添加一个导入声明：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下只能使用直接导入的 .proto 文件中的定义。然而，有时候需要移动一个 .proto 文件到一个新的位置，可以不直接移动 .proto 文件，只需放入一个伪 .proto 文件在老的位置， 然后使用 <code>import public</code> 转向新的位置。<code>import public</code> 依赖性会通过任意导入包含<code>import public</code> 声明的 proto 文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是旧的proto</span></span><br><span class="line"><span class="comment">// 这是所有客户端正在导入的包</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">"new.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端 proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用新旧两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用 <code>-I/--proto_pathprotocal</code> 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常只要指定 <code>proto_path</code> 标志为工程根目录，并且指定好导入的正确名称就好。</p>
<h3 id="使用-proto2-的消息类型"><a href="#使用-proto2-的消息类型" class="headerlink" title="使用 proto2 的消息类型"></a>使用 proto2 的消息类型</h3><p>导入 proto2 的消息类型并在 proto3 消息中使用是可以的，反之也如此。但是，<strong>proto2 的枚举不能在 proto3 语法中使用</strong></p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result 消息就定义在 SearchResponse 消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想在它的父消息类型的外部重用这个消息类型，需要以 <code>Parent.Type</code> 的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>&#123;</span><br><span class="line">  SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>&#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="built_in">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>&#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="built_in">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>Any 类型消息允许在没有指定他们的 .proto 定义的情况下使用消息作为一个嵌套类型。一个 Any 类型包括一个可以被序列化 bytes 类型的任意消息，以及一个 URL 作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入<code>import google/protobuf/any.proto</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">  <span class="title">repeated</span> google.protobuf.Any details = 2;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型 URL 是 <code>type.googleapis.com/packagename.messagename</code>。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装 Any 值。例如在 java 中，Any类型会有特殊的 <code>pack()</code> 和 <code>unpack()</code> 访问器，在C++中会有 <code>PackFrom()</code> 和 <code>UnpackTo()</code> 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></span><br><span class="line">NetworkErrorDetails details = ...;</span><br><span class="line">ErrorStatus status;</span><br><span class="line">status.add_details()-&gt;PackFrom(details);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reading an arbitrary message from Any.</span></span><br><span class="line">ErrorStatus status = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Any&amp; detail : status.details()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (detail.Is&lt;NetworkErrorDetails&gt;()) &#123;</span><br><span class="line">    NetworkErrorDetails network_error;</span><br><span class="line">    detail.UnpackTo(&amp;network_error);</span><br><span class="line">    ... processing network_error ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前，用于Any类型的动态库仍在开发之中</p>
<p>如果熟悉proto2语法，使用Any替换 extensions 关键字。</p>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果消息中有很多可选字段，并且同时至多一个字段会被设置， 可以通过使用 Oneof 特性来强化这个行为并节省内存。</p>
<p>Oneof 字段就像可选字段， 除了它们<strong>会共享内存，并且同一时间最多一个字段会被设置</strong>。 设置其中一个字段会清除其它字段。 可以使用 <code>case()</code> 或者 <code>WhichOneof()</code>  方法检查哪个 oneof 字段被设置，这取决于使用什么编程语言。</p>
<p>因为 proto3 没有办法区分正常的值是否是设置了还是取得缺省值(比如 int64 类型字段，如果它的值是 0，无法判断数据是否包含这个字段，因为 0 既可能是数据中设置的值，也可能是这个字段的零值)，所以可以通过 Oneof 取得这个功能，因为 Oneof 有判断字段是否设置的功能。</p>
<h3 id="使用-Oneof"><a href="#使用-Oneof" class="headerlink" title="使用 Oneof"></a>使用 Oneof</h3><p>为了在 . proto 定义 Oneof 字段， 需要在名字前面加上 oneof 关键字, 比如下面例子的 test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再将 oneof 字段定义到 test_oneof 中。<strong>可以增加任意类型的字段，但是不能使用 repeated 关键字</strong>。</p>
<p>在产生的代码中, oneof 字段拥有同样的 getters 和setters， 就像正常的可选字段一样，也有一个特殊的方法来检查到底哪个字段被设置。</p>
<h3 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h3><ul>
<li>设置 oneof 会自动清楚其它 oneof 字段的值。所以设置多次后，只有最后一次设置的字段有值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.set_name(<span class="string">"name"</span>);</span><br><span class="line">CHECK(message.has_name());</span><br><span class="line">message.mutable_sub_message();   <span class="comment">// Will clear name field.</span></span><br><span class="line">CHECK(!message.has_name());</span><br></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个 oneof 中有多个成员，只有看到的最后一个成员会被解析成消息。</li>
<li>oneof 不支持 repeated.</li>
<li>反射 API 对 oneof 字段有效.</li>
<li>如果使用 C++，需确保代码不会导致内存泄漏。下面的代码会崩溃， 因为 sub_message 已经通过 set_name() 删除了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.mutable_sub_message();</span><br><span class="line">message.set_name(<span class="string">"name"</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 C++ 中，如果使用 Swap() 来交换两个带有 oneof 的消息，每个消息将会有另一个消息的 oneof，例如在下面的例子中，msg1 会拥有sub_message 并且 msg2 会有 name。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.set_name(<span class="string">"name"</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.mutable_sub_message();</span><br><span class="line">msg1.swap(&amp;msg2);</span><br><span class="line">CHECK(msg1.has_sub_message());</span><br><span class="line">CHECK(msg2.has_name());</span><br></pre></td></tr></table></figure>

<h3 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>当增加或者删除 oneof 字段时一定要小心。如果检查 oneof 的值返回 <code>None/NOT_SET</code>，它意味着 oneof 字段没有被赋值或者在一个不同的版本中赋值了。 没有办法知道是哪种情况，因为没有办法判断一个未知字段是否是 oneof 的成员。</p>
<h3 id="Tag-重用问题"><a href="#Tag-重用问题" class="headerlink" title="Tag 重用问题"></a>Tag 重用问题</h3><ul>
<li><strong>将字段移入或移除oneof</strong>：在消息被序列号或者解析后，可能会失去一些信息（有些字段也许会被清除）</li>
<li><strong>删除一个字段或者加入一个字段</strong>：在消息被序列号或者解析后，这也许会清除现在设置的 oneof 字段</li>
<li><strong>分离或者融合oneof</strong>：和移动普通字段一样有类似问题。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>如果希望创建一个关联映射，protocol buffer 提供了一种快捷的语法：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<p>其中 key_type 可以是任意 Integer 或者 string 类型（所以，除了 floating 和 bytes 的任意简单类型都是可以的）。</p>
<p>value_type 可以是任意类型。</p>
<p>例如，如果希望创建一个 project 的映射，每个 Projecct 使用一个 string 作为 key，可以像下面这样定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map 的字段不可以是 repeated。</li>
<li>序列化后的顺序和 map 迭代器的顺序是不确定的，所以不要期望以固定顺序处理 Map。</li>
<li>当为 .proto 文件产生生成文本格式的时候，map 会按照 key 的顺序排序，数值化的 key 会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的 key 则后一个 key 不会被使用，当从文本格式中解析 map 时，如果存在重复的 key，则可能会导致解析失败。</li>
<li>如果为映射字段提供键但没有值，则序列化字段时的行为取决于语言。在 C ++，Java 和 Python 中，该类型的默认值已序列化，而在其他语言中，则没有序列化。</li>
</ul>
<h3 id="向后兼容性问题-1"><a href="#向后兼容性问题-1" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>map语法序列化后等同于如下内容，因此即使是不支持 map 语法的protocol buffer 实现也是可以处理数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapFieldEntry</span> </span>&#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N</span><br></pre></td></tr></table></figure>

<h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>当然可以为 .proto 文件新增一个可选的 package 声明符，用来防止不同的消息类型有命名冲突。如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>在其他的消息格式定义中可以使用<code>包名+消息名</code>的方式来定义字段的类型，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于 C++，产生的类会被包装在 C++ 的命名空间中，如上例中的 Open 会被封装在 foo::bar 空间中。</li>
<li>对于 Java，包声明符会变为 java 的一个包，除非在 .proto 文件中提供了一个明确有 <code>java_package</code>。</li>
<li>对于 Python，这个包声明符是被忽略的，因为 Python 模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于 Go，包可以被用做 Go 包名称，除非显式的提供一个 <code>option go_package</code> 在 .proto 文件中。</li>
<li>对于 Ruby，生成的类可以被包装在内置的 Ruby 名称空间中，转换成 Ruby 所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如 Open 会在 Foo::Bar 名称空间中。</li>
<li>对于 javaNano 包会使用 Java 包，除非在文件中显式的提供一个 <code>option java_package</code>。</li>
<li>对于 C# 包可以转换为 PascalCase 后作为名称空间，除非你在你的文件中显式的提供一个 <code>option csharp_namespace</code>，例如，Open会在 Foo.Bar 名称空间中</li>
</ul>
<h3 id="包及命名的解析"><a href="#包及命名的解析" class="headerlink" title="包及命名的解析"></a>包及命名的解析</h3><p>Protocol buffer 语言中类型名称的解析与 C++ 是一致的：首先从最内部开始查找，依次向外进行，每个包都被认为是它父包的”内层”。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer 编译器会解析 .proto 文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="定义服务-Service"><a href="#定义服务-Service" class="headerlink" title="定义服务(Service)"></a>定义服务(Service)</h2><p>如果想要将消息类型用在 RPC (远程方法调用)系统中，可以在 .proto 文件中定义一个 RPC 服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个 RPC 服务并具有一个方法，该方法能够接收 SearchRequest 并返回一个 SearchResponse，此时可以在 .proto 文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最直观的使用 protocol buffer 的 RPC 系统是 Go 的 RPC 框架 gRPC，一个由谷歌开发的语言和平台中的开源的 PRC 系统，gRPC 在使用 protocl buffer 时非常有效，如果使用特殊的 protocol buffer 插件可以直接从 .proto 文件中产生相关的RPC代码。</p>
<p>如果不想使用 gRPC，也可以使用 protocol buffer 用于自己的 RPC 实现。</p>
<h2 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h2><p>Proto3 支持 JSON 的编码规范，使它更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果 JSON 编码的数据丢失或者其本身就是 null，这个数据会在解析成 protocol buffer 的时候被表示成默认值。如果一个字段在 protocol buffer 中表示为默认值，那么它在转化成 JSON 编码的时候会被忽略掉以节省空间。</p>
<table>
<thead>
<tr>
<th align="left">proto3</th>
<th align="left">JSON</th>
<th align="left">JSON 示例</th>
<th align="left">注意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">message</td>
<td align="left">object</td>
<td align="left">{“fBar”: v, “g”: null, …}</td>
<td align="left">产生 JSON 对象，消息字段名可以被映射成lowerCamelCase 形式，并且成为 JSON 对象键，null 被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">string</td>
<td align="left">“FOO_BAR”</td>
<td align="left">枚举值的名字在 proto 文件中被指定</td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">object</td>
<td align="left">{“k”: v, …}</td>
<td align="left">所有的键都被转换成 string</td>
</tr>
<tr>
<td align="left">repeated V</td>
<td align="left">array</td>
<td align="left">[v, …]</td>
<td align="left">null 被视为空列表</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">true, false</td>
<td align="left">true, false</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">string</td>
<td align="left">“Hello World!”</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">base64 string</td>
<td align="left">“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int32, fixed32, uint32</td>
<td align="left">number</td>
<td align="left">1, -10, 0</td>
<td align="left">JSON 值会是一个十进制数，数值型或者 string 类型都会接受</td>
</tr>
<tr>
<td align="left">int64, fixed64, uint64</td>
<td align="left">string</td>
<td align="left">“1”, “-10”</td>
<td align="left">JSON 值会是一个十进制数，数值型或者 string 类型都会接受</td>
</tr>
<tr>
<td align="left">float, double</td>
<td align="left">number</td>
<td align="left">1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td align="left">JSON 值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td align="left">Any</td>
<td align="left">object</td>
<td align="left">{“@type”: “url”, “f”: v, … }</td>
<td align="left">如果一个 Any 保留一个特上述的JSON映射，则它会转换成一个如下形式：<code>{&quot;@type&quot;: xxx, &quot;value&quot;: yyy}</code>否则，该值会被转换成一个JSON对象，<code>@type</code> 字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">string</td>
<td align="left">“1972-01-01T10:00:20.021Z”</td>
<td align="left">使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td>
</tr>
<tr>
<td align="left">Duration</td>
<td align="left">string</td>
<td align="left">“1.000340012s”, “1s”</td>
<td align="left">生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td align="left">Struct</td>
<td align="left">object</td>
<td align="left">{ … }</td>
<td align="left">任意的JSON对象，见struct.proto</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">various types</td>
<td align="left">2, “2”, “foo”, true, “true”, null, 0, …</td>
<td align="left">包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td>
</tr>
<tr>
<td align="left">FieldMask</td>
<td align="left">string</td>
<td align="left">“f.fooBar,h”</td>
<td align="left">见fieldmask.proto</td>
</tr>
<tr>
<td align="left">ListValue</td>
<td align="left">array</td>
<td align="left">[foo, bar, …]</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Value</td>
<td align="left">value</td>
<td align="left"></td>
<td align="left">任意JSON值</td>
</tr>
<tr>
<td align="left">NullValue</td>
<td align="left">null</td>
<td align="left"></td>
<td align="left">JSON null</td>
</tr>
</tbody></table>
<h2 id="Option-选项"><a href="#Option-选项" class="headerlink" title="Option 选项"></a>Option 选项</h2><p>定义 .proto 文件时能够标注一系列的 option。Option 并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum 或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。还有些选项可以作用在字段、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选项：</p>
<ul>
<li><code>java_package</code> (文件选项) :这个选项表明生成 java 类所在的包。如果在 .proto 文件中没有明确的声明 java_package，就采用默认的包名。默认方式产生的 java 包名并不是最好的方式，因为 java 包应该是按照应用名称倒序方式进行排序的，而 proto package 不会以这种方式创建包。如果不需要产生 java 代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option java_package = &quot;com.example.foo&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>java_outer_classname</code> (文件选项): 该选项表明想要生成 Java 类的名称。如果在 .proto 文件中没有明确的 java_outer_classname 定义，生成的 class 名称将会根据 .proto 文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto 生成的 java 类名为 FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option java_outer_classname = &quot;Ponycopter&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>optimize_for</code>(文件选项): 可以被设置为 SPEED, CODE_SIZE，或者 LITE_RUNTIME。这些值将通过如下的方式影响 C++及 java 代码的生成：<ul>
<li>SPEED (default): protocol buffer 编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer 编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比 SPEED 要少得多， 但是操作要相对慢些。当然实现的类及其对外的 API与SPEED 模式都是一样的。这种方式经常用在一些包含大量的 .proto 文件而且并不盲目追求速度的应用中。</li>
<li>LITE_RUNTIME: protocol buffer 编译器依赖于运行时核心类库来生成代码（即采用 libprotobuf-lite 替代 libprotobuf）。这种核心类库由于忽略了一些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与 SPEED 模式不相上下，产生的类通过实现  MessageLite 接口，但它仅仅是 Messager 接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cc_enable_arenas</code>(文件选项)：对于 C++ 产生的代码启用arena allocation</li>
<li><code>objc_class_prefix</code>(文件选项)：设置 Objective-C 类的前缀，添加到所有 Objective-C 前面。proto 文件产生的类和枚举类型。没有默认值，所使用的前缀应该是 proto 推荐的3-5个大写字符，注意2个字节的前缀是 proto 所保留的。</li>
<li><code>deprecated</code>(字段选项)：如果设置为 true 则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在 java 中，这回变成 <code>@Deprecated</code> 注释。在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用，也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 old_field = 6 [deprecated=true];</span><br></pre></td></tr></table></figure>

<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p>除了前面介绍的类型外，还有一些常见的类型，Protobuf 也提供了定义，比如 <code>Timestamp</code> 和 <code>Duration</code>。</p>
<p>Protobuf提供了 <code>github.com/golang/protobuf/ptypes/timestamp.Timestamp</code> 和 <code>github.com/golang/protobuf/ptypes/duration.Duration</code> 两种扩展类型，用来表示时间，并提供了和 go 标准库  <code>time.Time</code>和  <code>time.Duration</code>的转换函数。</p>
<p>可以在 proto 中需要时间戳和 duration 的地方使用这两个类型，而不是使用标准库的 <code>time.Time</code> 和 <code>time.Duration</code>，因为标注库的类型没有提供 protobuf 序列化反序列化的功能，需要额外处理，所以不如直接使用 Protobuf 提供的对应类型。</p>
<p>同时，它还是以指针的方式定义字段，这也意味着可以分别反序列化的时候，可以区分对应字段是否在数据中存在。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	fmt <span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	proto <span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">	ptypes <span class="string">"github.com/golang/protobuf/ptypes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg := &amp;WellKnownTypes&#123;</span><br><span class="line">		Now:  ptypes.TimestampNow(),</span><br><span class="line">		Took: ptypes.DurationProto(<span class="number">10</span> * time.Minute),</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := proto.Marshal(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = proto.Unmarshal(data, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过-proto-文件生成代码"><a href="#通过-proto-文件生成代码" class="headerlink" title="通过 .proto 文件生成代码"></a>通过 .proto 文件生成代码</h1><p>可以通过定义好的 .proto 文件来生成 Java,Python,C++, Ruby, JavaNano, Objective-C,或者 C# 代码，需要基于.proto 文件运行 protocol buffer 编译器 protoc。如果没有安装编译器，下载安装包并遵照 README 安装。对于 Go，还需要安装一个特殊的代码生成器插件。可以通过 GitHub 上的 protobuf 库找到安装过程。</p>
<p>通过如下方式调用 protocol 编译器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IMPORT_PATH</code> 声明了一个 .proto 文件所在的解析 import 具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用 –proto_path，它们将会顺序的被访问并执行导入。<code>-I=IMPORT_PATH</code> 是 <code>--proto_path</code> 的简化形式。</li>
<li>当然也可以提供一个或多个输出路径：<ul>
<li><code>--cpp_out</code> 在目标目录 DST_DIR 中产生 C++ 代码。</li>
<li><code>--java_out</code> 在目标目录DST_DIR中产生 Java 代码。</li>
<li><code>--python_out</code> 在目标目录 DST_DIR 中产生 Python 代码。</li>
<li><code>--go_out</code> 在目标目录 DST_DIR 中产生 Go 代码。</li>
<li><code>--ruby_out</code> 在目标目录 DST_DIR 中产生 Ruby 代码。</li>
<li><code>--javanano_out</code> 在目标目录 DST_DIR 中生成 JavaNano，JavaNano 代码生成器有一系列的选项用于定制自定义生成器的输出。</li>
<li><code>--objc_out</code> 在目标目录 DST_DIR 中产生 Object 代码。</li>
<li><code>--csharp_out</code> 在目标目录 DST_DIR 中产生 Object 代码。</li>
<li><code>--php_out</code> 在目标目录 DST_DIR 中产生 Object 代码。</li>
</ul>
</li>
</ul>
<p>作为一个方便的拓展，如果 DST_DIR 以 .zip 或者 .jar 结尾，编译器会将输出写到一个 ZIP 格式文件或者符合 JAR 标准的 .jar 文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。</p>
<ul>
<li>可以提供一个或多个 .proto 文件作为输入，多个 .proto 文件可以只指定一次。文件路径是相对于当前目录的相对路径命名的，每个文件必须位于其 IMPORT_PATH 下，以便每个文件可以确定其规范的名称。</li>
</ul>
<h1 id="Protobuf-代码规范"><a href="#Protobuf-代码规范" class="headerlink" title="Protobuf 代码规范"></a>Protobuf 代码规范</h1><p>通过遵循下列约定, 可以让 protocol buffer 消息定义和他们对应的类保持一致并容易阅读。</p>
<h2 id="消息和字段名"><a href="#消息和字段名" class="headerlink" title="消息和字段名"></a>消息和字段名</h2><p>消息名使用驼峰法，例如, SongServerRequest；字段名使用下划线分隔，例如, song_name。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SongServerRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> song_name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为字段名使用这种命名约定可以得到如下的访问器:</p>
<p>C++:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">song_name</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_song_name</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; x)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSongName</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setSongName</span><span class="params">(String v)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型名使用驼峰法(首字母大写)，值的名字使用大写加下划线分隔:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Foo &#123;</span><br><span class="line">  FIRST_VALUE = <span class="number">1</span>;</span><br><span class="line">  SECOND_VALUE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个枚举值以分号(;)结束, 不要用逗号(,)。</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>如果 .proto 文件定义 RPC 服务, 服务名和任何 rpc 方法应该用驼峰法(首字母大写):</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetSomething(FooRequest) <span class="keyword">returns</span> (FooResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在-Go-中使用-protobuf"><a href="#在-Go-中使用-protobuf" class="headerlink" title="在 Go 中使用 protobuf"></a>在 Go 中使用 protobuf</h1><h2 id="安装-protoc-编译器"><a href="#安装-protoc-编译器" class="headerlink" title="安装 protoc 编译器"></a>安装 protoc 编译器</h2><p>下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>在上面寻找相应的版本下载即可</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>Protobuf 核心的工具集是 C++ 语言开发的，官方的 protoc 编译器中并不支持 Go 语言，需要安装一个插件才能生成 Go 代码。用如下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go</span><br></pre></td></tr></table></figure>

<p>此命令会将 protoc-gen-go 可执行文件安装在 <code>$GOPATH/bin</code> 目录下。当编译器调用时传递了<code>--go_out</code>命令行标志时 <code>protoc</code> 就会使用该插件。<code>--go_out</code> 告诉编译器把 Go 源代码写到哪里。编译器会为每个 <code>.proto</code> 文件生成一个单独的源代码文件。</p>
<p>输出文件的名称是通过获取 .proto 文件的名称并进行两处更改来计算的：</p>
<ul>
<li>生成文件的扩展名是 <code>.pb.go</code>。比如说 <code>player_record.proto</code> 编译后会得到 <code>player_record.pb.go</code>。</li>
<li>proto路径（使用 <code>--proto_path</code> 或 <code>-I</code> 命令行标志指定）将替换为输出路径（使用 <code>--go_out</code> 标志指定）。</li>
</ul>
<p>当运行如下编译命令时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --go_out=build/gen src/foo.proto src/bar/baz.proto</span><br></pre></td></tr></table></figure>

<p>编译器会读取文件 <code>src/foo.proto</code> 和 <code>src/bar/baz.proto</code>，这将会生成两个输出文件<code>build/gen/foo.pb.go</code>和<code>build/gen/bar/baz.pb.go</code></p>
<p>如果有必要，编译器会自动生成 <code>build/gen/bar</code> 目录，但是它不能创建 <code>build</code> 或者 <code>build/gen</code> 目录，这两个必须是已经存在的目录。</p>
<h2 id="Package-1"><a href="#Package-1" class="headerlink" title="Package"></a>Package</h2><p>如果一个 <code>.proto</code> 文件中有包声明，生成的源代码将会使用它来作为Go的包名，如果 <code>.proto</code> 的包名中有 <code>.</code> ,在 Go 包名中会将 <code>.</code> 转换为 <code>_</code>。举例来说 <code>proto</code> 包名 <code>example.high_score</code> 将会生成Go包名 <code>example_high_score</code>。</p>
<p>在 <code>.proto</code> 文件中可以使用 <code>option go_package</code> 指令来覆盖上面默认生成 Go 包名的规则。比如说包含如下指令的一个 <code>.proto</code> 文件</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example.high_score;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"hs"</span>;</span><br></pre></td></tr></table></figure>

<p>生成的Go源代码的包名是 <code>hs</code>。</p>
<p>如果一个 <code>.proto</code> 文件中不包含 package 声明，生成的源代码将会使用 <code>.proto</code> 文件的文件名(去掉扩展名)作为 Go 包名，<code>.</code>会被首先转换为 <code>_</code>。举例来说，一个名为 <code>high.score.proto</code> 不包含 pack 声明的文件将会生成文件 <code>high.score.pb.go</code>，他的Go包名是 <code>high_score</code>。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>一个简单的消息声明：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>protocol buffer 编译器将会生成一个名为 <code>Foo</code> 的结构体，实现了 <code>proto.Message</code> 接口的 <code>Foo</code> 类型的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置 proto 为默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Foo)</span> <span class="title">Reset</span><span class="params">()</span></span>         &#123; *m = Foo&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 返回 proto 的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> proto.CompactTextString(m) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoMessage 作为一个 tag 确保其他人不会意外的实现</span></span><br><span class="line"><span class="comment">// proto.Message 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Foo)</span> <span class="title">ProtoMessage</span><span class="params">()</span></span>    &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内嵌的消息"><a href="#内嵌的消息" class="headerlink" title="内嵌的消息"></a>内嵌的消息</h3><p>一个 message 可以声明在其他 message 的内部。比如说：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况，编译器会生成两个结构体：<code>Foo</code>和 <code>Foo_Bar</code>。</p>
<h3 id="预定义消息类型"><a href="#预定义消息类型" class="headerlink" title="预定义消息类型"></a>预定义消息类型</h3><p>Protobufs 带有一组预定义的消息，称为众所周知的类型（WKT）。这种类型可以理解为可拓展的第三方类型，比如需要使用时间戳时就可以引入。例如，给出如下消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/struct.proto"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">NamedStruct</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  google.protobuf.Struct definition = <span class="number">2</span>;</span><br><span class="line">  google.protobuf.Timestamp last_modified = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的Go代码将会像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> google_protobuf <span class="string">"github.com/golang/protobuf/ptypes/struct"</span></span><br><span class="line"><span class="keyword">import</span> google_protobuf1 <span class="string">"github.com/golang/protobuf/ptypes/timestamp"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NamedStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name         <span class="keyword">string</span></span><br><span class="line">   Definition   *google_protobuf.Struct</span><br><span class="line">   LastModified *google_protobuf1.Timestamp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，不需要将这些类型直接导入代码中。但是，如果需要直接引用其中一种类型，只需导入 <code>github.com/golang/protobuf/ptypes/[TYPE]</code> 包，并正常使用该类型。</p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>编译器会为每个在 message 中定义的字段生成一个 Go 结构体的字段，字段的确切性质取决于它的类型以及它是 <code>singular</code>，<code>repeated</code>，<code>map</code> 还是 <code>oneof</code> 字段。</p>
<p>需要注意生成的 Go 结构体的字段将始终使用驼峰命名，即使在 <code>.proto</code> 文件中消息字段用的是小写加下划线（应该这样）。大小写转换的原理如下：</p>
<ul>
<li>首字母会大些，如果 message 中字段的第一个字符是 <code>_</code>，它将被替换为X。</li>
<li>如果内部下划线后跟小写字母，则删除下划线，并将后面跟随的字母大写。</li>
</ul>
<p>因此，proto字段 <code>foo_bar_baz</code> 在Go中变成 <code>FooBarBaz</code>， <code>_my_field_name_2</code>变为 <code>XMyFieldName_2</code>。</p>
<h3 id="单一标量字段"><a href="#单一标量字段" class="headerlink" title="单一标量字段"></a>单一标量字段</h3><p>对于字段定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>编译器将生成一个带有名为 Foo 的 int32 字段和一个访问器方法 GetFoo() 的结构，该方法返回 Foo 中的 int32 值或该字段的零值（如果字段未设置（数值型零值为0，字符串为空字符串））。</p>
<h3 id="单一-message-字段"><a href="#单一-message-字段" class="headerlink" title="单一 message 字段"></a>单一 message 字段</h3><p>给出如下消息类型</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个有<code>Bar</code>类型字段的消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto3</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">  Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个Go结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">  Foo *Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息类型的字段可以设置为 nil，这意味着该字段未设置，从而有效清除该字段。这不等同于将值设置为消息结构体的“空”实例。</p>
<p>编译器还生成一个<code>func(m * Baz) GetFoo() * Bar</code>辅助函数。如果 m 为 <code>nil</code> 或 <code>foo</code> 未设置，则此函数返回 <code>nil *Bar</code> 。这让不在中间检查 nil 值而进行链式调用成为可能。</p>
<h3 id="可重复字段"><a href="#可重复字段" class="headerlink" title="可重复字段"></a>可重复字段</h3><p>每个重复的字段在 Go 中的结构中生成一个 T 类型的 slice，其中 T 是字段的元素类型。对于带有重复字段的此消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会生成如下结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">   Foo  []*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于字段定义 <code>repeated bytes foo = 1;</code> 编译器将会生成一个带有类型为 <code>[][]byte</code> 名为 <code>Foo</code> 的字段的 Go 结构体。对于可重复的枚举 <code>repeated MyEnum bar = 2;</code>，编译器会生成带有类型为 <code>[]MyEnum</code>名为 <code>Bar</code> 的字段的Go结构体。</p>
<p>下面的例子展示了如何设置值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baz := &amp;Baz&#123;</span><br><span class="line">  Foo: []*Bar&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// First element.</span></span><br><span class="line">    &#123;&#125;, <span class="comment">// Second element.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要获取字段内容，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := baz.GetFoo() <span class="comment">// foo type is []*Bar.</span></span><br><span class="line">b1 := foo[<span class="number">0</span>] <span class="comment">// b1 type is *Bar, the first element in foo.</span></span><br></pre></td></tr></table></figure>

<h3 id="映射字段"><a href="#映射字段" class="headerlink" title="映射字段"></a>映射字段</h3><p>每个映射字段会在 Go 的结构体中生成一个 <code>map[TKey]TValue</code> 类型的字段，其中 <code>TKey</code> 是字段的键类型 <code>TValue</code> 是字段的值类型。对于下面这个消息定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="built_in">string</span>, Bar&gt; foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器生成 Go 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">  Foo <span class="keyword">map</span>[<span class="keyword">string</span>]*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Oneof-字段"><a href="#Oneof-字段" class="headerlink" title="Oneof 字段"></a>Oneof 字段</h3><p>对于 oneof 字段，protobuf 编译器会生成一个接口类型为 <code>isMessageName_MyField</code> 的单个字段。它还为其中的每个单一字段（singular field）生成一个结构。这些字段都实现了 <code>isMessageName_MyField</code> 接口。如下面的例子：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> account;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> avatar &#123;</span><br><span class="line">    <span class="built_in">string</span> image_url = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bytes</span> image_data = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器生成 Go 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Types that are valid to be assigned to Avatar:</span></span><br><span class="line">        <span class="comment">//      *Profile_ImageUrl</span></span><br><span class="line">        <span class="comment">//      *Profile_ImageData</span></span><br><span class="line">        Avatar isProfile_Avatar <span class="string">`protobuf_oneof:"avatar"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile_ImageUrl <span class="keyword">struct</span> &#123;</span><br><span class="line">        ImageUrl <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Profile_ImageData <span class="keyword">struct</span> &#123;</span><br><span class="line">        ImageData []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>*Profile_ImageUrl</code> 和 <code>*Profile_ImageData</code> 都通过提供一个空的 <code>isProfile_Avatar()</code> 方法来实现 <code>isProfile_Avatar</code> 接口。</p>
<p>如果想要设置值，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1 := &amp;account.Profile&#123;</span><br><span class="line">  Avatar: &amp;account.Profile_ImageUrl&#123;<span class="string">"http://example.com/image.png"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// imageData is []byte</span></span><br><span class="line">imageData := getImageData()</span><br><span class="line">p2 := &amp;account.Profile&#123;</span><br><span class="line">  Avatar: &amp;account.Profile_ImageData&#123;imageData&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要访问该字段，可以根据使用值上的类型来处理不同的消息类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x := m.Avatar.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *account.Profile_ImageUrl:</span><br><span class="line">        <span class="comment">// Load profile image based on URL</span></span><br><span class="line">        <span class="comment">// using x.ImageUrl</span></span><br><span class="line"><span class="keyword">case</span> *account.Profile_ImageData:</span><br><span class="line">        <span class="comment">// Load profile image based on bytes</span></span><br><span class="line">        <span class="comment">// using x.ImageData</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// The field is not set.</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Profile.Avatar has unexpected type %T"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器还会生成 get 方法 <code>func(m * Profile) GetImageUrl()  string</code> 和 <code>func(m * Profile) GetImageData() [] byte</code>。每个 get 函数都返回该字段的值，如果未设置，则返回零值。</p>
<h2 id="枚举-2"><a href="#枚举-2" class="headerlink" title="枚举"></a>枚举</h2><p>给出如下枚举：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个枚举类型和一系列该类型的常量。</p>
<p>对于消息中的枚举（像上面那样），类型名字以消息名开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SearchRequest_Corpus <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proto</span></span><br><span class="line">enum Foo &#123;</span><br><span class="line">  DEFAULT_BAR = <span class="number">0</span>;</span><br><span class="line">  BAR_BELLS = <span class="number">1</span>;</span><br><span class="line">  BAR_B_CUE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 中的类型不会对proto中的枚举名称进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Foo int32</span><br></pre></td></tr></table></figure>

<p>此类型具有 <code>String()</code> 方法，该方法返回给定值的名称。</p>
<p><code>Enum()</code>方法使用给定值初始化新分配的内存并返回相应的指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Foo)</span> <span class="title">Enum</span><span class="params">()</span> *<span class="title">Foo</span></span></span><br></pre></td></tr></table></figure>

<p>编译器为枚举中的每个值生成一个常量。对于消息中的枚举，常量以消息的名称开头：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        SearchRequest_UNIVERSAL SearchRequest_Corpus = <span class="number">0</span></span><br><span class="line">        SearchRequest_WEB       SearchRequest_Corpus = <span class="number">1</span></span><br><span class="line">        SearchRequest_IMAGES    SearchRequest_Corpus = <span class="number">2</span></span><br><span class="line">        SearchRequest_LOCAL     SearchRequest_Corpus = <span class="number">3</span></span><br><span class="line">        SearchRequest_NEWS      SearchRequest_Corpus = <span class="number">4</span></span><br><span class="line">        SearchRequest_PRODUCTS  SearchRequest_Corpus = <span class="number">5</span></span><br><span class="line">        SearchRequest_VIDEO     SearchRequest_Corpus = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举，常量以枚举名称开头:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Foo_DEFAULT_BAR Foo = <span class="number">0</span></span><br><span class="line">        Foo_BAR_BELLS   Foo = <span class="number">1</span></span><br><span class="line">        Foo_BAR_B_CUE   Foo = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>protobuf 编译器还生成从整数值到字符串名称的映射以及从名称到值的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo_name = <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">"DEFAULT_BAR"</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">"BAR_BELLS"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"BAR_B_CUE"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Foo_value = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int32</span>&#123;</span><br><span class="line">        <span class="string">"DEFAULT_BAR"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"BAR_BELLS"</span>:   <span class="number">1</span>,</span><br><span class="line">        <span class="string">"BAR_B_CUE"</span>:   <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>.proto</code> 语言允许多个枚举符号具有相同的数值。具有相同数值的符号是同义词。这些在 Go 中以完全相同的方式表示，多个名称对应于相同的数值。反向映射包含数字值的单个条目，数值映射到出现在 <code>proto</code> 文件中首先出现的名称。</p>
<h2 id="服务-1"><a href="#服务-1" class="headerlink" title="服务"></a>服务</h2><p>默认情况下，Go 代码生成器不会为服务生成输出。如果启用 gRPC 插件（参阅 <a href="https://github.com/grpc/grpc-go/tree/master/examples" target="_blank" rel="noopener">gRPC Go快速入门指南</a>），则会生成代码以支持 gRPC。</p>
<h2 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h2><p>在Go中，使用 <code>proto</code> 库的 <code>Marshal</code> 函数来序列化 protocol buffer 数据。指向消息的结构体的指针实现了 <code>proto.Message</code>接口。调用 <code>proto.Marshal</code> 会返回以其有线格式编码的 protocol buffer。</p>
<p>要解析编码消息，需要使用 <code>proto</code> 库的 <code>Unmarshal</code> 函数。调用它将 buf 中的数据解析为 protocol buffer，并将结果放在结构体中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := &amp;pb.Person&#123;</span><br><span class="line">		Id:    <span class="number">1234</span>,</span><br><span class="line">		Name:  <span class="string">"silverming"</span>,</span><br><span class="line">		Email: <span class="string">"934933088@qq.com"</span>,</span><br><span class="line">		Phones: []*pb.Person_PhoneNumber&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Number: <span class="string">"0663-15627076633"</span>,</span><br><span class="line">				Type:   pb.Person_MOBILE,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	bytes := marshal(p)</span><br><span class="line">	unmarshal(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal</span><span class="params">(person *pb.Person)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	p := []*pb.Person&#123;person&#125;</span><br><span class="line">	book := &amp;pb.AddressBook&#123;</span><br><span class="line">		People: p,</span><br><span class="line">	&#125;</span><br><span class="line">	out, err := proto.Marshal(book)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">"Failed to encode address book:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * [10 53 10 10 115 105 108 118 101 114 109 105 110 103 16 210</span></span><br><span class="line"><span class="comment">	 * 9 26 16 57 51 52 57 51 51 48 56 56 64 113 113 46 99 111 109</span></span><br><span class="line"><span class="comment">	 * 34 18 10 16 48 54 54 51 45 49 53 54 50 55 48 55 54 54 51 51]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fmt.Println(out)</span><br><span class="line">	fmt.Println(<span class="string">"-------------------------"</span>)</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshal</span><span class="params">(in []<span class="keyword">byte</span>)</span> *<span class="title">pb</span>.<span class="title">AddressBook</span></span> &#123;</span><br><span class="line">	book := &amp;pb.AddressBook&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := proto.Unmarshal(in,book);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">"Failed to parse address book:"</span>,err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * people:&#123;name:"silverming" id:1234 email:"934933088@qq.com" phones:&#123;number:"0663-15627076633"&#125;&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fmt.Println(book.String())</span><br><span class="line">	<span class="keyword">return</span> book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="protobuf-编码规则"><a href="#protobuf-编码规则" class="headerlink" title="protobuf 编码规则"></a>protobuf 编码规则</h1><p>Protobuf 消息由字段（field）构成，每个字段有其规则（rule）、数据类型（type）、字段名（name）、tag，以及选项（option）。比如下面这段代码描述了由10个字段构成的Test消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="comment">//type 	name	tag	options</span></span><br><span class="line">	<span class="built_in">int32</span> 	a = 	<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int32</span> 	b = 	<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">sint32</span> 	c = 	<span class="number">3</span>;</span><br><span class="line">	<span class="built_in">int32</span>		d =		<span class="number">4</span>[packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时，消息字段会按照 tag 顺序，以 <code>key+val</code> 的格式，编码成二进制数据。</p>
<p>Protobuf 消息序列化之后，会产生二进制数据。这些数据（精确到 bit）按照含义不同，可以划分为6个部分：<code>MSB flag</code>、<code>tag</code>、<code>wire_type</code>(编码后数据类型)、<code>length</code>(长度)、<code>value</code>(字段值）、以及 <code>padding</code>(填充)。</p>
<p>其中，<code>key</code> 指的是：<code>key = tag &lt;&lt; 3 | wire_type</code>，也就是说， <code>key</code> 的最后 3 个比特是 <code>wire_type</code>，剩下的比特是 <code>tag</code> 值。</p>
<p>Protobuf 支持丰富的数据类型，对于不同的数据类型，会使用不同的编码方式（对应不同的 <code>wire_type</code>)，主要有以下几种类型：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Used For</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint</td>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited</td>
<td>string, bytes, embedded messages（内嵌消息）, packed repeated fields（打包重复字段）</td>
</tr>
<tr>
<td>3</td>
<td>Start group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>4</td>
<td>End group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td>fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<p>因此，用 3 个比特来表示 <code>wire_type</code> 已经足够。</p>
<h2 id="Varint-编码规则"><a href="#Varint-编码规则" class="headerlink" title="Varint 编码规则"></a>Varint 编码规则</h2><p>假设有下面这个非常简单的消息定义:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用中, 创建一个 Test1 消息并设置 a 为150。然后序列化这个消息到输出流。如果可以检查编码后的消息，会看到3个字节:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 96 01</span><br></pre></td></tr></table></figure>

<p>这里采用的就是 varint 编码。</p>
<p>varints 是使用一个或者多个字节序列化整型的方法，越小的数字需要越少数量的字节。</p>
<p>在一个 varint 中的每个字节中, 除了最后一个字节外（设置为0）, 前面的字节最高位都设置有 <code>most significant bit</code> (msb)（设置为 1），用来表示后面还有字节需要处理。</p>
<p>例如, 这里有一个数字1，这是一个字节, 因此msb不被设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0001</span><br></pre></td></tr></table></figure>

<p>下面是300，这个相对就会复杂一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1010 1100 0000 0010</span><br></pre></td></tr></table></figure>

<p>怎么知道这是300呢? 首先将每个字节的 msb 去掉, 这个仅仅是告诉我们是否已经读到数字的结尾(可以看到, 第一个字节被设置了,因为在 varint 中不止一个字节):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 去掉最高位的 1 bit</span><br><span class="line">1010 1100 0000 0010</span><br><span class="line">→ 010 1100  000 0010</span><br></pre></td></tr></table></figure>

<p>把两个 7bit 的组翻转过来， 然后可以将他们连接起来，去掉前面的0就得到最后的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000 0010  010 1100</span><br><span class="line">→  000 0010 ++ 010 1100</span><br><span class="line">→  100101100</span><br><span class="line">→  256 + 32 + 8 + 4 = 300</span><br></pre></td></tr></table></figure>

<p>注: 为了更好的理解这个例子,可以从头到尾来推断一下 300 这个数字的编码过程：</p>
<ol>
<li>整型 300 的标准 32 位(4字节)二进制表示为 <code>00000000 00000000 00000001 00101100</code></li>
<li>从后向前每次按 7bit 分隔为 <code>0000010 0101100</code>， 剩下全是 0 的忽略</li>
<li>翻转过来得到 <code>0101100 0000010</code></li>
<li><strong>为每个 7bit 增加 msb, 前面 7bit 之前加 1 表示后面还有数据并凑成 8bit 为一个 byte, 最后一个 msb 设置为 0, 这样得到 <code>10101100 00000010</code></strong></li>
</ol>
<h3 id="对有符号类型的编码"><a href="#对有符号类型的编码" class="headerlink" title="对有符号类型的编码"></a>对有符号类型的编码</h3><p>在上面的例子中，所有和类型 0 关联的 protocol buffer 类型被编码为 varints。但是, 当编码负数的时候, 在有符号整型(sint32和sint64) 和 “标准” 整型类型(int32和int64)之间有一个重要的差别：如果用 int32 或者 int64 作为一个负数的类型, 所得结果的 varint 总是 10 个字节长度，这是因为它被当成一个非常巨大的无符号整型处理（最高位为 1）。如果使用有符号类型, 所得结果的 varint 使用更有效率的 ZigZag 编码。</p>
<p>ZigZag 编码将有符号整型映射到无符号整型，所有绝对值小的值(比如 -1 )数字会得到一个小的 varint 编码值。实现的方式是 “zig-zags”, 在正数和负数整型之间来回摇摆, 因此 -1被编码为1, 1 被编码为 2, -2 被编码为 3, 由此类推, 在下面的表格中可以看到:</p>
<table>
<thead>
<tr>
<th>原始有符号整型</th>
<th>编码结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483648</td>
<td>4294967295</td>
</tr>
</tbody></table>
<p>换句话说, 对于 sint32, 每个值 n 被编码为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</span><br></pre></td></tr></table></figure>

<p>或者 64 位版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</span><br></pre></td></tr></table></figure>

<p>注意第二个移动 <code>(n &gt;&gt; 31)</code> 部分，是一个算数位移运算。 因此，移动的结果要么是0(如果n是正数) 要么是1(如果n是负数)。</p>
<p>当 sint32 或者 sint64 被解析时, 它的值被解码回原始值, 有符号的版本。</p>
<h2 id="64-bit-和-32-bit-编码规则"><a href="#64-bit-和-32-bit-编码规则" class="headerlink" title="64-bit 和 32-bit 编码规则"></a>64-bit 和 32-bit 编码规则</h2><p> 对于 double 和 fixed64，它们的是类型1, 这会告诉解析器，它们需要一个固定 64 位的数据块；类似的，float 和 fixed32 是类型5，这会告诉解析器会需要一个 32 位的数据块。</p>
<h2 id="Length-delimited-编码规则"><a href="#Length-delimited-编码规则" class="headerlink" title="Length-delimited 编码规则"></a>Length-delimited 编码规则</h2><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>类型 2 (length-delimited) 意味着值<strong>是一个 varint 编码长度加指定数量的数据字节</strong>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 b 的值为 “testing” 会得到结果:</p>
<blockquote>
<p>12 07 <u>74 65 73 74 69 6e 67</u></p>
</blockquote>
<p>下划线字节是 utf8 编码的 “testing”。这里的 key 是 0x12（十进制的18），其求解过程为：tag=2, type=2 ，对 key 进行 Varint 编码后：（<code>key = tag &lt;&lt; 3 | wire_type</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00010 010</span><br></pre></td></tr></table></figure>

<p>另外 testing 的长度为 7，所以第二个字节是 <code>len = 7</code>,其后面跟随的 7 个字节就是字符串的值 “testing”。</p>
<h3 id="内嵌消息"><a href="#内嵌消息" class="headerlink" title="内嵌消息"></a>内嵌消息</h3><p>这是带有一个内嵌消息的消息定义:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> Test1 c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test1 的字段再次设置为150，下面是编码后的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1a 03 08 96 01</span><br></pre></td></tr></table></figure>

<p>可以看到, 最后三个字节和第一个例子里面完全相同(08 96 01)，他们前面还有一个数字3 表示后面有三个字节，也就是说，内嵌消息完全是和字符串(wire type = 2)一样对待的。</p>
<p>推导过程如下：</p>
<ol>
<li>第一个字节 1A 的二进制是 “0001 1010”</li>
<li>“0001 1010”的位移三位后结果是”011”,表示字段的数字标签值是3, 对应消息定义里面的 c=3</li>
<li>“0001 1010”的后三位”010”值是2, 表示 wire type 为 2, Length-delimited</li>
<li>从 1A 后按照 varint 读取长度, 03的结果是3, 表示后面有三个字节</li>
<li>继续读取 3 个字节, 这是内嵌的消息 Test1 c 的内容, 然后按照 Test1 的定义继续解析这三个字节</li>
</ol>
<h3 id="对于-repeated-字段的编码"><a href="#对于-repeated-字段的编码" class="headerlink" title="对于 repeated 字段的编码"></a>对于 repeated 字段的编码</h3><p>如果 proto2 消息定义具有重复的元素（不带[packed = true]选项），则<strong>编码消息具有零个或多个具有相同字段编号的键值对</strong>。这些重复的值不必连续出现。它们可能与其他字段交错。解析时，元素之间的顺序会保留下来，尽管其他字段的顺序会丢失。</p>
<blockquote>
<p>在proto3中，重复字段使用 packed 编码，下面会有提高，这里讲 proto2 的编码有助于理解 packed 编码</p>
</blockquote>
<p>通常，编码消息永远不会有一个以上非重复字段的实例。但是，解析器能处理这种实际情况，对于数字类型和字符串，如果同一字段多次出现，则解析器将接受它看到的最后一个值。对于嵌入式消息字段，解析器将合并同一字段的多个实例，就像使用<code>Message :: MergeFrom</code>方法一样。</p>
<p>也就是说，后一个实例中的所有单个标量字段将替换前一个实例中的 singular 字段，repeated 字段会被串联到一块。</p>
<p>这些规则的作用是，解析两个编码的消息的连接所产生的结果与分别解析两个消息并合并结果对象的结果完全相同。也就是说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyMessage message;</span><br><span class="line">message.ParseFromString(str1 + str2);</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyMessage message, message2;</span><br><span class="line">message.ParseFromString(str1);</span><br><span class="line">message2.ParseFromString(str2);</span><br><span class="line">message.MergeFrom(message2);</span><br></pre></td></tr></table></figure>

<h3 id="打包重复字段"><a href="#打包重复字段" class="headerlink" title="打包重复字段"></a>打包重复字段</h3><p>proto 版本 2.1.0 引入了压缩重复字段，在 proto2 中声明为重复字段，并使用特殊的 <code>[packed = true]</code> 选项。<strong>在 proto3 中，默认情况下压缩标量数字类型的重复字段</strong>。这些功能类似于重复的字段，但编码方式不同。包含零元素的压缩重复字段不会出现在编码的消息中。否则，该字段的所有元素都将打包为类型为2（定界）的单个键值对。每个元素的编码方式与通常相同，不同之处在于元素之前没有键。也就是说，如果 repeated 字段设置了 <code>packed</code> 选项，则会使用 <code>Length-delimited</code> 格式来编码字段值。</p>
<p>举例来说，有以下消息类型：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> d = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设构造一个 Test4，为重复的字段 d 提供值3、270 和 86942。然后，消息编码后的形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22        // key (field number 4, wire type 2)</span><br><span class="line">06        // payload size (6 bytes)</span><br><span class="line">03        // first element (varint 3)</span><br><span class="line">8E 02     // second element (varint 270)</span><br><span class="line">9E A7 05  // third element (varint 86942)</span><br></pre></td></tr></table></figure>

<p>只能将原始数字类型（使用varint，32位或64位线型的类型）的重复字段声明为 <code>packed</code>。</p>
<p>Proto3 中对数字类型的 repeated 字段采用 <code>pack</code> 处理方式，同一个 repeated 元素共享同一个key，之后是字段的整体字节长度，然后是各个元素。因为数字类型天生具有可区分性，不需要额外的分隔符进行区分。</p>
<h2 id="字段顺序"><a href="#字段顺序" class="headerlink" title="字段顺序"></a>字段顺序</h2><p>字段编号可以在 .proto 文件中以任何顺序使用。选择使用的顺序对消息的序列化方式没有影响。</p>
<p>序列化消息时，对于如何写入其已知字段或未知字段没有保证的顺序。序列化顺序是一个实现细节，将来任何特定实现的细节都可能更改。因此，protocol buffer 解析器必须能够以任何顺序解析字段。</p>
<p><strong>参考文档</strong>：</p>
<blockquote>
<p><a href="https://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="noopener">Protobuf3语言指南（汉译 by 千念飞羽）</a></p>
<p><a href="https://juejin.cn/post/6844903944511029262#heading-5" target="_blank" rel="noopener">Protobuf生成Go代码指南</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#top_of_page" target="_blank" rel="noopener">Go Generated Code</a></p>
<p><a href="https://juejin.cn/post/6844903946348134413#heading-5" target="_blank" rel="noopener">在Golang中使用Protobuf</a></p>
<p><a href="https://blog.csdn.net/qq_15437667/article/details/78425151" target="_blank" rel="noopener">golang使用protobuf简易教程</a></p>
<p><a href="https://skyao.io/learning-proto3/" target="_blank" rel="noopener">Protocol Buffer 3 学习笔记——敖小剑的博客</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Protocol Buffers-Encoding</a></p>
<p><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/" target="_blank" rel="noopener">Protobuf 终极教程</a></p>
<p><a href="https://blog.csdn.net/zxhoo/article/details/53228303" target="_blank" rel="noopener">图解Protobuf编码</a></p>
<p><a href="https://juejin.cn/post/6844903955776929806" target="_blank" rel="noopener">Protobuf编码指南</a></p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/protobuf/" rel="tag"># protobuf</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/25/Elasticsearch%20%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/" rel="prev" title="Elasticsearch 倒排索引原理">
      <i class="fa fa-chevron-left"></i> Elasticsearch 倒排索引原理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Protobuf-概述"><span class="nav-number">1.</span> <span class="nav-text">Protobuf 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Protobuf-与-XML-比较"><span class="nav-number">1.1.</span> <span class="nav-text">Protobuf 与 XML 比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Protobuf-语法"><span class="nav-number">2.</span> <span class="nav-text">Protobuf 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个消息类型"><span class="nav-number">2.1.</span> <span class="nav-text">定义一个消息类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定字段类型"><span class="nav-number">2.2.</span> <span class="nav-text">指定字段类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配标识号"><span class="nav-number">2.3.</span> <span class="nav-text">分配标识号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定字段规则"><span class="nav-number">2.4.</span> <span class="nav-text">指定字段规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义多个消息类型"><span class="nav-number">2.5.</span> <span class="nav-text">定义多个消息类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加注释"><span class="nav-number">2.6.</span> <span class="nav-text">添加注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保留标识符（Reserved）"><span class="nav-number">2.7.</span> <span class="nav-text">保留标识符（Reserved）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从-proto-生成的文件"><span class="nav-number">3.</span> <span class="nav-text">从 .proto 生成的文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Protobuf-的类型与编程语言的对应"><span class="nav-number">4.</span> <span class="nav-text">Protobuf 的类型与编程语言的对应</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#默认值"><span class="nav-number">5.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新一个消息类型"><span class="nav-number">6.</span> <span class="nav-text">更新一个消息类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字段的类型"><span class="nav-number">7.</span> <span class="nav-text">字段的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">7.1.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义类型"><span class="nav-number">7.2.</span> <span class="nav-text">自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导入其他文件中的类型"><span class="nav-number">7.2.1.</span> <span class="nav-text">导入其他文件中的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-proto2-的消息类型"><span class="nav-number">7.2.2.</span> <span class="nav-text">使用 proto2 的消息类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套类型"><span class="nav-number">7.3.</span> <span class="nav-text">嵌套类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Any"><span class="nav-number">7.4.</span> <span class="nav-text">Any</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Oneof"><span class="nav-number">7.5.</span> <span class="nav-text">Oneof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Oneof"><span class="nav-number">7.5.1.</span> <span class="nav-text">使用 Oneof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oneof-特性"><span class="nav-number">7.5.2.</span> <span class="nav-text">Oneof 特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容性问题"><span class="nav-number">7.5.3.</span> <span class="nav-text">向后兼容性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag-重用问题"><span class="nav-number">7.5.4.</span> <span class="nav-text">Tag 重用问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">7.6.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容性问题-1"><span class="nav-number">7.6.1.</span> <span class="nav-text">向后兼容性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Package"><span class="nav-number">7.7.</span> <span class="nav-text">Package</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包及命名的解析"><span class="nav-number">7.7.1.</span> <span class="nav-text">包及命名的解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义服务-Service"><span class="nav-number">7.8.</span> <span class="nav-text">定义服务(Service)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-映射"><span class="nav-number">7.9.</span> <span class="nav-text">JSON 映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Option-选项"><span class="nav-number">7.10.</span> <span class="nav-text">Option 选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他类型"><span class="nav-number">7.11.</span> <span class="nav-text">其他类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过-proto-文件生成代码"><span class="nav-number">8.</span> <span class="nav-text">通过 .proto 文件生成代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Protobuf-代码规范"><span class="nav-number">9.</span> <span class="nav-text">Protobuf 代码规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#消息和字段名"><span class="nav-number">9.1.</span> <span class="nav-text">消息和字段名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举-1"><span class="nav-number">9.2.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务"><span class="nav-number">9.3.</span> <span class="nav-text">服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在-Go-中使用-protobuf"><span class="nav-number">10.</span> <span class="nav-text">在 Go 中使用 protobuf</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装-protoc-编译器"><span class="nav-number">10.1.</span> <span class="nav-text">安装 protoc 编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装插件"><span class="nav-number">10.2.</span> <span class="nav-text">安装插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Package-1"><span class="nav-number">10.3.</span> <span class="nav-text">Package</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message"><span class="nav-number">10.4.</span> <span class="nav-text">Message</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内嵌的消息"><span class="nav-number">10.4.1.</span> <span class="nav-text">内嵌的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义消息类型"><span class="nav-number">10.4.2.</span> <span class="nav-text">预定义消息类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段"><span class="nav-number">10.5.</span> <span class="nav-text">字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一标量字段"><span class="nav-number">10.5.1.</span> <span class="nav-text">单一标量字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单一-message-字段"><span class="nav-number">10.5.2.</span> <span class="nav-text">单一 message 字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重复字段"><span class="nav-number">10.5.3.</span> <span class="nav-text">可重复字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射字段"><span class="nav-number">10.5.4.</span> <span class="nav-text">映射字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oneof-字段"><span class="nav-number">10.5.5.</span> <span class="nav-text">Oneof 字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举-2"><span class="nav-number">10.6.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务-1"><span class="nav-number">10.7.</span> <span class="nav-text">服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码解码"><span class="nav-number">10.8.</span> <span class="nav-text">编码解码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#protobuf-编码规则"><span class="nav-number">11.</span> <span class="nav-text">protobuf 编码规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Varint-编码规则"><span class="nav-number">11.1.</span> <span class="nav-text">Varint 编码规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对有符号类型的编码"><span class="nav-number">11.1.1.</span> <span class="nav-text">对有符号类型的编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-bit-和-32-bit-编码规则"><span class="nav-number">11.2.</span> <span class="nav-text">64-bit 和 32-bit 编码规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Length-delimited-编码规则"><span class="nav-number">11.3.</span> <span class="nav-text">Length-delimited 编码规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串String"><span class="nav-number">11.3.1.</span> <span class="nav-text">字符串String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内嵌消息"><span class="nav-number">11.3.2.</span> <span class="nav-text">内嵌消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于-repeated-字段的编码"><span class="nav-number">11.3.3.</span> <span class="nav-text">对于 repeated 字段的编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打包重复字段"><span class="nav-number">11.3.4.</span> <span class="nav-text">打包重复字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段顺序"><span class="nav-number">11.4.</span> <span class="nav-text">字段顺序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
