<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="倒排索引也是索引的一种。索引，本质上就是为了快速检索我们存储的数据。 每种数据库都有自己要解决的问题（或者说擅长的领域），对应的就有自己的数据结构，而不同的使用场景和数据结构，需要用不同的索引，才能起到最大化加快查询的目的。 对于 MySQL 来说，使用 B+ tree 索引是为了优化已有数据的存储结构，对于不需要快速更新的时候，采用预先排序等方式换取更小的存储空间，更快的检索速度，但同时，由于每">
<meta name="keywords" content="Elasticsearch,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch 倒排索引原理">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;11&#x2F;25&#x2F;Elasticsearch%20%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&#x2F;index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="倒排索引也是索引的一种。索引，本质上就是为了快速检索我们存储的数据。 每种数据库都有自己要解决的问题（或者说擅长的领域），对应的就有自己的数据结构，而不同的使用场景和数据结构，需要用不同的索引，才能起到最大化加快查询的目的。 对于 MySQL 来说，使用 B+ tree 索引是为了优化已有数据的存储结构，对于不需要快速更新的时候，采用预先排序等方式换取更小的存储空间，更快的检索速度，但同时，由于每">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;Lucene%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;es%20FOR%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;Lucene%E8%B7%B3%E8%A1%A8%E8%AE%A1%E7%AE%97%E4%BE%8B%E5%AD%90.jpg">
<meta property="og:updated_time" content="2020-11-25T04:24:42.547Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;qiniu.xiaoming.net.cn&#x2F;Lucene%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg">

<link rel="canonical" href="http://yoursite.com/2020/11/25/Elasticsearch%20%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Elasticsearch 倒排索引原理 | Silverming</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silverming</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/25/Elasticsearch%20%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Elasticsearch 倒排索引原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-25 10:23:27 / 修改时间：12:24:42" itemprop="dateCreated datePublished" datetime="2020-11-25T10:23:27+08:00">2020-11-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>倒排索引也是索引的一种。索引，本质上就是为了快速检索我们存储的数据。</p>
<p><strong>每种数据库都有自己要解决的问题（或者说擅长的领域），对应的就有自己的数据结构，而不同的使用场景和数据结构，需要用不同的索引，才能起到最大化加快查询的目的。</strong></p>
<p>对于 MySQL 来说，使用 B+ tree 索引是为了优化已有数据的存储结构，对于不需要快速更新的时候，采用预先排序等方式换取更小的存储空间，更快的检索速度，但同时，由于每次更新都需要对 B+ 树进行调整，导致更新比较慢。Elasticsearch 是通过 Lucene 的倒排索引技术实现比关系型数据库更快的过滤。特别是它对多条件的过滤支持非常好。</p>
<blockquote>
<p>Elasticsearch 是建立在全文搜索引擎库 Lucene 基础上的搜索引擎，它隐藏了 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API，不过掩盖不了它底层也是 Lucene 的事实。<br>Elasticsearch 的倒排索引，其实就是 Lucene 的倒排索引。</p>
</blockquote>
<a id="more"></a>

<h1 id="倒排索引名字的由来"><a href="#倒排索引名字的由来" class="headerlink" title="倒排索引名字的由来"></a>倒排索引名字的由来</h1><p>在没有搜索引擎时，我们是直接输入一个网址，然后获取网站内容，这时我们的行为是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document -&gt; to -&gt; words</span><br></pre></td></tr></table></figure>

<p>通过文章，获取里面的单词，这种就是所谓的”正向索引”（forward index）。</p>
<p>后来，我们希望能够输入一个单词，找到含有这个单词，或者和这个单词有关系的文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word -&gt; to -&gt; documents</span><br></pre></td></tr></table></figure>

<p>于是就把这种索引，称为 inverted index，直译过来，应该叫”反向索引”，国内翻译成”倒排索引”。</p>
<h1 id="倒排索引的内部结构"><a href="#倒排索引的内部结构" class="headerlink" title="倒排索引的内部结构"></a>倒排索引的内部结构</h1><p>首先，在数据生成的时候，比如插入一份文档，内容是“生存还是死亡”，这个时候通过使用分词器，会将它分解为“生存”、“还是”、“死亡”三个词语，然后可能还会把“还是”这个无意义的词语干掉。</p>
<p>接着，就会将这两个词语以及对应的文档 id 存下来：</p>
<table>
<thead>
<tr>
<th>word</th>
<th>documentId</th>
</tr>
</thead>
<tbody><tr>
<td>生存</td>
<td>1</td>
</tr>
<tr>
<td>死亡</td>
<td>1</td>
</tr>
</tbody></table>
<p>然后我们再插入一个文档，这个内容是“生存”，于是索引就变成了：</p>
<table>
<thead>
<tr>
<th>word</th>
<th>documentId</th>
</tr>
</thead>
<tbody><tr>
<td>生存</td>
<td>1，2</td>
</tr>
<tr>
<td>死亡</td>
<td>1</td>
</tr>
</tbody></table>
<p>下回在搜索“生存”的时候，就会返回1，2两份文档。</p>
<p>但是只是这样是远远不够的，世界上的语言种类特别多，没搜索一个单词，就都要全局遍历，效率特别低。这时候就需要用到了排序，以便采用二分查找等方式提高遍历效率，在这里 lucene 采用了跳表的数据结构，这就是<strong>Term Dictionary</strong>,另一方面，光使用排序还会导致磁盘IO速度过慢（因为数据都放在磁盘中），如果将数据放入内存，又会导致内存爆满。</p>
<p>所以，Lucene 的倒排索引，在上面的表格的基础上，在左边增加了一层<strong>字典树 term index</strong>，它不存储所有的单词，只存储单词前缀，通过字典书找到单词所在的块，也就是单词的大概位置，再在块里二分查找，找到对应的单词，再找到单词对应的文档列表。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Lucene%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="Lucene倒排索引内部结构"></p>
<p>另外，为了进一步节省内存，Lucene 还用了 FST（Finite State Transducers）对 Term Index 做进一步压缩，term index 在内存中是以FST（finite state transducers）的形式保存的，其特点是非常节省内存。Term dictionary 在磁盘上是以分 block 的方式保存的，一个block 内部利用公共前缀压缩，比如都是 Ab 开头的单词就可以把 Ab 省去。这样 term dictionary 可以比 b-tree 更节约磁盘空间。</p>
<h2 id="对-Posting-List-的改进"><a href="#对-Posting-List-的改进" class="headerlink" title="对 Posting List 的改进"></a>对 Posting List 的改进</h2><p>原生的 Posting List 有两个可以改进的地方：</p>
<ul>
<li>如何压缩以节省磁盘空间</li>
<li>如何快速求并交集</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>假设有这样一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[73, 300, 302, 332, 343, 372]</span><br></pre></td></tr></table></figure>

<p>如何进行压缩呢？</p>
<p>在Lucene里，数据是按照 Segment 存储的，每个 Segment 最多存 65536 个文档 ID， 所以文档 ID 的范围，从 0 到 2^16-1，所以如果不进行任何处理，那么每个元素都会占用 2 bytes ，对应上面的数组，就是 6 * 2 = 12 bytes。</p>
<p><strong>压缩，就是尽可能降低每个数据占用的空间，同时又能让信息不失真，能够还原回来。</strong></p>
<h4 id="增量编码"><a href="#增量编码" class="headerlink" title="增量编码"></a>增量编码</h4><p>数据只记录元素与元素之间的增量，于是数组变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[73, 227, 2, 30, 11, 29]</span><br></pre></td></tr></table></figure>

<h4 id="分割成块"><a href="#分割成块" class="headerlink" title="分割成块"></a>分割成块</h4><p>Lucene 里每个块是 256 个文档 ID，这样可以保证每个块，增量编码后，每个元素都不会超过 256（1 byte），另外还方便进行后面求交并集的跳表运算。</p>
<p>为了方便演示，我们假设每个块是 3 个文档 ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[73, 227, 2], [30, 11, 29]</span><br></pre></td></tr></table></figure>

<h4 id="按需分配空间"><a href="#按需分配空间" class="headerlink" title="按需分配空间"></a>按需分配空间</h4><p>对于第一个块，[73, 227, 2]，最大元素是227，需要 8 bits，所以就给每个元素都分配 8 bits的空间。</p>
<p>但是对于第二个块，[30, 11, 29]，最大的元素才30，只需要 5 bits，所有给每个元素只分配 5 bits 的空间足矣。</p>
<p>以上三个步骤，共同组成了一项编码技术，Frame Of Reference（FOR）：</p>
<p><img src="https://qiniu.xiaoming.net.cn/es%20FOR%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF.jpg" alt="es FOR编码技术"></p>
<h3 id="快速求交并集"><a href="#快速求交并集" class="headerlink" title="快速求交并集"></a>快速求交并集</h3><p>在 Lucene 中查询，通常不只有一个查询条件，比如想搜索：</p>
<ul>
<li>含有“生存”相关词语的文档</li>
<li>文档发布时间在最近一个月</li>
<li>文档发布者是平台的特约作者</li>
</ul>
<p>这样就需要根据三个字段，去三棵倒排索引里去查，当然，磁盘里的数据，上一节提到过，用了 FOR 进行压缩，所以我们要把数据进行反向处理，即解压，才能还原成原始的文档 ID，然后把这三个文档 ID 数组在内存中做一个交集。</p>
<blockquote>
<p>即使没有多条件查询， Lucene 也需要频繁求并集，因为 Lucene 是分片存储的。</p>
</blockquote>
<p>可以把 Lucene 遇到的问题，简化成一道算法题。</p>
<p>假设有下面三个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[64, 300, 303, 343]</span><br><span class="line"></span><br><span class="line">[73, 300, 302, 303, 343, 372]</span><br><span class="line"></span><br><span class="line">[303, 311, 333, 343]</span><br></pre></td></tr></table></figure>

<p>求它们的交集。</p>
<h4 id="Integer-数组"><a href="#Integer-数组" class="headerlink" title="Integer 数组"></a>Integer 数组</h4><p>直接用原始的文档 ID ，如果逐个数组遍历一遍，这样就可以求了，这样不管是空间还是性能都不够理想。</p>
<p>其实对于有序的数组，用跳表（skip table）可以更高效，但是不管是从性能，还是空间上考虑，Integer 数组都不靠谱，假设有100M 个文档 ID，每个文档 ID 占 2 bytes，那已经是 200 MB，而这些数据是要放到内存中进行处理的，把这么大量的数据，从磁盘解压后丢到内存，内存肯定撑不住。</p>
<h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>假设有这样一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,6,7,10]</span><br></pre></td></tr></table></figure>

<p>那么可以这样通过使用 bitmap （位图）来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0,0,1,0,0,1,1,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>我们用 0 表示角标对应的数字不存在，用 1 表示存在。</strong></p>
<p>这样带来了两个好处：</p>
<ul>
<li>节省空间：只需要 0 和 1，那每个文档 ID 就只需要 1 bit，还是假设有 100M 个文档，那只需要 100M bits = 100M * 1/8 bytes = 12.5 MB，比之前用 Integer 数组的 200 MB 节省了大量的内存。</li>
<li>运算更快：0 和 1，天然就适合进行位运算，求交集，「与」一下，求并集，「或」一下，一切都回归到计算机的起点</li>
</ul>
<h4 id="Roaring-Bitmaps"><a href="#Roaring-Bitmaps" class="headerlink" title="Roaring Bitmaps"></a>Roaring Bitmaps</h4><p>bitmap 有个硬伤，就是不管你有多少个文档，你占用的空间都是一样的，之前说过，Lucene Posting List 的每个 Segement 最多放 65536 个文档ID，举一个极端的例子，有一个数组，里面只有两个文档 ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 65535]</span><br></pre></td></tr></table></figure>

<p>如果使用 bitmap 表示，那就需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,….(超级多个0),…,0,0,1]</span><br></pre></td></tr></table></figure>

<p>需要 65536 个 bit，也就是 65536/8 = 8192 bytes，而用 Integer 数组，只需要 2 * 2 bytes = 4 bytes</p>
<p>可见在文档数量不多的时候，使用 Integer 数组更加节省内存。</p>
<p>计算一下临界值，很简单，无论文档数量多少，bitmap 都需要 8192 bytes，而 Integer 数组则和文档数量成线性相关，每个文档 ID 占 2 bytes，所以：</p>
<p>8192 / 2 = 4096</p>
<p>当文档数量少于 4096 时，用 Integer 数组，否则，用 bitmap。</p>
<h4 id="对于-Integer，使用-Skip-List（跳表）做合并计算"><a href="#对于-Integer，使用-Skip-List（跳表）做合并计算" class="headerlink" title="对于 Integer，使用 Skip List（跳表）做合并计算"></a>对于 Integer，使用 Skip List（跳表）做合并计算</h4><p>对于需要查找的每一个 int 数组建立跳表，然后由最短的 posting list 开始遍历，遍历的过程中各自可以跳过不少元素，比如下面的例子：</p>
<p><img src="https://qiniu.xiaoming.net.cn/Lucene%E8%B7%B3%E8%A1%A8%E8%AE%A1%E7%AE%97%E4%BE%8B%E5%AD%90.jpg" alt="Lucene 跳表例子"></p>
<p>以上是三个posting list。现在需要把它们用AND的关系合并，得出posting list的交集。首先选择最短的posting list，然后从小到大遍历。遍历的过程可以跳过一些元素，比如我们遍历到绿色的13的时候，就可以跳过蓝色的3了，因为3比13要小。</p>
<p>整个过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Next -&gt; 2</span><br><span class="line">Advance(2) -&gt; 13</span><br><span class="line">Advance(13) -&gt; 13</span><br><span class="line">Already on 13</span><br><span class="line">Advance(13) -&gt; 13 MATCH!!!</span><br><span class="line">Next -&gt; 17</span><br><span class="line">Advance(17) -&gt; 22</span><br><span class="line">Advance(22) -&gt; 98</span><br><span class="line">Advance(98) -&gt; 98</span><br><span class="line">Advance(98) -&gt; 98 MATCH!!!</span><br></pre></td></tr></table></figure>

<h1 id="Roaring-bitmaps-和-Frame-Of-Reference-的关系"><a href="#Roaring-bitmaps-和-Frame-Of-Reference-的关系" class="headerlink" title="Roaring bitmaps 和 Frame Of Reference 的关系"></a>Roaring bitmaps 和 Frame Of Reference 的关系</h1><p><code>Frame Of Reference</code> 是压缩数据，减少磁盘占用空间，所以当我们从磁盘取数据时，也需要一个反向的过程，即解压，解压后才有我们上面看到的这样子的文档ID数组：[73, 300, 302, 303, 343, 372] ，接着我们需要对数据进行处理，求交集或者并集，这时候数据是需要放到内存进行处理的，我们有三个这样的数组，这些数组可能很大，而内存空间比磁盘还宝贵，于是需要更强有力的压缩算法，同时还要有利于快速的求交并集，于是有了Roaring Bitmaps 算法。</p>
<p>另外，Lucene 还会把从磁盘取出来的数据，通过 Roaring bitmaps 处理后，缓存到内存中，Lucene 称之为 filter cache.</p>
<h1 id="为什么-Elasticsearch-Lucene-检索可以比-mysql-快"><a href="#为什么-Elasticsearch-Lucene-检索可以比-mysql-快" class="headerlink" title="为什么 Elasticsearch/Lucene 检索可以比 mysql 快"></a>为什么 Elasticsearch/Lucene 检索可以比 mysql 快</h1><p>Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。检索一个 term 需要若干次随机 IO 的磁盘操作。而 Lucene 在 term dictionary 的基础上添加了term index来加速检索，term index 以树的形式缓存在内存中。从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access （随机IO）次数。</p>
<p> <strong>参考文档</strong></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/76485252" target="_blank" rel="noopener">聊聊 Elasticsearch 的倒排索引</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33671444" target="_blank" rel="noopener">elasticsearch 倒排索引原理</a></p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Elasticsearch/" rel="tag"># Elasticsearch</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/19/ElasticSearch/" rel="prev" title="ElasticSearch">
      <i class="fa fa-chevron-left"></i> ElasticSearch
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/27/Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/" rel="next" title="Protobuf">
      Protobuf <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#倒排索引名字的由来"><span class="nav-number">1.</span> <span class="nav-text">倒排索引名字的由来</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#倒排索引的内部结构"><span class="nav-number">2.</span> <span class="nav-text">倒排索引的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对-Posting-List-的改进"><span class="nav-number">2.1.</span> <span class="nav-text">对 Posting List 的改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#压缩"><span class="nav-number">2.1.1.</span> <span class="nav-text">压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增量编码"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">增量编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分割成块"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">分割成块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按需分配空间"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">按需分配空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速求交并集"><span class="nav-number">2.1.2.</span> <span class="nav-text">快速求交并集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer-数组"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">Integer 数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bitmap"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">Bitmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Roaring-Bitmaps"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">Roaring Bitmaps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对于-Integer，使用-Skip-List（跳表）做合并计算"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">对于 Integer，使用 Skip List（跳表）做合并计算</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Roaring-bitmaps-和-Frame-Of-Reference-的关系"><span class="nav-number">3.</span> <span class="nav-text">Roaring bitmaps 和 Frame Of Reference 的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么-Elasticsearch-Lucene-检索可以比-mysql-快"><span class="nav-number">4.</span> <span class="nav-text">为什么 Elasticsearch/Lucene 检索可以比 mysql 快</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:43</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
  <div>
     <a href="http://www.beianbeian.com/beianxinxi/56c155c0ed5f44020af3c1659377b89d.html" target="_blank" rel="noopener">粤ICP备18114217号</a>
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
