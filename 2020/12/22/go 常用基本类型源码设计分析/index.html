

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="数组类型数组作为一种基本的数据类型，通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中会使用如下所示的方式来表示数组类型：
12[10]int[200]interface&amp;#123;&amp;#125;

Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。">
  <meta name="author" content="Silverming">
  <meta name="keywords" content="">
  
  <title>go 常用基本类型源码设计分析 - Silverming</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"54ebb03ad7ad5b762ac8ff7958df6d3f","google":"G-M2RT7SDT3L","gtag":"G-M2RT7SDT3L","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tFHjJkaAYKqH8BIXKnJVurUc-MdYXbMMI","app_key":"1qR5F7XyydYd5YJtIpMJBFmP","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Silverming</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="go 常用基本类型源码设计分析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-22 21:17" pubdate>
        2020年12月22日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      40.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      507
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">go 常用基本类型源码设计分析</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年6月20日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><p>数组作为一种基本的数据类型，通常会从两个维度描述数组，也就是数组中存储的<strong>元素类型</strong>和数组最大能存储的<strong>元素个数</strong>，在 Go 语言中会使用如下所示的方式来表示数组类型：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">[<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span><br>[<span class="hljs-number">200</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，<strong>只有两个条件都相同才是同一类型</strong>。</p>
<a id="more"></a>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建数组时由以下函数进行创建，当前数组是否应该在堆栈中初始化也在编译期就确定了：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// elem 为元素类型，bound 为数组大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArray</span><span class="hljs-params">(elem *Type, bound <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Type</span></span> &#123;<br>	<span class="hljs-keyword">if</span> bound &lt; <span class="hljs-number">0</span> &#123;<br>		Fatalf(<span class="hljs-string">"NewArray: invalid bound %v"</span>, bound)<br>	&#125;<br>	t := New(TARRAY)<br>	t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;<br>  	<span class="hljs-comment">// 判断当前数组是否要在堆栈中初始化</span><br>	t.SetNotInHeap(elem.NotInHeap())<br>	<span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码推导数组的大小：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr1 := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>arr2 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导。</p>
<h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc.anylit</code> 函数中做两种不同的优化：</p>
<ol>
<li><strong>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上</strong>；</li>
<li><strong>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出</strong>；</li>
</ol>
<p>当数组中元素的个数小于或者等于四个时，会将原有的初始化语句 <code>[3]int{1, 2, 3}</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>

<p>但是如果当前数组的元素大于四个，会先获取一个唯一的 <code>staticname</code>，然后调用 <code>cmd/compile/internal/gc.fixedlit</code> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p>
<p>假设代码需要初始化 <code>[5]int{1, 2, 3, 4, 5}</code>，那么可以将过程理解成以下的伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span><br>statictmp_0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>statictmp_0[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>statictmp_0[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br>statictmp_0[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span><br>statictmp_0[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span><br>arr = statictmp_0<br></code></pre></div></td></tr></table></figure>

<p>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>在访问数组的时候，会先检测下标是否越界，其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck1</span><span class="hljs-params">(n *Node, top <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(res *Node)</span></span> &#123;<br>	<span class="hljs-keyword">switch</span> n.Op &#123;<br>	<span class="hljs-keyword">case</span> OINDEX:<br>		ok |= ctxExpr<br>		l := n.Left  <span class="hljs-comment">// array</span><br>		r := n.Right <span class="hljs-comment">// index</span><br>		<span class="hljs-keyword">switch</span> n.Left.Type.Etype &#123;<br>		<span class="hljs-keyword">case</span> TSTRING, TARRAY, TSLICE:<br>			...<br>			<span class="hljs-keyword">if</span> n.Right.Type != <span class="hljs-literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;<br>				yyerror(<span class="hljs-string">"non-integer %s index %v"</span>, why, n.Right)<br>				<span class="hljs-keyword">break</span><br>			&#125;<br><br>			<span class="hljs-keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;<br>				x := n.Right.Int64()<br>				<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>					yyerror(<span class="hljs-string">"invalid %s index %v (index must be non-negative)"</span>, why, n.Right)<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.IsArray() &amp;&amp; x &gt;= t.NumElem() &#123;<br>					yyerror(<span class="hljs-string">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, t.NumElem())<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> Isconst(n.Left, CTSTR) &amp;&amp; x &gt;= <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">len</span>(strlit(n.Left))) &#123;<br>					yyerror(<span class="hljs-string">"invalid string index %v (out of bounds for %d-byte string)"</span>, n.Right, <span class="hljs-built_in">len</span>(strlit(n.Left)))<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Right.Val().U.(*Mpint).Cmp(maxintval[TINT]) &gt; <span class="hljs-number">0</span> &#123;<br>					yyerror(<span class="hljs-string">"invalid %s index %v (index too large)"</span>, why, n.Right)<br>				&#125;<br>			&#125;<br>		&#125;<br>	...<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol>
<li>访问数组的索引是非整数时，报错 <code>“non-integer %s index %v”</code>；</li>
<li>访问数组的索引是负数时，报错 <code>&quot;invalid %s index %v (index must be non-negative)&quot;</code>；</li>
<li>访问数组的索引越界时，报错 <code>&quot;invalid array index %v (out of bounds for %d-element array)&quot;</code>；</li>
</ol>
<blockquote>
<p>另外两个报错暂时没搞懂啥意思</p>
</blockquote>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组。但是<strong>如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，这时需要 Go 语言运行时阻止不合法的访问</strong>。例如下面这种越界访问：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> check<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outOfRange</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>	arr := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>	i := <span class="hljs-number">4</span><br>	elem := arr[i]<br>	<span class="hljs-keyword">return</span> elem<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>runtime.panicIndex</code> 和 <code>runtime.goPanicIndex</code> 触发程序的运行时错误并导致崩溃退出。</p>
<p>因此，Go 语言对于数组的访问有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。</p>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会计算出数组当前元素的内存地址，然后修改当前内存地址的内容。赋值的过程中会先确定目标数组的地址，再获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中。<strong>无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与</strong>。</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h2><p>在 Go 中，声明切片的方式为：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">[]<span class="hljs-keyword">int</span><br>[]<span class="hljs-keyword">interface</span><br></code></pre></div></td></tr></table></figure>

<p>切片在编译期间的生成的类型只会包含切片中的元素类型，即 <code>int</code> 或者 <code>interface{}</code> 等。</p>
<p><code>cmd/compile/internal/types.NewSlice</code>就是编译期间用于创建切片类型的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// NewSlice returns the slice Type with element type elem.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSlice</span><span class="hljs-params">(elem *Type)</span> *<span class="hljs-title">Type</span></span> &#123;<br>	<span class="hljs-keyword">if</span> t := elem.Cache.slice; t != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> t.Elem() != elem &#123;<br>			Fatalf(<span class="hljs-string">"elem mismatch"</span>)<br>		&#125;<br>		<span class="hljs-keyword">return</span> t<br>	&#125;<br><br>	t := New(TSLICE)<br>	t.Extra = Slice&#123;Elem: elem&#125;<br>	elem.Cache.slice = t<br>	<span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面方法返回结构体中的 <code>Extra</code> 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 <code>Extra</code> 字段中帮助程序在运行时动态获取。</p>
<h2 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h2><p>切片在运行时的数据结构由 <code>reflect.SliceHeader</code> 结构体表示：</p>
<ul>
<li><code>Data</code> 是指向数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>	Data <span class="hljs-keyword">uintptr</span><br>	Len  <span class="hljs-keyword">int</span><br>	Cap  <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="切片数据结构"></p>
<p><code>Data</code> 是一片连续的内存空间，用于存储切片中的全部元素，从逻辑上来说，它就是一个数组。切片引入了一个抽象层，提供了对数组中部分连续片段的引用。作为数组的引用，可以在运行区间可以修改它的长度和范围。当切片底层的数组长度不足时就会触发扩容，切片指向的数组可能会发生变化。</p>
<h2 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h2><p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>] or slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作，例如对于下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSlice</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;<br>  arr := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>	slice := arr[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>	<span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其编译过程中 <code>slice := arr[0:1]</code> 会有如下代码生成：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v27 (+<span class="hljs-number">5</span>) = SliceMake &lt;[]<span class="hljs-keyword">int</span>&gt; v11 v14 v17<br><br>name &amp;arr[*[<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>]: v11<br>name slice.ptr[*<span class="hljs-keyword">int</span>]: v11<br>name slice.<span class="hljs-built_in">len</span>[<span class="hljs-keyword">int</span>]: v14<br>name slice.<span class="hljs-built_in">cap</span>[<span class="hljs-keyword">int</span>]: v17<br></code></pre></div></td></tr></table></figure>

<p><code>SliceMake</code> 操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，对应切片的数据结构。</p>
<p><strong>使用下标初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。</strong></p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>当使用字面量 <code>[]int{1, 2, 3}</code> 创建新的切片时，<code>cmd/compile/internal/gc.slicelit</code> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vstat [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span><br>vstat[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>vstat[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>vstat[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> vauto *[<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">new</span>([<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>)<br>*vauto = vstat<br>slice := vauto[:]<br></code></pre></div></td></tr></table></figure>

<p>上面代码的流程如下：</p>
<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<p>使用下标和字面量的方式创建切片时，很多的工作都是在编译期间完成的。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量。go 不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>。除了校验参数之外，还会根据条件决定切片的分配：</p>
<ol>
<li>切片的大小和容量是否足够小</li>
<li>切片是否发生了逃逸</li>
</ol>
<p>当切片发生逃逸或者非常大时，运行时需要通过 <code>runtime.makeslice</code> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span><br>n := arr[:<span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure>

<p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组并将 <code>[:3]</code> 同样转换成使用下标方式中的 <code>OpSliceMake</code> 操作。</p>
<p>对于 <code>runtime.makeslice</code> 函数，其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>	mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>))<br>	<span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span> &gt; <span class="hljs-built_in">cap</span> &#123;<br>		<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Produce a 'len out of range' error instead of a</span><br>		<span class="hljs-comment">// 'cap out of range' error when someone does make([]T, bignumber).</span><br>		<span class="hljs-comment">// 'cap out of range' is true too, but since the cap is only being</span><br>		<span class="hljs-comment">// supplied implicitly, saying len is clearer.</span><br>		<span class="hljs-comment">// See golang.org/issue/4085.</span><br>		mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>))<br>		<span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> &#123;<br>			panicmakeslicelen()<br>		&#125;<br>		panicmakeslicecap()<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> mallocgc(mem, et, <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上述函数的主要工作是计算切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：<br>$$<br>内存空间 = 切片中元素大小 \times 切片容量<br>$$<br>同时，创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>runtime.makeslice</code> 在最后调用的 <code>runtime.mallocgc</code> 是用于申请内存的函数，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的对象会在堆上初始化。</p>
<h2 id="访问切片"><a href="#访问切片" class="headerlink" title="访问切片"></a>访问切片</h2><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环。</p>
<p>使用 <code>len</code> 和 <code>cap</code> 获取长度或者容量是切片最常见的操作，编译器将这它们看成两种特殊操作，即 <code>OLEN</code> 和 <code>OCAP</code>。<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会直接替换成切片的长度或者容量，不需要在运行时获取。</p>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问。</p>
<h2 id="切片的追加和扩容"><a href="#切片的追加和扩容" class="headerlink" title="切片的追加和扩容"></a>切片的追加和扩容</h2><h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，会根据返回值是否会覆盖原变量，选择进入两种流程。如果 <code>append</code> 返回的新切片不需要赋值回原有的变量，就会先通过切片获取它的的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <code>runtime.growslice</code> 对切片进行扩容并将新的元素依次加入切片。如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的切片会覆盖原切片，此时 go 会调用另一个方式展开关键字，会获取数组的指针，之后直接在数组中追加元素，避免发生拷贝影响性能。</p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>当切片的容量不足时，会调用 <code>runtime.growslice</code> 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程。在该函数中，首先会确认新切片的容量：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;<br>  <span class="hljs-comment">//...</span><br>  newcap := old.<span class="hljs-built_in">cap</span><br>	doublecap := newcap + newcap<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>		newcap = <span class="hljs-built_in">cap</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<br>			newcap = doublecap<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br>			<span class="hljs-comment">// and prevent an infinite loop.</span><br>			<span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>				newcap += newcap / <span class="hljs-number">4</span><br>			&#125;<br>			<span class="hljs-comment">// Set newcap to the requested cap when</span><br>			<span class="hljs-comment">// the newcap calculation overflowed.</span><br>			<span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>				newcap = <span class="hljs-built_in">cap</span><br>			&#125;<br>		&#125;<br>	&#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p><strong>上述代码片段仅会确定切片的大致容量</strong>，还需要根据切片中的元素大小对齐内存，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会通过 <code>roundupsize</code>  进行对齐内存，内存对齐主要是为了适应 go 的内存分配，可以提高内存的分配效率并减少碎片。</p>
<p>实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> overflow <span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-keyword">uintptr</span><br><span class="hljs-comment">// Specialize for common values of et.size.</span><br><span class="hljs-comment">// For 1 we don't need any division/multiplication.</span><br><span class="hljs-comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span><br><span class="hljs-comment">// For powers of 2, use a variable shift.</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>:<br>	lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>)<br>	newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>)<br>	capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap))<br>	overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAlloc<br>	newcap = <span class="hljs-keyword">int</span>(capmem)<br><span class="hljs-keyword">case</span> et.size == sys.PtrSize:<br>	lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>) * sys.PtrSize<br>	newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>) * sys.PtrSize<br>	capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap) * sys.PtrSize)<br>	overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize<br>	newcap = <span class="hljs-keyword">int</span>(capmem / sys.PtrSize)<br> <span class="hljs-comment">//...</span><br> <span class="hljs-keyword">default</span>:<br>   <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure>

<p><code>roundupsize</code> 则会使用 <code>runtime.size_to_class</code> 和 <code>runtime.class_to_size</code> 数组对申请的内存向上取整：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<br>	<span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;<br>    	<span class="hljs-comment">// 首先通过 size_to_class 确认 size 的级别，再通过 class_to_size 取整为该 class 的上限大小</span><br>		<span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="hljs-number">-1</span>)/smallSizeDiv]])<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="hljs-number">-1</span>)/largeSizeDiv]])<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> size+_PageSize &lt; size &#123;<br>		<span class="hljs-keyword">return</span> size<br>	&#125;<br>	<span class="hljs-keyword">return</span> alignUp(size, _PageSize)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>当使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <code>cmd/compile/internal/gc.copyany</code>  也会分两种情况进行处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">n := <span class="hljs-built_in">len</span>(a)<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-built_in">len</span>(b) &#123;<br>    n = <span class="hljs-built_in">len</span>(b)<br>&#125;<br><span class="hljs-keyword">if</span> a.ptr != b.ptr &#123;<br>    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) <br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>runtime.memmove</code> 会负责拷贝内存。而如果拷贝是在运行时发生的，例如：<code>go copy(a, b)</code>，编译器会使用 <code>runtime.slicecopy</code> 替换运行期间调用的 <code>copy</code>，该函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicecopy</span><span class="hljs-params">(to, fm slice, width <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">if</span> fm.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> || to.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	n := fm.<span class="hljs-built_in">len</span><br>	<span class="hljs-keyword">if</span> to.<span class="hljs-built_in">len</span> &lt; n &#123;<br>		n = to.<span class="hljs-built_in">len</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> width == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> n<br>	&#125;<br>	...<br><br>	size := <span class="hljs-keyword">uintptr</span>(n) * width<br>	<span class="hljs-keyword">if</span> size == <span class="hljs-number">1</span> &#123;<br>		*(*<span class="hljs-keyword">byte</span>)(to.array) = *(*<span class="hljs-keyword">byte</span>)(fm.array)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		memmove(to.array, fm.array, size)<br>	&#125;<br>	<span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code> <strong>将整块内存的内容拷贝到目标的内存区域中</strong>：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%8B%B7%E8%B4%9D.png" alt="切片拷贝"></p>
<p>相比于依次拷贝元素，<code>runtime.memmove</code> 能够提供更好的性能。需要注意的是，成块拷贝内存仍然会占用非常多的资源，在大切片上执行拷贝操作时一定要注意对性能的影响。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串实际上是由字符组成的数组，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个<strong>只读的字节数组</strong>，下图展示了 <code>&quot;hello&quot;</code> 字符串在内存中的存储方式：</p>
<p><img src="https://qiniu.xiaoming.net.cn/hello%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt="hello 字符串在内存中的存储方式"></p>
<p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，假设有以下代码，其中包含了一个字符串，当将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cat main.go<br>package main<br><br>func <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>	str := <span class="hljs-string">"hello"</span><br>	println([]byte(str))<br>&#125;<br><br>$ GOOS=linux GOARCH=amd64 go tool compile -S main.go<br>...<br>go.string.<span class="hljs-string">"hello"</span> SRODATA dupok size=5<br>	0x0000 68 65 6c 6c 6f                                   hello<br>...<br></code></pre></div></td></tr></table></figure>

<p><strong>只读只意味着字符串会分配到只读的内存空间</strong>，但是 Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间，仍然可以通过在 <code>string</code> 和 <code>[]byte</code> 类型之间反复转换实现修改这一目的：</p>
<ol>
<li>先将这段内存拷贝到堆或者栈上；</li>
<li>将变量的类型转换成 <code>[]byte</code> 后并修改字节数据；</li>
<li>将修改后的字节数组转换回 <code>string</code>；</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>字符串在 Go 中的接口是 <code>reflect.StringHeader</code> ，其中包含指向字节数组的指针和数组的大小：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>	Data <span class="hljs-keyword">uintptr</span><br>	Len  <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="字符串解析过程"><a href="#字符串解析过程" class="headerlink" title="字符串解析过程"></a>字符串解析过程</h2><p>解析器在词法分析阶段会解析字符串，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列。在 Go 中，声明字符串的方式有两种，即双引号和反引号：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">str1 := <span class="hljs-string">"this is a string"</span><br>str2 := <span class="hljs-string">`this is another string`</span><br></code></pre></div></td></tr></table></figure>

<p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而反引号声明的字符串可以摆脱单行的限制。当使用反引号时，因为双引号不再负责标记字符串的开始和结束，所以可以在字符串内部直接使用 <code>&quot;</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">json := <span class="hljs-string">`&#123;"author": "draven", "tags": ["golang"]&#125;`</span><br></code></pre></div></td></tr></table></figure>

<p>解析字符串使用的扫描器 <code>cmd/compile/internal/syntax.scanner</code> 会将输入的字符串转换成 Token 流。</p>
<p><code>stdString</code> 方法是它用来解析使用双引号的标准字符串：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">func (s *scanner) stdString() &#123;<br>	s.startLit()<br>	s.bad = false<br><br>	for &#123;<br>		r := s.getr()<br>		if r == '"' &#123;<br>			break<br>		&#125;<br>		if r == '\\' &#123;<br>			s.escape('"')<br>			continue<br>		&#125;<br>		if r == '\n' &#123;<br>            // 如果存在隐式换行\n,则报错<br>			s.ungetr() // assume newline is not part of literal<br>			s.errorf("newline in string")<br>			break<br>		&#125;<br>		if r &lt; 0 &#123;<br>			s.errorAtf(0, "string not terminated")<br>			break<br>		&#125;<br>	&#125;<br><br>	s.nlsemi = true<br>	s.lit = string(s.stopLit())<br>	s.kind = StringLit<br>	s.tok = _Literal<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>该方法的逻辑如下：</p>
<ol>
<li><p>标准字符串使用双引号表示开头和结尾；</p>
</li>
<li><p>标准字符串需要使用反斜杠 <code>\</code> 来逃逸双引号；</p>
</li>
<li><p>标准字符串不能出现例如下面这样的隐式换行 <code>\n</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">str := "start<br>end"<br></code></pre></div></td></tr></table></figure>

</li>
</ol>
<p><code>rawString</code> 方法是用来解析反引号声明的字符串，它会将非反引号的所有字符都划分到当前字符串的范围中，所以可以使用它支持复杂的多行字符串，实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *scanner)</span> <span class="hljs-title">rawString</span><span class="hljs-params">()</span></span> &#123;<br>	s.startLit()<br>	s.bad = <span class="hljs-literal">false</span><br><br>	<span class="hljs-keyword">for</span> &#123;<br>		r := s.getr()<br>		<span class="hljs-keyword">if</span> r == <span class="hljs-string">'`'</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;<br>			s.errorAtf(<span class="hljs-number">0</span>, <span class="hljs-string">"string not terminated"</span>)<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// We leave CRs in the string since they are part of the</span><br>	<span class="hljs-comment">// literal (even though they are not part of the literal</span><br>	<span class="hljs-comment">// value).</span><br><br>	s.nlsemi = <span class="hljs-literal">true</span><br>	s.lit = <span class="hljs-keyword">string</span>(s.stopLit())<br>	s.kind = StringLit<br>	s.tok = _Literal<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>无论是标准字符串还是原始字符串都会被标记成 <code>StringLit</code> 并传递到语法分析阶段。在语法分析阶段，与字符串相关的表达式都会由 <code>basicLit</code> 方法处理：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *noder)</span> <span class="hljs-title">basicLit</span><span class="hljs-params">(lit *syntax.BasicLit)</span> <span class="hljs-title">Val</span></span> &#123;<br>	<span class="hljs-comment">// We don't use the errors of the conversion routines to determine</span><br>	<span class="hljs-comment">// if a literal string is valid because the conversion routines may</span><br>	<span class="hljs-comment">// accept a wider syntax than the language permits. Rely on lit.Bad</span><br>	<span class="hljs-comment">// instead.</span><br>	<span class="hljs-keyword">switch</span> s := lit.Value; lit.Kind &#123;<br>	<span class="hljs-keyword">case</span> syntax.IntLit:<br>		checkLangCompat(lit)<br>		x := <span class="hljs-built_in">new</span>(Mpint)<br>		<span class="hljs-keyword">if</span> !lit.Bad &#123;<br>			x.SetString(s)<br>		&#125;<br>		<span class="hljs-keyword">return</span> Val&#123;U: x&#125;<br><br>	<span class="hljs-keyword">case</span> syntax.FloatLit:<br>		checkLangCompat(lit)<br>		x := newMpflt()<br>		<span class="hljs-keyword">if</span> !lit.Bad &#123;<br>			x.SetString(s)<br>		&#125;<br>		<span class="hljs-keyword">return</span> Val&#123;U: x&#125;<br><br>	<span class="hljs-keyword">case</span> syntax.ImagLit:<br>		checkLangCompat(lit)<br>		x := newMpcmplx()<br>		<span class="hljs-keyword">if</span> !lit.Bad &#123;<br>			x.Imag.SetString(strings.TrimSuffix(s, <span class="hljs-string">"i"</span>))<br>		&#125;<br>		<span class="hljs-keyword">return</span> Val&#123;U: x&#125;<br><br>	<span class="hljs-keyword">case</span> syntax.RuneLit:<br>		x := <span class="hljs-built_in">new</span>(Mpint)<br>		x.Rune = <span class="hljs-literal">true</span><br>		<span class="hljs-keyword">if</span> !lit.Bad &#123;<br>			u, _ := strconv.Unquote(s)<br>			<span class="hljs-keyword">var</span> r <span class="hljs-keyword">rune</span><br>			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(u) == <span class="hljs-number">1</span> &#123;<br>				r = <span class="hljs-keyword">rune</span>(u[<span class="hljs-number">0</span>])<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				r, _ = utf8.DecodeRuneInString(u)<br>			&#125;<br>			x.SetInt64(<span class="hljs-keyword">int64</span>(r))<br>		&#125;<br>		<span class="hljs-keyword">return</span> Val&#123;U: x&#125;<br><br>    <span class="hljs-comment">// 字符串的处理    </span><br>	<span class="hljs-keyword">case</span> syntax.StringLit:<br>		<span class="hljs-keyword">var</span> x <span class="hljs-keyword">string</span><br>		<span class="hljs-keyword">if</span> !lit.Bad &#123;<br>			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">'`'</span> &#123;<br>				<span class="hljs-comment">// strip carriage returns from raw string</span><br>				s = strings.Replace(s, <span class="hljs-string">"\r"</span>, <span class="hljs-string">""</span>, <span class="hljs-number">-1</span>)<br>			&#125;<br>			x, _ = strconv.Unquote(s)<br>		&#125;<br>		<span class="hljs-keyword">return</span> Val&#123;U: x&#125;<br><br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"unhandled BasicLit kind"</span>)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两遍的引号等无关干扰，还原其本来的面目。</p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <code>walkexpr</code> 方法中调用 <code>addstr</code> 函数生成用于拼接字符串的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkexpr</span><span class="hljs-params">(n *Node, init *Nodes)</span> *<span class="hljs-title">Node</span></span> &#123;<br>	<span class="hljs-keyword">switch</span> n.Op &#123;<br>	...<br>	<span class="hljs-keyword">case</span> OADDSTR:<br>		n = addstr(n, init)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>addstr</code> 能够在编译期间选择合适的函数对字符串进行拼接，该函数会根据带拼接的字符串数量选择不同的逻辑：</p>
<ul>
<li>如果小于或者等于 5 个，那么会调用 <code>concatstring{2,3,4,5}</code> 等一系列函数；</li>
<li>如果超过 5 个，那么会选择 <code>runtime.concatstrings</code> 传入一个数组切片；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addstr</span><span class="hljs-params">(n *Node, init *Nodes)</span> *<span class="hljs-title">Node</span></span> &#123;<br>	<span class="hljs-comment">// order.expr rewrote OADDSTR to have a list of strings.</span><br>	c := n.List.Len()<br><br>	<span class="hljs-keyword">if</span> c &lt; <span class="hljs-number">2</span> &#123;<br>		Fatalf(<span class="hljs-string">"addstr count %d too small"</span>, c)<br>	&#125;<br><br>	buf := nodnil()<br>	<span class="hljs-keyword">if</span> n.Esc == EscNone &#123;<br>		sz := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">for</span> _, n1 := <span class="hljs-keyword">range</span> n.List.Slice() &#123;<br>			<span class="hljs-keyword">if</span> n1.Op == OLITERAL &#123;<br>				sz += <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">len</span>(strlit(n1)))<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Don't allocate the buffer if the result won't fit.</span><br>		<span class="hljs-keyword">if</span> sz &lt; tmpstringbufsize &#123;<br>			<span class="hljs-comment">// Create temporary buffer for result string on stack.</span><br>			t := types.NewArray(types.Types[TUINT8], tmpstringbufsize)<br>			buf = nod(OADDR, temp(t), <span class="hljs-literal">nil</span>)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// build list of string arguments</span><br>	args := []*Node&#123;buf&#125;<br>	<span class="hljs-keyword">for</span> _, n2 := <span class="hljs-keyword">range</span> n.List.Slice() &#123;<br>		args = <span class="hljs-built_in">append</span>(args, conv(n2, types.Types[TSTRING]))<br>	&#125;<br><br>	<span class="hljs-keyword">var</span> fn <span class="hljs-keyword">string</span><br>	<span class="hljs-keyword">if</span> c &lt;= <span class="hljs-number">5</span> &#123;<br>		<span class="hljs-comment">// 少量的字符串使用直接的运行时帮助程序。</span><br>		<span class="hljs-comment">// note: order.expr knows this cutoff too.</span><br>		fn = fmt.Sprintf(<span class="hljs-string">"concatstring%d"</span>, c)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 大量字符串作为切片传递给运行时。</span><br>		fn = <span class="hljs-string">"concatstrings"</span><br><br>		t := types.NewSlice(types.Types[TSTRING])<br>		slice := nod(OCOMPLIT, <span class="hljs-literal">nil</span>, typenod(t))<br>		<span class="hljs-keyword">if</span> prealloc[n] != <span class="hljs-literal">nil</span> &#123;<br>			prealloc[slice] = prealloc[n]<br>		&#125;<br>		slice.List.Set(args[<span class="hljs-number">1</span>:]) <span class="hljs-comment">// skip buf arg</span><br>		args = []*Node&#123;buf, slice&#125;<br>		slice.Esc = EscNone<br>	&#125;<br><br>	cat := syslook(fn)<br>	r := nod(OCALL, cat, <span class="hljs-literal">nil</span>)<br>	r.List.Set(args)<br>	r = typecheck(r, ctxExpr)<br>	r = walkexpr(r, init)<br>	r.Type = n.Type<br><br>	<span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其实无论使用 <code>concatstring{2,3,4,5}</code> 中的哪一个，最终都会调用 <code>runtime.concatstrings</code>，它会先对遍历传入的切片参数，再过滤空字符串并计算拼接后字符串的长度。</p>
<p><code>concatstrings</code> 实现了 Go 字符串串联 <code>x + y + z + ...</code>。操作数在切片 a 中传递。 <strong>如果 <code>buf ！= nil</code>，则编译器已确定结果不会逃逸出调用函数，因此，如果字符串数据足够小，则可以将其存储在 buf 中</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstrings</span><span class="hljs-params">(buf *tmpBuf, a []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>	idx := <span class="hljs-number">0</span><br>	l := <span class="hljs-number">0</span><br>	count := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> a &#123;<br>		n := <span class="hljs-built_in">len</span>(x)<br>		<span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> l+n &lt; l &#123;<br>			throw(<span class="hljs-string">"string concatenation too long"</span>)<br>		&#125;<br>		l += n<br>		count++<br>		idx = i<br>	&#125;<br>	<span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">""</span><br>	&#125;<br><br>	<span class="hljs-comment">// 如果非空字符串的数量为 1 并且当前的字符串不在栈上，</span><br>    <span class="hljs-comment">// 就可以直接返回该字符串，不需要做出额外操作。</span><br>	<span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> &amp;&amp; (buf != <span class="hljs-literal">nil</span> || !stringDataOnStack(a[idx])) &#123;<br>		<span class="hljs-keyword">return</span> a[idx]<br>	&#125;<br>	s, b := rawstringtmp(buf, l)<br>	<span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> a &#123;<br>		<span class="hljs-built_in">copy</span>(b, x)<br>		b = b[<span class="hljs-built_in">len</span>(x):]<br>	&#125;<br>	<span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在正常情况下，<strong>运行时会调用 <code>copy</code>  将输入的多个字符串拷贝到目标字符串所在的内存空间</strong>。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的开销并没有想象的那么小，经常会看到 <code>runtime.slicebytetostring</code> 等函数出现在火焰图中，成为程序的性能热点。</p>
<p>从字节数组到字符串的转换需要使用 <code>runtime.slicebytetostring</code>函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是长度为 0 或者 1 的字节数组：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Buf 是结果的固定大小的缓冲区，如果结果不逃逸，则为 nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicebytetostring</span><span class="hljs-params">(buf *tmpBuf, b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span> &#123;<br>	l := <span class="hljs-built_in">len</span>(b)<br>	<span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Turns out to be a relatively common case.</span><br>		<span class="hljs-comment">// Consider that you want to parse out data between parens in "foo()bar",</span><br>		<span class="hljs-comment">// you find the indices and convert the subslice to string.</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-string">""</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> raceenabled &#123;<br>		racereadrangepc(unsafe.Pointer(&amp;b[<span class="hljs-number">0</span>]),<br>			<span class="hljs-keyword">uintptr</span>(l),<br>			getcallerpc(),<br>			funcPC(slicebytetostring))<br>	&#125;<br>	<span class="hljs-keyword">if</span> msanenabled &#123;<br>		msanread(unsafe.Pointer(&amp;b[<span class="hljs-number">0</span>]), <span class="hljs-keyword">uintptr</span>(l))<br>	&#125;<br>    <span class="hljs-comment">// runtime.stringStructOf 会将传入的字符串指针转换成 runtime.stringStruct 结构体指针</span><br>    <span class="hljs-comment">// 设置结构体持有的字符串指针 str 和长度 len</span><br>	<span class="hljs-keyword">if</span> l == <span class="hljs-number">1</span> &#123;<br>		stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="hljs-number">0</span>]])<br>		stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = <span class="hljs-number">1</span><br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>    <span class="hljs-comment">// 分配新的内存空间</span><br>	<span class="hljs-keyword">var</span> p unsafe.Pointer<br>	<span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(b) &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>		p = unsafe.Pointer(buf)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		p = mallocgc(<span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>(b)), <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<br>	&#125;<br>	stringStructOf(&amp;str).str = p<br>	stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = <span class="hljs-built_in">len</span>(b)<br>    <span class="hljs-comment">// 通过 runtime.memmove 将原 []byte 中的字节全部复制到新的内存空间中</span><br>	memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>(b)))<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>处理过后会根据传入的缓冲区大小决定是否需要为新字符串分配一片内存空间，<code>runtime.stringStructOf</code> 会将传入的字符串指针转换成 <code>runtime.stringStruct</code> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后<strong>通过 <code>runtime.memmove</code> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中</strong>。</p>
<p>当想要将字符串转换成 <code>[]byte</code> 类型时，需要使用 <code>runtime.stringtoslicebyte</code> 函数，该函数的实现非常容易理解：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringtoslicebyte</span><span class="hljs-params">(buf *tmpBuf, s <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>	<span class="hljs-keyword">var</span> b []<span class="hljs-keyword">byte</span><br>	<span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>		*buf = tmpBuf&#123;&#125;<br>		b = buf[:<span class="hljs-built_in">len</span>(s)]<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		b = rawbyteslice(<span class="hljs-built_in">len</span>(s))<br>	&#125;<br>	<span class="hljs-built_in">copy</span>(b, s)<br>	<span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上述函数会根据是否传入缓冲区做出不同的处理：</p>
<ul>
<li>当传入缓冲区时，它会使用传入的缓冲区存储 <code>[]byte</code>；</li>
<li>当没有传入缓冲区时，运行时会调用 <code>runtime.rawbyteslice</code> 创建新的字节切片并将字符串中的内容拷贝过去</li>
</ul>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。<strong>不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</strong></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Go 中的 map 使用的是链地址法解决哈希冲突，但是它的实现并不是对冲突的元素采用链表存储，而是采用了数组的形式。</p>
<h2 id="哈希表相关概念"><a href="#哈希表相关概念" class="headerlink" title="哈希表相关概念"></a>哈希表相关概念</h2><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数（常被称为散列函数）是可以用于将任意大小的数据映射到固定大小值的函数，常见的包括MD5、SHA系列等。实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求<strong>哈希函数的输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p>一个设计优秀的哈希函数应该包含以下特性：</p>
<ul>
<li><strong>均匀性</strong>：一个好的哈希函数应该在其输出范围内尽可能均匀地映射，也就是说，应以大致相同的概率生成输出范围内的每个哈希值。</li>
<li><strong>效率高</strong>：哈希效率要高，即使很长的输入参数也能快速计算出哈希值。</li>
<li><strong>可确定性</strong>：哈希过程必须是确定性的，这意味着对于给定的输入值，它必须始终生成相同的哈希值。</li>
<li><strong>雪崩效应</strong>：微小的输入值变化也会让输出值发生巨大的变化。</li>
<li><strong>不可逆</strong>：从哈希函数的输出值不可反向推导出原始的数据。</li>
</ul>
<h3 id="哈希桶与装载因子"><a href="#哈希桶与装载因子" class="headerlink" title="哈希桶与装载因子"></a>哈希桶与装载因子</h3><ol>
<li><p>哈希桶。哈希桶（也称为槽，类似于抽屉原理中的一个抽屉）可以理解为一个哈希值，所有的哈希值组成哈希空间。</p>
</li>
<li><p>装载因子。装载因子是表示哈希表中元素的填满程度。它的计算公式：<br>$$<br>装载因子=填入哈希表中的元素个数/哈希表的长度。<br>$$<br>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，<strong>但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong>。</p>
<p>装载因子也是决定哈希表是否进行扩容的关键指标，在 java 的 <code>HashMap</code> 的中，其默认装载因子为 0.75；Python的 <code>dict</code> 默认装载因子为2/3。</p>
</li>
</ol>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希函数是将任意大小的数据映射到固定大小值的函数。那么，可以预见到，即使哈希函数设计得足够优秀，几乎每个输入值都能映射为不同的哈希值。但是，当输入数据足够大，大到能超过固定大小值的组合能表达的最大数量数，冲突将不可避免！</p>
<blockquote>
<p>这里提到的哈希碰撞不是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。</p>
</blockquote>
<blockquote>
<p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，至少会有一个抽屉里面放不少于两个苹果。抽屉原理有时也被称为鸽巢原理。</p>
</blockquote>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86.webp" alt="抽屉原理"></p>
<h4 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h4><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p>开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong></p>
<p>对于开放寻址法而言，所有的元素都是存储在 Hash 表当中的，所以无论任何时候都要保证哈希表的槽位数 m 大于或等于键的数据 n（必要时，需要对哈希表进行动态扩容）。</p>
<p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。举个线性探测法的例子：</p>
<p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值， 表示哈希表的槽位数（哈希表的大小）。</p>
<p>线性探测法则可以表示为：</p>
<ul>
<li><p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p>
</li>
<li><p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p>
</li>
<li><p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p>
</li>
</ul>
<p>……</p>
<p>开放寻址法中对性能影响最大的是<strong>装载因子</strong>。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 <code>O(n)</code> 的，这时需要遍历数组中的全部元素，所以在实现哈希表时需要多关注装载因子的变化。</p>
<h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>链地址法的思想是将映射在一个桶里的所有元素用链表串起来。</p>
<p>对于开放寻址法而言，它只有数组一种数据结构就可完成存储，继承了数组的优点，对 CPU 缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。<strong>当数据量明确、装载因子小，适合采用开放寻址法</strong>。</p>
<p>链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。<strong>但是链地址法需要额外的空间来存储指针</strong>。</p>
<blockquote>
<p> 在 Python 中 <code>dict</code> 在发生哈希冲突时采用的开放寻址法，而 java 的 <code>HashMap</code> 采用的是链地址法，而 Go 中使用的也是链地址法，但不完全遵循了链地址法的思想，其主要使用的空间还是数组，其次才用了链表。</p>
</blockquote>
<h2 id="Map-中的数据结构"><a href="#Map-中的数据结构" class="headerlink" title="Map 中的数据结构"></a>Map 中的数据结构</h2><p>Go 中的结构体为 hamp，该结构体的字段如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 代表当前哈希表中的元素个数，len(map) 返回的就是该字段值</span><br>	count     <span class="hljs-keyword">int</span> <br>    <span class="hljs-comment">// 状态标识，比如正在被写、buckets 和 oldbuckets 在被遍历、等量扩容(Map扩容相关字段)</span><br>	flags     <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// buckets（桶）的数量的对数，也就是说该哈希表中桶的数量为 2^B 个</span><br>	B         <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 溢出桶的大致数量</span><br>	noverflow <span class="hljs-keyword">uint16</span><br>    <span class="hljs-comment">// 哈希种子，这个值在哈希创建时随机生成，并在计算 key 的哈希的时候会传入哈希函数，以此提高哈希函数的随机性</span><br>	hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// hash seed</span><br><br>    <span class="hljs-comment">// 指向 buckets 数组的指针，数组大小为 2^B，如果元素个数为 0，它为 nil。</span><br>	buckets    unsafe.Pointer<br>    <span class="hljs-comment">// 如果发生扩容，oldbuckets 是指向老的 buckets 数组的指针，老的 buckets 数组大小是新的buckets 的 1/2。非扩容状态下，它为 nil。</span><br>	oldbuckets unsafe.Pointer<br>    <span class="hljs-comment">// 表示扩容进度，小于此地址的 buckets 代表已搬迁完成。</span><br>	nevacuate  <span class="hljs-keyword">uintptr</span><br><br>    <span class="hljs-comment">// 这个字段是为了优化 GC 扫描而设计的。当 key 和 value 均不包含指针，并且都可以 &lt;=128 字节时使用。extra 是指向 mapextra 类型的指针。</span><br>	extra *mapextra<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h3><p><code>buckets</code> 是一个指针，它指向的是一个类型为 <code>bmap</code> 的结构体数组，也就是具体存储 map 键值对的哈希空间。<code>bmap</code> 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// tophash 包含此桶中每个键的哈希值最高字节（高8位）信息。</span><br>    <span class="hljs-comment">// 如果tophash[0] &lt; minTopHash，tophash[0]则代表桶的搬迁（evacuation）状态。</span><br>	tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里的 <code>tophash</code> 指的是哈希值的高八位，在 Go 中，Hash 值的分布如下，高八位即 <code>high-order bits</code> 部分：</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%E5%93%88%E5%B8%8C%E5%80%BC%E9%AB%98%E4%BD%8E%E4%BD%8D.webp" alt="go中哈希值的高地位"></p>
<p>在运行期间，<code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，<strong>因为哈希表中可能存储不同类型的键值对（例如声明了接口类型），而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导</strong>。<code>bmap</code> 中的其他字段在运行时也都是通过计算内存地址的方式访问的，所以它的定义中就不包含这些字段。所以在编译期间通过 <code>cmd/compile/internal/gc.bmap</code> 函数重建了它的结构，动态地创建一个新的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">//hash值的高八位</span><br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// key 的数组</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    <span class="hljs-comment">// value 的数组</span><br>    values   [<span class="hljs-number">8</span>]valuetype<br>    <span class="hljs-comment">// 对齐内存使用的，不是每个 bmap 都有会这个字段，需要满足一定条件</span><br>    pad      <span class="hljs-keyword">uintptr</span><br>    <span class="hljs-comment">// 溢出桶，也是指向一个 bmap，上面的字段 topbits、keys、elems 长度为 8，最多存8组键值对，存满了就往指向的这个 bmap 里存</span><br>    overflow <span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>一个 <code>bmap</code> 的内存模型如下所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/bmap%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.webp" alt="bmap内存模型"></p>
<p>在上图解示例中，该桶的第 7 位 <code>cell</code> 和第 8 位 <code>cell</code> 还未有对应键值对。需要注意的是，<code>key</code> 和 <code>value</code> 是各自存储起来的，并非想象中的 <code>key/value/key/value…</code> 的形式。这样做虽然会让代码组织稍显复杂，但是它的好处是能让消除填充所需要的字段（padding）。例如 <code>map[int64]int</code> ，如果按照 <code>key/value/key/value/...</code> 这样的模式存储，那在每一个 <code>key/value</code> 对之后都要额外 <code>padding 7</code> 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 <code>padding</code>。</p>
<p>此外，在 8 个键值对数据后面有一个 <code>overflow</code> 指针，因为桶中最多只能装 8 个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过 overflow 指针链接起来。</p>
<h3 id="mapextra"><a href="#mapextra" class="headerlink" title="mapextra"></a>mapextra</h3><p>当 map 的 <code>key</code> 和 <code>value</code> 都不是指针，并且 <code>size</code> 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，bmap 其实有一个 <code>overflow</code> 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 <code>overflow</code> 移动到 <code>extra</code> 字段来，在这个字段里将指针指向溢出桶。</p>
<p><strong>所以实际上 <code>bmap.overflow</code> 和 <code>hmap.extra.overflow</code> 所指向的地址是一样的，都是溢出桶的内存地址，只是在某些特殊情况下用 <code>hmap.extra.overflow</code> 代替 <code>bmap.overflow</code> ，从而优化了 GC 过程。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>   <br>   <span class="hljs-comment">// 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)</span><br>   <span class="hljs-comment">// 就使用 hmap 的 extr a字段来存储 overflow buckets，这样可以避免 GC 扫描整个 map</span><br>   <span class="hljs-comment">// 然而 bmap.overflow 也是个指针。随意其实 bmap.overflow 的指针也是指向了</span><br>   <span class="hljs-comment">// hmap.extra.overflow 和 hmap.extra.oldoverflow 中</span><br>   <span class="hljs-comment">// overflow 包含的是 hmap.buckets 的 overflow 的 buckets</span><br>   <span class="hljs-comment">// oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket</span><br>   overflow    *[]*bmap<br>   oldoverflow *[]*bmap<br><br>   <span class="hljs-comment">// 指向空闲的 overflow bucket 的指针</span><br>   nextOverflow *bmap<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="map-中的常量"><a href="#map-中的常量" class="headerlink" title="map 中的常量"></a>map 中的常量</h3><p>map 中还定义了一些重要的常量：</p>
<blockquote>
<p>注意：键和值超过 128 个字节后，会被转换成指针</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">// 一个桶中最多容纳的键值对的对数，也就是一个桶最多容纳 2^3=8 个</span><br>	bucketCntBits = <span class="hljs-number">3</span><br>	bucketCnt     = <span class="hljs-number">1</span> &lt;&lt; bucketCntBits<br><br>    <span class="hljs-comment">// 触发扩容的装载因子为 13/2=6.5</span><br>	loadFactorNum = <span class="hljs-number">13</span><br>	loadFactorDen = <span class="hljs-number">2</span><br><br>	<span class="hljs-comment">// 键和值超过 128 个字节后，会被转换成指针</span><br>	maxKeySize  = <span class="hljs-number">128</span><br>	maxElemSize = <span class="hljs-number">128</span><br><br>	<span class="hljs-comment">// 数据偏移量，大小为 bmap 结构体的大小，它需要正确的对齐，</span><br>	dataOffset = unsafe.Offsetof(<span class="hljs-keyword">struct</span> &#123;<br>		b bmap<br>		v <span class="hljs-keyword">int64</span><br>	&#125;&#123;&#125;.v)<br><br>	<span class="hljs-comment">// 每个桶（如果有溢出，则包含它的 overflow 的链桶）在搬迁完成状态（evacuated* states）下，</span><br>    <span class="hljs-comment">// 要么会包含它所有的键值对，要么一个都不包含（但不包括调用 evacuate() 方法阶段，</span><br>    <span class="hljs-comment">// 该方法调用只会在对 map 发起 write 时发生，在该阶段其他 goroutine 是无法查看该map的（map 非并发安全））。</span><br>    <span class="hljs-comment">// 简单的说，在非写过程的状态中，桶里的数据要么一起搬走，要么一个都还未搬。</span><br>    <span class="hljs-comment">// tophash 除了放置正常的高 8 位 hash 值，还会存储一些特殊状态值（标志该 cell 的搬迁状态）。</span><br>    <br>    <span class="hljs-comment">// 正常的tophash值，最小应该是5，以下列出的就是一些特殊状态值：</span><br>    <span class="hljs-comment">// 表示 cell 为空，并且比它高索引位的 cell 或者 overflows 中的 cell 都是空的。（初始化 bucket 时，就是该状态）</span><br>    emptyRest      = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 空的cell，cell已经被搬迁到新的bucket</span><br>	emptyOne       = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 键值对已经搬迁完毕，key 在新 buckets 数组的前半部分</span><br>	evacuatedX     = <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 键值对已经搬迁完毕，key 在新 buckets 数组的后半部分</span><br>	evacuatedY     = <span class="hljs-number">3</span><br>    <span class="hljs-comment">// cell 为空，整个 bucket 已经搬迁完毕</span><br>	evacuatedEmpty = <span class="hljs-number">4</span><br>    <span class="hljs-comment">// tophash的最小正常值</span><br>	minTopHash     = <span class="hljs-number">5</span><br><br>	<span class="hljs-comment">// flags</span><br>    <span class="hljs-comment">// 可能有迭代器在使用 buckets</span><br>	iterator     = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 可能有迭代器在使用 oldbuckets</span><br>	oldIterator  = <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 有协程正在向 map 写入 key</span><br>	hashWriting  = <span class="hljs-number">4</span><br>    <span class="hljs-comment">// 等量扩容</span><br>	sameSizeGrow = <span class="hljs-number">8</span><br><br>	<span class="hljs-comment">// 用于迭代器检查的 bucket ID</span><br>	noCheck = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">8</span>*sys.PtrSize) - <span class="hljs-number">1</span><br>)<br></code></pre></div></td></tr></table></figure>

<p>整体来说，map 的数据结构如下所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/Go%20map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.webp" alt="Go map 数据结构"></p>
<p>在上面的数据结构中，实际上 <code>buckets</code> 指向的 <code>[]bmap</code> 和 <code>bmap.overflow</code> 指向的 <code>[]bmap</code> 的内存在地址空间上是连续的，这个可以在下面 map 初始化的时候看出来。</p>
<h2 id="Map-初始化"><a href="#Map-初始化" class="headerlink" title="Map 初始化"></a>Map 初始化</h2><p>map  初始化的方式有以下两种：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[k]v)<br><span class="hljs-comment">// 指定初始化大小为 hint 的 map</span><br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[k]v,hint)<br></code></pre></div></td></tr></table></figure>

<p>对于不指定初始化大小，和初始化值 <code>hint&lt;=8(bucketCnt)</code> 时，go会调用 <code>makemap_small</code> 函数（源码位置 <code>src/runtime/map.go</code>），并直接从堆上进行分配。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap_small</span><span class="hljs-params">()</span> *<span class="hljs-title">hmap</span></span> &#123;<br>    h := <span class="hljs-built_in">new</span>(hmap)<br>    h.hash0 = fastrand()<br>    <span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当 <code>hint&gt;8</code> 时，则调用 <code>makemap</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 如果编译器认为可以在栈上创建 map 和第一个 bucket，那么 h 和 bucket 可能都是非空</span><br><span class="hljs-comment">// 如果 h != nil，那么 map 可以直接在 h 中创建</span><br><span class="hljs-comment">// 如果 h.buckets != nil，那么 h 指向的 bucket 可以作为 map 的第一个 bucket 使用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-keyword">int</span>, h *hmap)</span> *<span class="hljs-title">hmap</span></span> &#123;<br>    <span class="hljs-comment">// math.MulUintptr 返回 hint 与 t.bucket.size 的乘积，并判断该乘积是否溢出。</span><br>	mem, overflow := math.MulUintptr(<span class="hljs-keyword">uintptr</span>(hint), t.bucket.size)<br>	<span class="hljs-comment">// maxAlloc 的值，根据平台系统的差异而不同，具体计算方式参照 src/runtime/malloc.go</span><br>    <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;<br>		hint = <span class="hljs-number">0</span><br>	&#125;<br><br>	<span class="hljs-comment">// initialize Hmap</span><br>	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>		h = <span class="hljs-built_in">new</span>(hmap)<br>	&#125;<br>    <span class="hljs-comment">// 通过 fastrand 得到一个随机的哈希种子</span><br>	h.hash0 = fastrand()<br><br>	<span class="hljs-comment">// 根据输入的元素个数 hint，找到能装下这些元素所需要的 B 值</span><br>	B := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 2^B &lt; hint/装载因子，找到满足条件的 B</span><br>	<span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;<br>		B++<br>	&#125;<br>	h.B = B<br><br>	<span class="hljs-comment">// 分配初始哈希表</span><br>    <span class="hljs-comment">// 如果 B 为0，那么 buckets 字段后续会在 mapassign 方法中 lazily 分配</span><br>    <span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">var</span> nextOverflow *bmap<br>        <span class="hljs-comment">// makeBucketArray 创建一个 map 的底层保存 buckets 的数组，它最少会分配 h.B^2 的大小。</span><br>		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)<br>		<span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>			h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>			h.extra.nextOverflow = nextOverflow<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>分配 <code>buckets</code> 数组的 <code>makeBucketArray</code> 函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// makeBucket 为 map 创建用于保存 buckets 的数组。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBucketArray</span><span class="hljs-params">(t *maptype, b <span class="hljs-keyword">uint8</span>, dirtyalloc unsafe.Pointer)</span> <span class="hljs-params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;<br>	base := bucketShift(b)<br>	nbuckets := base<br>    <span class="hljs-comment">// 对于小的 b 值（小于4），即桶的数量小于 16 时，使用溢出桶的可能性很小。对于此情况，就避免计算开销。</span><br>	<span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">4</span> &#123;<br>		<span class="hljs-comment">// 当桶的数量大于等于 16 个时，正常情况下就会额外创建 2^(b-4) 个溢出桶</span><br>		nbuckets += bucketShift(b - <span class="hljs-number">4</span>)<br>		sz := t.bucket.size * nbuckets<br>		up := roundupsize(sz)<br>		<span class="hljs-keyword">if</span> up != sz &#123;<br>			nbuckets = up / t.bucket.size<br>		&#125;<br>	&#125;<br><br>    <span class="hljs-comment">// 这里，dirtyalloc 分两种情况。</span><br>    <span class="hljs-comment">// 如果它为 nil，则会分配一个新的底层数组。</span><br>    <span class="hljs-comment">// 如果它不为 nil，则它指向的是曾经分配过的底层数组，该底层数组是由之前同样的 t 和 b 参数通过 makeBucketArray 分配的</span><br>    <span class="hljs-comment">// 如果数组不为空，需要把该数组之前的数据清空并复用。</span><br>	<span class="hljs-keyword">if</span> dirtyalloc == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 由这里可以看出，正常桶和溢出桶在内存中的存储空间是连续的，因为分配的大小是正常桶+溢出桶</span><br>		buckets = newarray(t.bucket, <span class="hljs-keyword">int</span>(nbuckets))<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		buckets = dirtyalloc<br>		size := t.bucket.size * nbuckets<br>		<span class="hljs-keyword">if</span> t.bucket.ptrdata != <span class="hljs-number">0</span> &#123;<br>			memclrHasPointers(buckets, size)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			memclrNoHeapPointers(buckets, size)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 在满足分配溢出桶的条件下，为了把跟踪这些溢出桶的开销降至最低，使用了以下约定：</span><br>    <span class="hljs-comment">// 如果预分配的溢出桶的 overflow 指针为 nil，那么可以通过指针碰撞（bumping the pointer）获得更多可用桶。</span><br>    <span class="hljs-comment">// 关于指针碰撞：假设内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”）</span><br>	<span class="hljs-keyword">if</span> base != nbuckets &#123;<br>        <span class="hljs-comment">// buckets(基地址) + base(2^B)*bucketsize, 即获得第一个 overflow</span><br>		nextOverflow = (*bmap)(add(buckets, base*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>        <span class="hljs-comment">// 对于最后一个溢出桶，需要一个安全的非 nil 指针指向它，这是为了保证这部分尚未使用的内存 GC 期间安全</span><br>        <span class="hljs-comment">// 最后一个 overflow</span><br>		last := (*bmap)(add(buckets, (nbuckets<span class="hljs-number">-1</span>)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>        <span class="hljs-comment">// 最后一个 overflow 指针指向 buckets(基地址, 也是安全的指针)</span><br>		last.setoverflow(t, (*bmap)(buckets))<br>	&#125;<br>	<span class="hljs-keyword">return</span> buckets, nextOverflow<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>通过上面的创建过程，初始化出来的 map 大致是如下的结构：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg" alt="初始化的map"></p>
<p>此外，还能看出，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <code>hmap</code> 中的不同字段引用而已</p>
<h2 id="Map-的哈希函数"><a href="#Map-的哈希函数" class="headerlink" title="Map 的哈希函数"></a>Map 的哈希函数</h2><p>在初始化 go 程序运行环境时（<code>src/runtime/proc.go</code>中的 <code>schedinit</code>），就需要通过 <code>alginit</code> 方法完成对哈希的初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;<br>    lockInit(&amp;sched.lock, lockRankSched)<br><br>    ...<br><br>    tracebackinit()<br>   	moduledataverify()<br>    stackinit()<br>    mallocinit()<br>    fastrandinit() <span class="hljs-comment">// must run before mcommoninit</span><br>    mcommoninit(_g_.m, <span class="hljs-number">-1</span>)<br>    cpuinit()       <span class="hljs-comment">// must run before alginit</span><br>    <span class="hljs-comment">// 这里调用alginit()</span><br>    alginit()       <span class="hljs-comment">// maps must not be used before this call</span><br>    modulesinit()   <span class="hljs-comment">// provides activeModules</span><br>    typelinksinit() <span class="hljs-comment">// uses maps, activeModules</span><br>    itabsinit()     <span class="hljs-comment">// uses activeModules</span><br><br>    ...<br><br>    goargs()<br>    goenvs()<br>    parsedebugvars()<br>    gcinit()<br><br>  	...<br> &#125;<br></code></pre></div></td></tr></table></figure>

<p>对于哈希算法的选择，程序会根据当前架构判断是否支持 <code>AES</code>，如果支持就使用 <code>AES hash</code>，其实现的代码位于 <code>src/runtime/asm_{386,amd64,arm64}.s</code> 中；若不支持，其 hash 算法则根据 <code>xxhash</code> 算法和 <code>cityhash</code> 算启发而来，代码分别对应于 32 位（<code>src/runtime/hash32.go</code>）和 64 位机器（<code>src/runtime/hash32.go</code>）中：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">alginit</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// Install AES hash algorithms if the instructions needed are present.</span><br>	<span class="hljs-keyword">if</span> (GOARCH == <span class="hljs-string">"386"</span> || GOARCH == <span class="hljs-string">"amd64"</span>) &amp;&amp;<br>		cpu.X86.HasAES &amp;&amp; <span class="hljs-comment">// AESENC</span><br>		cpu.X86.HasSSSE3 &amp;&amp; <span class="hljs-comment">// PSHUFB</span><br>		cpu.X86.HasSSE41 &#123; <span class="hljs-comment">// PINSR&#123;D,Q&#125;</span><br>		initAlgAES()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">"arm64"</span> &amp;&amp; cpu.ARM64.HasAES &#123;<br>		initAlgAES()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	getRandomData((*[<span class="hljs-built_in">len</span>(hashkey) * sys.PtrSize]<span class="hljs-keyword">byte</span>)(unsafe.Pointer(&amp;hashkey))[:])<br>	hashkey[<span class="hljs-number">0</span>] |= <span class="hljs-number">1</span> <span class="hljs-comment">// make sure these numbers are odd</span><br>	hashkey[<span class="hljs-number">1</span>] |= <span class="hljs-number">1</span><br>	hashkey[<span class="hljs-number">2</span>] |= <span class="hljs-number">1</span><br>	hashkey[<span class="hljs-number">3</span>] |= <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面在创建 map 的时候，map 的哈希种子是通过 <code>h.hash0 = fastrand()</code> 得到的。它是在以下 <code>maptype</code> 中的 <code>hasher</code> 中被使用到，在下文内容中会看到hash值的生成。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> maptype <span class="hljs-keyword">struct</span> &#123;<br>	typ    _type<br>	key    *_type<br>	elem   *_type<br>	bucket *_type <span class="hljs-comment">// internal type representing a hash bucket</span><br>    <span class="hljs-comment">// hasher 的第一个参数就是指向 key 的指针，</span><br>    <span class="hljs-comment">// h.hash0 = fastrand() 得到的 hash0，就是 hasher 方法的第二个参数。</span><br>	<span class="hljs-comment">// hasher方法返回的就是hash值。</span><br>	hasher     <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span><br>	keysize    <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// size of key slot</span><br>	elemsize   <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// size of elem slot</span><br>	bucketsize <span class="hljs-keyword">uint16</span> <span class="hljs-comment">// size of bucket</span><br>	flags      <span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="Map-的基本操作"><a href="#Map-的基本操作" class="headerlink" title="Map 的基本操作"></a>Map 的基本操作</h2><h3 id="Key-的定位"><a href="#Key-的定位" class="headerlink" title="Key 的定位"></a>Key 的定位</h3><p>假定 key 经过哈希计算后得到 64bit 位的哈希值。如果 B=5，buckets 数组的长度，即桶的数量是 32（2 的 5 次方）。</p>
<p>现要置一 key 于 map 中，该 key 经过哈希后，得到的哈希值如下：</p>
<p>![图片](假定key经过哈希计算后得到64bit位的哈希值。如果B=5，buckets数组的长度，即桶的数量是32（2的5次方）。</p>
<p>例如，现要置一key于map中，该key经过哈希后，得到的哈希值如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%81%87%E5%AE%9A%E7%9A%8464%E4%BD%8D%E5%93%88%E5%B8%8C%E5%80%BC.png" alt="假定的64位哈希值"></p>
<p>哈希值低位（<code>low-order bits</code>）用于选择桶，哈希值高位（<code>high-order bits</code>）用于在一个独立的桶中区别出键。当 B 等于 5 时，那么选择的哈希值低位也是 5 位，即 01010，它的十进制值为10，代表 10 号桶。再用哈希值的高 8 位，找到此 key 在桶中的位置。最开始桶中还没有 key，那么新加入的 key 和 value 就会被放入第一个 key 空位和 value 空位。</p>
<p>注意：对于高八位的选择，该操作的实质是取余，但是取余开销很大，在实际代码实现中采用的是位操作，其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tophash</span><span class="hljs-params">(hash <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uint8</span></span> &#123;<br>	top := <span class="hljs-keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="hljs-number">8</span> - <span class="hljs-number">8</span>))<br>	<span class="hljs-keyword">if</span> top &lt; minTopHash &#123;<br>		top += minTopHash<br>	&#125;<br>	<span class="hljs-keyword">return</span> top<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当两个不同的 key 落在了同一个桶中，这时就发生了哈希冲突。go 的解决方式是链地址法（这里只描述非扩容且该 key 是第一次添加的情况）：在桶中按照顺序寻到第一个空位并记录下来，后续在该桶和它的溢出桶中均未发现存在的该 key，将 key 置于第一个空位；否则，去该桶的溢出桶中寻找空位，如果没有溢出桶，则添加溢出桶，并将其置溢出桶的第一个空位。</p>
<p>例如，下图中的 B 值为 5，所以桶的数量为 32。通过哈希函数计算出待插入 key 的哈希值，低 5 位哈希00110，对应于 6 号桶；高 8 位10010111，十进制为 151，由于桶中前 6 个 cell 已经有正常哈希值填充了(遍历)，所以将 151 对应的高位哈希值放置于第 7 位cell（第8个 cell 为empty Rest，表明它还未使用），对应将 key 和 value 分别置于相应的第七个空位。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Map%20key%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91.webp" alt="Map key的查找和插入逻辑"></p>
<p>如果是查找 key，那么会根据高位哈希值去桶中的每个 cell 中找，若在桶中没找到，并且 overflow 不为nil，那么继续去溢出桶中寻找，直至找到，如果所有的 cell 都找过了，还未找到，则返回 key 类型的默认值（例如 key 是 int 类型，则返回 0）。</p>
<h3 id="查找key"><a href="#查找key" class="headerlink" title="查找key"></a>查找key</h3><p>通过 <code>key</code> 查找 <code>value</code> 的方式有以下两种：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v     := hash[key] <span class="hljs-comment">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)</span><br>v, ok := hash[key] <span class="hljs-comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span><br></code></pre></div></td></tr></table></figure>

<p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p>
<ul>
<li>当接受一个参数时，会使用 <code>mapaccess1</code>，该函数仅会返回一个指向目标值的指针；</li>
<li>当接受两个参数时，会使用 <code>mapaccess2</code>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 <code>bool</code> 值。</li>
</ul>
<p><code>mapaccess1</code> 查找 <code>key</code> 的代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>    <span class="hljs-comment">// 如果开启了竞态检测 -race</span><br>	<span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>		callerpc := getcallerpc()<br>		pc := funcPC(mapaccess1)<br>		racereadpc(unsafe.Pointer(h), callerpc, pc)<br>		raceReadObjectPC(t.key, key, callerpc, pc)<br>	&#125;<br>    <span class="hljs-comment">// 如果开启了 memory sanitizer -msan</span><br>	<span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>		msanread(key, t.key.size)<br>	&#125;<br>    <span class="hljs-comment">// 如果 map 为空或者元素个数为 0，返回零值</span><br>	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>			t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>		&#125;<br>		<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>	&#125;<br>    <span class="hljs-comment">// 注意，这里是按位与操作</span><br>    <span class="hljs-comment">// 当 h.flags 对应的值为 hashWriting（代表有其他 goroutine 正在往 map 中写 key）时，</span><br>    <span class="hljs-comment">// 那么位计算的结果不为 0，因此抛出以下错误。</span><br>	<span class="hljs-comment">// 这也表明，go 的 map 是非并发安全的</span><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map read and map write"</span>)<br>	&#125;<br>    <span class="hljs-comment">// 不同类型的 key，会使用不同的 hash 算法，这里获取 hash 值</span><br>	hash := t.hasher(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>    <span class="hljs-comment">// 返回 1 &lt;&lt; b-1，即 low-order bits，用于下面与操作筛选出对应的 bucket</span><br>	m := bucketMask(h.B)<br>    <span class="hljs-comment">// 按位与操作，找到对应的 bucket</span><br>	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 如果 oldbuckets 不为空，那么证明 map 发生了扩容</span><br>  	<span class="hljs-comment">// 如果有扩容发生，老的 buckets 中的数据可能还未搬迁至新的 buckets 里</span><br>  	<span class="hljs-comment">// 所以需要先在老的 buckets 中找</span><br>    <span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br>			<span class="hljs-comment">// 增量扩容情况下，老 buckets 数组的大小是原来的一半</span><br>			m &gt;&gt;= <span class="hljs-number">1</span><br>		&#125;<br>        <span class="hljs-comment">// 找到 oldbucket 地址</span><br>		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>        <span class="hljs-comment">// 如果在 oldbuckets 中 tophash[0] 的值，为 evacuatedX、evacuatedY，evacuatedEmpty 其中之一</span><br>		<span class="hljs-comment">// 则 evacuated() 返回为true，说明搬迁完成。</span><br>    	<span class="hljs-comment">// 因此，只有当搬迁未完成时，才会从此 oldbucket 中遍历</span><br>		<span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>			b = oldb<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">// 取出当前 key 值的 tophash 值，即高八位的值</span><br>	top := tophash(hash)<br>bucketloop:<br>    <span class="hljs-comment">// 以下是查找的核心逻辑</span><br>  	<span class="hljs-comment">// 双重循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的 cell 遍历</span><br>  	<span class="hljs-comment">// 跳出循环的条件有三种：</span><br>    <span class="hljs-comment">// 1. 第一种是已经找到 key 值；</span><br>    <span class="hljs-comment">// 2. 第二种是当前桶再无溢出桶；</span><br>  	<span class="hljs-comment">// 3. 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest，这个值它代表此时的桶后面的 cell 还未利用，所以无需再继续遍历。</span><br>    <span class="hljs-comment">// 初识时 b 为 key 所在的桶，此时是在正常桶中</span><br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>        <span class="hljs-comment">// 该桶存放最多 8 个键值对，依次对比 tophash 值是否相等</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>                <span class="hljs-comment">// 不相等且满足第三种条件，跳出循环</span><br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>                <span class="hljs-comment">// 不相等继续遍历</span><br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>            <span class="hljs-comment">// 因为在 bucket 中 key 是用连续的存储空间存储的，因此可以通过 bucket 地址 +</span><br>            <span class="hljs-comment">// 数据偏移量（bmap 结构体的大小，也就是 tophash 占用的大小，因为 dataOffset 定义的是声明的 bmap）+ </span><br>            <span class="hljs-comment">// keysize 的大小，得到 k 的地址</span><br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>            <span class="hljs-comment">// 如果 key 是指针（当键超过 maxKeySize（128个字节）时会转换为指针），则需要进行解引用</span><br>			<span class="hljs-keyword">if</span> t.() &#123;<br>				k = *((*unsafe.Pointer)(k))<br>			&#125;<br>            <span class="hljs-comment">// 判断 key 是否相等</span><br>			<span class="hljs-keyword">if</span> t.key.equal(key, k) &#123;<br>                <span class="hljs-comment">// 同理，value 的地址也是相似的计算方法，只是再要加上8个 keysize 的内存地址</span><br>				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.elemsize))<br>                <span class="hljs-comment">// 如果 value 是指针，解引用</span><br>				<span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>					e = *((*unsafe.Pointer)(e))<br>				&#125;<br>                <span class="hljs-comment">// 返回找到的值</span><br>				<span class="hljs-keyword">return</span> e<br>			&#125;<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">// 所有的bucket都未找到，则返回零值</span><br>	<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>根据上面的代码，可以看出它的查找流程如下：</p>
<ol>
<li>判断 map 是否为空，为空的话返回零值</li>
<li>通过按位与的操作检测 map 是否有其他线程在进行写入，有的话则抛出错误。这也表明 map <strong>不是并发安全的</strong></li>
<li>对 key 取 hash 获得哈希值，通过哈希值的低位确定在哪一个 bucket</li>
<li>判断是否发生了扩容，如果发生了扩容并且键值搬迁未完成，则需要先到 old bucket 中查找</li>
<li>开始内外层循环遍历，依次对比 tophash 是否相等，直到找到对应的 key 或者找不到退出循环，查找过程结束</li>
</ol>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.webp" alt="go map 查找流程"></p>
<p>对于 <code>mapaccess2</code> 函数，它的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-params">(unsafe.Pointer, <span class="hljs-keyword">bool</span>)</span></span><br></code></pre></div></td></tr></table></figure>

<p>与 <code>mapaccess1</code> 相比，<code>mapaccess2</code>只是多了一个bool类型的返回值，它代表的是是否在 map 中找到了对应的<code>key</code> ，这里贴一下间断的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-params">(unsafe.Pointer, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	...<br>bucketloop:<br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			<span class="hljs-keyword">if</span> alg.equal(key, k) &#123;<br>				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))<br>                <span class="hljs-comment">// 多了一个 boolean 返回值</span><br>				<span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br>			&#125;<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">// 找不到，返回 false</span><br>	<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>同时，源码中还有mapaccessK方法，它的函数签名如下。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccessK</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>与 <code>mapaccess1</code> 相比，<code>mapaccessK</code> 同时返回了 <code>key</code>和 <code>value</code>，其代码逻辑也一致。</p>
<h3 id="写入-key"><a href="#写入-key" class="headerlink" title="写入 key"></a>写入 key</h3><p>向 map 中插入或者修改 <code>key</code>，最终调用的是 <code>mapassign</code> 函数。</p>
<p>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</p>
<p><code>mapassign</code> 函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>	<span class="hljs-comment">// 如果 h 是空指针，赋值会引起panic</span><br>    <span class="hljs-comment">// 例如以下语句</span><br>    <span class="hljs-comment">// var m map[string]int</span><br>    <span class="hljs-comment">// m["k"] = 1</span><br>    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"assignment to entry in nil map"</span>))<br>	&#125;<br>    <span class="hljs-comment">// 如果开启了竞态检测 -race</span><br>	<span class="hljs-keyword">if</span> raceenabled &#123;<br>		callerpc := getcallerpc()<br>		pc := funcPC(mapassign)<br>		racewritepc(unsafe.Pointer(h), callerpc, pc)<br>		raceReadObjectPC(t.key, key, callerpc, pc)<br>	&#125;<br>    <span class="hljs-comment">// 如果开启了memory sanitizer -msan</span><br>	<span class="hljs-keyword">if</span> msanenabled &#123;<br>		msanread(key, t.key.size)<br>	&#125;<br>    <span class="hljs-comment">// 同样检查是否有其他 goroutine 正在对 map 进行 key 写入，有的话抛出错误</span><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map writes"</span>)<br>	&#125;<br>    <span class="hljs-comment">// 获取哈希值</span><br>	hash := t.hasher(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br><br>	<span class="hljs-comment">// 将 flags 的值与 hashWriting 做按位"异或"运算并赋值到 flags</span><br>   	<span class="hljs-comment">// 因为在当前 goroutine 可能还未完成 key 的写入，再次调用 t.hasher 会发生 panic。</span><br>	h.flags ^= hashWriting<br><br>    <span class="hljs-comment">// 这种情况在初始化 map 并且 hint&lt;=8(bucketCnt)时，由于直接在堆上进行分配，所以会出现</span><br>	<span class="hljs-keyword">if</span> h.buckets == <span class="hljs-literal">nil</span> &#123;<br>		h.buckets = newobject(t.bucket) <span class="hljs-comment">// newarray(t.bucket, 1)</span><br>	&#125;<br><br>again:<br>    <span class="hljs-comment">// bucketMask 返回值是 2 的 B 次方减 1，即 low-order bits</span><br>   	<span class="hljs-comment">// 因此，通过 hash 值与 bucketMask 返回值做按位与操作获取 low-order bits，</span><br>    <span class="hljs-comment">// 返回在 buckets 数组中的第几号桶</span><br>	bucket := hash &amp; bucketMask(h.B)<br>    <span class="hljs-comment">// 如果 map 正在搬迁（即h.oldbuckets != nil）中,则先进行搬迁工作。</span><br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>		growWork(t, h, bucket)<br>	&#125;<br>    <span class="hljs-comment">// 计算出上面求出的 bucket 的内存位置</span><br>   	<span class="hljs-comment">// post = start + bucketNumber * bucketsize</span><br>	b := (*bmap)(unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(h.buckets) + bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 获取高八位哈希值</span><br>    top := tophash(hash)<br><br>	<span class="hljs-keyword">var</span> inserti *<span class="hljs-keyword">uint8</span><br>	<span class="hljs-keyword">var</span> insertk unsafe.Pointer<br>	<span class="hljs-keyword">var</span> elem unsafe.Pointer<br>bucketloop:<br>	<span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 遍历桶中的 8 个 cell</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>        <br>            <span class="hljs-comment">// 这里分两种情况：</span><br>            <br>        	<span class="hljs-comment">// 第一种情况是 cell 位的 tophash 值和当前 tophash 值不相等</span><br>       		<span class="hljs-comment">// 在 b.tophash[i] != top 的情况下，这个位置有可能会是一个空槽位</span><br>       		<span class="hljs-comment">// 一般情况下 map 的槽位分布是这样的，e 表示 empty:</span><br>       		<span class="hljs-comment">// [h0][h1][h2][h3][h4][e][e][e]</span><br>       		<span class="hljs-comment">// 但在执行过 delete 操作时，可能会变成这样:</span><br>       		<span class="hljs-comment">// [h0][h1][e][e][h5][e][e][e]</span><br>       		<span class="hljs-comment">// 所以如果再插入的话，会尽量往前面的位置插</span><br>       		<span class="hljs-comment">// [h0][h1][e][e][h5][e][e][e]</span><br>       		<span class="hljs-comment">//          ^</span><br>       		<span class="hljs-comment">//          ^</span><br>       		<span class="hljs-comment">//       这个位置</span><br>       		<span class="hljs-comment">// 所以在循环的时候还要顺便把前面的空位置先记下来</span><br>       		<span class="hljs-comment">// 因为有可能在后面会找到相等的 key，也可能找不到相等的 key</span><br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>                <span class="hljs-comment">// 当前是一个空槽位并且这是第一个空位</span><br>				<span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="hljs-literal">nil</span> &#123;<br>                    <span class="hljs-comment">// 记录这个空闲的位置tophash的地址，用于后面赋值，同时获取将要插入 k，v 位置的地址</span><br>					inserti = &amp;b.tophash[i]<br>					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>					elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.elemsize))<br>				&#125;<br>                <span class="hljs-comment">// 查找到末尾了，break 跳出循环</span><br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>            <span class="hljs-comment">// 第二种情况是 cell 位的 tophash 值和当前的 tophash 值相等</span><br>            <span class="hljs-comment">// 查找当前 cell 位的 key 值</span><br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>				k = *((*unsafe.Pointer)(k))<br>			&#125;<br>            <span class="hljs-comment">// 注意，即使当前 cell 位的 tophash 值相等，不一定它对应的 key 也是相等的</span><br>            <span class="hljs-comment">// 所以还要做一个 key 值判断，判断如果 key 值不相等，记录下一轮遍历</span><br>			<span class="hljs-keyword">if</span> !t.key.equal(key, k) &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// 如果已经有该 key 了，就更新它</span><br>			<span class="hljs-keyword">if</span> t.needkeyupdate() &#123;<br>				typedmemmove(t.key, k, key)<br>			&#125;<br>            <span class="hljs-comment">// 这里获取到了要插入 key 对应的 value 的内存地址</span><br>       		<span class="hljs-comment">// pos = start + dataOffset + 8*keysize + i*elemsize</span><br>			elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.elemsize))<br>			<span class="hljs-comment">// 如果顺利到这，就直接跳到done的结束逻辑中去</span><br>            <span class="hljs-comment">// 这种情况下不会触发下面的情况，直接跳到 done</span><br>            <span class="hljs-keyword">goto</span> done<br>		&#125;<br>        <span class="hljs-comment">// 如果桶中的 8 个 cell 遍历完，还未找到对应的空 cell 或覆盖 cell，</span><br>        <span class="hljs-comment">// 那么就进入它的溢出桶中去遍历</span><br>		ovf := b.overflow(t)<br>        <span class="hljs-comment">// 如果连溢出桶中都没有找到合适的 cell，跳出循环。</span><br>		<span class="hljs-keyword">if</span> ovf == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		b = ovf<br>	&#125;<br><br>	<br>    <span class="hljs-comment">// 在已有的桶和溢出桶中都未找到合适的 cell 供 key 写入，那么有可能会触发以下两种情况</span><br>  	<br>    <span class="hljs-comment">// 情况一：</span><br>  	<span class="hljs-comment">// 判断当前 map 的装载因子是否达到设定的 6.5 阈值，或者当前 map 的溢出桶数量是否过多。如果存在这两种情况之一，则进行扩容操作。</span><br>  	<span class="hljs-comment">// 注意，这里 hashGrow() 实际并未完成扩容，对哈希表数据的搬迁（复制）操作是通过 growWork() 来完成的。</span><br>  	<span class="hljs-comment">// 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。</span><br>	<span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>        <span class="hljs-comment">// 此处涉及的扩容机制后面讲</span><br>		hashGrow(t, h)<br>		<span class="hljs-keyword">goto</span> again<br>	&#125;<br><br>    <span class="hljs-comment">// 情况二：</span><br>	<span class="hljs-comment">// 在不满足情况一的条件下，会为当前桶再新建溢出桶，</span><br>    <span class="hljs-comment">// 并将 tophash，key 插入到新建溢出桶的对应内存的 0 号位置</span><br>	<span class="hljs-keyword">if</span> inserti == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 获取新建溢出桶的位置（后面有分析这个函数的实现）</span><br>		newb := h.newoverflow(t, b)<br>        <span class="hljs-comment">// 记录这个空闲的位置tophash的地址，用于后面赋值，同时获取将要插入 k、v 的位置的指针</span><br>		inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]<br>		insertk = add(unsafe.Pointer(newb), dataOffset)<br>		elem = add(insertk, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>	&#125;<br><br>	<span class="hljs-comment">// 如果 key 是指针（当键超过 maxKeySize（128个字节）时会转换为指针），则需要进行解引用获取值</span><br>	<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>		kmem := newobject(t.key)<br>        <span class="hljs-comment">// 赋值</span><br>		*(*unsafe.Pointer)(insertk) = kmem<br>		insertk = kmem<br>	&#125;<br>    <span class="hljs-comment">// value 同理</span><br>	<span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>		vmem := newobject(t.elem)<br>        <span class="hljs-comment">// 获取 value 应该插入的地址</span><br>		*(*unsafe.Pointer)(elem) = vmem<br>	&#125;<br>    <span class="hljs-comment">// 更新 key 值</span><br>	typedmemmove(t.key, insertk, key)<br>    <span class="hljs-comment">// 将 tophash 赋值到bmap tophash数组的[i]位置</span><br>	*inserti = top<br>	h.count++<br><br>done:<br>    <span class="hljs-comment">// 再判断一次当前 map 是否有其他 goroutine 在写</span><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map writes"</span>)<br>	&#125;<br>	h.flags &amp;^= hashWriting<br>	<span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>        <span class="hljs-comment">// 获取 value 应该插入的地址</span><br>		elem = *((*unsafe.Pointer)(elem))<br>	&#125;<br>    <span class="hljs-comment">// 返回 value 的底层内存位置</span><br>	<span class="hljs-keyword">return</span> elem<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在上面的写入流程中，在已有的桶和溢出桶中都未找到合适的 <code>cell</code> 供 <code>key</code> 写入，并且尚不满足扩容阈值的情况下，会通过 <code>newoverflow</code> 获得新的溢出桶。前面 map 初始化的时候提到过，其初始化后的结构是这样子的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg" alt="初始化的map"></p>
<p>所以  <code>extra.nextOverflow</code> 会指向预分配的溢出桶，另外最后一个溢出桶的 <code>overflow</code> 会指向 <code>buckets[0]</code>，通过这个特性，可以用来判断是否是最后一个溢出桶。</p>
<p>这里再分析一下 <code>newoverflow</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hmap)</span> <span class="hljs-title">newoverflow</span><span class="hljs-params">(t *maptype, b *bmap)</span> *<span class="hljs-title">bmap</span></span> &#123;<br>	<span class="hljs-keyword">var</span> ovf *bmap<br>    <span class="hljs-comment">// 在创建 map 时，实际上会先分配一部分溢出桶用于后续需要</span><br>    <span class="hljs-comment">// 这里就会先检查是否有预分配的溢出桶，并且溢出桶还没有用完</span><br>	<span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// ovf 指向预分配的溢出桶位置</span><br>		ovf = h.extra.nextOverflow<br>        <span class="hljs-comment">// overflow 为 nil ，说明不是最后一个桶</span><br>		<span class="hljs-keyword">if</span> ovf.overflow(t) == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// 这时候只需要修改 nextOverflow 地址指向下一个溢出桶(因为内存是连续的)，即碰撞指针的思想</span><br>			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// overflow 不是 nil，说明这是最后的一个桶了，</span><br>            <span class="hljs-comment">// 重置此桶上的 overflow 指针为 nil，同时设置 extra.nextOverflow = nil,</span><br>            <span class="hljs-comment">// 标记溢出桶已经用完了</span><br>			ovf.setoverflow(t, <span class="hljs-literal">nil</span>)<br>			h.extra.nextOverflow = <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有溢出桶 或者 溢出桶用完了</span><br>    	<span class="hljs-comment">// 内存空间重新分配一个bmap</span><br>		ovf = (*bmap)(newobject(t.bucket))<br>	&#125;<br>    <span class="hljs-comment">// 生成溢出桶 bmap 的计数器计数</span><br>	h.incrnoverflow()<br>	<span class="hljs-keyword">if</span> t.bucket.ptrdata == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 创建 extra 和 overflow</span><br>		h.createOverflow()<br>		*h.extra.overflow = <span class="hljs-built_in">append</span>(*h.extra.overflow, ovf)<br>	&#125;<br>    <span class="hljs-comment">// 将这个 bucket 的 overflow 指针指向溢出桶</span><br>	b.setoverflow(t, ovf)<br>	<span class="hljs-keyword">return</span> ovf<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>通过对 <code>mapassign</code> 的代码分析之后，发现该函数并没有将插入 <code>key</code> 对应的 <code>value</code> 写入对应的内存，而是返回了 <code>value</code> 应该插入的内存地址。也就是说 <strong>map 并不会在 <code>mapassign</code> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址</strong>。</p>
<p>真正的赋值操作是<strong>在编译期间插入</strong>的，对下面的程序使用 <code>go tool</code> 工具分析：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        m[i] = <span class="hljs-number">666</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>m[i] = 666</code>对应的汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta"> $</span><span class="bash"> go tool compile -S map.go</span><br> ...<br>         0x0098 00152 (map.go:6) LEAQ    type.map[int]int(SB), CX<br>         0x009f 00159 (map.go:6) MOVQ    CX, (SP)<br>         0x00a3 00163 (map.go:6) LEAQ    ""..autotmp_2+184(SP), DX<br>         0x00ab 00171 (map.go:6) MOVQ    DX, 8(SP)<br>         0x00b0 00176 (map.go:6) MOVQ    AX, 16(SP)<br>         0x00b5 00181 (map.go:6) CALL    runtime.mapassign_fast64(SB) // 调用函数runtime.mapassign_fast64，该函数实质就是 mapassign（上文示例源代码是该 mapassign 系列的通用逻辑）<br>         0x00ba 00186 (map.go:6) MOVQ    24(SP), AX 24(SP), AX // 返回值，即 value 应该存放的内存地址<br>        0x00bf 00191 (map.go:6) MOVQ    $666, (AX) // 把 666 放入该地址中<br>...<br></code></pre></div></td></tr></table></figure>

<p>可以看到，赋值的最后一步实际上是<strong>编译器额外生成的汇编指令来完成的</strong>，可见靠 runtime 有些工作是没有做完的。所以，在 go 中，编译器和 runtime 配合，才能完成一些复杂的工作。</p>
<p>此外，可以看到上面的函数调用是 <code>runtime.mapassign_fast64</code>，这里说明一下：</p>
<blockquote>
<p> <code>mapassign</code> 有一系列的函数，根据 <code>key</code> 类型的不同，编译器会将其优化为相应的“快速函数”，但在实现思路上其实都跟 <code>mapassign</code> 一样。类型有以下这些：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">插入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
</tbody></table>
</blockquote>
<p>最后，总结一下 map 中 key 的写入流程：</p>
<ol>
<li>检测 map 中 <code>hmap</code> 是否为空指针，是否有其他 <code>groutine</code> 在进行写入，如果有抛出错误；标记 <code>flags</code> 表示当前 <code>groutine</code> 在对 map 进行写操作</li>
<li>根据哈希值的低位获得对应的 bucket</li>
<li>判断是否正在进行扩容后的搬迁，如果是则先进行搬迁</li>
<li>计算高八位的哈希值，首先循环遍历桶中的 8 个 cell，如果 8 个 cell 遍历完还没有，则到溢出桶中进行遍历。这里分两种情况：</li>
</ol>
<ul>
<li>第一种情况是 cell 位的 <code>tophash</code> 值和当前 <code>tophash</code> 值不相等，因为有可能删除导致中间个别 <code>cell</code> 没有值，但是在后面又还有可能找到相等的 <code>tophash</code>，所以这时会先记录第一个不相等的值（可能当前位为空），然后继续遍历，目的是尽可能往前插入键值</li>
<li>第二种情况是 <code>cell</code> 位的 <code>tophash</code> 值和当前的 <code>tophash</code> 值相等，此时会查看当前的 key 值，因为即使当前 <code>cell</code> 位的 <code>tophash</code> 值相等，不一定它对应的 <code>key</code> 也是相等的。不相等则继续遍历，相等则获取当前 <code>value</code> 的地址直接返回(相当于更新 value）。</li>
</ul>
<ol start="5">
<li>如果遍历所有之后没有找到合适的位置，则需要新建溢出桶来承载键值对。这里也分为两种情况：</li>
</ol>
<ul>
<li><p>第一种是需要判断当前 map 的装载因子是否达到 6.5 的阈值或者溢出桶过多，这两种情况都需要对 map 进行扩容处理后再重新遍历</p>
</li>
<li><p>第二种情况则是在在不满足情况一的条件下，为当前桶新建溢出桶，并将 <code>tophash</code>，<code>key</code> 插入到新建溢出桶的对应内存的 0 号位置，然后返回 <code>value</code> 的底层内存位置</p>
</li>
</ul>
<h3 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h3><p>map 在扩容的时候有两个指标：<strong>装载因子</strong>和<strong>溢出桶的数量</strong>。</p>
<p>为了保证访问效率，当 map 将要添加、修改或删除 <code>key</code> 时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。在上面源码 <code>mapassign</code> 中，其实已经注释 map 扩容条件，主要是两点：</p>
<ol>
<li>判断已经达到装载因子的临界点，即<code>元素个数 &gt; 桶（bucket）总数 * 6.5</code>，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到 6.5 个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">overLoadFactor</span><span class="hljs-params">(count <span class="hljs-keyword">int</span>, B <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="hljs-keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li>判断溢出桶是否太多，当<code>桶总数 &lt; 2 ^ 15</code> 时，如果<code>溢出桶总数 &gt;= 桶总数</code>，则认为溢出桶过多。当<code>桶总数 &gt;= 2 ^ 15</code> 时，直接与 <code>2 ^ 15</code> 比较，当<code>溢出桶总数 &gt;= 2 ^ 15</code> 时，即认为溢出桶太多了。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tooManyOverflowBuckets</span><span class="hljs-params">(noverflow <span class="hljs-keyword">uint16</span>, B <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">if</span> B &gt; <span class="hljs-number">15</span> &#123;<br>		B = <span class="hljs-number">15</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> noverflow &gt;= <span class="hljs-keyword">uint16</span>(<span class="hljs-number">1</span>)&lt;&lt;(B&amp;<span class="hljs-number">15</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>对于第2点，其实是对第 1 点的补充。因为在装载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而仅判断第 1 点是避免不了这种情况的。在这种情况下，计算装载因子的分子比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。</p>
<p>在某些场景下，比如不断的增删，这样会造成 overflow 的 bucket 数量增多，但负载因子又不高，未达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 点判断指标。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。 </p>
<p>例如下面，由于 map 的不断删除，0 号 bucket 中的桶链就造成了大量的稀疏桶。</p>
<p><img src="https://qiniu.xiaoming.net.cn/tooManyOverflowBuckets%E6%83%85%E5%86%B5.webp" alt="tooManyOverflowBuckets情况"></p>
<p>针对这两种情况，官方采用了不同的解决方案</p>
<ul>
<li>针对 1，将 B + 1，新建一个 buckets 数组，也就是说新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。该方法称之为<strong>增量扩容</strong>。</li>
<li>针对 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使 bucket 的使用率更高，进而保证更快的存取。该方法称之为<strong>等量扩容</strong>。</li>
</ul>
<p>对于 2 的解决方案，其实存在一个极端的情况：如果插入 map 的 key 哈希都一样，那么它们就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。但 <strong>Go 的每一个 map 都会在初始化阶段的 makemap 时定一个随机的哈希种子，所以要构造这种冲突是没那么容易的</strong>。</p>
<p>在源码中，和扩容相关的主要是 <code>hashGrow()</code> 函数与 <code>growWork()</code> 函数<strong>。<code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 <code>mapassign()</code> 和 <code>mapdelete()</code> 函数中。</strong>也就是插入（包括修改）、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。它们会先检查 oldbuckets 是否搬迁完毕（检查 oldbuckets 是否为 nil），再决定是否进行搬迁工作。</p>
<p>再重新看一下 <code>mapassign</code> 的相关片段：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">again:<br>    ...<br>    <span class="hljs-comment">// 如果 map 正在搬迁（即h.oldbuckets != nil）中,则先进行搬迁工作。</span><br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>        <span class="hljs-comment">// 这里其实只搬迁了当前的 bucket</span><br>		growWork(t, h, bucket)<br>	&#125;<br>    ...<br><br><br>	<span class="hljs-comment">// 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。</span><br>	<span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>        <span class="hljs-comment">// 分配新的 buckets，并将老的 buckets 挂到 oldbuckets 字段上</span><br>		hashGrow(t, h)<br>		<span class="hljs-keyword">goto</span> again<br>	&#125;<br></code></pre></div></td></tr></table></figure>

<p>再分别看看 <code>hashGrow</code> 和 <code>growWork</code>  的实现:</p>
<p><code>hashGrow</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashGrow</span><span class="hljs-params">(t *maptype, h *hmap)</span></span> &#123;<br>	<span class="hljs-comment">// 如果达到条件 1，那么将 B 值加 1，相当于是原来的 2 倍</span><br>   	<span class="hljs-comment">// 否则对应条件 2，进行等量扩容，所以 B 不变</span><br>	bigger := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> !overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) &#123;<br>		bigger = <span class="hljs-number">0</span><br>		h.flags |= sameSizeGrow<br>	&#125;<br>    <span class="hljs-comment">// 记录老的buckets</span><br>	oldbuckets := h.buckets<br>    <span class="hljs-comment">// 申请新的 buckets 空间</span><br>	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="hljs-literal">nil</span>)<br><br>    <span class="hljs-comment">// 注意 &amp;^ 运算符，这块代码的逻辑是转移标志位</span><br>	flags := h.flags &amp;^ (iterator | oldIterator)<br>	<span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &#123;<br>		flags |= oldIterator<br>	&#125;<br>	<span class="hljs-comment">// 提交 grow</span><br>	h.B += bigger<br>	h.flags = flags<br>	h.oldbuckets = oldbuckets<br>	h.buckets = newbuckets<br>    <span class="hljs-comment">// 搬迁进度为0</span><br>	h.nevacuate = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// overflow buckets 数为0</span><br>	h.noverflow = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 如果发现 hmap 是通过 extra 字段来存储 overflow buckets 时</span><br>	<span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &amp;&amp; h.extra.overflow != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// Promote current overflow buckets to the old generation.</span><br>		<span class="hljs-keyword">if</span> h.extra.oldoverflow != <span class="hljs-literal">nil</span> &#123;<br>			throw(<span class="hljs-string">"oldoverflow is not nil"</span>)<br>		&#125;<br>		h.extra.oldoverflow = h.extra.overflow<br>		h.extra.overflow = <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> h.extra == <span class="hljs-literal">nil</span> &#123;<br>			h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>		&#125;<br>		h.extra.nextOverflow = nextOverflow<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>growWork</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growWork</span><span class="hljs-params">(t *maptype, h *hmap, bucket <span class="hljs-keyword">uintptr</span>)</span></span> &#123;<br>	<span class="hljs-comment">// 为了确认搬迁的 bucket 是我们正在使用的 bucket</span><br>  	<span class="hljs-comment">// 即如果当前 key 映射到老的 bucket1，那么就搬迁该 bucket1。</span><br>	evacuate(t, h, bucket&amp;h.oldbucketmask())<br><br>	<span class="hljs-comment">// 如果还未完成扩容工作，则再搬迁一个bucket。</span><br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>		evacuate(t, h, h.nevacuate)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从 <code>growWork()</code> 函数可以知道，搬迁的核心逻辑是 <code>evacuate()</code> 函数。</p>
<p>从上面可以看出，扩容过程是渐进性的，每次最多搬迁两个桶。</p>
<p><strong>为什么每次至多搬迁 2 个bucket？</strong></p>
<p>这其实是一种性能考量，如果 map 存储了数以亿计的 <code>key-value</code>，一次性搬迁将会造成比较大的延时，因此才采用逐步搬迁策略。</p>
<p>在搬迁函数 <code>evacuate</code> 中，其逻辑主要涉及一个是 <strong>bucket 序列号的变化</strong>，另外一个就是<strong>搬迁区间的确认</strong>。</p>
<ul>
<li><strong>bucket 序列号的变化</strong></li>
</ul>
<p>对于 bucket 序列号的变化，增量扩容（条件1）和等量扩容（条件2）都需要进行 bucket 的搬迁工作。对于等量扩容而言，由于 buckets 的数量不变，因此可以按照序号来搬迁。例如老的的 0 号 bucket，仍然搬至新的 0 号 bucket 中。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="等量扩容bucket序列号"></p>
<p>但是，对于增量扩容而言，就会有所不同。例如原来的 B=5，那么增量扩容时，B 就会变成 6。那么决定 key 值落入哪个 bucket 的低位哈希值就会发生变化（<strong>从取 5 位变为取 6 位</strong>），取新的低位 hash 值得过程称为 <strong>rehash</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.webp" alt="增量扩容bucket序列号"></p>
<p>因此，在增量扩容中，某个 key 在搬迁前后 bucket 序号可能和原来相等，<strong>也可能是相比原来加上 2^B（原来的 B 值），取决于低 hash 值第倒数第 B+1 位是 0 还是 1</strong>。</p>
<p>如下图中，当原始的 B = 3 时，旧 buckets 数组长度为 8，在编号为 2 的 bucket 中，其 2 号 cell 和 5 号 cell，它们的低 3 位哈希值相同（不相同的话，也就不会落在同一个桶中了），但是它们的低 4 位分别是 0010、1010。当发生了增量扩容，2 号就会被搬迁到新 buckets 数组的 2 号 bucket 中去，5 号被搬迁到新 buckets 数组的 10 号 bucket 中去，它们的桶号差距是 2 的 3 次方。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9rehash.webp" alt="增量扩容rehash"></p>
<ul>
<li><strong>搬迁区间的确认</strong></li>
</ul>
<p>在源码中，有 <code>bucket x</code> 和 <code>bucket y</code> 的概念，其实就是增量扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 <code>bucket x</code>，后一半桶被称为 <code>bucket y</code>。一个 bucket 中的 key 可能会分裂到两个桶中去，分别位于 <code>bucket x</code> 的桶，或 <code>bucket y</code> 中的桶。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个区间（而对于同一个桶而言，搬迁到 <code>bucket x</code> 和 <code>bucket y</code> 桶序号的差别是老的 buckets 大小，即 <code>2^old_B</code>）。</p>
<p><img src="https://qiniu.xiaoming.net.cn/bucketX%E5%92%8CbucketY.webp" alt="bucketX和bucketY"></p>
<p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 <code>key/value</code> 值 copy 到目的地相应的位置。设置 <code>key</code> 在原始 buckets 的 <code>tophash</code> 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的<code>bucket x</code> 或是 <code>bucket y</code>，新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p>
<p><strong>为什么确定 key 落在哪个区间很重要？</strong></p>
<p>因为对于增量扩容而言，原本一个 <code>bucket</code> 中的 <code>key</code> 会被分裂到两个 <code>bucket</code> 中去，它们分别处于 <code>bucket x</code> 和 <code>bucket y</code> 中，但是它们之间存在关系 <code>bucket x + 2^B = bucket y</code> （其中，B 是老 bucket 对应的 B 值）。</p>
<p>假设 <code>key</code> 所在的老 <code>bucket</code> 序号为 n，那么如果 <code>key</code> 落在新的 <code>bucket x</code>，则它应该置入 <code>bucket x 起始位置 + n*bucket</code> 的内存中去；如果 <code>key</code> 落在新的 <code>bucket y</code>，则它应该置入 <code>bucket y 起始位置 + n*bucket</code> 的内存中去。因此，确定 <code>key</code> 落在哪个区间，这样就很方便进行内存地址计算，快速找到 <code>key</code> 应该插入的内存地址。</p>
<p>下面看看 <code>evacuate()</code> 函数的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evacuate</span><span class="hljs-params">(t *maptype, h *hmap, oldbucket <span class="hljs-keyword">uintptr</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 传进来的 oldbucket 实际上是当前定位到的需要搬迁的 bucket</span><br>    <span class="hljs-comment">// 这里首先定位原先 bucket 的位置</span><br>	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 获取扩容之前 bucket 的个数</span><br>    newbit := h.noldbuckets()<br>    <span class="hljs-comment">// 判断该 bucket 是否已经完成搬迁</span><br>	<span class="hljs-keyword">if</span> !evacuated(b) &#123;<br>        <br>        <span class="hljs-comment">// 官方TODO，后续也许会实现：如果没有迭代器使用旧的存储桶，则重用溢出存储桶而不是使用新的存储桶。 </span><br><br>		<span class="hljs-comment">// xy 包含了高低区间的搬迁目的地内存信息，[bucket, index, key, value]</span><br>     	<span class="hljs-comment">// x.b 是对应的搬迁目的桶</span><br>     	<span class="hljs-comment">// x.k 是指向对应目的桶中存储当前 key 的内存地址</span><br>    	<span class="hljs-comment">// x.e 是指向对应目的桶中存储当前 value 的内存地址</span><br>		<span class="hljs-keyword">var</span> xy [<span class="hljs-number">2</span>]evacDst<br>		x := &amp;xy[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment">// 获取基地址</span><br>		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>		x.k = add(unsafe.Pointer(x.b), dataOffset)<br>		x.e = add(x.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br><br>        <span class="hljs-comment">// 只有当增量扩容时才计算 bucket y 的相关信息（和后续计算 useY 相呼应）</span><br>		<span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br>			y := &amp;xy[<span class="hljs-number">1</span>]<br>			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>			y.k = add(unsafe.Pointer(y.b), dataOffset)<br>			y.e = add(y.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>		&#125;<br><br>        <span class="hljs-comment">// evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。</span><br>     	<span class="hljs-comment">// bucket 还会链接 overflow bucket，它们同样需要搬迁。</span><br>     	<span class="hljs-comment">// 因此同样会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。</span><br> <br>     	<span class="hljs-comment">// 遍历当前桶 bucket 和其之后的溢出桶 overflow bucket</span><br>     	<span class="hljs-comment">// 注意：初始的 b 是待搬迁的老 bucket</span><br>		<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>			k := add(unsafe.Pointer(b), dataOffset)<br>			e := add(k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>            <span class="hljs-comment">// 遍历桶中的 cell，这里 i，k，e 分别用于对应 tophash 下标，key 和 value</span><br>			<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="hljs-number">1</span>, add(k, <span class="hljs-keyword">uintptr</span>(t.keysize)), add(e, <span class="hljs-keyword">uintptr</span>(t.elemsize)) &#123;<br>                <span class="hljs-comment">// 获取tophash</span><br>				top := b.tophash[i]<br>                <span class="hljs-comment">// 如果当前 cell 的 tophash 值是 emptyOne 或者 emptyRest，</span><br>                <span class="hljs-comment">// 则代表此 cell 没有key。将其标记为evacuatedEmpty，表示它“已经被搬迁”。</span><br>				<span class="hljs-keyword">if</span> isEmpty(top) &#123;<br>					b.tophash[i] = evacuatedEmpty<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>                <span class="hljs-comment">// 正常不会出现这种情况</span><br>         		<span class="hljs-comment">// 未被搬迁的 cell 只可能是 emptyOne、emptyRest 或是正常的 top hash（大于等于 minTopHash）</span><br>				<span class="hljs-keyword">if</span> top &lt; minTopHash &#123;<br>					throw(<span class="hljs-string">"bad map state"</span>)<br>				&#125;<br>				k2 := k<br>                <span class="hljs-comment">// 如果 key 是指针，则解引用</span><br>				<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>					k2 = *((*unsafe.Pointer)(k2))<br>				&#125;<br>				<span class="hljs-keyword">var</span> useY <span class="hljs-keyword">uint8</span><br>                <span class="hljs-comment">// 如果是增量扩容</span><br>				<span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br>					<span class="hljs-comment">// 计算哈希值，判断当前key和vale是要被搬迁到bucket x还是bucket y</span><br>					hash := t.hasher(k2, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>					<span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) &#123;<br>						<span class="hljs-comment">// 有一个特殊情况：有一种 key，每次对它计算 hash，得到的结果都不一样。</span><br>                        <span class="hljs-comment">// 这个 key 就是 math.NaN() 的结果，它的含义是 not a number，类型是 float64。</span><br> 						<span class="hljs-comment">// 当它作为 map 的 key时，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</span><br>            			<span class="hljs-comment">// 这个 key 是永远不会被 Get 操作获取的！当使用 m[math.NaN()] 语句的时候，是查不出来结果的。</span><br>                        <span class="hljs-comment">// 这个 key 只有在遍历整个 map 的时候，才能被找到。</span><br>                        <span class="hljs-comment">// 并且，可以向一个 map 插入多个数量的 math.NaN() 作为 key，它们并不会被互相覆盖。</span><br>                        <span class="hljs-comment">// 当搬迁碰到 math.NaN() 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。</span><br>                        <span class="hljs-comment">// 如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</span><br>						useY = top &amp; <span class="hljs-number">1</span><br>						top = tophash(hash)<br>					&#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 对于正常的 key，则进入 else 的逻辑</span><br>						<span class="hljs-keyword">if</span> hash&amp;newbit != <span class="hljs-number">0</span> &#123;<br>							useY = <span class="hljs-number">1</span><br>						&#125;<br>					&#125;<br>				&#125;<br><br>				<span class="hljs-keyword">if</span> evacuatedX+<span class="hljs-number">1</span> != evacuatedY || evacuatedX^<span class="hljs-number">1</span> != evacuatedY &#123;<br>					throw(<span class="hljs-string">"bad evacuatedN"</span>)<br>				&#125;<br><br>                <span class="hljs-comment">// 标示这个位置k，v 迁到 x 还是 y，</span><br>                <span class="hljs-comment">// 因为 evacuatedX + 1 == evacuatedY，如果 useY 是 0，那就是 x，否则是 y</span><br>				b.tophash[i] = evacuatedX + useY<br>                <span class="hljs-comment">// useY 要么为0，要么为 1。</span><br>                <span class="hljs-comment">// 这里就是选取在 bucket x 的起始内存位置，或者选择在 bucket y 的起始内存位置</span><br>                <span class="hljs-comment">// （只有增量同步才会有这个选择可能）。</span><br>				dst := &amp;xy[useY]                 <br><br>                <span class="hljs-comment">// 如果目的地的桶已经装满了（8个cell），那么需要新建一个溢出桶，继续搬迁到溢出桶上去。</span><br>				<span class="hljs-keyword">if</span> dst.i == bucketCnt &#123;<br>                    <span class="hljs-comment">//  newoverflow() 前面分析过，它会当将已经事先创建好的 overflow bucket 设置到 bucket 上了</span><br>					dst.b = h.newoverflow(t, dst.b)<br>					dst.i = <span class="hljs-number">0</span><br>					dst.k = add(unsafe.Pointer(dst.b), dataOffset)<br>					dst.e = add(dst.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>				&#125;<br>                <span class="hljs-comment">// 通过与操作直接避免了边界检查，并设置相应下标位置的值为 tophash（真的妙！！！）</span><br>				dst.b.tophash[dst.i&amp;(bucketCnt<span class="hljs-number">-1</span>)] = top<br>                <span class="hljs-comment">// 如果待搬迁的key是指针，则复制指针过去</span><br>				<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>					*(*unsafe.Pointer)(dst.k) = k2<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果待搬迁的key是值，则复制值过去 </span><br>					typedmemmove(t.key, dst.k, k)<br>				&#125;<br>                <span class="hljs-comment">// value 和 key 同理</span><br>				<span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>					*(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					typedmemmove(t.elem, dst.e, e)<br>				&#125;<br>                <span class="hljs-comment">// 将当前搬迁目的桶的记录 key/value 的索引值（也可以理解为 cell 的索引值）加一</span><br>				dst.i++<br>				<span class="hljs-comment">// 计算下一个 dst.k,dst.e 的内存地址</span><br>                <span class="hljs-comment">// 由于桶的内存布局中在最后还有 overflow 的指针，所以这里不用担心更新有可能会超出 key 和 value 数组的指针地址。</span><br>				dst.k = add(dst.k, <span class="hljs-keyword">uintptr</span>(t.keysize))<br>				dst.e = add(dst.e, <span class="hljs-keyword">uintptr</span>(t.elemsize))<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 如果没有协程在使用老的桶，就对老的桶进行清理，用于帮助 gc</span><br>		<span class="hljs-keyword">if</span> h.flags&amp;oldIterator == <span class="hljs-number">0</span> &amp;&amp; t.bucket.ptrdata != <span class="hljs-number">0</span> &#123;<br>			b := add(h.oldbuckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize))<br>			<span class="hljs-comment">// 只清除 bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态</span><br>			ptr := add(b, dataOffset)<br>			n := <span class="hljs-keyword">uintptr</span>(t.bucketsize) - dataOffset<br>			memclrHasPointers(ptr, n)<br>		&#125;<br>	&#125;<br><br>    <span class="hljs-comment">// 用于更新搬迁进度</span><br>	<span class="hljs-keyword">if</span> oldbucket == h.nevacuate &#123;<br>		advanceEvacuationMark(h, t, newbit)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>更新搬迁进度的函数 <code>advanceEvacuationMark</code> 实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">advanceEvacuationMark</span><span class="hljs-params">(h *hmap, t *maptype, newbit <span class="hljs-keyword">uintptr</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 搬迁桶的进度加一</span><br>	h.nevacuate++<br>    <span class="hljs-comment">// 实验表明，1024 至少会比 newbit 高出一个数量级。</span><br>    <span class="hljs-comment">// newbit 是传进来的参数，代表扩容之前老的 bucket 个数。</span><br>    <span class="hljs-comment">// 所以，用当前进度加 1024 用于确保 O(1) 行为。</span><br>	stop := h.nevacuate + <span class="hljs-number">1024</span><br>	<span class="hljs-keyword">if</span> stop &gt; newbit &#123;<br>		stop = newbit<br>	&#125;<br>    <span class="hljs-comment">// 计算已经搬迁完的桶数</span><br>	<span class="hljs-keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;<br>		h.nevacuate++<br>	&#125;<br>    <span class="hljs-comment">// 如果h.nevacuate == newbit，则代表所有的桶都已经搬迁完毕</span><br>	<span class="hljs-keyword">if</span> h.nevacuate == newbit &#123; <span class="hljs-comment">// newbit == # of oldbuckets</span><br>		<span class="hljs-comment">// 搬迁完毕，所以指向老的 buckets 的指针置为nil</span><br>		h.oldbuckets = <span class="hljs-literal">nil</span><br>		<span class="hljs-comment">// 前面说过，如果 map 中 key 和 value 均不包含指针，则都可以 inline。</span><br>    	<span class="hljs-comment">// 那么保存它们的 buckets 数组其实是挂在 hmap.extra 中的。</span><br>        <span class="hljs-comment">// 所以，这种情况下，其实我们是搬迁的 extra 的 buckets 数组。</span><br>		<span class="hljs-comment">// 因此，在这种情况下，需要在搬迁完毕后，将 hmap.extra.oldoverflow 指针置为nil。</span><br>		<span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &#123;<br>			h.extra.oldoverflow = <span class="hljs-literal">nil</span><br>		&#125;<br>        <span class="hljs-comment">// 最后，清除正在扩容的标志位，扩容完毕。</span><br>		h.flags &amp;^= sameSizeGrow<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里在看一下对于判断当前 <code>bucket</code> 是否搬迁完成的函数 <code>evacuated</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evacuated</span><span class="hljs-params">(b *bmap)</span> <span class="hljs-title">bool</span></span> &#123;<br>	h := b.tophash[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果 <code>b.tophash[0]</code> 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">empty</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">evacuatedEmpty</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">evacuatedX</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">evacuatedY</span> = <span class="hljs-number">3</span><br><span class="hljs-attr">minTopHash</span> = <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>

<p>到这里就完成了 map 的扩容，总结一下整体的流程如下：</p>
<ol>
<li>首先判断是需要等量扩容还是增量扩容，增量扩容的条件是<code>元素个数 &gt; 桶（bucket）总数 * 6.5</code>。而等量扩容的条件是当<code>桶总数 &lt; 2 ^ 15</code> 时，如果<code>溢出桶总数 &gt;= 桶总数</code>，则认为溢出桶过多;当<code>桶总数 &gt;= 2 ^ 15</code> 时，直接与 <code>2 ^ 15</code> 比较，当<code>溢出桶总数 &gt;= 2 ^ 15</code> 时，即认为溢出桶太多了</li>
<li>记录当前 <code>buckets</code> 数据，申请新的 <code>buckets</code> 空间</li>
<li>将 <code>oldbuckets</code> 指针原有的 <code>buckets</code>，设置 <code>nextOverflow</code> 指针</li>
<li>通过 <code>growWork</code> 函数执行旧键值对的搬迁，搬迁采用渐进式的方式，次至多搬迁 2 个bucket。</li>
<li>搬迁过程会进行 rehash，对于等量扩容，则只需要将旧的键值对取出来依次放入即可；对于增量扩容，从哈希值的倒数 B 位（原来的 B 值）多取 1 位，变成 B+1位（这里其实是因为扩容后容量为 2 倍，所以在最高位多取一位相当于乘以 2）。然后根据多取出来的一位是 0 还是 1 进行分配，0 则分配到前一般桶 <code>bucket x</code> 加上偏移的位置；1 则分配到后一般桶 <code>backet y</code> 对应加上偏移的位置。</li>
</ol>
<p>针对下面的 map，其 B 为3，所以原始 buckets 数组为8。当 map 元素数变多，加载因子超过 6.5，所以引起了增量扩容。</p>
<p>以 3 号 <code>bucket</code> 为例，可以看到，由于 B 值加 1，所以在新选取桶时，需要取低 4 位哈希值，这样就会造成 cell 会被搬迁到新 buckets 数组中不同的桶（3 号或 11 号桶）中去。注意，在一个桶中，搬迁 cell 的工作是有序的：它们是依序填进对应新桶的 <code>cell</code> 中去的。</p>
<p>当然，实际情况中 3 号桶很可能还有溢出桶，在这里为了简化绘图，假设 3 号桶没有溢出桶，如果有溢出桶，则相应地添加到新的 3 号桶和 11 号桶中即可，如果对应的 3 号和 11 号桶均装满，则给新的桶添加溢出桶来装载。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp" alt="扩容例子图示"></p>
<p>对于下图的 map，其 B 也为 3。假设整个 map 中的 <code>overflow</code> 过多，触发了等量扩容。注意，等量扩容时，新的 <code>buckets</code> 数组大小和旧 <code>buckets</code> 数组是一样的。</p>
<p>以 6 号桶为例，它有一个 bucket 和 3 个 overflow buckets，但是实际上桶里的数据非常稀疏，等量扩容的目的就是为了把松散的键值对重新排列一次，以使 <code>bucket</code> 的使用率更高，进而保证更快的存取。搬迁完毕后，新的 6 号桶中只有一个基础 <code>bucket</code>，暂时并不需要溢出桶。这样，和原 6 号桶相比，数据变得紧密，使后续的数据存取变快。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp" alt="等量扩容例子图示"></p>
<h3 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h3><p>哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<p>删除操作底层的执行函数是 <code>mapdelete</code>，它的流程如下：</p>
<ol>
<li><p>首先会检查 <code>h.flags</code> 标志，如果发现写标位是 1，直接 <code>panic</code>，因为这表明有其他协程同时在进行写操作。</p>
</li>
<li><p>接着计算 <code>key</code> 的哈希，找到落入的 <code>bucket</code>。检查此 <code>map</code> 如果正在扩容的过程中，直接触发一次搬迁操作。</p>
</li>
<li><p>删除操作同样是两层循环，核心还是找到 <code>key</code> 的具体位置。寻找过程都是类似的，在 <code>bucket</code> 中挨个 <code>cell</code> 寻找。</p>
</li>
<li><p>找到对应位置后，对 <code>key</code> 或者 <code>value</code> 进行“清零”操作。</p>
</li>
<li><p>修改 <code>map</code> 中 <code>cell</code> 的状态，如果 <code>bucket</code> 以一堆 <code>emptyOne</code> 状态结束, 还需要将其更改为 <code>emptyRest</code> 状态</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapdelete</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;<br>    <span class="hljs-comment">// 如果开启了竞态检测 -race</span><br>	<span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>		callerpc := getcallerpc()<br>		pc := funcPC(mapdelete)<br>		racewritepc(unsafe.Pointer(h), callerpc, pc)<br>		raceReadObjectPC(t.key, key, callerpc, pc)<br>	&#125;<br>    <span class="hljs-comment">// 如果开启了memory sanitizer -msan</span><br>	<span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>		msanread(key, t.key.size)<br>	&#125;<br>    <span class="hljs-comment">// 如果map为空或者元素个数为0, 直接返回</span><br>	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>			t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>		&#125;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>    <span class="hljs-comment">// 当 h.flags 对应的值为 hashWriting (代表有其他goroutine正在往map中写key)时,</span><br>    <span class="hljs-comment">// 那么位计算的结果不为0, 因此抛出错误</span><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map writes"</span>)<br>	&#125;<br><br>	hash := t.hasher(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br><br>	<span class="hljs-comment">// 将 flags 的值与 hashWriting 做按位 "异或" 运算</span><br>    <span class="hljs-comment">// 之所以调用 t.hasher 后设置 hashWriting, 是因为 t.hasher 可能会 panic, </span><br>    <span class="hljs-comment">// 在这种情况下, 实际上并没有执行写(删除)操作.</span><br>	h.flags ^= hashWriting<br><br>    <span class="hljs-comment">// 计算出桶的位置</span><br>	bucket := hash &amp; bucketMask(h.B)<br>    <span class="hljs-keyword">if</span> h.growing() &#123;<br>        <span class="hljs-comment">// 直接触发一次搬迁操作</span><br>		growWork(t, h, bucket)<br>	&#125;<br>    <span class="hljs-comment">// 获取 bucket 的内存地址</span><br>	b := (*bmap)(add(h.buckets, bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	bOrig := b<br>	top := tophash(hash)<br>search:<br>    <span class="hljs-comment">// 以下是查找的核心逻辑</span><br>    <span class="hljs-comment">// 同样双重循环遍历: 外层循环是从桶到溢出桶遍历; 内层是桶中的cell遍历</span><br>    <span class="hljs-comment">// 跳出循环的条件有三种: </span><br>    <span class="hljs-comment">// 第一种是已经找到 key 值, 并且已经完成清理工作</span><br>    <span class="hljs-comment">// 第二种是当前桶再无溢出桶;</span><br>    <span class="hljs-comment">// 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest, 它代表此时的桶后面的 cell 还未利用, 所以无需再继续遍历</span><br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>                <span class="hljs-comment">// 第三种情况</span><br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> search<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			k2 := k<br>			<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>				k2 = *((*unsafe.Pointer)(k2))<br>			&#125;<br>			<span class="hljs-keyword">if</span> !t.key.equal(key, k2) &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>            <span class="hljs-comment">// 第一种情况, 说明已经找到了 key 值完全一样</span><br>			<span class="hljs-comment">// 对 key 清零</span><br>			<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>				*(*unsafe.Pointer)(k) = <span class="hljs-literal">nil</span><br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.key.ptrdata != <span class="hljs-number">0</span> &#123;<br>				memclrHasPointers(k, t.key.size)<br>			&#125;<br>			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.elemsize))<br>			<span class="hljs-comment">// 对 value 清零</span><br>            <span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>				*(*unsafe.Pointer)(e) = <span class="hljs-literal">nil</span><br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.elem.ptrdata != <span class="hljs-number">0</span> &#123;<br>				memclrHasPointers(e, t.elem.size)<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				memclrNoHeapPointers(e, t.elem.size)<br>			&#125;<br>            <span class="hljs-comment">// 对应的 tophash 设置成 emptyOne</span><br>			b.tophash[i] = emptyOne<br>			<br>            <span class="hljs-comment">// 如果 bucket 现在以一堆 emptyOne 状态结束, 将其更改为 emptyRest 状态.</span><br>            <span class="hljs-comment">// 将此功能设为一个单独的函数会很好, 但是 for 循环当前不可内联</span><br>            <span class="hljs-comment">// 可以立即结束循环的的两种状况:</span><br>            <span class="hljs-comment">// 情况1: 当前 cell 是 bucket 的最后一个 cell, 且后续的 overflow bucket 的 cell tophash 不为 emptyRest</span><br>            <span class="hljs-comment">// 情况2: 当前 cell 后续的 cell tophash 不为 emptyRest</span><br>			<br>            <span class="hljs-keyword">if</span> i == bucketCnt<span class="hljs-number">-1</span> &#123;<br>                <span class="hljs-comment">// 第一种情况</span><br>				<span class="hljs-keyword">if</span> b.overflow(t) != <span class="hljs-literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="hljs-number">0</span>] != emptyRest &#123;<br>					<span class="hljs-keyword">goto</span> notLast<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 第二种情况</span><br>				<span class="hljs-keyword">if</span> b.tophash[i+<span class="hljs-number">1</span>] != emptyRest &#123;<br>					<span class="hljs-keyword">goto</span> notLast<br>				&#125;<br>			&#125;<br>            <span class="hljs-comment">// 如果 bucket 现在以一堆 emptyOne 状态结束, 将其更改为 emptyRest 状态</span><br>            <span class="hljs-comment">// 在这里存在两种情况:</span><br>            <span class="hljs-comment">// 跳出本循环的两种情况:</span><br>            <span class="hljs-comment">// 1. 遇到桶内的第一个 bucket。注意: 桶实质上就是一个单向的链表。</span><br>            <span class="hljs-comment">// 2. 遇到 cell 的 tophash 非删除状态(emptyOne)</span><br>			<span class="hljs-keyword">for</span> &#123;<br>				b.tophash[i] = emptyRest<br>				<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>                    <span class="hljs-comment">// 回到桶开始的位置</span><br>					<span class="hljs-keyword">if</span> b == bOrig &#123;<br>						<span class="hljs-keyword">break</span><br>					&#125;<br>                    <span class="hljs-comment">// 获取当前 bucket 的前面的 prev bucket(即 prev bucket 的 overflow 是当前 bucket)</span><br>                    <span class="hljs-comment">// 每次都是从桶内的首个元素开始，相当于从后往前将 emptyOne 改成 emptyRest</span><br>					c := b<br>					<span class="hljs-keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;<br>					&#125;<br>					i = bucketCnt - <span class="hljs-number">1</span><br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					i--<br>				&#125;<br>				<span class="hljs-keyword">if</span> b.tophash[i] != emptyOne &#123;<br>					<span class="hljs-keyword">break</span><br>				&#125;<br>			&#125;<br>		notLast:<br>            <span class="hljs-comment">// 对应 count 值减一</span><br>			h.count--<br>			<span class="hljs-keyword">break</span> search<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map writes"</span>)<br>	&#125;<br>    <span class="hljs-comment">// 清除 hashWriting flag</span><br>	h.flags &amp;^= hashWriting<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>同样，和写入函数一样，根据 key 类型的不同，删除操作会被优化成更具体的函数：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">删除</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapdelete_fast32(t *maptype, h *hmap, key uint32)</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapdelete_fast64(t *maptype, h *hmap, key uint64)</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapdelete_faststr(t *maptype, h *hmap, ky string)</td>
</tr>
</tbody></table>
<h3 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h3><p><strong>迭代 map 的结果是无序的</strong>，对于下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        m[i] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Println(k, v)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>运行以上代码，会发现每次输出顺序都是不同的。</p>
<p>map 遍历的过程，是按序遍历 <code>bucket</code>，同时按需遍历 <code>bucket</code> 中和其 <code>overflow bucket</code> 中的 <code>cell</code>。但是 map 在扩容后，会发生 <code>key</code> 的搬迁，这造成原来落在一个 <code>bucket</code> 中的 key，搬迁后，有可能会落到其他 <code>bucket</code> 中了，从这个角度看，遍历 map 的结果就不可能是按照原来的顺序了。</p>
<p>但其实，go 为了保证遍历 map 的结果是无序的，做了以下事情：map在遍历时，并不是从固定的 0 号 bucket 开始遍历的，每次遍历，都会从一个<strong>随机值序号的 bucket，再从其中随机的 cell 开始遍历。然后再按照桶序遍历下去，直到回到起始桶结束</strong>。</p>
<p>下面的例子是遍历一个处于未扩容状态的 map。如果 map 正处于扩容状态时，需要先判断当前遍历 <code>bucket</code> 是否已经完成搬迁，如果数据还在老的 <code>bucket</code>，那么就去老 <code>bucket</code> 中拿数据。</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E7%9A%84%E9%81%8D%E5%8E%86.webp" alt="go map的遍历"></p>
<p>当发生了增量扩容时，一个老的 <code>bucket</code> 数据可能会分裂到两个不同的 <code>bucket</code> 中去，那么此时，如果需要从老的 <code>bucket</code> 中遍历数据，例如 1 号，则不能将老 1 号 <code>bucket</code> 中的数据全部取出，仅仅只能取出老 1 号 <code>bucket</code> 中那些在裂变之后，分配到新 1 号 <code>bucket</code> 中的那些 <code>key</code>。</p>
<p>对下面的例子进行编译：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>	m[<span class="hljs-string">"silverming"</span>] = <span class="hljs-number">18</span><br>	<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>		fmt.Println(k, v)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">go tool compile -S main.go<br></code></pre></div></td></tr></table></figure>

<p>可以看到如下几行汇编的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//...<br>0x0104 00260 (main.go:8)  CALL    runtime.mapiterinit(SB)<br>//...<br>0x01c8 00456 (main.go:8)  CALL    runtime.mapiternext(SB)<br>//...<br></code></pre></div></td></tr></table></figure>

<p>可以看到对于 map 的迭代，底层调用的是 <code>mapiterinit</code> 和 <code>mapiternext</code> 函数。</p>
<p><code>mapiterinit</code> 就是对 <code>hiter</code> 结构体里的字段进行初始化赋值操作，这个结构用于保证随机性。</p>
<p><code>hiter</code> 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hiter <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// key 指针</span><br>	key         unsafe.Pointer<br>    <span class="hljs-comment">// value 指针</span><br>	elem        unsafe.Pointer<br>    <span class="hljs-comment">// map 类型，包含如 key size 大小等</span><br>	t           *maptype<br>	h           *hmap<br>    <span class="hljs-comment">// 初始化时指向的 buckets</span><br>	buckets     unsafe.Pointer<br>    <span class="hljs-comment">// 当前遍历到的 bmap</span><br>	bptr        *bmap<br>	overflow    *[]*bmap       <span class="hljs-comment">// keeps overflow buckets of hmap.buckets alive</span><br>	oldoverflow *[]*bmap       <span class="hljs-comment">// keeps overflow buckets of hmap.oldbuckets alive</span><br>	<span class="hljs-comment">// 起始遍历的 bucket 编号</span><br>    startBucket <span class="hljs-keyword">uintptr</span><br>    <span class="hljs-comment">// 在迭代过程中开始的桶内偏移，也就是从桶的哪个 cell 开始</span><br>	offset      <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 是否又从头遍历了</span><br>	wrapped     <span class="hljs-keyword">bool</span><br>    <span class="hljs-comment">// B 的大小</span><br>	B           <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 当前 cell 序号</span><br>	i           <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 指向当前的 bucket</span><br>	bucket      <span class="hljs-keyword">uintptr</span><br>    <span class="hljs-comment">// 因为扩容需要检查的 bucket</span><br>	checkBucket <span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>mapinterinit</code> 函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// mapiterinit 初始化用于在 map 上进行遍历的 hiter 结构</span><br><span class="hljs-comment">// it 指向的 hiter 结构由编译器顺序传递在堆栈上分配, 或者由 reflect_mapiterinit 在堆上分配</span><br><span class="hljs-comment">// 由于结构包含指针, 因此两者都需要将 hiter 归零</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapiterinit</span><span class="hljs-params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;<br>    <span class="hljs-comment">// 如果开启了竞态检测 -race</span><br>	<span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>		callerpc := getcallerpc()<br>		racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit))<br>	&#125;<br><br>    <span class="hljs-comment">// hmap 不存在 或者 hmap 没有存储数据</span><br>	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>    <span class="hljs-comment">// hiter 的大小是 12 个系统指针大小。在 cmd/compile/internal/gc/reflect.go:hiter() 当中有这样的体现</span><br>	<span class="hljs-keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/sys.PtrSize != <span class="hljs-number">12</span> &#123;<br>		throw(<span class="hljs-string">"hash_iter size incorrect"</span>) <span class="hljs-comment">// see cmd/compile/internal/gc/reflect.go</span><br>	&#125;<br>	it.t = t<br>	it.h = h<br><br>	<span class="hljs-comment">// 抓取桶状态快照</span><br>	it.B = h.B<br>	it.buckets = h.buckets<br>	<span class="hljs-keyword">if</span> t.bucket.ptrdata == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 重新分配 overflow </span><br>        <span class="hljs-comment">// 并在 hiter 中存储指向当前 h.extra.overflow 和 h.extra.oldoverflow.</span><br>        <span class="hljs-comment">// 这样在迭代的过程中, 不论 table 的增长还是有新的 overflow buckets 被添加到 table 当中</span><br>        <span class="hljs-comment">// 都可以让 overflow bucket 处于活动状态</span><br>		h.createOverflow()<br>		it.overflow = h.extra.overflow<br>		it.oldoverflow = h.extra.oldoverflow<br>	&#125;<br><br>    <span class="hljs-comment">// 随机迭代的关键代码</span><br>	<span class="hljs-comment">// 生成随机数</span><br>	r := <span class="hljs-keyword">uintptr</span>(fastrand())<br>	<span class="hljs-keyword">if</span> h.B &gt; <span class="hljs-number">31</span>-bucketCntBits &#123;<br>        <span class="hljs-comment">// 在 B&gt;28 时, 增加一个偏移量</span><br>		r += <span class="hljs-keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="hljs-number">31</span><br>	&#125;<br>    <span class="hljs-comment">// 确定从哪个 bucket 开始遍历</span><br>    <span class="hljs-comment">// bucketMask(h.B)	返回 2^B-1，也就是桶的数量-1</span><br>	it.startBucket = r &amp; bucketMask(h.B)<br>    <span class="hljs-comment">// 确定从哪个 bucket 的哪个 cell 开始遍历</span><br>	it.offset = <span class="hljs-keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="hljs-number">1</span>))<br><br>	<span class="hljs-comment">// iterator state</span><br>	it.bucket = it.startBucket<br><br>	<span class="hljs-comment">// 标记当前的迭代器</span><br>	<span class="hljs-comment">// 多个迭代器可以同事运行</span><br>	<span class="hljs-keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;<br>		atomic.Or8(&amp;h.flags, iterator|oldIterator)<br>	&#125;<br><br>    <span class="hljs-comment">// 开始进行迭代</span><br>	mapiternext(it)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面的代码实现中，例如，B = 2，那 <code>bucketMask(h.B)</code> 结果就是 3，低 8 位为 <code>00000011</code>，将 r 与之相与，就可以得到一个 <code>0~3</code> 的 bucket 序号；<code>bucketCnt - 1</code> 等于 7，低 8 位为 <code>00000111</code>，将 r 右移 2 位后，与 7 相与，就可以得到一个 <code>0~7</code> 号的 cell。</p>
<p>于是，在 <code>mapiternext</code> 函数中就会从 <code>it.startBucket</code> 的 <code>it.offset</code> 号的 <code>cell</code> 开始遍历，取出其中的 <code>key</code> 和 <code>value</code>，直到又回到起点 <code>bucket</code>，完成遍历过程。</p>
<p>源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。</p>
<p>接下来看看遍历的过程，<code>mapiternext</code> 的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapiternext</span><span class="hljs-params">(it *hiter)</span></span> &#123;<br>	h := it.h<br>    <span class="hljs-comment">// 如果开启了竞态检测 -race</span><br>	<span class="hljs-keyword">if</span> raceenabled &#123;<br>		callerpc := getcallerpc()<br>		racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext))<br>	&#125;<br>    <span class="hljs-comment">// 检测当前是不是有 groutine 在进行写入，有的话直接抛出错误</span><br>	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>		throw(<span class="hljs-string">"concurrent map iteration and map write"</span>)<br>	&#125;<br>   	<br>    <span class="hljs-comment">// 获取相应的元素</span><br>	t := it.t<br>	bucket := it.bucket<br>	b := it.bptr<br>	i := it.i<br>	checkBucket := it.checkBucket<br><br>next:<br>    <span class="hljs-comment">// current bucket 为 nil, 第一次或者最后一次迭代</span><br>	<span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 当前的 bucket 是开始的 bucket 并且已经遍历过了</span><br>		<span class="hljs-keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;<br>			<span class="hljs-comment">// end of iteration</span><br>			it.key = <span class="hljs-literal">nil</span><br>			it.elem = <span class="hljs-literal">nil</span><br>			<span class="hljs-keyword">return</span><br>		&#125;<br>        <span class="hljs-comment">// 如果迭代器是在增长过程中启动的，尚未完成增长。</span><br>        <span class="hljs-comment">// 并且要查看的存储桶尚未装满（即尚未撤离旧存储桶），</span><br>        <span class="hljs-comment">// 则需要遍历旧存储桶，仅返回将要迁移到该存储桶的旧存储桶的值。 </span><br>        <span class="hljs-comment">// 也就是像上面的例子，仅仅只能取出老 1 号 bucket 中那些在裂变之后，分配到新 1 号 bucket 中的那些 key。</span><br>		<span class="hljs-keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;<br>            <span class="hljs-comment">// 按位与操作，根据 bucket 新增位是 1 还是 0 判断分配到哪里，</span><br>            <span class="hljs-comment">// 0 的是需要遍历的（见扩容原理）</span><br>            oldbucket := bucket &amp; it.h.oldbucketmask()<br>			b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>			<span class="hljs-comment">// 判断当前 bucket 是否已经搬迁了</span><br>            <span class="hljs-keyword">if</span> !evacuated(b) &#123;<br>                <span class="hljs-comment">// 如果还没有完成搬迁，则当前 bucket 不需要遍历，后面会跳到 oldbucket 中遍历</span><br>				checkBucket = bucket<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 还没后完成搬迁，则当前 bucket 不需要遍历</span><br>				b = (*bmap)(add(it.buckets, bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>				checkBucket = noCheck<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 正常情况，没有发生扩容时的遍历</span><br>			b = (*bmap)(add(it.buckets, bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>			checkBucket = noCheck<br>		&#125;<br>		bucket++<br>        <span class="hljs-comment">// 到了顺序上的最后一个 bucket，置 0 继续遍历</span><br>		<span class="hljs-keyword">if</span> bucket == bucketShift(it.B) &#123;<br>			bucket = <span class="hljs-number">0</span><br>			it.wrapped = <span class="hljs-literal">true</span><br>		&#125;<br>		i = <span class="hljs-number">0</span><br>	&#125;<br>    <span class="hljs-comment">// 遍历当前 bucket 的 cell</span><br>	<span class="hljs-keyword">for</span> ; i &lt; bucketCnt; i++ &#123;<br>		offi := (i + it.offset) &amp; (bucketCnt - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// </span><br>		<span class="hljs-keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;<br>			<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> emptyRest is hard to use here, as we start iterating</span><br>			<span class="hljs-comment">// in the middle of a bucket. It's feasible, just tricky.</span><br>            <span class="hljs-comment">// 当前的 cell 状态是 emptyRest, emptyOne(空), evacuatedEmpty(迁移前是emptyRest, emptyOne)</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>        <span class="hljs-comment">// 获取 k,e 分别对应 key 和 value 的内存地址</span><br>		k := add(unsafe.Pointer(b), dataOffset+<span class="hljs-keyword">uintptr</span>(offi)*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>		<span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>			k = *((*unsafe.Pointer)(k))<br>		&#125;<br>		e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+<span class="hljs-keyword">uintptr</span>(offi)*<span class="hljs-keyword">uintptr</span>(t.elemsize))<br>		<span class="hljs-comment">// 去掉需要忽略的特殊情况，也就是增量扩容的情况</span><br>        <span class="hljs-keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;<br>            <span class="hljs-comment">// 特殊情况：需要遍历 oldbucket 的场景</span><br>            <span class="hljs-comment">// 遍历 oldbucket，跳过将要转到另一个新 bucket 的任何键（在增长过程中，每个 oldbucket 会扩展到两个 bucket 中）。</span><br>            <span class="hljs-comment">// reflexivekey() // true if k==k for all keys</span><br>			<span class="hljs-keyword">if</span> t.reflexivekey() || t.key.equal(k, k) &#123;<br>				<span class="hljs-comment">// 如果 oldbucket 中的 cell 不是搬移到迭代中的当前新存储桶的, 则将其跳过.</span><br>				hash := t.hasher(k, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>				<span class="hljs-keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">// 如果 k！= k(也就是 key 值是 NaNs 的特殊情况), 则 hash 不可重复. 这里需要对迁移期间发送 NaN 的方向进行可重复且随机的选择.</span><br>                <span class="hljs-comment">// 这里将使用低位的 tophash 来决定 NaN 的走法.</span><br>                <span class="hljs-comment">// 注意: 这种情况就是为什么我们需要两个迁移值, 即 evacuatedX 和 evacuatedY, 它们的低位不同.</span><br>				<span class="hljs-keyword">if</span> checkBucket&gt;&gt;(it.B<span class="hljs-number">-1</span>) != <span class="hljs-keyword">uintptr</span>(b.tophash[offi]&amp;<span class="hljs-number">1</span>) &#123;<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>			&#125;<br>		&#125;<br>        <span class="hljs-comment">// 遍历, 获取对应的 k, v   </span><br>		<span class="hljs-keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||<br>			!(t.reflexivekey() || t.key.equal(k, k)) &#123;<br>			<span class="hljs-comment">// 特殊情况: </span><br>            <span class="hljs-comment">// 在正常状况(没有发生map扩容[增量方式])下进行遍历也称为 golden data; </span><br>            <span class="hljs-comment">// 或者</span><br>            <span class="hljs-comment">// key != key (只能发生 key=NANs 的状况下), 这些 key 是没法更新和删除的, 只能在遍历的时候返回。</span><br>			it.key = k<br>			<span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>				e = *((*unsafe.Pointer)(e))<br>			&#125;<br>			it.elem = e<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 自从启动迭代器以来，哈希表已经增长。这个 key 的 value 现在位于其他位置。</span><br>            <span class="hljs-comment">// 检查当前哈希表中的数据。</span><br>            <span class="hljs-comment">// 此代码处理 key 已被删除，更新，删除或重新插入的情况。</span><br>            <span class="hljs-comment">// 注意：这里需要重新注册 key ，因为它可能已更新为 equal（）相同但不相同的 key（例如+0.0与-0.0）。</span><br>			rk, re := mapaccessK(t, h, k)<br>			<span class="hljs-keyword">if</span> rk == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// key 已经被删除</span><br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			it.key = rk<br>			it.elem = re<br>		&#125;<br>        <span class="hljs-comment">// 后续处理</span><br>		it.bucket = bucket<br>		<span class="hljs-keyword">if</span> it.bptr != b &#123; <span class="hljs-comment">// avoid unnecessary write barrier; see issue 14921</span><br>			it.bptr = b<br>		&#125;<br>		it.i = i + <span class="hljs-number">1</span><br>		it.checkBucket = checkBucket<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	b = b.overflow(t)<br>	i = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">goto</span> next<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在上面的遍历过程中有一个特殊情况，如果碰到 key 是 <code>math.NaN()</code> 这种的，处理方式要看它被分裂后具体落入哪个 <code>bucket</code>。只不过只用看它 <code>tophash</code> 的最低位。如果 <code>tophash</code> 的最低位是 0 ，分配到 <code>X part</code>；如果是 1 ，则分配到 <code>Y part</code>。据此决定是否取出 <code>key</code>，放到遍历结果集里。</p>
<p>map 遍历的核心在于理解 2 倍扩容时，老 <code>bucket</code> 会分裂到 2 个新 <code>bucket</code> 中去。而遍历操作，会按照新 <code>bucket</code> 的序号顺序进行，碰到老 <code>bucket</code> 未搬迁的情况时，要在老 <code>bucket</code> 中找到将来要搬迁到新 <code>bucket</code> 来的 key。也就是上面说的当发生了增量扩容时，一个老的 <code>bucket</code> 数据可能会分裂到两个不同的 <code>bucket</code> 中去，那么此时，如果需要从老的 <code>bucket</code> 中遍历数据，例如 1 号，则不能将老 1 号 <code>bucket</code> 中的数据全部取出，仅仅只能取出老 1 号 <code>bucket</code> 中那些在裂变之后，分配到新 1 号 <code>bucket</code> 中的那些 <code>key</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 Map 的相关实现原理，可以看到，它并不是一个并发安全的数据结构。同时对 map 进行读写时，程序很容易出错。因此，要想在并发情况下使用 map，可以加上锁（<code>sync.Mutex</code> 或者 <code>sync.RwMutex</code>）。其实，Go 标准库中已经实现了并发安全的 map——<code>sync.Map</code>。</p>
<p>遍历 map 的结果是无序的，在使用中，应该注意到该点。</p>
<p>通过 map 的结构体可以知道，它其实是通过指针指向底层 buckets 数组。所以和 slice 一样，尽管 go 函数都是值传递，但是，当 map 作为参数被函数调用时，在函数内部对 map 的操作同样会影响到外部的map。</p>
<p>另外，有个特殊的 key 值 <code>math.NaN</code>，它每次生成的哈希值是不一样的，这会造成 <code>m[math.NaN]</code> 是拿不到值的，而且多次对它赋值，会让 map 中存在多个 <code>math.NaN</code> 的 key。</p>
<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<p>对于下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">return</span> a + b, a - b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	myFunction(<span class="hljs-number">66</span>, <span class="hljs-number">77</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>main</code> 函数在调用 <code>myFunction</code> 之前会先通过汇编指令 <code>SUBQ $40, SP</code> 指令在栈上分配了 40 字节的内存空间，分配如下的栈结构：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A81.png" alt="函数调用1"></p>
<p>相应的大小和用途如下：</p>
<table>
<thead>
<tr>
<th>空间</th>
<th>大小</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SP+32 ~ BP</td>
<td>8 字节</td>
<td><code>main</code> 函数的栈基址指针</td>
</tr>
<tr>
<td>SP+16 ~ SP+32</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个返回值</td>
</tr>
<tr>
<td>SP ~ SP+16</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个参数</td>
</tr>
</tbody></table>
<p>当入参时，入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 <code>SP ~ SP+8</code>，第二个参数存储在 <code>SP+8 ~ SP+16</code> 的空间中。</p>
<p>当准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并执行 <code>myFunction</code> 的汇编指令。</p>
<p><code>muFunction</code> 函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82.png" alt="函数调用2"></p>
<p><strong>图 4-3 myFunction 函数返回前的栈</strong></p>
<p>在 <code>myFunction</code> 返回后，<code>main</code> 函数会恢复栈基址指针并销毁已经失去作用的 40 字节栈内存。</p>
<h2 id="跟-C-语言对比"><a href="#跟-C-语言对比" class="headerlink" title="跟 C 语言对比"></a>跟 C 语言对比</h2><p>C 语言和 Go 语言在设计函数的调用惯例时选择了不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。这两种设计的优点和缺点如下：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li><strong>CPU 访问栈的开销比访问寄存器高几十倍</strong>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><strong>Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。</p>
<h3 id="整型和数组"><a href="#整型和数组" class="headerlink" title="整型和数组"></a>整型和数组</h3><p>如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, arr [2]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	i := <span class="hljs-number">30</span><br>	arr := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;<br>	fmt.Printf(<span class="hljs-string">"before calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)<br>	myFunction(i, arr)<br>	fmt.Printf(<span class="hljs-string">"after  calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc0000b2008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc0000b2010</span>)<br>in my_funciton - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc0000b2028</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc0000b2040</span>)<br>after  calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc0000b2008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc0000b2010</span>)<br></code></pre></div></td></tr></table></figure>

<p>当通过命令运行这段代码时会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p>
<p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。</p>
<p>如果在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？这里更新 <code>myFunction</code> 函数并重新执行这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, arr [2]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>	i = <span class="hljs-number">29</span><br>	arr[<span class="hljs-number">1</span>] = <span class="hljs-number">88</span><br>	fmt.Printf(<span class="hljs-string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc00012a008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc00012a010</span>)<br>in my_funciton - i=(<span class="hljs-number">29</span>, <span class="hljs-number">0xc00012a028</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">88</span>], <span class="hljs-number">0xc00012a040</span>)<br>after  calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc00012a008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc00012a010</span>)<br></code></pre></div></td></tr></table></figure>

<p>可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以能得出如下结论：<strong>Go 语言的整型和数组类型都是值传递的，也就是在调用函数时会对内容进行拷贝。需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成比较大的影响。</strong></p>
<h3 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h3><p>下面这段代码中定义了一个结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>	i <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(a MyStruct, b *MyStruct)</span></span> &#123;<br>	a.i = <span class="hljs-number">31</span><br>	b.i = <span class="hljs-number">41</span><br>	fmt.Printf(<span class="hljs-string">"in my_function - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	a := MyStruct&#123;i: <span class="hljs-number">30</span>&#125;<br>	b := &amp;MyStruct&#123;i: <span class="hljs-number">40</span>&#125;<br>	fmt.Printf(<span class="hljs-string">"before calling - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)<br>	myFunction(a, b)<br>	fmt.Printf(<span class="hljs-string">"after calling  - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - a=(&#123;<span class="hljs-number">30</span>&#125;, <span class="hljs-number">0xc0000b2008</span>) b=(&amp;&#123;<span class="hljs-number">40</span>&#125;, <span class="hljs-number">0xc0000ac018</span>)<br>in my_function - a=(&#123;<span class="hljs-number">31</span>&#125;, <span class="hljs-number">0xc0000b2028</span>) b=(&amp;&#123;<span class="hljs-number">41</span>&#125;, <span class="hljs-number">0xc0000ac028</span>)<br>after calling  - a=(&#123;<span class="hljs-number">30</span>&#125;, <span class="hljs-number">0xc0000b2008</span>) b=(&amp;&#123;<span class="hljs-number">41</span>&#125;, <span class="hljs-number">0xc0000ac018</span>)<br></code></pre></div></td></tr></table></figure>

<p>从上述运行的结果可以得出如下结论：</p>
<ul>
<li>传递结构体时：会拷贝结构体中的全部内容；</li>
<li>传递结构体指针时：会拷贝结构体指针；</li>
</ul>
<p>修改结构体指针是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。</p>
<p>简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>	i <span class="hljs-keyword">int</span><br>	j <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(ms *MyStruct)</span></span> &#123;<br>	ptr := unsafe.Pointer(ms)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>		c := (*<span class="hljs-keyword">int</span>)(unsafe.Pointer((<span class="hljs-keyword">uintptr</span>(ptr) + <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">8</span>*i))))<br>		*c += i + <span class="hljs-number">1</span><br>		fmt.Printf(<span class="hljs-string">"[%p] %d\n"</span>, c, *c)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	a := &amp;MyStruct&#123;i: <span class="hljs-number">40</span>, j: <span class="hljs-number">50</span>&#125;<br>	myFunction(a)<br>	fmt.Printf(<span class="hljs-string">"[%p] %v\n"</span>, a, a)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>[<span class="hljs-number">0xc000134010</span>] <span class="hljs-number">41</span><br>[<span class="hljs-number">0xc000134018</span>] <span class="hljs-number">52</span><br>[<span class="hljs-number">0xc000134010</span>] &amp;&#123;<span class="hljs-number">41</span> <span class="hljs-number">52</span>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这段代码中，通过指针修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p>
<p>如果将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>	i <span class="hljs-keyword">int</span><br>	j <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(ms *MyStruct)</span> *<span class="hljs-title">MyStruct</span></span> &#123;<br>	<span class="hljs-keyword">return</span> ms<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> tool compile -S -N -l main.<span class="hljs-keyword">go</span><br><span class="hljs-string">""</span>.myFunction STEXT nosplit size=<span class="hljs-number">20</span> args=<span class="hljs-number">0x10</span> locals=<span class="hljs-number">0x0</span><br>	<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>)	MOVQ	$<span class="hljs-number">0</span>, <span class="hljs-string">""</span>.~r1+<span class="hljs-number">16</span>(SP) <span class="hljs-comment">// 初始化返回值</span><br>	<span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)	MOVQ	<span class="hljs-string">""</span>.ms+<span class="hljs-number">8</span>(SP), AX   <span class="hljs-comment">// 复制引用</span><br>	<span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)	MOVQ	AX, <span class="hljs-string">""</span>.~r1+<span class="hljs-number">16</span>(SP) <span class="hljs-comment">// 返回引用</span><br>	<span class="hljs-number">0x0013</span> <span class="hljs-number">00019</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)	RET<br></code></pre></div></td></tr></table></figure>

<p>在这段汇编语言中，当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令复制引用，然后将复制后的指针作为返回值传递回调用方。根据上面函数调用的原理，可以知道此时栈内的结构如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A83.png" alt="函数调用3"></p>
<p>所以将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
<p>需要注意，在传递数组或者内存占用非常大的结构体时，应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Go 语言中接口的实现都是隐式的，只需要实现接口中的方法就相当于实现了接口。<strong>Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查</strong>。例如有以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>	Error() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> RPCError <span class="hljs-keyword">struct</span> &#123;<br>	Code    <span class="hljs-keyword">int64</span><br>	Message <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// *RPCError 实现了 error 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *RPCError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%s, code=%d"</span>, e.Message, e.Code)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> rpcErr error = NewRPCError(<span class="hljs-number">400</span>, <span class="hljs-string">"unknown err"</span>) <span class="hljs-comment">// 赋值进行类型检查1</span><br>	err := AsErr(rpcErr) <span class="hljs-comment">// 传参进行类型检查</span><br>	<span class="hljs-built_in">println</span>(err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRPCError</span><span class="hljs-params">(code <span class="hljs-keyword">int64</span>, msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;RPCError&#123; <span class="hljs-comment">// 参数返回类型检查</span><br>		Code:    code,<br>		Message: msg,<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AsErr</span><span class="hljs-params">(err error)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Go 语言在编译期间会对代码进行类型检查，上面的代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才检查类型，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface{}</code>：</p>
<p>Go 语言使用 <code>runtime.iface</code> 表示第一种接口，使用 <code>runtime.eface</code> 表示第二种不包含任何方法的接口 <code>interface{}</code>，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface{}</code> 类型不是任意类型。如果将类型转换成了 <code>interface{}</code> 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 <code>interface{}</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span>&#123;&#125;<br>	v := Test&#123;&#125;<br>	Print(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-built_in">println</span>(v)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面 <code>Print</code> 函数不接受任意类型的参数，只接受 <code>interface{}</code> 类型的值，在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface{}</code> 类型。</p>
<h2 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h2><p>下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;&#125;<br><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c  Cat)</span> <span class="hljs-title">Quack</span></span> &#123;&#125;  <span class="hljs-comment">// 使用结构体实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">Quack</span></span> &#123;&#125;  <span class="hljs-comment">// 使用结构体指针实现接口</span><br><br><span class="hljs-keyword">var</span> d Duck = Cat&#123;&#125;      <span class="hljs-comment">// 使用结构体初始化变量</span><br><span class="hljs-keyword">var</span> d Duck = &amp;Cat&#123;&#125;     <span class="hljs-comment">// 使用结构体指针初始化变量</span><br></code></pre></div></td></tr></table></figure>

<p>实现接口的类型和初始化返回的类型两个维度共组成了四种情况，然而这四种情况不是都能通过编译器的检查：</p>
<table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th>结构体指针实现接口</th>
</tr>
</thead>
<tbody><tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td>不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td>通过</td>
</tr>
</tbody></table>
<p>四种中只有使用指针实现接口，使用结构体初始化变量无法通过编译，其他的三种情况都可以正常执行。</p>
<p>也就是说，<strong>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法</strong></p>
<p>对于方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">Quack</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">"meow"</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> c Duck = &amp;Cat&#123;&#125;<br>	c.Quack()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>作为指针的 <code>&amp;Cat{}</code> 变量能够<strong>隐式地获取</strong>到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。表面上看，<code>*Cat</code> 类型并没有实现 <code>Quack</code> 方法，但是因为 <code>Cat</code> 类型实现了 <code>Quack</code> 方法，所以让 <code>*Cat</code> 类型自动拥有了 <code>Quack</code> 方法。</p>
<p>但是如果将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123;<br>	Quack()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">Quack</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">"meow"</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> c Duck = Cat&#123;&#125;<br>	c.Quack()<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> build <span class="hljs-keyword">interface</span>.<span class="hljs-keyword">go</span><br>./<span class="hljs-keyword">interface</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span>:<span class="hljs-number">6</span>: cannot use Cat literal (<span class="hljs-keyword">type</span> Cat) as <span class="hljs-keyword">type</span> Duck in assignment:<br>	Cat does not implement Duck (Quack method has pointer receiver)<br></code></pre></div></td></tr></table></figure>

<p>编译器会提醒：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。</p>
<p>原因在于，Go 语言在传递参数时都是传值的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%80%BC%E6%83%85%E5%86%B5.png" alt="指针和接口传值情况"></p>
<p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat{}</code> 还是 <code>&amp;Cat{}</code>，<strong>使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝</strong>：</p>
<ul>
<li>如上图左侧，<strong>对于 <code>&amp;Cat{}</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat{}</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体</strong>；</li>
<li>如上图右侧，<strong>对于 <code>Cat{}</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat{}</code>，因为方法的参数是 <code>Cat</code>，编译器不会无中生有创建一个新的指针</strong>；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>从设计上来说，接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如<strong>果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者</strong>。</p>
<p>因此，当使用指针实现接口时，只有指针类型的变量才会实现该接口；当使用结构体实现接口时，指针类型和结构体类型都会实现该接口。</p>
<h3 id="值接收者和指针接收者应用场景"><a href="#值接收者和指针接收者应用场景" class="headerlink" title="值接收者和指针接收者应用场景"></a>值接收者和指针接收者应用场景</h3><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li><p>方法能够修改接收者指向的值。</p>
</li>
<li><p>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</p>
</li>
</ul>
<p>但是是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<strong>本质</strong>。</p>
<p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p>
<blockquote>
<p>Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作<strong>标头（header）值</strong>。从技术细节上说，字符串也是一种引用类型。</p>
<p>每个引用类型创建的标头值是<strong>包含一个指向底层数据结构的指针</strong>。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。</p>
</blockquote>
<p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。</p>
<h2 id="接口的数据结构"><a href="#接口的数据结构" class="headerlink" title="接口的数据结构"></a>接口的数据结构</h2><p>Go 语言<strong>根据接口类型是否包含一组方法</strong>将接口类型分成了两类：</p>
<ul>
<li>使用 <code>runtime.iface</code> 结构体表示包含方法的接口</li>
<li>使用 <code>runtime.eface</code> 结构体表示不包含任何方法的 <code>interface{}</code> 类型；</li>
</ul>
<h3 id="eface-结构"><a href="#eface-结构" class="headerlink" title="eface 结构"></a>eface 结构</h3><p><code>runtime.eface</code> 结构体在 Go 语言中的定义是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;	<span class="hljs-comment">// 16 字节</span><br>	_type *_type<br>	data  unsafe.Pointer<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>由于 <code>interface{}</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针：维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型；<code>data</code> 描述了具体的值。</p>
<p>从上述结构也能推断出：Go 语言的任意类型都可以转换成 <code>interface{}</code>。</p>
<h3 id="iface-结构"><a href="#iface-结构" class="headerlink" title="iface 结构"></a>iface 结构</h3><p>另一个用于表示接口的结构体是 <code>runtime.iface</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 16 字节</span><br>	tab  *itab<br>	data unsafe.Pointer<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示<strong>接口的类型以及赋给这个接口的实体类型</strong>。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p>
<h4 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h4><p><code>runtime.itab</code> 结构体是接口类型的核心组成部分，每一个 <code>runtime.itab</code> 都占 32 字节，可以将其看成<strong>接口类型</strong>和<strong>具体类型</strong>的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 32 字节</span><br>	inter *interfacetype<br>	_type *_type<br>	hash  <span class="hljs-keyword">uint32</span><br>	_     [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span><br>	fun   [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p><code>inter</code> 字段则描述了接口的类型</p>
</li>
<li><p><code>_type</code> 字段描述了实体的具体类型</p>
</li>
<li><p><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>runtime._type</code> 是否一致；</p>
</li>
<li><p><code>fun</code> 是一个动态大小的数组，用于放置和接口方法对应的具体数据类型的方法地址。它是一个用于动态派发的虚函数表，存储了一组函数指针。一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p>
<p>另外，数组大小虽然是 1，但是这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。所以虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code>数组中保存的元素数量是不确定的。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p>
</li>
</ul>
<h4 id="interfacetype"><a href="#interfacetype" class="headerlink" title="interfacetype"></a>interfacetype</h4><p><code>interfacetype</code> 描述的是接口的类型，它的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> interfacetype <span class="hljs-keyword">struct</span> &#123;<br>	typ     _type<br>	pkgpath name<br>	mhdr    []imethod<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。这里需要注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p>
<h4 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h4><p><code>runtime._type</code> 是 Go 语言类型的运行时表示。它描述了实体的类型，包括内存对齐方式，大小等。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<blockquote>
<p>注意这里的 hash 值是根据类型、方法生成的，与 data 内容无关</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 存储了类型占用的内存空间，为内存空间的分配提供信息</span><br>	size       <span class="hljs-keyword">uintptr</span><br>	ptrdata    <span class="hljs-keyword">uintptr</span><br>    <span class="hljs-comment">// 类型的 hash 值，能够快速确定类型是否相等</span><br>	hash       <span class="hljs-keyword">uint32</span><br>    <span class="hljs-comment">// 类型的 flag，和反射相关</span><br>	tflag      tflag<br>    <span class="hljs-comment">// 内存对齐相关</span><br>	align      <span class="hljs-keyword">uint8</span><br>	fieldAlign <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 类型的编号，有 bool, slice, struct 等等等等</span><br>	kind       <span class="hljs-keyword">uint8</span><br>    <span class="hljs-comment">// 用于判断当前类型的多个对象是否相等，</span><br>    <span class="hljs-comment">// 该字段是为了减少 Go 语言二进制包大小从 `typeAlg` 结构体中迁移过来的</span><br>	equal      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="hljs-title">bool</span></span><br>    <span class="hljs-comment">// gc 相关</span><br>	gcdata     *<span class="hljs-keyword">byte</span><br>	str        nameOff<br>	ptrToThis  typeOff<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> arraytype <span class="hljs-keyword">struct</span> &#123;    <br>    typ   _type    <br>    elem  *_type    <br>    slice *_type    <br>    <span class="hljs-built_in">len</span>   <span class="hljs-keyword">uintptr</span><br>&#125;<br><span class="hljs-keyword">type</span> chantype <span class="hljs-keyword">struct</span> &#123;    <br>    typ  _type    <br>    elem *_type    <br>    dir  <span class="hljs-keyword">uintptr</span><br>&#125;<br><span class="hljs-keyword">type</span> slicetype <span class="hljs-keyword">struct</span> &#123;    <br>    typ  _type    <br>    elem *_type<br>&#125;<br><span class="hljs-keyword">type</span> structtype <span class="hljs-keyword">struct</span> &#123;    <br>    typ     _type    <br>    pkgPath name    <br>    fields  []structfield<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这些数据类型的结构体定义，是反射实现的基础。</p>
<p>整体来说，iface 的结构如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/iface%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="iface整体结构"></p>
<h2 id="接口的动态类型和动态值"><a href="#接口的动态类型和动态值" class="headerlink" title="接口的动态类型和动态值"></a>接口的动态类型和动态值</h2><p>从上面的数据结构可以看到，<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<strong>动态类型</strong>和<strong>动态值</strong>。而<strong>接口值包括动态类型和动态值</strong>。</p>
<p>接口值的零值是指动态类型和动态值都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p>
<p>例如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coder <span class="hljs-keyword">interface</span> &#123;<br>    code()<br>&#125;<br><br><span class="hljs-keyword">type</span> Gopher <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g Gopher)</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">"%s is coding\n"</span>, g.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c Coder<br>    fmt.Println(c == <span class="hljs-literal">nil</span>)<br>    fmt.Printf(<span class="hljs-string">"c: %T, %v\n"</span>, c, c)<br><br>    <span class="hljs-keyword">var</span> g *Gopher<br>    fmt.Println(g == <span class="hljs-literal">nil</span>)<br><br>    c = g<br>    fmt.Println(c == <span class="hljs-literal">nil</span>)<br>    fmt.Printf(<span class="hljs-string">"c: %T, %v\n"</span>, c, c)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">true<br>c: &lt;nil&gt;, &lt;nil&gt;<br>true<br>false<br>c: *main.Gopher, &lt;nil&gt;<br></code></pre></div></td></tr></table></figure>

<p>一开始，<code>c</code> 的动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p>
<p>再看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> TestStruct <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NilOrNot</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> v == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> s *TestStruct<br>	fmt.Println(s == <span class="hljs-literal">nil</span>)      <span class="hljs-comment">// #=&gt; true</span><br>	fmt.Println(NilOrNot(s))   <span class="hljs-comment">// #=&gt; false</span><br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>

<p>简单总结一下上述代码执行的结果：</p>
<ul>
<li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li>
<li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li>
</ul>
<p>出现上述现象的原因是： 调用 <code>NilOrNot</code> 函数时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>TestStruct</code> 类型会转换成 <code>interface{}</code> 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。 </p>
<h2 id="编译器自动检测类型是否实现接口"><a href="#编译器自动检测类型是否实现接口" class="headerlink" title="编译器自动检测类型是否实现接口"></a>编译器自动检测类型是否实现接口</h2><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)<br></code></pre></div></td></tr></table></figure>

<p>这种做法是为了让编译器由此检查 <code>myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p>
<p>下面有个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"io"</span><br><br><span class="hljs-keyword">type</span> myWriter <span class="hljs-keyword">struct</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;    <br>	return<br>&#125;*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <br>    <span class="hljs-comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口    </span><br>    <span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)<br>    <br>    <span class="hljs-comment">// 检查 myWriter 类型是否实现了 io.Writer 接口    </span><br>    <span class="hljs-keyword">var</span> _ io.Writer = myWriter&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>注释掉为 <code>myWriter</code> 定义的 <code>Write</code> 函数后，运行程序：</p>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">src/main.go:14:6: cannot use (*myWriter)(<span class="hljs-literal">nil</span>) (type *myWriter) as<span class="hljs-built_in"> type </span>io.Writer <span class="hljs-keyword">in</span> assignment:    <br>	*myWriter does <span class="hljs-keyword">not</span> implement io.Writer (missing Write method)<br>src/main.go:15:6: cannot use myWriter literal (type myWriter) as<span class="hljs-built_in"> type </span>io.Writer <span class="hljs-keyword">in</span> assignment:    <br>	myWriter does <span class="hljs-keyword">not</span> implement io.Writer (missing Write method)<br></code></pre></div></td></tr></table></figure>

<p>报错信息：<code>*myWriter/myWriter</code> 未实现 <code>io.Writer</code> 接口，也就是未实现 <code>Write</code> 方法。</p>
<p>解除注释后，运行程序不报错。</p>
<p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p>
<p>总结一下，<em>可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</em></p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)<span class="hljs-keyword">var</span> _ io.Writer = myWriter&#123;&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p>
<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>需要反射的 2 个常见场景：</p>
<ol>
<li>有时需要编写一个函数，但是并不知道传给函数的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li>
<li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li>
</ol>
<p>但是使用反射也存在一定的风险：</p>
<ol>
<li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li>
<li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li>
<li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，<strong>对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性</strong>。</li>
</ol>
<h2 id="反射的三大法则"><a href="#反射的三大法则" class="headerlink" title="反射的三大法则"></a>反射的三大法则</h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码，但是过量的使用反射会使程序逻辑变得难以理解并且运行缓慢。在 Go 官方关于反射的博客中提到，反射有三大定律：</p>
<ol>
<li><p>从 <code>interface{}</code> 变量可以反射出反射对象；</p>
</li>
<li><p>从反射对象可以获取 <code>interface{}</code> 变量；</p>
</li>
<li><p>要修改反射对象，其值必须可设置；</p>
</li>
</ol>
<h3 id="第一法则"><a href="#第一法则" class="headerlink" title="第一法则"></a>第一法则</h3><p>反射是一种检测存储在 <code>interface</code> 中的类型和值机制。这可以通过 <code>TypeOf</code> 函数和 <code>ValueOf</code> 函数得到。</p>
<p>反射的第一法则是能将 Go 语言的 <code>interface{}</code> 变量转换成反射对象。这里之所以说是 <code>interface</code> ，是因为当执行如 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是<strong>由于 <code>reflect.TypeOf</code>、<code>reflect.ValueOf</code> 两个方法的入参都是 <code>interface{}</code> 类型，所以在方法执行的过程中发生了类型转换。</strong>所以实际上都是从 <code>interface{}</code> 中反射对象。</p>
<p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是从接口到反射对象。</p>
<p>上面提到的 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数就能完成这里的转换，如果认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。</p>
<h3 id="第二法则"><a href="#第二法则" class="headerlink" title="第二法则"></a>第二法则</h3><p>第二条实际上和第一条是相反的机制，它将 <code>ValueOf</code> 的返回值通过 <code>Interface()</code> 函数反向转变成 <code>interface</code> 变量。</p>
<p>反射的第二法则是可以从反射对象可以获取 <code>interface{}</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code> 中的 <code>reflect.Value.Interface</code> 就能完成这项工作。</p>
<p>不过调用 <code>reflect.Value.Interface</code> 方法只能获得 <code>interface{}</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v := reflect.ValueOf(<span class="hljs-number">1</span>)<br>v.Interface().(<span class="hljs-keyword">int</span>)<br></code></pre></div></td></tr></table></figure>

<p>第一第二法则就是说接口型变量和反射类型对象可以相互转化，反射类型对象实际上就是指的前面说的<code>reflect.Type</code> 和 <code>reflect.Value</code>。</p>
<h3 id="第三法则"><a href="#第三法则" class="headerlink" title="第三法则"></a>第三法则</h3><p>如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，所以第二种情况在语言层面是不被允许的。</p>
<p>举一个经典例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.4</span><br>v := reflect.ValueOf(x)<br>v.SetFloat(<span class="hljs-number">7.1</span>) <span class="hljs-comment">// Error: will panic.</span><br></code></pre></div></td></tr></table></figure>

<p>执行上面的代码会产生 panic，原因是反射变量 <code>v</code> 不能代表 <code>x</code> 本身，因为调用 <code>reflect.ValueOf(x)</code> 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 <code>v</code> 代表的只是 <code>x</code> 的一个拷贝，因此对 <code>v</code> 进行操作是被禁止的。</p>
<p>可设置是反射变量 <code>Value</code> 的一个性质，但不是所有的 <code>Value</code> 都是可被设置的。</p>
<p>就像在一般的函数里那样，当想改变传入的变量时，使用指针就可以解决了。但是在反射中：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.4</span><br>p := reflect.ValueOf(&amp;x)<br>fmt.Println(<span class="hljs-string">"type of p:"</span>, p.Type())<br>fmt.Println(<span class="hljs-string">"settability of p:"</span>, p.CanSet())<br></code></pre></div></td></tr></table></figure>

<p>输出是这样的：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">type of p:</span> <span class="hljs-meta">*float64</span><br><span class="hljs-attr">settability of p:</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>

<p>也就是说即使使用指针，<code>p</code> 还不是代表 <code>x</code>，这只是 <code>x</code> 的指针，<code>p.Elem()</code> 才真正代表 <code>x</code>（相当于解引用），这样就可以真正操作 <code>x</code> 了：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v := p.Elem()<br>v.SetFloat(<span class="hljs-number">7.1</span>)<br>fmt.Println(v.Interface()) <span class="hljs-comment">// 7.1</span><br>fmt.Println(x) <span class="hljs-comment">// 7.1</span><br></code></pre></div></td></tr></table></figure>

<p>关于第三条，记住一句话：如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p>
<h2 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h2><p>当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，<strong>反射就是通过接口的类型信息实现的，反射建立在类型的基础上</strong>。</p>
<p>Go 语言在 <code>reflect</code> 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。</p>
<h3 id="types-和-interface"><a href="#types-和-interface" class="headerlink" title="types 和 interface"></a>types 和 interface</h3><p>Go 语言中，每个变量都有一个静态类型，也就是声明时候的类型。这是在编译阶段就确定了的，比如 <code>int, float64, []int</code> 等等。注意，这个类型是声明时候的类型，不是底层数据类型。</p>
<p>Go 官方博客里就举了一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> j MyInt<br></code></pre></div></td></tr></table></figure>

<p>尽管 i，j 的底层类型都是 int，但他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 <code>MyInt</code>。</p>
<p>反射主要与 <code>interface{}</code> 类型相关。上面的接口一节已经列出了 <code>interface</code> 的底层结构，即 <code>iface</code> 和 <code>eface</code> 。</p>
<p><code>iface</code> 描述的是非空接口，它包含方法；</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>	tab  *itab<br>	data unsafe.Pointer<br>&#125;<br><br><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>	inter  *interfacetype<br>	_type  *_type<br>	link   *itab<br>	hash   <span class="hljs-keyword">uint32</span><br>	bad    <span class="hljs-keyword">bool</span><br>	inhash <span class="hljs-keyword">bool</span><br>	unused [<span class="hljs-number">2</span>]<span class="hljs-keyword">byte</span><br>	fun    [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其中 <code>itab</code> 由具体类型 <code>_type</code> 以及 <code>interfacetype</code> 组成。<code>_type</code> 表示具体类型，而 <code>interfacetype</code> 则表示具体类型实现的接口类型。</p>
<p>与之相对的是 <code>eface</code>，描述的是空接口，不包含任何方法，Go 语言里有的类型都实现了空接口。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>    _type *_type<br>    data  unsafe.Pointer<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>它只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p>
<p>需要明确的一点：<strong>接口变量可以存储任何实现了接口定义的所有方法的变量</strong>。</p>
<p>Go 语言中最常见的就是 <code>Reader</code> 和 <code>Writer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>接下来，就是接口之间的各种转换和赋值了：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> r io.Reader<br>tty, err := os.OpenFile(<span class="hljs-string">"/Users/silverming/test"</span>, os.O_RDWR, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>r = tty<br></code></pre></div></td></tr></table></figure>

<p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，<strong>这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code></strong>。</p>
<p>之后，<code>r = tty</code> 这一语句，<strong>将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</strong></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BE%8B.png" alt="接口变量存储实例"></p>
<p>此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = r.(io.Writer)<br></code></pre></div></td></tr></table></figure>

<p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p>
<p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，*<em>但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> *</em>。<code>w</code> 的内存形式如下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E8%B5%8B%E5%80%BCio.writer.png" alt="使用断言赋值io.writer"></p>
<p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p>
<p>最后，再看一个赋值：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">var</span> <span class="hljs-keyword">empty</span> <span class="hljs-class"><span class="hljs-keyword">interface</span></span>&#123;&#125;<br><span class="hljs-keyword">empty</span> = w<br></code></pre></div></td></tr></table></figure>

<p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E8%B5%8B%E5%80%BC%E7%BB%99%E7%A9%BA%E6%8E%A5%E5%8F%A3.png" alt="赋值给空接口"></p>
<p>从上面的三张图可以看到，<code>interface</code> 包含三部分信息：<code>_type</code> 是类型信息，<code>*data</code> 指向实际类型的实际值，<code>itab</code> 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法）。</p>
<h3 id="emptyInterface"><a href="#emptyInterface" class="headerlink" title="emptyInterface"></a>emptyInterface</h3><p>Go 语言的 <code>interface{}</code> 类型在语言内部是通过 <code>reflect.emptyInterface</code> 结体表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据。</p>
<p>这里的 <code>emptyInterface</code> 和上面提到的 <code>eface</code> 其实是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 <code>reflect</code> 包，后者在 <code>runtime</code> 包。 <code>eface.typ</code> 就是动态类型。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyInterface <span class="hljs-keyword">struct</span> &#123;<br>	typ  *rtype<br>	word unsafe.Pointer<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="TypeOf-方法的实现原理"><a href="#TypeOf-方法的实现原理" class="headerlink" title="TypeOf 方法的实现原理"></a>TypeOf 方法的实现原理</h3><p><code>reflect</code> 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p>
<p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，能获取数据的运行时表示，因此程序员可以获取甚至改变类型的值。</p>
<p><code>reflect</code> 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Type</span></span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Value</span></span><br></code></pre></div></td></tr></table></figure>

<p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface{}</code>，看下源码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Type</span></span> &#123;<br>	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))<br>	<span class="hljs-keyword">return</span> toType(eface.typ)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>调用此函数时，实参会先被转化为 <code>interface{}</code> 类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface{}</code> 变量里了。然后将传入的变量隐式转换成 <code>reflect.emptyInterface</code> 类型，并获取其中存储的类型信息 <code>reflect.rtype</code>。</p>
<p>至于 <code>toType</code> 函数，只是做了一个类型转换：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toType</span><span class="hljs-params">(t *rtype)</span> <span class="hljs-title">Type</span></span> &#123;<br>	<span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="rtype"><a href="#rtype" class="headerlink" title="rtype"></a>rtype</h4><p>首先看看获取的 <code>rtypr</code> ，它和 <code>_type</code> 是一回事，而且源代码里也注释了：两边要保持同步：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// rtype must be kept in sync with ../runtime/type.go:/^type._type.</span><br><span class="hljs-keyword">type</span> rtype <span class="hljs-keyword">struct</span> &#123;<br>	size       <span class="hljs-keyword">uintptr</span><br>	ptrdata    <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of bytes in the type that can contain pointers</span><br>	hash       <span class="hljs-keyword">uint32</span>  <span class="hljs-comment">// hash of type; avoids computation in hash tables</span><br>	tflag      tflag   <span class="hljs-comment">// extra type information flags</span><br>	align      <span class="hljs-keyword">uint8</span>   <span class="hljs-comment">// alignment of variable with this type</span><br>	fieldAlign <span class="hljs-keyword">uint8</span>   <span class="hljs-comment">// alignment of struct field with this type</span><br>	kind       <span class="hljs-keyword">uint8</span>   <span class="hljs-comment">// enumeration for C</span><br>	<span class="hljs-comment">// function for comparing objects of this type</span><br>	<span class="hljs-comment">// (ptr to object A, ptr to object B) -&gt; ==?</span><br>	equal     <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="hljs-title">bool</span></span><br>	gcdata    *<span class="hljs-keyword">byte</span>   <span class="hljs-comment">// garbage collection data</span><br>	str       nameOff <span class="hljs-comment">// string form</span><br>	ptrToThis typeOff <span class="hljs-comment">// type for pointer to this type, may be zero</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>reflect</code> 包下所有的类型都会包含 <code>rtype</code> 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。</p>
<p>比如下面的 <code>arrayType</code> 和 <code>chanType</code> 都包含 <code>rytpe</code>，而前者还包含 slice，len 等和数组相关的信息；后者则包含 <code>dir</code> 表示通道方向的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// arrayType represents a fixed array type.</span><br><span class="hljs-keyword">type</span> arrayType <span class="hljs-keyword">struct</span> &#123;<br>	rtype <span class="hljs-string">`reflect:"array"`</span><br>	elem  *rtype <span class="hljs-comment">// array element type</span><br>	slice *rtype <span class="hljs-comment">// slice type</span><br>	<span class="hljs-built_in">len</span>   <span class="hljs-keyword">uintptr</span><br>&#125;<br><br><span class="hljs-comment">// chanType represents a channel type.</span><br><span class="hljs-keyword">type</span> chanType <span class="hljs-keyword">struct</span> &#123;<br>	rtype <span class="hljs-string">`reflect:"chan"`</span><br>	elem  *rtype  <span class="hljs-comment">// channel element type</span><br>	dir   <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// channel direction (ChanDir)</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="Type-接口的方法"><a href="#Type-接口的方法" class="headerlink" title="Type 接口的方法"></a>Type 接口的方法</h4><p> 注意，<code>TypeOf</code> 函数的返回值 <code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而上面的 <code>*rtype</code> 实现了 <code>Type</code> 接口。Type 接口有如下的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// 所有的类型都可以调用下面这些函数</span><br><br>	<span class="hljs-comment">// 此类型的变量对齐后所占用的字节数</span><br>	Align() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 如果是 struct 的字段，对齐后占用的字节数</span><br>	FieldAlign() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 方法返回类型的方法集中的第 i 个方法。 </span><br>    <span class="hljs-comment">// 如果不在[0， NumMethod （））范围内，它会发生 panic。</span><br>    <span class="hljs-comment">// </span><br>	<span class="hljs-comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span><br>    <span class="hljs-comment">// 其第一个参数为接收方。</span><br>    <span class="hljs-comment">// </span><br>	<span class="hljs-comment">// 对于接口类型，返回的 Method 的 Type 字段给出方法签名，没有接收方，而 Func 字段为 nil。</span><br>	<span class="hljs-comment">// </span><br>    <span class="hljs-comment">// 仅可导出方法，并且它们按字典顺序排序</span><br>	Method(<span class="hljs-keyword">int</span>) Method<br><br>	<span class="hljs-comment">// MethodByName 返回在类型的方法集中具有该名称的方法和一个布尔值，指示是否找到该方法。</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span><br>    <span class="hljs-comment">// 其第一个参数为接收方。</span><br>	<span class="hljs-comment">//    </span><br>    <span class="hljs-comment">// 对于接口类型，返回的 Method 的 Type 字段给出方法签名，没有接收方，而 Func 字段为 nil</span><br>	MethodByName(<span class="hljs-keyword">string</span>) (Method, <span class="hljs-keyword">bool</span>)<br><br>	<span class="hljs-comment">// 获取类型方法集里导出的方法个数</span><br>	NumMethod() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 类型名称</span><br>	Name() <span class="hljs-keyword">string</span><br><br>    <span class="hljs-comment">// 返回类型所在的路径，如：encoding/base64</span><br>	PkgPath() <span class="hljs-keyword">string</span><br><br>	<span class="hljs-comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span><br>	Size() <span class="hljs-keyword">uintptr</span><br><br>	<span class="hljs-comment">// 返回类型的字符串表示形式</span><br>	String() <span class="hljs-keyword">string</span><br><br>	<span class="hljs-comment">// 返回类型的类型值</span><br>	Kind() Kind<br><br>	<span class="hljs-comment">// 类型是否实现了接口 u</span><br>	Implements(u Type) <span class="hljs-keyword">bool</span><br><br>	<span class="hljs-comment">// 是否可以赋值给 u</span><br>	AssignableTo(u Type) <span class="hljs-keyword">bool</span><br><br>	<span class="hljs-comment">// 是否可以类型转换成 u</span><br>	ConvertibleTo(u Type) <span class="hljs-keyword">bool</span><br><br>	<span class="hljs-comment">// 类型是否可以比较</span><br>	Comparable() <span class="hljs-keyword">bool</span><br>    <br>   <br>    <span class="hljs-comment">// 下面的方法仅适用于某些特定类型，具体取决于种类。</span><br>    <span class="hljs-comment">// 每种类型允许使用的方法有：</span><br>	<span class="hljs-comment">//	Int*, Uint*, Float*, Complex*: Bits</span><br>	<span class="hljs-comment">//	Array: Elem, Len</span><br>	<span class="hljs-comment">//	Chan: ChanDir, Elem</span><br>	<span class="hljs-comment">//	Func: In, NumIn, Out, NumOut, IsVariadic.</span><br>	<span class="hljs-comment">//	Map: Key, Elem</span><br>	<span class="hljs-comment">//	Ptr: Elem</span><br>	<span class="hljs-comment">//	Slice: Elem</span><br>	<span class="hljs-comment">//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField</span><br><br>	<span class="hljs-comment">// 类型所占据的位数</span><br>	Bits() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 返回通道的方向，只能是 chan 类型调用，其他类型会 panic</span><br>	ChanDir() ChanDir<br><br>    <span class="hljs-comment">// 返回类型是否是可变参数，只能是 func 类型调用</span><br>	<span class="hljs-comment">// 比如 t 是类型 func(x int, y ... float64)</span><br>	<span class="hljs-comment">// 那么 t.IsVariadic() == true</span><br>	IsVariadic() <span class="hljs-keyword">bool</span><br><br>	<span class="hljs-comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span><br>	Elem() Type<br><br>	<span class="hljs-comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span><br>	<span class="hljs-comment">// 如果 i 超过了总字段数，就会 panic</span><br>	Field(i <span class="hljs-keyword">int</span>) StructField<br><br>	<span class="hljs-comment">// 返回嵌套的结构体的字段，等效于为每个索引 i 依次调用 Field</span><br>	FieldByIndex(index []<span class="hljs-keyword">int</span>) StructField<br><br>	<span class="hljs-comment">// 通过字段名称获取字段</span><br>	FieldByName(name <span class="hljs-keyword">string</span>) (StructField, <span class="hljs-keyword">bool</span>)<br><br>	<span class="hljs-comment">// FieldByNameFunc returns the struct field with a name</span><br>	<span class="hljs-comment">// 返回名称符合 func 函数的字段</span><br>	FieldByNameFunc(match <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span>) <span class="hljs-params">(StructField, <span class="hljs-keyword">bool</span>)</span></span><br><br>	<span class="hljs-comment">// 获取函数类型的第 i 个参数的类型</span><br>	In(i <span class="hljs-keyword">int</span>) Type<br><br>	<span class="hljs-comment">// 返回 map 的 key 类型，只能由类型 map 调用</span><br>	Key() Type<br><br>	<span class="hljs-comment">// 返回 Array 的长度，只能由类型 Array 调用</span><br>	Len() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 返回类型字段的数量，只能由类型 Struct 调用</span><br>	NumField() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 返回函数类型的输入参数个数</span><br>	NumIn() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 返回函数类型的返回值个数</span><br>	NumOut() <span class="hljs-keyword">int</span><br><br>	<span class="hljs-comment">// 返回函数类型的第 i 个值的类型</span><br>	Out(i <span class="hljs-keyword">int</span>) Type<br><br>    <span class="hljs-comment">// 返回类型结构体的相同部分</span><br>	common() *rtype<br>    <span class="hljs-comment">// 返回类型结构体的不同部分</span><br>	uncommon() *uncommonType<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Type</code> 定义了非常多的方法，通过它们可以获取类型的一切信息。注意到，<code>Type</code> 接口实现了 <code>String()</code> 函数，满足 <code>fmt.Stringer</code> 接口，因此使用 <code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。另外，<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是打印参数的动态类型。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">"%T"</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// int</span><br></code></pre></div></td></tr></table></figure>

<h3 id="ValueOf-实现原理"><a href="#ValueOf-实现原理" class="headerlink" title="ValueOf 实现原理"></a>ValueOf 实现原理</h3><p><code>ValueOf</code> 的实现源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Value</span></span> &#123;<br>	<span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> Value&#123;&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 保证当前值逃逸到堆上</span><br>	escapes(i)<br><br>	<span class="hljs-keyword">return</span> unpackEface(i)	<br>&#125;<br><br><span class="hljs-comment">// 分解 eface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unpackEface</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Value</span></span> &#123;<br>	e := (*emptyInterface)(unsafe.Pointer(&amp;i))<br><br>	t := e.typ<br>	<span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> Value&#123;&#125;<br>	&#125;<br>	<br>	f := flag(t.Kind())<br>	<span class="hljs-keyword">if</span> ifaceIndir(t) &#123;<br>		f |= flagIndir<br>	&#125;<br>	<span class="hljs-keyword">return</span> Value&#123;t, e.word, f&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>返回值 <code>reflect.Value</code> 表示 <code>interface{}</code> 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 <code>_type</code> (具体到这里是指 <code>structType</code>) 类型持有的关于结构体的字段信息、偏移信息，以及 <code>*data</code> 所指向的内容 —— 结构体的实际值。</p>
<p>从源码看，先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p>
<p><code>Value</code> 结构体定义了很多方法，通过这些方法可以直接操作 <code>Value</code> 字段 <code>ptr</code> 所指向的实际数据：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 设置切片的 len 字段，如果类型不是切片，就会panic</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">SetLen</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span><br> <br> <span class="hljs-comment">// 设置切片的 cap 字段</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">SetCap</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span><br> <br> <span class="hljs-comment">// 设置字典的 kv</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">SetMapIndex</span><span class="hljs-params">(key, val Value)</span></span><br><br> <span class="hljs-comment">// 返回切片、字符串、数组的索引 i 处的值</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">Index</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Value</span></span><br> <br> <span class="hljs-comment">// 根据名称获取结构体的内部字段值</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">FieldByName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Value</span></span><br> <br> <span class="hljs-comment">// ……</span><br></code></pre></div></td></tr></table></figure>

<p><code>Value</code> 字段还有很多其他的方法。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 用来获取 int 类型的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">Int</span><span class="hljs-params">()</span> <span class="hljs-title">int64</span></span><br><br><span class="hljs-comment">// 用来获取结构体字段（成员）数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">NumField</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span><br><br><span class="hljs-comment">// 尝试向通道发送数据（不会阻塞）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">TrySend</span><span class="hljs-params">(x reflect.Value)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 通过参数列表 in 调用 v 值所代表的函数（或方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">Call</span><span class="hljs-params">(in []Value)</span> <span class="hljs-params">(r []Value)</span></span> <br><br><span class="hljs-comment">// 调用变参长度可变的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">CallSlice</span><span class="hljs-params">(in []Value)</span> []<span class="hljs-title">Value</span></span><br></code></pre></div></td></tr></table></figure>

<p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。<code>Type()</code> 方法也可以返回变量的类型信息，与 <code>reflect.TypeOf()</code> 函数等价。<code>Interface()</code> 方法可以将 <code>Value</code> 还原成原来的 <code>interface</code>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Interface%E3%80%81type%E3%80%81value%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="三者关系"></p>
<p>总结一下：<code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p>
<h3 id="reflect-Set的实现"><a href="#reflect-Set的实现" class="headerlink" title="reflect.Set的实现"></a>reflect.Set的实现</h3><p>当想要更新 <code>reflect.Value</code> 时，一般需要这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> 	i := <span class="hljs-number">2.33</span><br> 	v := reflect.ValueOf(&amp;i)<br> 	v.Elem().SetFloat(<span class="hljs-number">6.66</span>)<br>    <span class="hljs-comment">// value:  6.66</span><br> 	log.Println(<span class="hljs-string">"value: "</span>, i)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里会需要调用 <code>reflect.Value.Set</code> 更新反射对象，该方法会调用 <code>reflect.flag.mustBeAssignable</code> 和 <code>reflect.flag.mustBeExported</code> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">Set</span><span class="hljs-params">(x Value)</span></span> &#123;<br>    <span class="hljs-comment">// 检查当前反射对象是否是可以被设置</span><br>	v.mustBeAssignable()<br>    <span class="hljs-comment">// 检查 x 字段是否是对外公开</span><br>	x.mustBeExported() <span class="hljs-comment">// do not let unexported x leak</span><br>	<span class="hljs-keyword">var</span> target unsafe.Pointer<br>	<span class="hljs-keyword">if</span> v.kind() == Interface &#123;<br>		target = v.ptr<br>	&#125;<br>	x = x.assignTo(<span class="hljs-string">"reflect.Set"</span>, v.typ, target)<br>	<span class="hljs-keyword">if</span> x.flag&amp;flagIndir != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// func typedmemmove(t *rtype, dst unsafe.Pointer, src unsafe.Pointer)</span><br>		<span class="hljs-comment">// typedmemmove 将类型 t 的值从 src 复制到 dst。</span><br>		typedmemmove(v.typ, v.ptr, x.ptr)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		*(*unsafe.Pointer)(v.ptr) = x.ptr<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Set</code> 函数的步骤如下：</p>
<ol>
<li><p>检查反射对象及其字段是否可以被设置。</p>
</li>
<li><p>检查反射对象及其字段是否导出（对外公开）。</p>
</li>
<li><p>调用 <code>assignTo</code> 方法创建一个新的反射对象并对原本的反射对象进行覆盖。</p>
<p><code>assignTo</code> 会根据当前和被设置的反射对象类型创建一个新的 <code>reflect.Value</code>结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">assignTo</span><span class="hljs-params">(context <span class="hljs-keyword">string</span>, dst *rtype, target unsafe.Pointer)</span> <span class="hljs-title">Value</span></span> &#123;<br>	<span class="hljs-keyword">if</span> v.flag&amp;flagMethod != <span class="hljs-number">0</span> &#123;<br>		v = makeMethodValue(context, v)<br>	&#125;<br><br>	<span class="hljs-keyword">switch</span> &#123;<br>	<span class="hljs-keyword">case</span> directlyAssignable(dst, v.typ):<br>		<span class="hljs-comment">// Overwrite type so that they match.</span><br>		<span class="hljs-comment">// Same memory layout, so no harm done.</span><br>		fl := v.flag&amp;(flagAddr|flagIndir) | v.flag.ro()<br>		fl |= flag(dst.Kind())<br>        <span class="hljs-comment">// 返回一个新的结构题</span><br>		<span class="hljs-keyword">return</span> Value&#123;dst, v.ptr, fl&#125;<br><br>	<span class="hljs-keyword">case</span> implements(dst, v.typ):<br>		<span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<br>			target = unsafe_New(dst)<br>		&#125;<br>		<span class="hljs-keyword">if</span> v.Kind() == Interface &amp;&amp; v.IsNil() &#123;<br>			<span class="hljs-comment">// A nil ReadWriter passed to nil Reader is OK,</span><br>			<span class="hljs-comment">// but using ifaceE2I below will panic.</span><br>			<span class="hljs-comment">// Avoid the panic by returning a nil dst (e.g., Reader) explicitly.</span><br>			<span class="hljs-keyword">return</span> Value&#123;dst, <span class="hljs-literal">nil</span>, flag(Interface)&#125;<br>		&#125;<br>		x := valueInterface(v, <span class="hljs-literal">false</span>)<br>		<span class="hljs-keyword">if</span> dst.NumMethod() == <span class="hljs-number">0</span> &#123;<br>			*(*<span class="hljs-keyword">interface</span>&#123;&#125;)(target) = x<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			ifaceE2I(dst, x, target)<br>		&#125;<br>		<span class="hljs-keyword">return</span> Value&#123;dst, target, flagIndir | flag(Interface)&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Failed.</span><br>	<span class="hljs-built_in">panic</span>(context + <span class="hljs-string">": value of type "</span> + v.typ.String() + <span class="hljs-string">" is not assignable to type "</span> + dst.String())<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>根据 <code>assignTo</code> 方法所返回的指针值，对当前反射对象的指针进行值的修改。</p>
</li>
</ol>
<p>简单来讲就是，检查是否可以设置，接着创建一个新的对象，最后对其修改。是一个非常标准的赋值流程。</p>
<h2 id="未导出成员"><a href="#未导出成员" class="headerlink" title="未导出成员"></a>未导出成员</h2><p>利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。</p>
<p>注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。</p>
<blockquote>
<p>一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。<br><code>CanAddr</code> 不能说明一个变量是否可以被修改。<br><code>CanSet</code> 则可以检查对应的 <code>reflect.Value</code> 是否可取地址并可被修改。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">"reflect"</span><br>	<span class="hljs-string">"fmt"</span><br>)<br><br><span class="hljs-keyword">type</span> Child <span class="hljs-keyword">struct</span> &#123;<br>	Name     <span class="hljs-keyword">string</span><br>	handsome <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	qcrao := Child&#123;Name: <span class="hljs-string">"qcrao"</span>, handsome: <span class="hljs-literal">true</span>&#125;<br><br>	v := reflect.ValueOf(&amp;qcrao)<br><br>	f := v.Elem().FieldByName(<span class="hljs-string">"Name"</span>)<br>	fmt.Println(f.String())<br><br>	f.SetString(<span class="hljs-string">"stefno"</span>)<br>	fmt.Println(f.String())<br><br>	f = v.Elem().FieldByName(<span class="hljs-string">"handsome"</span>)<br>	<br>	<span class="hljs-comment">// 这一句会导致 panic，因为 handsome 字段未导出</span><br>	<span class="hljs-comment">//f.SetBool(true)</span><br>	fmt.Println(f.Bool())<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">qcrao</span><br>stefno<br><span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>

<p>上面的例子中，<code>handsome</code> 字段未导出，可以读取，但不能调用相关 <code>set</code> 方法，否则会 <code>panic</code>。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。</p>
<h2 id="反射的实际应用"><a href="#反射的实际应用" class="headerlink" title="反射的实际应用"></a>反射的实际应用</h2><p>反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p>
<p>这里举 2 个例子：json 序列化和 DeepEqual 函数。</p>
<h3 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h3><p><code>json</code> 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。</p>
<p>Go 语言中，主要提供 2 个函数用于序列化和反序列化：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span><br></code></pre></div></td></tr></table></figure>

<p>两个函数的参数都包含 <code>interface</code>，具体实现的时候，都会用到反射相关的特性。</p>
<p>对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 <code>get</code> 函数或者 <code>set</code> 函数进行实际的操作。</p>
<h3 id="DeepEqual-的作用及原理"><a href="#DeepEqual-的作用及原理" class="headerlink" title="DeepEqual 的作用及原理"></a>DeepEqual 的作用及原理</h3><p>在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。</p>
<p>例如：如何判断两个 <code>slice</code> 所有的元素完全相同；如何判断两个 <code>map</code> 的 <code>key</code> 和 <code>value</code> 完全相同等等。</p>
<p>上述问题，可以通过 <code>DeepEqual</code> 函数实现。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br></code></pre></div></td></tr></table></figure>

<p><code>DeepEqual</code> 函数的参数是两个 <code>interface</code>，实际上也就是可以输入任意类型，输出 <code>true</code> 或者 <code>flase</code> 表示输入的两个变量是否是“深度”相等。</p>
<p>先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><br><span class="hljs-keyword">type</span> YourInt <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	m := MyInt(<span class="hljs-number">1</span>)<br>	y := YourInt(<span class="hljs-number">1</span>)<br><br>	fmt.Println(reflect.DeepEqual(m, y)) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 <code>MyInt</code>，后者是 <code>YourInt</code>，因此两者不是“深度”相等。</p>
<p>在源码里，有对 <code>DeepEqual</code> 函数的非常清楚地注释，列举了不同类型，<code>DeepEqual</code> 的比较情形，这里做一个总结：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>深度相等情形</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>Struct</td>
<td>相应字段，包含导出和不导出，“深度”相等</td>
</tr>
<tr>
<td>Func</td>
<td>只有两者都是 nil 时</td>
</tr>
<tr>
<td>Interface</td>
<td>两者存储的具体值“深度”相等</td>
</tr>
<tr>
<td>Map</td>
<td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td>
</tr>
<tr>
<td>Pointer</td>
<td>1、使用 == 比较的结果相等；2、指向的实体“深度”相等</td>
</tr>
<tr>
<td>Slice</td>
<td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] == &amp;y[0] 或者 相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>numbers, bools, strings, and channels</td>
<td>使用 == 比较的结果为真</td>
</tr>
</tbody></table>
<p>一般情况下，<code>DeepEqual</code> 的实现只需要递归地调用 <code>==</code> 就可以比较两个变量是否是真的“深度”相等。</p>
<p>但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等<em>；</em>float 类型，由于精度的原因，也是不能使用 <code>==</code> 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。</p>
<p>对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。</p>
<p>同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。</p>
<p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p>
<p>来看源码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || y == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> x == y<br>	&#125;<br>	v1 := ValueOf(x)<br>	v2 := ValueOf(y)<br>	<span class="hljs-keyword">if</span> v1.Type() != v2.Type() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> deepValueEqual(v1, v2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[visit]<span class="hljs-keyword">bool</span>), <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。</p>
<p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p>
<p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p>
<p>代码比较长，思路却比较简单清晰：核心是一个 <code>switch</code> 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。</p>
<p>实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 <code>map</code> 类型的比较：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// deepValueEqual 函数</span><br><span class="hljs-comment">// ……</span><br><br><span class="hljs-keyword">case</span> Map:<br>	<span class="hljs-keyword">if</span> v1.IsNil() != v2.IsNil() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> v1.Len() != v2.Len() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> v1.Pointer() == v2.Pointer() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> v1.MapKeys() &#123;<br>		val1 := v1.MapIndex(k)<br>		val2 := v2.MapIndex(k)<br>		<span class="hljs-keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>	<br><span class="hljs-comment">// ……</span><br></code></pre></div></td></tr></table></figure>

<p>和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> visit <span class="hljs-keyword">struct</span> &#123;<br>	a1  unsafe.Pointer<br>	a2  unsafe.Pointer<br>	typ Type<br>&#125;<br><br><span class="hljs-keyword">map</span>[visit]<span class="hljs-keyword">bool</span><br></code></pre></div></td></tr></table></figure>

<p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 <code>true</code>。</p>
<p><strong>参考文章</strong>：</p>
<blockquote>
<p><a href="https://www.iminho.me/wiki/blog-26.html" target="_blank" rel="noopener">Go 语言数组和切片的原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/pvzO8wu13gLKK00zp77zWA" target="_blank" rel="noopener">由浅到深，入门Go语言Map实现原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/hmOBmHFiybS0JqoCpQHmSw" target="_blank" rel="noopener">Go是如何设计Map的</a></p>
<p><a href="https://mp.weixin.qq.com/s/Jq65sSHTX-ucSG8TlI5Zxg" target="_blank" rel="noopener">深度解密Go语言之map</a></p>
<p><a href="https://blog.csdn.net/cyq6239075/article/details/106047992" target="_blank" rel="noopener">深入理解GO语言：map结构原理和源码分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/271145056" target="_blank" rel="noopener">三万字带你认识 Go 底层 map 的实现</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/" target="_blank" rel="noopener">Go 语言设计与实现 3.3 节</a></p>
<p><a href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA" target="_blank" rel="noopener">深度解密Go语言之关于 interface 的 10 个问题</a></p>
<p><a href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">深度解密Go语言之反射</a></p>
<p><a href="https://mp.weixin.qq.com/s/onl3sBCSNs8l42uihi_p4A" target="_blank" rel="noopener">解密 Go 语言之反射 reflect</a></p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/go/">go</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/16/go%E4%B8%ADContext%E5%8C%85/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Go 中 Context 包</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/16/Go%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
                        <span class="hidden-mobile">Go 内存管理与垃圾回收</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'xiao-ming9/xiao-ming9.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备18114217号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=粤ICP备18114217号-1"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" alt="police-icon"/>
            
            <span>粤ICP备18114217号-1</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?54ebb03ad7ad5b762ac8ff7958df6d3f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-M2RT7SDT3L', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M2RT7SDT3L"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-M2RT7SDT3L');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
