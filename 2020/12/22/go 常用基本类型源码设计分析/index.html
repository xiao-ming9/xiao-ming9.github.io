<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数组类型数组作为一种基本的数据类型，通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中会使用如下所示的方式来表示数组类型： [10]int [200]interface&amp;#123;&amp;#125;  Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。">
<meta property="og:type" content="article">
<meta property="og:title" content="go 常用基本类型源码设计分析">
<meta property="og:url" content="http://yoursite.com/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Silverming">
<meta property="og:description" content="数组类型数组作为一种基本的数据类型，通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中会使用如下所示的方式来表示数组类型： [10]int [200]interface&amp;#123;&amp;#125;  Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/hello%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%E5%93%88%E5%B8%8C%E5%80%BC%E9%AB%98%E4%BD%8E%E4%BD%8D.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/bmap%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/Go%20map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%81%87%E5%AE%9A%E7%9A%8464%E4%BD%8D%E5%93%88%E5%B8%8C%E5%80%BC.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/Map%20key%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%20map%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/tooManyOverflowBuckets%E6%83%85%E5%86%B5.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9rehash.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/bucketX%E5%92%8CbucketY.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%20map%E7%9A%84%E9%81%8D%E5%8E%86.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-1.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-2.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-3.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A81.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A83.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%80%BC%E6%83%85%E5%86%B5.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/iface%E7%BB%93%E6%9E%84%E4%BD%93.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BE%8B.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E8%B5%8B%E5%80%BCio.writer.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E8%B5%8B%E5%80%BC%E7%BB%99%E7%A9%BA%E6%8E%A5%E5%8F%A3.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/Interface%E3%80%81type%E3%80%81value%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/Goroutine%20%E4%BD%BF%E7%94%A8%20Channel%20%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png">
<meta property="article:published_time" content="2020-12-22T13:17:51.000Z">
<meta property="article:modified_time" content="2022-07-23T10:06:27.598Z">
<meta property="article:author" content="Silverming">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="http://yoursite.com/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/","path":"2020/12/22/go 常用基本类型源码设计分析/","title":"go 常用基本类型源码设计分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go 常用基本类型源码设计分析 | Silverming</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Silverming</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry,stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">数组的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">语句转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">访问数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="nav-number">1.4.</span> <span class="nav-text">数组赋值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">2.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="nav-number">2.1.</span> <span class="nav-text">创建切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">切片的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">切片的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.3.</span> <span class="nav-text">关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%88%87%E7%89%87"><span class="nav-number">2.4.</span> <span class="nav-text">访问切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9"><span class="nav-number">2.5.</span> <span class="nav-text">切片的追加和扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">2.5.1.</span> <span class="nav-text">追加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9"><span class="nav-number">2.5.2.</span> <span class="nav-text">切片扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%87%E7%89%87"><span class="nav-number">2.6.</span> <span class="nav-text">拷贝切片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">字符串解析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">3.3.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">哈希表相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%A1%B6%E4%B8%8E%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="nav-number">4.1.2.</span> <span class="nav-text">哈希桶与装载因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">4.1.3.</span> <span class="nav-text">哈希冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">解决哈希冲突的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="nav-number">4.1.3.1.1.</span> <span class="nav-text">开放寻址法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">4.1.3.1.2.</span> <span class="nav-text">链地址法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">Map 中的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bmap"><span class="nav-number">4.2.1.</span> <span class="nav-text">bmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapextra"><span class="nav-number">4.2.2.</span> <span class="nav-text">mapextra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">map 中的常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.3.</span> <span class="nav-text">Map 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">Map 的哈希函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.</span> <span class="nav-text">Map 的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="nav-number">4.5.1.</span> <span class="nav-text">Key 的定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BEkey"><span class="nav-number">4.5.2.</span> <span class="nav-text">查找key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5-key"><span class="nav-number">4.5.3.</span> <span class="nav-text">写入 key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E6%89%A9%E5%AE%B9"><span class="nav-number">4.5.4.</span> <span class="nav-text">map 扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-key"><span class="nav-number">4.5.5.</span> <span class="nav-text">删除 key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-map"><span class="nav-number">4.5.6.</span> <span class="nav-text">遍历 map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%9F-C-%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.</span> <span class="nav-text">跟 C 语言对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">5.2.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">整型和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-number">5.2.2.</span> <span class="nav-text">结构体和指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.</span> <span class="nav-text">指针和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.2.1.</span> <span class="nav-text">值接收者和指针接收者应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.</span> <span class="nav-text">接口的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eface-%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.1.</span> <span class="nav-text">eface 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iface-%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.2.</span> <span class="nav-text">iface 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#itab-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">itab 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interfacetype"><span class="nav-number">6.3.2.2.</span> <span class="nav-text">interfacetype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-number">6.3.2.3.</span> <span class="nav-text">_type</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC"><span class="nav-number">6.4.</span> <span class="nav-text">接口的动态类型和动态值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.5.</span> <span class="nav-text">编译器自动检测类型是否实现接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">7.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">7.1.</span> <span class="nav-text">反射的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%88%99"><span class="nav-number">7.2.</span> <span class="nav-text">反射的三大法则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%B3%95%E5%88%99"><span class="nav-number">7.2.1.</span> <span class="nav-text">第一法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%B3%95%E5%88%99"><span class="nav-number">7.2.2.</span> <span class="nav-text">第二法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%B3%95%E5%88%99"><span class="nav-number">7.2.3.</span> <span class="nav-text">第三法则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.</span> <span class="nav-text">反射的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#types-%E5%92%8C-interface"><span class="nav-number">7.3.1.</span> <span class="nav-text">types 和 interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emptyInterface"><span class="nav-number">7.3.2.</span> <span class="nav-text">emptyInterface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeOf-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.3.</span> <span class="nav-text">TypeOf 方法的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rtype"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">rtype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Type-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">Type 接口的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ValueOf-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.4.</span> <span class="nav-text">ValueOf 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Set%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.5.</span> <span class="nav-text">reflect.Set的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E5%AF%BC%E5%87%BA%E6%88%90%E5%91%98"><span class="nav-number">7.4.</span> <span class="nav-text">未导出成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">反射的实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#json-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">7.5.1.</span> <span class="nav-text">json 序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeepEqual-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">7.5.2.</span> <span class="nav-text">DeepEqual 的作用及原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">通道类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">8.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93"><span class="nav-number">8.2.</span> <span class="nav-text">创建管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%80%9A%E9%81%93%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="nav-number">8.3.</span> <span class="nav-text">向通道传递数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E9%80%81"><span class="nav-number">8.3.1.</span> <span class="nav-text">直接发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">8.3.2.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%8F%91%E9%80%81"><span class="nav-number">8.3.3.</span> <span class="nav-text">阻塞发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">8.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%80%9A%E9%81%93%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">8.4.</span> <span class="nav-text">从通道接收数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8E%A5%E6%94%B6"><span class="nav-number">8.4.1.</span> <span class="nav-text">直接接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-1"><span class="nav-number">8.4.2.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%8E%A5%E6%94%B6"><span class="nav-number">8.4.3.</span> <span class="nav-text">阻塞接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">8.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93"><span class="nav-number">8.5.</span> <span class="nav-text">关闭通道</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Silverming</p>
  <div class="site-description" itemprop="description">Wechat:934933088</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/go%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Silverming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silverming">
      <meta itemprop="description" content="Wechat:934933088">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go 常用基本类型源码设计分析 | Silverming">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 常用基本类型源码设计分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-22 21:17:51" itemprop="dateCreated datePublished" datetime="2020-12-22T21:17:51+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-23 18:06:27" itemprop="dateModified" datetime="2022-07-23T18:06:27+08:00">2022-07-23</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>97k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:28</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><p>数组作为一种基本的数据类型，通常会从两个维度描述数组，也就是数组中存储的<strong>元素类型</strong>和数组最大能存储的<strong>元素个数</strong>，在 Go 语言中会使用如下所示的方式来表示数组类型：</p>
<pre><code class="go">[10]int
[200]interface&#123;&#125;
</code></pre>
<p>Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，<strong>只有两个条件都相同才是同一类型</strong>。</p>
<span id="more"></span>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建数组时由以下函数进行创建，当前数组是否应该在堆栈中初始化也在编译期就确定了：</p>
<pre><code class="go">// elem 为元素类型，bound 为数组大小
func NewArray(elem *Type, bound int64) *Type &#123;
    if bound &lt; 0 &#123;
        Fatalf(&quot;NewArray: invalid bound %v&quot;, bound)
    &#125;
    t := New(TARRAY)
    t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;
      // 判断当前数组是否要在堆栈中初始化
    t.SetNotInHeap(elem.NotInHeap())
    return t
&#125;
</code></pre>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，<strong>Go 语言会在编译期间通过源代码推导数组的大小</strong>：</p>
<pre><code class="go">arr1 := [3]int&#123;1, 2, 3&#125;
arr2 := [...]int&#123;1, 2, 3&#125;
</code></pre>
<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导。</p>
<h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc.anylit</code> 函数中做两种不同的优化：</p>
<ol>
<li><strong>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上</strong>；</li>
<li><strong>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出</strong>；</li>
</ol>
<p>当数组中元素的个数小于或者等于四个时，会将原有的初始化语句 <code>[3]int&#123;1, 2, 3&#125;</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<pre><code class="go">var arr [3]int
arr[0] = 1
arr[1] = 2
arr[2] = 3
</code></pre>
<p>但是如果当前数组的元素大于四个，会先获取一个唯一的 <code>staticname</code>，然后调用 <code>cmd/compile/internal/gc.fixedlit</code> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p>
<p>假设代码需要初始化 <code>[5]int&#123;1, 2, 3, 4, 5&#125;</code>，那么可以将过程理解成以下的伪代码：</p>
<pre><code class="go">var arr [5]int
statictmp_0[0] = 1
statictmp_0[1] = 2
statictmp_0[2] = 3
statictmp_0[3] = 4
statictmp_0[4] = 5
arr = statictmp_0
</code></pre>
<p>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>在访问数组的时候，会先检测下标是否越界，其实现如下：</p>
<pre><code class="go">func typecheck1(n *Node, top int) (res *Node) &#123;
    switch n.Op &#123;
    case OINDEX:
        ok |= ctxExpr
        l := n.Left  // array
        r := n.Right // index
        switch n.Left.Type.Etype &#123;
        case TSTRING, TARRAY, TSLICE:
            ...
            if n.Right.Type != nil &amp;&amp; !n.Right.Type.IsInteger() &#123;
                yyerror(&quot;non-integer %s index %v&quot;, why, n.Right)
                break
            &#125;

            if !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;
                x := n.Right.Int64()
                if x &lt; 0 &#123;
                    yyerror(&quot;invalid %s index %v (index must be non-negative)&quot;, why, n.Right)
                &#125; else if t.IsArray() &amp;&amp; x &gt;= t.NumElem() &#123;
                    yyerror(&quot;invalid array index %v (out of bounds for %d-element array)&quot;, n.Right, t.NumElem())
                &#125; else if Isconst(n.Left, CTSTR) &amp;&amp; x &gt;= int64(len(strlit(n.Left))) &#123;
                    yyerror(&quot;invalid string index %v (out of bounds for %d-byte string)&quot;, n.Right, len(strlit(n.Left)))
                &#125; else if n.Right.Val().U.(*Mpint).Cmp(maxintval[TINT]) &gt; 0 &#123;
                    yyerror(&quot;invalid %s index %v (index too large)&quot;, why, n.Right)
                &#125;
            &#125;
        &#125;
    ...
    &#125;
&#125;
</code></pre>
<ol>
<li>访问数组的索引是非整数时，报错 <code>“non-integer %s index %v”</code>；</li>
<li>访问数组的索引是负数时，报错 <code>&quot;invalid %s index %v (index must be non-negative)&quot;</code>；</li>
<li>访问数组的索引越界时，报错 <code>&quot;invalid array index %v (out of bounds for %d-element array)&quot;</code>；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组。但是<strong>如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，这时需要 Go 语言运行时阻止不合法的访问</strong>。例如下面这种越界访问：</p>
<pre><code class="go">package check

func outOfRange() int &#123;
    arr := [3]int&#123;1, 2, 3&#125;
    i := 4
    elem := arr[i]
    return elem
&#125;
</code></pre>
<p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>runtime.panicIndex</code> 和 <code>runtime.goPanicIndex</code> 触发程序的运行时错误并导致崩溃退出。</p>
<p>因此，Go 语言对于数组的访问有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。</p>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会计算出数组当前元素的内存地址，然后修改当前内存地址的内容。赋值的过程中会先确定目标数组的地址，再获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中。<strong>无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与</strong>。</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h2><p>在 Go 中，声明切片的方式为：</p>
<pre><code class="go">[]int
[]interface
</code></pre>
<p>切片在编译期间的生成的类型只会包含切片中的元素类型，即 <code>int</code> 或者 <code>interface&#123;&#125;</code> 等。</p>
<p><code>cmd/compile/internal/types.NewSlice</code>就是编译期间用于创建切片类型的函数：</p>
<pre><code class="go">// NewSlice returns the slice Type with element type elem.
func NewSlice(elem *Type) *Type &#123;
    if t := elem.Cache.slice; t != nil &#123;
        if t.Elem() != elem &#123;
            Fatalf(&quot;elem mismatch&quot;)
        &#125;
        return t
    &#125;

    t := New(TSLICE)
    t.Extra = Slice&#123;Elem: elem&#125;
    elem.Cache.slice = t
    return t
&#125;
</code></pre>
<p>上面方法返回结构体中的 <code>Extra</code> 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 <code>Extra</code> 字段中帮助程序在运行时动态获取。</p>
<h2 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h2><p>切片在运行时的数据结构由 <code>reflect.SliceHeader</code> 结构体表示：</p>
<ul>
<li><code>Data</code> 是指向数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<pre><code class="go">type SliceHeader struct &#123;
    Data uintptr
    Len  int
    Cap  int
&#125;
</code></pre>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="切片数据结构"></p>
<p><code>Data</code> 是一片连续的内存空间，用于存储切片中的全部元素，从逻辑上来说，它就是一个数组。切片引入了一个抽象层，提供了对数组中部分连续片段的引用。作为数组的引用，可以在运行区间可以修改它的长度和范围。当切片底层的数组长度不足时就会触发扩容，切片指向的数组可能会发生变化。</p>
<h2 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h2><p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<pre><code class="go">arr[0:3] or slice[0:3]
slice := []int&#123;1, 2, 3&#125;
slice := make([]int, 10)
</code></pre>
<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作，例如对于下面的代码：</p>
<pre><code class="go">func newSlice() []int &#123;
  arr := [3]int&#123;1, 2, 3&#125;
    slice := arr[0:1]
    return slice
&#125;
</code></pre>
<p>其编译过程中 <code>slice := arr[0:1]</code> 会有如下代码生成：</p>
<pre><code class="go">v27 (+5) = SliceMake &lt;[]int&gt; v11 v14 v17

name &amp;arr[*[3]int]: v11
name slice.ptr[*int]: v11
name slice.len[int]: v14
name slice.cap[int]: v17
</code></pre>
<p><code>SliceMake</code> 操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，对应切片的数据结构。</p>
<p><strong>使用下标初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。</strong></p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>当使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建新的切片时，<code>cmd/compile/internal/gc.slicelit</code> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<pre><code class="go">var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
</code></pre>
<p>上面代码的流程如下：</p>
<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<p>使用下标和字面量的方式创建切片时，很多的工作都是在编译期间完成的。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量。go 不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>。除了校验参数之外，还会根据条件决定切片的分配：</p>
<ol>
<li>切片的大小和容量是否足够小</li>
<li>切片是否发生了逃逸</li>
</ol>
<p>当切片发生逃逸或者非常大时，运行时需要通过 <code>runtime.makeslice</code> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<pre><code class="go">var arr [4]int
n := arr[:3]
</code></pre>
<p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组并将 <code>[:3]</code> 同样转换成使用下标方式中的 <code>OpSliceMake</code> 操作。</p>
<p>对于 <code>runtime.makeslice</code> 函数，其实现如下：</p>
<pre><code class="go">func makeslice(et *_type, len, cap int) unsafe.Pointer &#123;
    mem, overflow := math.MulUintptr(et.size, uintptr(cap))
    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap &#123;
        // NOTE: Produce a &#39;len out of range&#39; error instead of a
        // &#39;cap out of range&#39; error when someone does make([]T, bignumber).
        // &#39;cap out of range&#39; is true too, but since the cap is only being
        // supplied implicitly, saying len is clearer.
        // See golang.org/issue/4085.
        mem, overflow := math.MulUintptr(et.size, uintptr(len))
        if overflow || mem &gt; maxAlloc || len &lt; 0 &#123;
            panicmakeslicelen()
        &#125;
        panicmakeslicecap()
    &#125;

    return mallocgc(mem, et, true)
&#125;
</code></pre>
<p>上述函数的主要工作是计算切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p>
<p>$$<br>内存空间 &#x3D; 切片中元素大小 \times 切片容量<br>$$</p>
<p>同时，创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>runtime.makeslice</code> 在最后调用的 <code>runtime.mallocgc</code> 是用于申请内存的函数，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的对象会在堆上初始化。</p>
<h2 id="访问切片"><a href="#访问切片" class="headerlink" title="访问切片"></a>访问切片</h2><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环。</p>
<p>使用 <code>len</code> 和 <code>cap</code> 获取长度或者容量是切片最常见的操作，编译器将这它们看成两种特殊操作，即 <code>OLEN</code> 和 <code>OCAP</code>。<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会直接替换成切片的长度或者容量，不需要在运行时获取。</p>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问。</p>
<h2 id="切片的追加和扩容"><a href="#切片的追加和扩容" class="headerlink" title="切片的追加和扩容"></a>切片的追加和扩容</h2><h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，会根据返回值是否会覆盖原变量，选择进入两种流程。</p>
<p>如果 <code>append</code> 返回的新切片不需要赋值回原有的变量，就会先通过切片获取它的的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <code>runtime.growslice</code> 对切片进行扩容并将新的元素依次加入切片。</p>
<p>如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的切片会覆盖原切片，此时 go 会调用另一个方式展开关键字，会获取数组的指针，之后直接在数组中追加元素，避免发生拷贝影响性能。</p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>当切片的容量不足时，会调用 <code>runtime.growslice</code> 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程。在该函数中，首先会确认新切片的容量：</p>
<pre><code class="go">func growslice(et *_type, old slice, cap int) slice &#123;
  //...
  newcap := old.cap
    doublecap := newcap + newcap
    if cap &gt; doublecap &#123;
        newcap = cap
    &#125; else &#123;
        if old.len &lt; 1024 &#123;
            newcap = doublecap
        &#125; else &#123;
            // Check 0 &lt; newcap to detect overflow
            // and prevent an infinite loop.
            for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;
                newcap += newcap / 4
            &#125;
            // Set newcap to the requested cap when
            // the newcap calculation overflowed.
            if newcap &lt;= 0 &#123;
                newcap = cap
            &#125;
        &#125;
    &#125;
  //...
&#125;
</code></pre>
<p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p><strong>上述代码片段仅会确定切片的大致容量</strong>，还需要根据切片中的元素大小对齐内存，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会通过 <code>roundupsize</code>  进行对齐内存，内存对齐主要是为了适应 go 的内存分配，可以提高内存的分配效率并减少碎片。</p>
<p>实现如下：</p>
<pre><code class="go">    var overflow bool
    var lenmem, newlenmem, capmem uintptr
    // Specialize for common values of et.size.
    // For 1 we don&#39;t need any division/multiplication.
    // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
    // For powers of 2, use a variable shift.
    switch &#123;
    case et.size == 1:
        lenmem = uintptr(old.len)
        newlenmem = uintptr(cap)
        capmem = roundupsize(uintptr(newcap))
        overflow = uintptr(newcap) &gt; maxAlloc
        newcap = int(capmem)
    case et.size == sys.PtrSize:
        lenmem = uintptr(old.len) * sys.PtrSize
        newlenmem = uintptr(cap) * sys.PtrSize
        capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
        overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize
        newcap = int(capmem / sys.PtrSize)
  //...
  default:
    //...
</code></pre>
<p><code>roundupsize</code> 则会使用 <code>runtime.size_to_class</code> 和 <code>runtime.class_to_size</code> 数组对申请的内存向上取整：</p>
<pre><code class="go">func roundupsize(size uintptr) uintptr &#123;
    if size &lt; _MaxSmallSize &#123;
        // 首先通过 size_to_class 确认 size 的级别，再通过 class_to_size 取整为该 class 的上限大小
        if size &lt;= smallSizeMax-8 &#123;
            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
        &#125; else &#123;
            return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
        &#125;
    &#125;
    if size+_PageSize &lt; size &#123;
        return size
    &#125;
    return alignUp(size, _PageSize)
&#125;
</code></pre>
<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>当使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <code>cmd/compile/internal/gc.copyany</code>  也会分两种情况进行处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<pre><code class="go">n := len(a)
if n &gt; len(b) &#123;
    n = len(b)
&#125;
if a.ptr != b.ptr &#123;
    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) 
&#125;
</code></pre>
<p><code>runtime.memmove</code> 会负责拷贝内存。而如果拷贝是在运行时发生的，例如：<code>go copy(a, b)</code>，编译器会使用 <code>runtime.slicecopy</code> 替换运行期间调用的 <code>copy</code>，该函数的实现如下：</p>
<pre><code class="go">func slicecopy(to, fm slice, width uintptr) int &#123;
    if fm.len == 0 || to.len == 0 &#123;
        return 0
    &#125;
    n := fm.len
    if to.len &lt; n &#123;
        n = to.len
    &#125;
    if width == 0 &#123;
        return n
    &#125;
    ...

    size := uintptr(n) * width
    if size == 1 &#123;
        *(*byte)(to.array) = *(*byte)(fm.array)
    &#125; else &#123;
        memmove(to.array, fm.array, size)
    &#125;
    return n
&#125;
</code></pre>
<p>无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code> <strong>将整块内存的内容拷贝到目标的内存区域中</strong>：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%87%E7%89%87%E6%8B%B7%E8%B4%9D.png" alt="切片拷贝"></p>
<p>相比于依次拷贝元素，<code>runtime.memmove</code> 能够提供更好的性能。需要注意的是，成块拷贝内存仍然会占用非常多的资源，在大切片上执行拷贝操作时一定要注意对性能的影响。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串实际上是由字符组成的数组，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个<strong>只读的字节数组</strong>，下图展示了 <code>&quot;hello&quot;</code> 字符串在内存中的存储方式：</p>
<p><img src="https://qiniu.xiaoming.net.cn/hello%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt="hello 字符串在内存中的存储方式"></p>
<p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，假设有以下代码，其中包含了一个字符串，当将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p>
<pre><code class="bash">$ cat main.go
package main

func main() &#123;
    str := &quot;hello&quot;
    println([]byte(str))
&#125;

$ GOOS=linux GOARCH=amd64 go tool compile -S main.go
...
go.string.&quot;hello&quot; SRODATA dupok size=5
    0x0000 68 65 6c 6c 6f                                   hello
...
</code></pre>
<p><strong>只读只意味着字符串会分配到只读的内存空间</strong>，但是 Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间，仍然可以通过在 <code>string</code> 和 <code>[]byte</code> 类型之间反复转换实现修改这一目的：</p>
<ol>
<li>先将这段内存拷贝到堆或者栈上；</li>
<li>将变量的类型转换成 <code>[]byte</code> 后并修改字节数据；</li>
<li>将修改后的字节数组转换回 <code>string</code>；</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>字符串在 Go 中的接口是 <code>reflect.StringHeader</code> ，其中包含指向字节数组的指针和数组的大小：</p>
<pre><code class="go">type StringHeader struct &#123;
    Data uintptr
    Len  int
&#125;
</code></pre>
<h2 id="字符串解析过程"><a href="#字符串解析过程" class="headerlink" title="字符串解析过程"></a>字符串解析过程</h2><p>解析器在词法分析阶段会解析字符串，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列。在 Go 中，声明字符串的方式有两种，即双引号和反引号：</p>
<pre><code class="go">str1 := &quot;this is a string&quot;
str2 := `this is another string`
</code></pre>
<p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而<strong>反引号声明的字符串可以摆脱单行的限制</strong>。</p>
<p>当使用反引号时，因为双引号不再负责标记字符串的开始和结束，所以可以在字符串内部直接使用 <code>&quot;</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p>
<pre><code class="go">json := `&#123;&quot;author&quot;: &quot;draven&quot;, &quot;tags&quot;: [&quot;golang&quot;]&#125;`
</code></pre>
<p>解析字符串使用的扫描器 <code>cmd/compile/internal/syntax.scanner</code> 会将输入的字符串转换成 Token 流。</p>
<p><code>stdString</code> 方法是它用来解析使用双引号的标准字符串：</p>
<pre><code class="go">func (s *scanner) stdString() &#123;
    s.startLit()
    s.bad = false

    for &#123;
        r := s.getr()
        if r == &#39;&quot;&#39; &#123;
            break
        &#125;
        if r == &#39;\\&#39; &#123;
            s.escape(&#39;&quot;&#39;)
            continue
        &#125;
        if r == &#39;\n&#39; &#123;
            // 如果存在隐式换行\n,则报错
            s.ungetr() // assume newline is not part of literal
            s.errorf(&quot;newline in string&quot;)
            break
        &#125;
        if r &lt; 0 &#123;
            s.errorAtf(0, &quot;string not terminated&quot;)
            break
        &#125;
    &#125;

    s.nlsemi = true
    s.lit = string(s.stopLit())
    s.kind = StringLit
    s.tok = _Literal
&#125;
</code></pre>
<p>该方法的逻辑如下：</p>
<ol>
<li><p>标准字符串使用双引号表示开头和结尾；</p>
</li>
<li><p>标准字符串需要使用反斜杠 <code>\</code> 来逃逸双引号；</p>
</li>
<li><p>标准字符串不能出现例如下面这样的隐式换行 <code>\n</code> ：</p>
<pre><code class="go">str := &quot;start
end&quot;
</code></pre>
</li>
</ol>
<p><code>rawString</code> 方法是用来解析反引号声明的字符串，它会将非反引号的所有字符都划分到当前字符串的范围中，所以可以使用它支持复杂的多行字符串，实现如下：</p>
<pre><code class="go">func (s *scanner) rawString() &#123;
    s.startLit()
    s.bad = false

    for &#123;
        r := s.getr()
        if r == &#39;`&#39; &#123;
            break
        &#125;
        if r &lt; 0 &#123;
            s.errorAtf(0, &quot;string not terminated&quot;)
            break
        &#125;
    &#125;
    // We leave CRs in the string since they are part of the
    // literal (even though they are not part of the literal
    // value).

    s.nlsemi = true
    s.lit = string(s.stopLit())
    s.kind = StringLit
    s.tok = _Literal
&#125;
</code></pre>
<p>无论是标准字符串还是原始字符串都会被标记成 <code>StringLit</code> 并传递到语法分析阶段。在语法分析阶段，与字符串相关的表达式都会由 <code>basicLit</code> 方法处理：</p>
<pre><code class="go">func (p *noder) basicLit(lit *syntax.BasicLit) Val &#123;
    // We don&#39;t use the errors of the conversion routines to determine
    // if a literal string is valid because the conversion routines may
    // accept a wider syntax than the language permits. Rely on lit.Bad
    // instead.
    switch s := lit.Value; lit.Kind &#123;
    case syntax.IntLit:
        checkLangCompat(lit)
        x := new(Mpint)
        if !lit.Bad &#123;
            x.SetString(s)
        &#125;
        return Val&#123;U: x&#125;

    case syntax.FloatLit:
        checkLangCompat(lit)
        x := newMpflt()
        if !lit.Bad &#123;
            x.SetString(s)
        &#125;
        return Val&#123;U: x&#125;

    case syntax.ImagLit:
        checkLangCompat(lit)
        x := newMpcmplx()
        if !lit.Bad &#123;
            x.Imag.SetString(strings.TrimSuffix(s, &quot;i&quot;))
        &#125;
        return Val&#123;U: x&#125;

    case syntax.RuneLit:
        x := new(Mpint)
        x.Rune = true
        if !lit.Bad &#123;
            u, _ := strconv.Unquote(s)
            var r rune
            if len(u) == 1 &#123;
                r = rune(u[0])
            &#125; else &#123;
                r, _ = utf8.DecodeRuneInString(u)
            &#125;
            x.SetInt64(int64(r))
        &#125;
        return Val&#123;U: x&#125;

    // 字符串的处理    
    case syntax.StringLit:
        var x string
        if !lit.Bad &#123;
            if len(s) &gt; 0 &amp;&amp; s[0] == &#39;`&#39; &#123;
                // strip carriage returns from raw string
                s = strings.Replace(s, &quot;\r&quot;, &quot;&quot;, -1)
            &#125;
            x, _ = strconv.Unquote(s)
        &#125;
        return Val&#123;U: x&#125;

    default:
        panic(&quot;unhandled BasicLit kind&quot;)
    &#125;
&#125;
</code></pre>
<p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两遍的引号等无关干扰，还原其本来的面目。</p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <code>walkexpr</code> 方法中调用 <code>addstr</code> 函数生成用于拼接字符串的代码：</p>
<pre><code class="go">func walkexpr(n *Node, init *Nodes) *Node &#123;
    switch n.Op &#123;
    ...
    case OADDSTR:
        n = addstr(n, init)
    &#125;
&#125;
</code></pre>
<p><code>addstr </code> 能够在编译期间选择合适的函数对字符串进行拼接，该函数会根据带拼接的字符串数量选择不同的逻辑：</p>
<ul>
<li>如果小于或者等于 5 个，那么会调用 <code>concatstring&#123;2,3,4,5&#125;</code> 等一系列函数；</li>
<li>如果超过 5 个，那么会选择 <code>runtime.concatstrings</code> 传入一个数组切片；</li>
</ul>
<pre><code class="go">func addstr(n *Node, init *Nodes) *Node &#123;
    // order.expr rewrote OADDSTR to have a list of strings.
    c := n.List.Len()

    if c &lt; 2 &#123;
        Fatalf(&quot;addstr count %d too small&quot;, c)
    &#125;

    buf := nodnil()
    if n.Esc == EscNone &#123;
        sz := int64(0)
        for _, n1 := range n.List.Slice() &#123;
            if n1.Op == OLITERAL &#123;
                sz += int64(len(strlit(n1)))
            &#125;
        &#125;

        // Don&#39;t allocate the buffer if the result won&#39;t fit.
        if sz &lt; tmpstringbufsize &#123;
            // Create temporary buffer for result string on stack.
            t := types.NewArray(types.Types[TUINT8], tmpstringbufsize)
            buf = nod(OADDR, temp(t), nil)
        &#125;
    &#125;

    // build list of string arguments
    args := []*Node&#123;buf&#125;
    for _, n2 := range n.List.Slice() &#123;
        args = append(args, conv(n2, types.Types[TSTRING]))
    &#125;

    var fn string
    if c &lt;= 5 &#123;
        // 少量的字符串使用直接的运行时帮助程序。
        // note: order.expr knows this cutoff too.
        fn = fmt.Sprintf(&quot;concatstring%d&quot;, c)
    &#125; else &#123;
        // 大量字符串作为切片传递给运行时。
        fn = &quot;concatstrings&quot;

        t := types.NewSlice(types.Types[TSTRING])
        slice := nod(OCOMPLIT, nil, typenod(t))
        if prealloc[n] != nil &#123;
            prealloc[slice] = prealloc[n]
        &#125;
        slice.List.Set(args[1:]) // skip buf arg
        args = []*Node&#123;buf, slice&#125;
        slice.Esc = EscNone
    &#125;

    cat := syslook(fn)
    r := nod(OCALL, cat, nil)
    r.List.Set(args)
    r = typecheck(r, ctxExpr)
    r = walkexpr(r, init)
    r.Type = n.Type

    return r
&#125;
</code></pre>
<p>其实无论使用 <code>concatstring&#123;2,3,4,5&#125;</code> 中的哪一个，最终都会调用 <code>runtime.concatstrings</code>，它会先对遍历传入的切片参数，再过滤空字符串并计算拼接后字符串的长度。</p>
<p><code>concatstrings</code> 实现了 Go 字符串串联 <code>x + y + z + ...</code>。操作数在切片 a 中传递。 <strong>如果 <code>buf ！= nil</code>，则编译器已确定结果不会逃逸出调用函数，因此，如果字符串数据足够小，则可以将其存储在 buf 中</strong>。</p>
<pre><code class="go">func concatstrings(buf *tmpBuf, a []string) string &#123;
    idx := 0
    l := 0
    count := 0
    for i, x := range a &#123;
        n := len(x)
        if n == 0 &#123;
            continue
        &#125;
        if l+n &lt; l &#123;
            throw(&quot;string concatenation too long&quot;)
        &#125;
        l += n
        count++
        idx = i
    &#125;
    if count == 0 &#123;
        return &quot;&quot;
    &#125;

    // 如果非空字符串的数量为 1 并且当前的字符串不在栈上，
    // 就可以直接返回该字符串，不需要做出额外操作。
    if count == 1 &amp;&amp; (buf != nil || !stringDataOnStack(a[idx])) &#123;
        return a[idx]
    &#125;
    s, b := rawstringtmp(buf, l)
    for _, x := range a &#123;
        copy(b, x)
        b = b[len(x):]
    &#125;
    return s
&#125;
</code></pre>
<p>在正常情况下，<strong>运行时会调用 <code>copy</code>  将输入的多个字符串拷贝到目标字符串所在的内存空间</strong>。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的开销并没有想象的那么小，经常会看到 <code>runtime.slicebytetostring</code> 等函数出现在火焰图中，成为程序的性能热点。</p>
<p>从字节数组到字符串的转换需要使用 <code>runtime.slicebytetostring </code>函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是长度为 0 或者 1 的字节数组：</p>
<pre><code class="go">// Buf 是结果的固定大小的缓冲区，如果结果不逃逸，则为 nil。
func slicebytetostring(buf *tmpBuf, b []byte) (str string) &#123;
    l := len(b)
    if l == 0 &#123;
        // Turns out to be a relatively common case.
        // Consider that you want to parse out data between parens in &quot;foo()bar&quot;,
        // you find the indices and convert the subslice to string.
        return &quot;&quot;
    &#125;
    if raceenabled &#123;
        racereadrangepc(unsafe.Pointer(&amp;b[0]),
            uintptr(l),
            getcallerpc(),
            funcPC(slicebytetostring))
    &#125;
    if msanenabled &#123;
        msanread(unsafe.Pointer(&amp;b[0]), uintptr(l))
    &#125;
    // runtime.stringStructOf 会将传入的字符串指针转换成 runtime.stringStruct 结构体指针
    // 设置结构体持有的字符串指针 str 和长度 len
    if l == 1 &#123;
        stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[0]])
        stringStructOf(&amp;str).len = 1
        return
    &#125;

    // 分配新的内存空间
    var p unsafe.Pointer
    if buf != nil &amp;&amp; len(b) &lt;= len(buf) &#123;
        p = unsafe.Pointer(buf)
    &#125; else &#123;
        p = mallocgc(uintptr(len(b)), nil, false)
    &#125;
    stringStructOf(&amp;str).str = p
    stringStructOf(&amp;str).len = len(b)
    // 通过 runtime.memmove 将原 []byte 中的字节全部复制到新的内存空间中
    memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, uintptr(len(b)))
    return
&#125;
</code></pre>
<p>处理过后会根据传入的缓冲区大小决定是否需要为新字符串分配一片内存空间，<code>runtime.stringStructOf</code> 会将传入的字符串指针转换成 <code>runtime.stringStruct</code> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后<strong>通过 <code>runtime.memmove</code> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中</strong>。</p>
<p>当想要将字符串转换成 <code>[]byte</code> 类型时，需要使用 <code>runtime.stringtoslicebyte</code> 函数，该函数的实现非常容易理解：</p>
<pre><code class="go">func stringtoslicebyte(buf *tmpBuf, s string) []byte &#123;
    var b []byte
    if buf != nil &amp;&amp; len(s) &lt;= len(buf) &#123;
        *buf = tmpBuf&#123;&#125;
        b = buf[:len(s)]
    &#125; else &#123;
        b = rawbyteslice(len(s))
    &#125;
    copy(b, s)
    return b
&#125;
</code></pre>
<p>上述函数会根据是否传入缓冲区做出不同的处理：</p>
<ul>
<li>当传入缓冲区时，它会使用传入的缓冲区存储 <code>[]byte</code>；</li>
<li>当没有传入缓冲区时，运行时会调用 <code>runtime.rawbyteslice</code> 创建新的字节切片并将字符串中的内容拷贝过去</li>
</ul>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。<strong>不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</strong></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Go 中的 map 使用的是链地址法解决哈希冲突，但是它的实现并不是对冲突的元素采用链表存储，而是采用了数组的形式。</p>
<h2 id="哈希表相关概念"><a href="#哈希表相关概念" class="headerlink" title="哈希表相关概念"></a>哈希表相关概念</h2><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数（常被称为散列函数）是可以用于将任意大小的数据映射到固定大小值的函数，常见的包括MD5、SHA系列等。实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求<strong>哈希函数的输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p>一个设计优秀的哈希函数应该包含以下特性：</p>
<ul>
<li><strong>均匀性</strong>：一个好的哈希函数应该在其输出范围内尽可能均匀地映射，也就是说，应以大致相同的概率生成输出范围内的每个哈希值。</li>
<li><strong>效率高</strong>：哈希效率要高，即使很长的输入参数也能快速计算出哈希值。</li>
<li><strong>可确定性</strong>：哈希过程必须是确定性的，这意味着对于给定的输入值，它必须始终生成相同的哈希值。</li>
<li><strong>雪崩效应</strong>：微小的输入值变化也会让输出值发生巨大的变化。</li>
<li><strong>不可逆</strong>：从哈希函数的输出值不可反向推导出原始的数据。</li>
</ul>
<h3 id="哈希桶与装载因子"><a href="#哈希桶与装载因子" class="headerlink" title="哈希桶与装载因子"></a>哈希桶与装载因子</h3><ol>
<li><p>哈希桶。哈希桶（也称为槽，类似于抽屉原理中的一个抽屉）可以理解为一个哈希值，所有的哈希值组成哈希空间。</p>
</li>
<li><p>装载因子。装载因子是表示哈希表中元素的填满程度。它的计算公式：</p>
<p>$$<br>装载因子&#x3D;填入哈希表中的元素个数&#x2F;哈希表的长度。<br>$$</p>
<p>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，<strong>但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong>。</p>
<p>装载因子也是决定哈希表是否进行扩容的关键指标，在 java 的 <code>HashMap</code> 的中，其默认装载因子为 0.75；Python的 <code>dict</code> 默认装载因子为2&#x2F;3。</p>
</li>
</ol>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希函数是将任意大小的数据映射到固定大小值的函数。那么，可以预见到，即使哈希函数设计得足够优秀，几乎每个输入值都能映射为不同的哈希值。但是，当输入数据足够大，大到能超过固定大小值的组合能表达的最大数量数，冲突将不可避免！</p>
<blockquote>
<p>这里提到的哈希碰撞不是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。</p>
</blockquote>
<blockquote>
<p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，至少会有一个抽屉里面放不少于两个苹果。抽屉原理有时也被称为鸽巢原理。</p>
</blockquote>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86.webp" alt="抽屉原理"></p>
<h4 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h4><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p>开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong></p>
<p>对于开放寻址法而言，所有的元素都是存储在 Hash 表当中的，所以无论任何时候都要保证哈希表的槽位数 m 大于或等于键的数据 n（必要时，需要对哈希表进行动态扩容）。</p>
<p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。举个线性探测法的例子：</p>
<p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值， 表示哈希表的槽位数（哈希表的大小）。</p>
<p>线性探测法则可以表示为：</p>
<ul>
<li><p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p>
</li>
<li><p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p>
</li>
<li><p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p>
</li>
</ul>
<p>……</p>
<p>开放寻址法中对性能影响最大的是<strong>装载因子</strong>。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 <code>O(n)</code> 的，这时需要遍历数组中的全部元素，所以在实现哈希表时需要多关注装载因子的变化。</p>
<h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>链地址法的思想是将映射在一个桶里的所有元素用链表串起来。</p>
<p>对于开放寻址法而言，它只有数组一种数据结构就可完成存储，继承了数组的优点，对 CPU 缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。<strong>当数据量明确、装载因子小，适合采用开放寻址法</strong>。</p>
<p>链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。<strong>但是链地址法需要额外的空间来存储指针</strong>。</p>
<blockquote>
<p> 在 Python 中 <code>dict</code> 在发生哈希冲突时采用的开放寻址法，而 java 的 <code>HashMap</code> 采用的是链地址法，而 Go 中使用的也是链地址法，但不完全遵循了链地址法的思想，其主要使用的空间还是数组，其次才用了链表。</p>
</blockquote>
<h2 id="Map-中的数据结构"><a href="#Map-中的数据结构" class="headerlink" title="Map 中的数据结构"></a>Map 中的数据结构</h2><p>Go 中的结构体为 hamp，该结构体的字段如下：</p>
<pre><code class="go">type hmap struct &#123;
    // 代表当前哈希表中的元素个数，len(map) 返回的就是该字段值
    count     int 
    // 状态标识，比如正在被写、buckets 和 oldbuckets 在被遍历、等量扩容(Map扩容相关字段)
    flags     uint8
    // buckets（桶）的数量的对数，也就是说该哈希表中桶的数量为 2^B 个
    B         uint8
    // 溢出桶的大致数量
    noverflow uint16
    // 哈希种子，这个值在哈希创建时随机生成，并在计算 key 的哈希的时候会传入哈希函数，以此提高哈希函数的随机性
    hash0     uint32 // hash seed

    // 指向 buckets 数组的指针，数组大小为 2^B，如果元素个数为 0，它为 nil。
    buckets    unsafe.Pointer
    // 如果发生扩容，oldbuckets 是指向老的 buckets 数组的指针，老的 buckets 数组大小是新的buckets 的 1/2。非扩容状态下，它为 nil。
    oldbuckets unsafe.Pointer
    // 表示扩容进度，小于此地址的 buckets 代表已搬迁完成。
    nevacuate  uintptr

    // 这个字段是为了优化 GC 扫描而设计的。当 key 和 value 均不包含指针，并且都可以 &lt;=128 字节时使用。extra 是指向 mapextra 类型的指针。
    extra *mapextra
&#125;
</code></pre>
<h3 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h3><p><code>buckets</code> 是一个指针，它指向的是一个类型为 <code>bmap</code> 的结构体数组，也就是具体存储 map 键值对的哈希空间。<code>bmap</code> 的结构如下：</p>
<pre><code class="go">type bmap struct &#123;
    // tophash 包含此桶中每个键的哈希值最高字节（高8位）信息。
    // 如果tophash[0] &lt; minTopHash，tophash[0]则代表桶的搬迁（evacuation）状态。
    tophash [bucketCnt]uint8
&#125;
</code></pre>
<p>这里的 <code>tophash</code> 指的是哈希值的高八位，在 Go 中，Hash 值的分布如下，高八位即 <code>high-order bits</code> 部分：</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%E5%93%88%E5%B8%8C%E5%80%BC%E9%AB%98%E4%BD%8E%E4%BD%8D.webp" alt="go中哈希值的高地位"></p>
<p>在运行期间，<code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，<strong>因为哈希表中可能存储不同类型的键值对（例如声明了接口类型），而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导</strong>。<code>bmap</code> 中的其他字段在运行时也都是通过计算内存地址的方式访问的，所以它的定义中就不包含这些字段。所以在编译期间通过 <code>cmd/compile/internal/gc.bmap</code> 函数重建了它的结构，动态地创建一个新的结构：</p>
<pre><code class="go">type bmap struct &#123;
    //hash值的高八位
    topbits  [8]uint8
    // key 的数组
    keys     [8]keytype
    // value 的数组
    values   [8]valuetype
    // 对齐内存使用的，不是每个 bmap 都有会这个字段，需要满足一定条件
    pad      uintptr
    // 溢出桶，也是指向一个 bmap，上面的字段 topbits、keys、elems 长度为 8，最多存8组键值对，存满了就往指向的这个 bmap 里存
    overflow uintptr
&#125;
</code></pre>
<p>一个 <code>bmap</code> 的内存模型如下所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/bmap%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.webp" alt="bmap内存模型"></p>
<p>在上图解示例中，该桶的第 7 位 <code>cell</code> 和第 8 位 <code>cell</code> 还未有对应键值对。需要注意的是，<code>key</code> 和 <code>value</code> 是各自存储起来的，并非想象中的 <code>key/value/key/value…</code> 的形式。这样做虽然会让代码组织稍显复杂，但是它的好处是能让消除填充所需要的字段（padding）。例如 <code>map[int64]int</code> ，如果按照 <code>key/value/key/value/...</code> 这样的模式存储，那在每一个 <code>key/value</code> 对之后都要额外 <code>padding 7</code> 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 <code>padding</code>。</p>
<p>此外，在 8 个键值对数据后面有一个 <code>overflow</code> 指针，因为桶中最多只能装 8 个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过 overflow 指针链接起来。</p>
<h3 id="mapextra"><a href="#mapextra" class="headerlink" title="mapextra"></a>mapextra</h3><p>当 map 的 <code>key</code> 和 <code>value</code> 都不是指针，并且 <code>size</code> 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，bmap 其实有一个 <code>overflow</code> 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 <code>overflow</code> 移动到 <code>extra</code> 字段来，在这个字段里将指针指向溢出桶。</p>
<p><strong>所以实际上 <code>bmap.overflow</code> 和 <code>hmap.extra.overflow</code> 所指向的地址是一样的，都是溢出桶的内存地址，只是在某些特殊情况下用 <code>hmap.extra.overflow</code> 代替 <code>bmap.overflow</code> ，从而优化了 GC 过程。</strong></p>
<pre><code class="go">type mapextra struct &#123;
   
   // 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
   // 就使用 hmap 的 extra 字段来存储 overflow buckets，这样可以避免 GC 扫描整个 map
   // overflow 包含的是 hmap.buckets 的 overflow 的 buckets
   // oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
   overflow    *[]*bmap
   oldoverflow *[]*bmap

   // 指向空闲的 overflow bucket 的指针
   nextOverflow *bmap
&#125;
</code></pre>
<h3 id="map-中的常量"><a href="#map-中的常量" class="headerlink" title="map 中的常量"></a>map 中的常量</h3><p>map 中还定义了一些重要的常量：</p>
<blockquote>
<p>注意：键和值超过 128 个字节后，会被转换成指针</p>
</blockquote>
<pre><code class="go">const (
    // 一个桶中最多容纳的键值对的对数，也就是一个桶最多容纳 2^3=8 个
    bucketCntBits = 3
    bucketCnt     = 1 &lt;&lt; bucketCntBits

    // 触发扩容的装载因子为 13/2=6.5
    loadFactorNum = 13
    loadFactorDen = 2

    // 键和值超过 128 个字节后，会被转换成指针
    maxKeySize  = 128
    maxElemSize = 128

    // 数据偏移量，大小为 bmap 结构体的大小，它需要正确的对齐，
    dataOffset = unsafe.Offsetof(struct &#123;
        b bmap
        v int64
    &#125;&#123;&#125;.v)

    // 每个桶（如果有溢出，则包含它的 overflow 的链桶）在搬迁完成状态（evacuated* states）下，
    // 要么会包含它所有的键值对，要么一个都不包含（但不包括调用 evacuate() 方法阶段，
    // 该方法调用只会在对 map 发起 write 时发生，在该阶段其他 goroutine 是无法查看该map的（map 非并发安全））。
    // 简单的说，在非写过程的状态中，桶里的数据要么一起搬走，要么一个都还未搬。
    // tophash 除了放置正常的高 8 位 hash 值，还会存储一些特殊状态值（标志该 cell 的搬迁状态）。
    
    // 正常的tophash值，最小应该是5，以下列出的就是一些特殊状态值：
    // 表示 cell 为空，并且比它高索引位的 cell 或者 overflows 中的 cell 都是空的。（初始化 bucket 时，就是该状态）
    emptyRest      = 0
    // 空的cell，cell已经被搬迁到新的bucket
    emptyOne       = 1
    // 键值对已经搬迁完毕，key 在新 buckets 数组的前半部分
    evacuatedX     = 2
    // 键值对已经搬迁完毕，key 在新 buckets 数组的后半部分
    evacuatedY     = 3
    // cell 为空，整个 bucket 已经搬迁完毕
    evacuatedEmpty = 4
    // tophash的最小正常值
    minTopHash     = 5

    // flags
    // 可能有迭代器在使用 buckets
    iterator     = 1
    // 可能有迭代器在使用 oldbuckets
    oldIterator  = 2
    // 有协程正在向 map 写入 key
    hashWriting  = 4
    // 等量扩容
    sameSizeGrow = 8

    // 用于迭代器检查的 bucket ID
    noCheck = 1&lt;&lt;(8*sys.PtrSize) - 1
)
</code></pre>
<p>整体来说，map 的数据结构如下所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/Go%20map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.webp" alt="Go map 数据结构"></p>
<p>在上面的数据结构中，实际上 <code>buckets</code> 指向的 <code>[]bmap</code> 和 <code>bmap.overflow</code> 指向的 <code>[]bmap</code> 的内存在地址空间上是连续的，这个可以在下面 map 初始化的时候看出来。</p>
<h2 id="Map-初始化"><a href="#Map-初始化" class="headerlink" title="Map 初始化"></a>Map 初始化</h2><p>map  初始化的方式有以下两种：</p>
<pre><code class="go">make(map[k]v)
// 指定初始化大小为 hint 的 map
make(map[k]v,hint)
</code></pre>
<p>对于不指定初始化大小，和初始化值 <code>hint&lt;=8(bucketCnt)</code> 时，go会调用 <code>makemap_small</code> 函数（源码位置 <code>src/runtime/map.go</code>），并直接从堆上进行分配。</p>
<pre><code class="go">func makemap_small() *hmap &#123;
    h := new(hmap)
    h.hash0 = fastrand()
    return h
&#125;
</code></pre>
<p>当 <code>hint&gt;8</code> 时，则调用 <code>makemap</code> 函数：</p>
<pre><code class="go">// 如果编译器认为可以在栈上创建 map 和第一个 bucket，那么 h 和 bucket 可能都是非空
// 如果 h != nil，那么 map 可以直接在 h 中创建
// 如果 h.buckets != nil，那么 h 指向的 bucket 可以作为 map 的第一个 bucket 使用
func makemap(t *maptype, hint int, h *hmap) *hmap &#123;
    // math.MulUintptr 返回 hint 与 t.bucket.size 的乘积，并判断该乘积是否溢出。
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    // maxAlloc 的值，根据平台系统的差异而不同，具体计算方式参照 src/runtime/malloc.go
    if overflow || mem &gt; maxAlloc &#123;
        hint = 0
    &#125;

    // initialize Hmap
    if h == nil &#123;
        h = new(hmap)
    &#125;
    // 通过 fastrand 得到一个随机的哈希种子
    h.hash0 = fastrand()

    // 根据输入的元素个数 hint，找到能装下这些元素所需要的 B 值
    B := uint8(0)
    // 2^B &lt; hint/装载因子，找到满足条件的 B
    for overLoadFactor(hint, B) &#123;
        B++
    &#125;
    h.B = B

    // 分配初始哈希表
    // 如果 B 为0，那么 buckets 字段后续会在 mapassign 方法中 lazily 分配
    if h.B != 0 &#123;
        var nextOverflow *bmap
        // makeBucketArray 创建一个 map 的底层保存 buckets 的数组，它最少会分配 h.B^2 的大小。
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil &#123;
            h.extra = new(mapextra)
            h.extra.nextOverflow = nextOverflow
        &#125;
    &#125;

    return h
&#125;
</code></pre>
<p>分配 <code>buckets</code> 数组的 <code>makeBucketArray</code> 函数如下：</p>
<pre><code class="go">// makeBucket 为 map 创建用于保存 buckets 的数组。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) &#123;
    base := bucketShift(b)
    nbuckets := base
    // 对于小的 b 值（小于4），即桶的数量小于 16 时，使用溢出桶的可能性很小。对于此情况，就避免计算开销。
    if b &gt;= 4 &#123;
        // 当桶的数量大于等于 16 个时，正常情况下就会额外创建 2^(b-4) 个溢出桶
        nbuckets += bucketShift(b - 4)
        sz := t.bucket.size * nbuckets
        up := roundupsize(sz)
        if up != sz &#123;
            nbuckets = up / t.bucket.size
        &#125;
    &#125;

    // 这里，dirtyalloc 分两种情况。
    // 如果它为 nil，则会分配一个新的底层数组。
    // 如果它不为 nil，则它指向的是曾经分配过的底层数组，该底层数组是由之前同样的 t 和 b 参数通过 makeBucketArray 分配的
    // 如果数组不为空，需要把该数组之前的数据清空并复用。
    if dirtyalloc == nil &#123;
        // 由这里可以看出，正常桶和溢出桶在内存中的存储空间是连续的，因为分配的大小是正常桶+溢出桶
        buckets = newarray(t.bucket, int(nbuckets))
    &#125; else &#123;
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 &#123;
            memclrHasPointers(buckets, size)
        &#125; else &#123;
            memclrNoHeapPointers(buckets, size)
        &#125;
    &#125;

    // 在满足分配溢出桶的条件下，为了把跟踪这些溢出桶的开销降至最低，使用了以下约定：
    // 如果预分配的溢出桶的 overflow 指针为 nil，那么可以通过指针碰撞（bumping the pointer）获得更多可用桶。
    // 关于指针碰撞：假设内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”）
    if base != nbuckets &#123;
        // buckets(基地址) + base(2^B)*bucketsize, 即获得第一个 overflow
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
        // 对于最后一个溢出桶，需要一个安全的非 nil 指针指向它，这是为了保证这部分尚未使用的内存 GC 期间安全
        // 最后一个 overflow
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
        // 最后一个 overflow 指针指向 buckets(基地址, 也是安全的指针)
        last.setoverflow(t, (*bmap)(buckets))
    &#125;
    return buckets, nextOverflow
&#125;
</code></pre>
<p>通过上面的创建过程，初始化出来的 map 大致是如下的结构：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg" alt="初始化的map"></p>
<p>此外，还能看出，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <code>hmap</code> 中的不同字段引用而已</p>
<h2 id="Map-的哈希函数"><a href="#Map-的哈希函数" class="headerlink" title="Map 的哈希函数"></a>Map 的哈希函数</h2><p>在初始化 go 程序运行环境时（<code>src/runtime/proc.go </code>中的 <code>schedinit</code>），就需要通过 <code>alginit</code> 方法完成对哈希的初始化：</p>
<pre><code class="go">func schedinit() &#123;
    lockInit(&amp;sched.lock, lockRankSched)

    ...

    tracebackinit()
    moduledataverify()
    stackinit()
    mallocinit()
    fastrandinit() // must run before mcommoninit
    mcommoninit(_g_.m, -1)
    cpuinit()       // must run before alginit
    // 这里调用alginit()
    alginit()       // maps must not be used before this call
    modulesinit()   // provides activeModules
    typelinksinit() // uses maps, activeModules
    itabsinit()     // uses activeModules

    ...

    goargs()
    goenvs()
    parsedebugvars()
    gcinit()

      ...
 &#125;
</code></pre>
<p>对于哈希算法的选择，程序会根据当前架构判断是否支持 <code>AES</code>，如果支持就使用 <code>AES hash</code>，其实现的代码位于 <code>src/runtime/asm_&#123;386,amd64,arm64&#125;.s</code> 中；若不支持，其 hash 算法则根据 <code>xxhash</code> 算法和 <code>cityhash</code> 算法启发而来，代码分别对应于 32 位（<code>src/runtime/hash32.go</code>）和 64 位机器（<code>src/runtime/hash32.go</code>）中：</p>
<pre><code class="go">func alginit() &#123;
    // Install AES hash algorithms if the instructions needed are present.
    if (GOARCH == &quot;386&quot; || GOARCH == &quot;amd64&quot;) &amp;&amp;
        cpu.X86.HasAES &amp;&amp; // AESENC
        cpu.X86.HasSSSE3 &amp;&amp; // PSHUFB
        cpu.X86.HasSSE41 &#123; // PINSR&#123;D,Q&#125;
        initAlgAES()
        return
    &#125;
    if GOARCH == &quot;arm64&quot; &amp;&amp; cpu.ARM64.HasAES &#123;
        initAlgAES()
        return
    &#125;
    getRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(&amp;hashkey))[:])
    hashkey[0] |= 1 // make sure these numbers are odd
    hashkey[1] |= 1
    hashkey[2] |= 1
    hashkey[3] |= 1
&#125;
</code></pre>
<p>上面在创建 map 的时候，map 的哈希种子是通过 <code>h.hash0 = fastrand()</code> 得到的。它是在以下 <code>maptype</code> 中的 <code>hasher</code> 中被使用到，在下文内容中会看到hash值的生成。</p>
<pre><code class="go">type maptype struct &#123;
    typ    _type
    key    *_type
    elem   *_type
    bucket *_type // internal type representing a hash bucket
    // hasher 的第一个参数就是指向 key 的指针，
    // h.hash0 = fastrand() 得到的 hash0，就是 hasher 方法的第二个参数。
    // hasher方法返回的就是hash值。
    hasher     func(unsafe.Pointer, uintptr) uintptr
    keysize    uint8  // size of key slot
    elemsize   uint8  // size of elem slot
    bucketsize uint16 // size of bucket
    flags      uint32
&#125;
</code></pre>
<h2 id="Map-的基本操作"><a href="#Map-的基本操作" class="headerlink" title="Map 的基本操作"></a>Map 的基本操作</h2><h3 id="Key-的定位"><a href="#Key-的定位" class="headerlink" title="Key 的定位"></a>Key 的定位</h3><p>假定 key 经过哈希计算后得到 64bit 位的哈希值。如果 B&#x3D;5，buckets 数组的长度，即桶的数量是 32（2 的 5 次方）。</p>
<p>例如，现要置一key于map中，该key经过哈希后，得到的哈希值如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%81%87%E5%AE%9A%E7%9A%8464%E4%BD%8D%E5%93%88%E5%B8%8C%E5%80%BC.png" alt="假定的64位哈希值"></p>
<p>哈希值低位（<code>low-order bits</code>）用于选择桶，哈希值高位（<code>high-order bits</code>）用于在一个独立的桶中区别出键。当 B 等于 5 时，那么选择的哈希值低位也是 5 位，即 01010，它的十进制值为10，代表 10 号桶。再用哈希值的高 8 位，找到此 key 在桶中的位置。最开始桶中还没有 key，那么新加入的 key 和 value 就会被放入第一个 key 空位和 value 空位。</p>
<p>注意：对于高八位的选择，该操作的实质是取余，但是取余开销很大，在实际代码实现中采用的是位操作，其实现如下：</p>
<pre><code class="go">func tophash(hash uintptr) uint8 &#123;
    top := uint8(hash &gt;&gt; (sys.PtrSize*8 - 8))
    if top &lt; minTopHash &#123;
        top += minTopHash
    &#125;
    return top
&#125;
</code></pre>
<p>当两个不同的 key 落在了同一个桶中，这时就发生了哈希冲突。go 的解决方式是链地址法（这里只描述非扩容且该 key 是第一次添加的情况）：在桶中按照顺序寻到第一个空位并记录下来，后续在该桶和它的溢出桶中均未发现存在的该 key，将 key 置于第一个空位；否则，去该桶的溢出桶中寻找空位，如果没有溢出桶，则添加溢出桶，并将其置溢出桶的第一个空位。</p>
<p>例如，下图中的 B 值为 5，所以桶的数量为 32。通过哈希函数计算出待插入 key 的哈希值，低 5 位哈希00110，对应于 6 号桶；高 8 位10010111，十进制为 151，由于桶中前 6 个 cell 已经有正常哈希值填充了(遍历)，所以将 151 对应的高位哈希值放置于第 7 位cell（第8个 cell 为empty Rest，表明它还未使用），对应将 key 和 value 分别置于相应的第七个空位。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Map%20key%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91.webp" alt="Map key的查找和插入逻辑"></p>
<p>如果是查找 key，那么会根据高位哈希值去桶中的每个 cell 中找，若在桶中没找到，并且 overflow 不为nil，那么继续去溢出桶中寻找，直至找到，如果所有的 cell 都找过了，还未找到，则返回 key 类型的默认值（例如 key 是 int 类型，则返回 0）。</p>
<h3 id="查找key"><a href="#查找key" class="headerlink" title="查找key"></a>查找key</h3><p>通过 <code>key</code> 查找 <code>value</code> 的方式有以下两种：</p>
<pre><code class="go">v     := hash[key] // =&gt; v     := *mapaccess1(maptype, hash, &amp;key)
v, ok := hash[key] // =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)
</code></pre>
<p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p>
<ul>
<li>当接受一个参数时，会使用 <code>mapaccess1</code>，该函数仅会返回一个指向目标值的指针；</li>
<li>当接受两个参数时，会使用 <code>mapaccess2</code>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 <code>bool</code> 值。</li>
</ul>
<p><code>mapaccess1</code> 查找 <code>key</code> 的代码实现如下：</p>
<pre><code class="go">func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123;
    // 如果开启了竞态检测 -race
    if raceenabled &amp;&amp; h != nil &#123;
        callerpc := getcallerpc()
        pc := funcPC(mapaccess1)
        racereadpc(unsafe.Pointer(h), callerpc, pc)
        raceReadObjectPC(t.key, key, callerpc, pc)
    &#125;
    // 如果开启了 memory sanitizer -msan
    if msanenabled &amp;&amp; h != nil &#123;
        msanread(key, t.key.size)
    &#125;
    // 如果 map 为空或者元素个数为 0，返回零值
    if h == nil || h.count == 0 &#123;
        if t.hashMightPanic() &#123;
            t.hasher(key, 0) // see issue 23734
        &#125;
        return unsafe.Pointer(&amp;zeroVal[0])
    &#125;
    // 注意，这里是按位与操作
    // 当 h.flags 对应的值为 hashWriting（代表有其他 goroutine 正在往 map 中写 key）时，
    // 那么位计算的结果不为 0，因此抛出以下错误。
    // 这也表明，go 的 map 是非并发安全的
    if h.flags&amp;hashWriting != 0 &#123;
        throw(&quot;concurrent map read and map write&quot;)
    &#125;
    // 不同类型的 key，会使用不同的 hash 算法，这里获取 hash 值
    hash := t.hasher(key, uintptr(h.hash0))
    // 返回 1 &lt;&lt; b-1，即 low-order bits，用于下面与操作筛选出对应的 bucket
    m := bucketMask(h.B)
    // 按位与操作，找到对应的 bucket
    b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))
    // 如果 oldbuckets 不为空，那么证明 map 发生了扩容
      // 如果有扩容发生，老的 buckets 中的数据可能还未搬迁至新的 buckets 里
      // 所以需要先在老的 buckets 中找
    if c := h.oldbuckets; c != nil &#123;
        if !h.sameSizeGrow() &#123;
            // 增量扩容情况下，老 buckets 数组的大小是原来的一半
            m &gt;&gt;= 1
        &#125;
        // 找到 oldbucket 地址
        oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))
        // 如果在 oldbuckets 中 tophash[0] 的值，为 evacuatedX、evacuatedY，evacuatedEmpty 其中之一
        // 则 evacuated() 返回为true，说明搬迁完成。
        // 因此，只有当搬迁未完成时，才会从此 oldbucket 中遍历
        if !evacuated(oldb) &#123;
            b = oldb
        &#125;
    &#125;
    // 取出当前 key 值的 tophash 值，即高八位的值
    top := tophash(hash)
bucketloop:
    // 以下是查找的核心逻辑
      // 双重循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的 cell 遍历
      // 跳出循环的条件有三种：
    // 1. 第一种是已经找到 key 值；
    // 2. 第二种是当前桶再无溢出桶；
    // 3. 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest，这个值它代表此时的桶后面的 cell 还未利用，所以无需再继续遍历。
    // 初始化时 b 为 key 所在的桶，此时是在正常桶中
    for ; b != nil; b = b.overflow(t) &#123;
        // 该桶存放最多 8 个键值对，依次对比 tophash 值是否相等
        for i := uintptr(0); i &lt; bucketCnt; i++ &#123;
            if b.tophash[i] != top &#123;
                // 不相等且满足第三种条件，跳出循环
                if b.tophash[i] == emptyRest &#123;
                    break bucketloop
                &#125;
                // 不相等继续遍历
                continue
            &#125;
            // 因为在 bucket 中 key 是用连续的存储空间存储的，因此可以通过 bucket 地址 +
            // 数据偏移量（bmap 结构体的大小，也就是 tophash 占用的大小，因为 dataOffset 定义的是声明的 bmap）+ 
            // keysize 的大小，得到 k 的地址
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            // 如果 key 是指针（当键超过 maxKeySize（128个字节）时会转换为指针），则需要进行解引用
            if t.() &#123;
                k = *((*unsafe.Pointer)(k))
            &#125;
            // 判断 key 是否相等
            if t.key.equal(key, k) &#123;
                // 同理，value 的地址也是相似的计算方法，只是再要加上8个 keysize 的内存地址
                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
                // 如果 value 是指针，解引用
                if t.indirectelem() &#123;
                    e = *((*unsafe.Pointer)(e))
                &#125;
                // 返回找到的值
                return e
            &#125;
        &#125;
    &#125;
    // 所有的bucket都未找到，则返回零值
    return unsafe.Pointer(&amp;zeroVal[0])
&#125;
</code></pre>
<p>根据上面的代码，可以看出它的查找流程如下：</p>
<ol>
<li>判断 map 是否为空，为空的话返回零值</li>
<li>通过按位与的操作检测 map 是否有其他线程在进行写入，有的话则抛出错误。这也表明 map <strong>不是并发安全的</strong></li>
<li>对 key 取 hash 获得哈希值，通过哈希值的低位确定在哪一个 bucket</li>
<li>判断是否发生了扩容，如果发生了扩容并且键值搬迁未完成，则需要先到 old bucket 中查找</li>
<li>开始内外层循环遍历，依次对比 tophash 是否相等，直到找到对应的 key 或者找不到退出循环，查找过程结束</li>
</ol>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.webp" alt="go map 查找流程"></p>
<p>对于 <code>mapaccess2</code> 函数，它的函数签名如下：</p>
<pre><code class="go">func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)
</code></pre>
<p>与 <code>mapaccess1</code> 相比，<code>mapaccess2  </code>只是多了一个bool类型的返回值，它代表的是是否在 map 中找到了对应的<code>key</code> ，这里贴一下间断的代码：</p>
<pre><code class="go">func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) &#123;
    ...
bucketloop:
    for ; b != nil; b = b.overflow(t) &#123;
        for i := uintptr(0); i &lt; bucketCnt; i++ &#123;
            if b.tophash[i] != top &#123;
                if b.tophash[i] == emptyRest &#123;
                    break bucketloop
                &#125;
                continue
            &#125;
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            if alg.equal(key, k) &#123;
                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
                // 多了一个 boolean 返回值
                return v, true
            &#125;
        &#125;
    &#125;
    // 找不到，返回 false
    return unsafe.Pointer(&amp;zeroVal[0]), false
&#125;
</code></pre>
<p>同时，源码中还有mapaccessK方法，它的函数签名如下。</p>
<pre><code class="go">func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) &#123;&#125;
</code></pre>
<p>与 <code>mapaccess1</code> 相比，<code>mapaccessK</code> 同时返回了 <code>key</code>和 <code>value</code>，其代码逻辑也一致。</p>
<h3 id="写入-key"><a href="#写入-key" class="headerlink" title="写入 key"></a>写入 key</h3><p>向 map 中插入或者修改 <code>key</code>，最终调用的是 <code>mapassign</code> 函数。</p>
<p>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</p>
<p><code>mapassign</code> 函数如下：</p>
<pre><code class="go">func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123;
    // 如果 h 是空指针，赋值会引起panic
    // 例如以下语句
    // var m map[string]int
    // m[&quot;k&quot;] = 1
    if h == nil &#123;
        panic(plainError(&quot;assignment to entry in nil map&quot;))
    &#125;
    // 如果开启了竞态检测 -race
    if raceenabled &#123;
        callerpc := getcallerpc()
        pc := funcPC(mapassign)
        racewritepc(unsafe.Pointer(h), callerpc, pc)
        raceReadObjectPC(t.key, key, callerpc, pc)
    &#125;
    // 如果开启了memory sanitizer -msan
    if msanenabled &#123;
        msanread(key, t.key.size)
    &#125;
    // 同样检查是否有其他 goroutine 正在对 map 进行 key 写入，有的话抛出错误
    if h.flags&amp;hashWriting != 0 &#123;
        throw(&quot;concurrent map writes&quot;)
    &#125;
    // 获取哈希值
    hash := t.hasher(key, uintptr(h.hash0))

    // 将 flags 的值与 hashWriting 做按位&quot;异或&quot;运算并赋值到 flags
       // 因为在当前 goroutine 可能还未完成 key 的写入，再次调用 t.hasher 会发生 panic。
    h.flags ^= hashWriting

    // 这种情况在初始化 map 并且 hint&lt;=8(bucketCnt)时，由于直接在堆上进行分配，所以会出现
    if h.buckets == nil &#123;
        h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
    &#125;

again:
    // bucketMask 返回值是 2 的 B 次方减 1，即 low-order bits
    // 因此，通过 hash 值与 bucketMask 返回值做按位与操作获取 low-order bits，
    // 返回在 buckets 数组中的第几号桶
    bucket := hash &amp; bucketMask(h.B)
    // 如果 map 正在搬迁（即h.oldbuckets != nil）中,则先进行搬迁工作。
    if h.growing() &#123;
        growWork(t, h, bucket)
    &#125;
    // 计算出上面求出的 bucket 的内存位置
    // post = start + bucketNumber * bucketsize
    b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
    // 获取高八位哈希值
    top := tophash(hash)

    var inserti *uint8
    var insertk unsafe.Pointer
    var elem unsafe.Pointer
bucketloop:
    for &#123;
        // 遍历桶中的 8 个 cell
        for i := uintptr(0); i &lt; bucketCnt; i++ &#123;
        
            // 这里分两种情况：
            
            // 第一种情况是 cell 位的 tophash 值和当前 tophash 值不相等
               // 在 b.tophash[i] != top 的情况下，这个位置有可能会是一个空槽位
               // 一般情况下 map 的槽位分布是这样的，e 表示 empty:
               // [h0][h1][h2][h3][h4][e][e][e]
               // 但在执行过 delete 操作时，可能会变成这样:
               // [h0][h1][e][e][h5][e][e][e]
               // 所以如果再插入的话，会尽量往前面的位置插
               // [h0][h1][e][e][h5][e][e][e]
               //          ^
               //          ^
               //       这个位置
               // 所以在循环的时候还要顺便把前面的空位置先记下来
               // 因为有可能在后面会找到相等的 key，也可能找不到相等的 key
            if b.tophash[i] != top &#123;
                // 当前是一个空槽位并且这是第一个空位
                if isEmpty(b.tophash[i]) &amp;&amp; inserti == nil &#123;
                    // 记录这个空闲的位置tophash的地址，用于后面赋值，同时获取将要插入 k，v 位置的地址
                    inserti = &amp;b.tophash[i]
                    insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
                &#125;
                // 查找到末尾了，break 跳出循环
                if b.tophash[i] == emptyRest &#123;
                    break bucketloop
                &#125;
                continue
            &#125;
            // 第二种情况是 cell 位的 tophash 值和当前的 tophash 值相等
            // 查找当前 cell 位的 key 值
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            if t.indirectkey() &#123;
                k = *((*unsafe.Pointer)(k))
            &#125;
            // 注意，即使当前 cell 位的 tophash 值相等，不一定它对应的 key 也是相等的
            // 所以还要做一个 key 值判断，判断如果 key 值不相等，记录下一轮遍历
            if !t.key.equal(key, k) &#123;
                continue
            &#125;
            // 如果已经有该 key 了，就更新它
            if t.needkeyupdate() &#123;
                typedmemmove(t.key, k, key)
            &#125;
            // 这里获取到了要插入 key 对应的 value 的内存地址
               // pos = start + dataOffset + 8*keysize + i*elemsize
            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
            // 如果顺利到这，就直接跳到done的结束逻辑中去
            // 这种情况下不会触发下面的情况，直接跳到 done
            goto done
        &#125;
        // 如果桶中的 8 个 cell 遍历完，还未找到对应的空 cell 或覆盖 cell，
        // 那么就进入它的溢出桶中去遍历
        ovf := b.overflow(t)
        // 如果连溢出桶中都没有找到合适的 cell，跳出循环。
        if ovf == nil &#123;
            break
        &#125;
        b = ovf
    &#125;

    
    // 在已有的桶和溢出桶中都未找到合适的 cell 供 key 写入，那么有可能会触发以下两种情况
      
    // 情况一：
      // 判断当前 map 的装载因子是否达到设定的 6.5 阈值，或者当前 map 的溢出桶数量是否过多。如果存在这两种情况之一，则进行扩容操作。
      // 注意，这里 hashGrow() 实际并未完成扩容，对哈希表数据的搬迁（复制）操作是通过 growWork() 来完成的。
      // 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。
    if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;
        // 此处涉及的扩容机制后面讲
        hashGrow(t, h)
        goto again
    &#125;

    // 情况二：
    // 在不满足情况一的条件下，会为当前桶再新建溢出桶，
    // 并将 tophash，key 插入到新建溢出桶的对应内存的 0 号位置
    if inserti == nil &#123;
        // 获取新建溢出桶的位置（后面有分析这个函数的实现）
        newb := h.newoverflow(t, b)
        // 记录这个空闲的位置tophash的地址，用于后面赋值，同时获取将要插入 k、v 的位置的指针
        inserti = &amp;newb.tophash[0]
        insertk = add(unsafe.Pointer(newb), dataOffset)
        elem = add(insertk, bucketCnt*uintptr(t.keysize))
    &#125;

    // 如果 key 是指针（当键超过 maxKeySize（128个字节）时会转换为指针），则需要进行解引用获取值
    if t.indirectkey() &#123;
        kmem := newobject(t.key)
        // 赋值
        *(*unsafe.Pointer)(insertk) = kmem
        insertk = kmem
    &#125;
    // value 同理
    if t.indirectelem() &#123;
        vmem := newobject(t.elem)
        // 获取 value 应该插入的地址
        *(*unsafe.Pointer)(elem) = vmem
    &#125;
    // 更新 key 值
    typedmemmove(t.key, insertk, key)
    // 将 tophash 赋值到bmap tophash数组的[i]位置
    *inserti = top
    h.count++

done:
    // 再判断一次当前 map 是否有其他 goroutine 在写
    if h.flags&amp;hashWriting == 0 &#123;
        throw(&quot;concurrent map writes&quot;)
    &#125;
    h.flags &amp;^= hashWriting
    if t.indirectelem() &#123;
        // 获取 value 应该插入的地址
        elem = *((*unsafe.Pointer)(elem))
    &#125;
    // 返回 value 的底层内存位置
    return elem
&#125;
</code></pre>
<p>在上面的写入流程中，在已有的桶和溢出桶中都未找到合适的 <code>cell</code> 供 <code>key</code> 写入，并且尚不满足扩容阈值的情况下，会通过 <code>newoverflow</code> 获得新的溢出桶。前面 map 初始化的时候提到过，其初始化后的结构是这样子的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84map.jpg" alt="初始化的map"></p>
<p>所以  <code>extra.nextOverflow</code> 会指向预分配的溢出桶，另外最后一个溢出桶的 <code>overflow</code> 会指向 <code>buckets[0]</code>，通过这个特性，可以用来判断是否是最后一个溢出桶。</p>
<p>这里再分析一下 <code>newoverflow</code> 的实现：</p>
<pre><code class="go">func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap &#123;
    var ovf *bmap
    // 在创建 map 时，实际上会先分配一部分溢出桶用于后续需要
    // 这里就会先检查是否有预分配的溢出桶，并且溢出桶还没有用完
    if h.extra != nil &amp;&amp; h.extra.nextOverflow != nil &#123;
        // ovf 指向预分配的溢出桶位置
        ovf = h.extra.nextOverflow
        // overflow 为 nil ，说明不是最后一个桶
        if ovf.overflow(t) == nil &#123;
            // 这时候只需要修改 nextOverflow 地址指向下一个溢出桶(因为内存是连续的)，即碰撞指针的思想
            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
        &#125; else &#123;
            // overflow 不是 nil，说明这是最后的一个桶了，
            // 重置此桶上的 overflow 指针为 nil，同时设置 extra.nextOverflow = nil,
            // 标记溢出桶已经用完了
            ovf.setoverflow(t, nil)
            h.extra.nextOverflow = nil
        &#125;
    &#125; else &#123;
        // 没有溢出桶 或者 溢出桶用完了
        // 内存空间重新分配一个bmap
        ovf = (*bmap)(newobject(t.bucket))
    &#125;
    // 生成溢出桶 bmap 的计数器计数
    h.incrnoverflow()
    if t.bucket.ptrdata == 0 &#123;
        // 创建 extra 和 overflow
        h.createOverflow()
        *h.extra.overflow = append(*h.extra.overflow, ovf)
    &#125;
    // 将这个 bucket 的 overflow 指针指向溢出桶
    b.setoverflow(t, ovf)
    return ovf
&#125;
</code></pre>
<p>通过对 <code>mapassign</code> 的代码分析之后，发现该函数并没有将插入 <code>key</code> 对应的 <code>value</code> 写入对应的内存，而是返回了 <code>value</code> 应该插入的内存地址。也就是说 <strong>map 并不会在 <code>mapassign</code> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址</strong>。</p>
<p>真正的赋值操作是<strong>在编译期间插入</strong>的，对下面的程序使用 <code>go tool</code> 工具分析：</p>
<pre><code class="go">package main

func main() &#123;
    m := make(map[int]int)
    for i := 0; i &lt; 100; i++ &#123;
        m[i] = 666
    &#125;
&#125;
</code></pre>
<p><code>m[i] = 666</code>对应的汇编代码</p>
<pre><code class="shell"> $ go tool compile -S map.go
 ...
         0x0098 00152 (map.go:6) LEAQ    type.map[int]int(SB), CX
         0x009f 00159 (map.go:6) MOVQ    CX, (SP)
         0x00a3 00163 (map.go:6) LEAQ    &quot;&quot;..autotmp_2+184(SP), DX
         0x00ab 00171 (map.go:6) MOVQ    DX, 8(SP)
         0x00b0 00176 (map.go:6) MOVQ    AX, 16(SP)
         0x00b5 00181 (map.go:6) CALL    runtime.mapassign_fast64(SB) // 调用函数runtime.mapassign_fast64，该函数实质就是 mapassign（上文示例源代码是该 mapassign 系列的通用逻辑）
         0x00ba 00186 (map.go:6) MOVQ    24(SP), AX 24(SP), AX // 返回值，即 value 应该存放的内存地址
        0x00bf 00191 (map.go:6) MOVQ    $666, (AX) // 把 666 放入该地址中
...        
</code></pre>
<p>可以看到，赋值的最后一步实际上是<strong>编译器额外生成的汇编指令来完成的</strong>，可见靠 runtime 有些工作是没有做完的。所以，在 go 中，编译器和 runtime 配合，才能完成一些复杂的工作。</p>
<p>此外，可以看到上面的函数调用是 <code> runtime.mapassign_fast64</code>，这里说明一下：</p>
<blockquote>
<p> <code>mapassign</code> 有一系列的函数，根据 <code>key</code> 类型的不同，编译器会将其优化为相应的“快速函数”，但在实现思路上其实都跟 <code>mapassign</code> 一样。类型有以下这些：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">插入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
</tbody></table>
</blockquote>
<p>最后，总结一下 map 中 key 的写入流程：</p>
<ol>
<li>检测 map 中 <code>hmap</code> 是否为空指针，是否有其他 <code>groutine</code> 在进行写入，如果有抛出错误；标记 <code>flags</code> 表示当前 <code>groutine</code> 在对 map 进行写操作</li>
<li>根据哈希值的低位获得对应的 bucket</li>
<li>判断是否正在进行扩容后的搬迁，如果是则先进行搬迁</li>
<li>计算高八位的哈希值，首先循环遍历桶中的 8 个 cell，如果 8 个 cell 遍历完还没有，则到溢出桶中进行遍历。这里分两种情况：</li>
</ol>
<ul>
<li>第一种情况是 cell 位的 <code>tophash</code> 值和当前 <code>tophash</code> 值不相等，因为有可能删除导致中间个别 <code>cell</code> 没有值，但是在后面又还有可能找到相等的 <code>tophash</code>，所以这时会先记录第一个不相等的值（可能当前位为空），然后继续遍历，目的是尽可能往前插入键值</li>
<li>第二种情况是 <code>cell</code> 位的 <code>tophash</code> 值和当前的 <code>tophash</code> 值相等，此时会查看当前的 key 值，因为即使当前 <code>cell</code> 位的 <code>tophash</code> 值相等，不一定它对应的 <code>key</code> 也是相等的。不相等则继续遍历，相等则获取当前 <code>value</code> 的地址直接返回(相当于更新 value）。</li>
</ul>
<ol start="5">
<li>如果遍历所有之后没有找到合适的位置，则需要新建溢出桶来承载键值对。这里也分为两种情况：</li>
</ol>
<ul>
<li><p>第一种是需要判断当前 map 的装载因子是否达到 6.5 的阈值或者溢出桶过多，这两种情况都需要对 map 进行扩容处理后再重新遍历</p>
</li>
<li><p>第二种情况则是在在不满足情况一的条件下，为当前桶新建溢出桶，并将 <code>tophash</code>，<code>key</code> 插入到新建溢出桶的对应内存的 0 号位置，然后返回 <code>value</code> 的底层内存位置</p>
</li>
</ul>
<h3 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h3><p>map 在扩容的时候有两个指标：<strong>装载因子</strong>和<strong>溢出桶的数量</strong>。</p>
<p>为了保证访问效率，当 map 将要添加、修改或删除 <code>key</code> 时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。在上面源码 <code>mapassign</code> 中，其实已经注释 map 扩容条件，主要是两点：</p>
<ol>
<li>判断已经达到装载因子的临界点，即<code>元素个数 &gt; 桶（bucket）总数 * 6.5</code>，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到 6.5 个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。</li>
</ol>
<pre><code class="go">func overLoadFactor(count int, B uint8) bool &#123;
    return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)
&#125;
</code></pre>
<ol start="2">
<li>判断溢出桶是否太多，当<code>桶总数 &lt; 2 ^ 15</code> 时，如果<code>溢出桶总数 &gt;= 桶总数</code>，则认为溢出桶过多。当<code>桶总数 &gt;= 2 ^ 15</code> 时，直接与 <code>2 ^ 15</code> 比较，当<code>溢出桶总数 &gt;= 2 ^ 15</code> 时，即认为溢出桶太多了。</li>
</ol>
<pre><code class="go">func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123;
    if B &gt; 15 &#123;
        B = 15
    &#125;
    return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)
&#125;
</code></pre>
<p>对于第2点，其实是对第 1 点的补充。因为在装载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而仅判断第 1 点是避免不了这种情况的。在这种情况下，计算装载因子的分子比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。</p>
<p>在某些场景下，比如不断的增删，这样会造成 overflow 的 bucket 数量增多，但负载因子又不高，未达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 点判断指标。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。 </p>
<p>例如下面，由于 map 的不断删除，0 号 bucket 中的桶链就造成了大量的稀疏桶。</p>
<p><img src="https://qiniu.xiaoming.net.cn/tooManyOverflowBuckets%E6%83%85%E5%86%B5.webp" alt="tooManyOverflowBuckets情况"></p>
<p>针对这两种情况，官方采用了不同的解决方案</p>
<ul>
<li>针对 1，将 B + 1，新建一个 buckets 数组，也就是说新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。该方法称之为<strong>增量扩容</strong>。</li>
<li>针对 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使 bucket 的使用率更高，进而保证更快的存取。该方法称之为<strong>等量扩容</strong>。</li>
</ul>
<p>对于 2 的解决方案，其实存在一个极端的情况：如果插入 map 的 key 哈希都一样，那么它们就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。但 <strong>Go 的每一个 map 都会在初始化阶段的 makemap 时定一个随机的哈希种子，所以要构造这种冲突是没那么容易的</strong>。</p>
<p>在源码中，和扩容相关的主要是 <code>hashGrow()</code> 函数与 <code>growWork()</code> 函数<strong>。<code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 <code>mapassign()</code> 和 <code>mapdelete()</code> 函数中。</strong>也就是插入（包括修改）、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。它们会先检查 oldbuckets 是否搬迁完毕（检查 oldbuckets 是否为 nil），再决定是否进行搬迁工作。</p>
<p>再重新看一下 <code>mapassign</code> 的相关片段：</p>
<pre><code class="go">again:
    ...
    // 如果 map 正在搬迁（即h.oldbuckets != nil）中,则先进行搬迁工作。
    if h.growing() &#123;
        // 这里其实只搬迁了当前的 bucket
        growWork(t, h, bucket)
    &#125;
    ...


    // 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。
    if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;
        // 分配新的 buckets，并将老的 buckets 挂到 oldbuckets 字段上
        hashGrow(t, h)
        goto again
    &#125;
</code></pre>
<p>再分别看看 <code>hashGrow</code> 和 <code>growWork</code>  的实现:</p>
<p><code>hashGrow</code> 函数：</p>
<pre><code class="go">func hashGrow(t *maptype, h *hmap) &#123;
    // 如果达到条件 1，那么将 B 值加 1，相当于是原来的 2 倍
       // 否则对应条件 2，进行等量扩容，所以 B 不变
    bigger := uint8(1)
    if !overLoadFactor(h.count+1, h.B) &#123;
        bigger = 0
        h.flags |= sameSizeGrow
    &#125;
    // 记录老的buckets
    oldbuckets := h.buckets
    // 申请新的 buckets 空间
    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)

    // 注意 &amp;^ 运算符，这块代码的逻辑是转移标志位
    flags := h.flags &amp;^ (iterator | oldIterator)
    if h.flags&amp;iterator != 0 &#123;
        flags |= oldIterator
    &#125;
    // 提交 grow
    h.B += bigger
    h.flags = flags
    h.oldbuckets = oldbuckets
    h.buckets = newbuckets
    // 搬迁进度为0
    h.nevacuate = 0
    // overflow buckets 数为0
    h.noverflow = 0

    // 如果发现 hmap 是通过 extra 字段来存储 overflow buckets 时
    if h.extra != nil &amp;&amp; h.extra.overflow != nil &#123;
        // Promote current overflow buckets to the old generation.
        if h.extra.oldoverflow != nil &#123;
            throw(&quot;oldoverflow is not nil&quot;)
        &#125;
        h.extra.oldoverflow = h.extra.overflow
        h.extra.overflow = nil
    &#125;
    if nextOverflow != nil &#123;
        if h.extra == nil &#123;
            h.extra = new(mapextra)
        &#125;
        h.extra.nextOverflow = nextOverflow
    &#125;
&#125;
</code></pre>
<p><code>growWork</code> 函数：</p>
<pre><code class="go">func growWork(t *maptype, h *hmap, bucket uintptr) &#123;
    // 为了确认搬迁的 bucket 是我们正在使用的 bucket
      // 即如果当前 key 映射到老的 bucket1，那么就搬迁该 bucket1。
    evacuate(t, h, bucket&amp;h.oldbucketmask())

    // 如果还未完成扩容工作，则再搬迁一个bucket。
    if h.growing() &#123;
        evacuate(t, h, h.nevacuate)
    &#125;
&#125;
</code></pre>
<p>从 <code>growWork()</code> 函数可以知道，搬迁的核心逻辑是 <code>evacuate()</code> 函数。</p>
<p>从上面可以看出，扩容过程是渐进性的，每次最多搬迁两个桶。</p>
<p><strong>为什么每次至多搬迁 2 个bucket？</strong></p>
<p>这其实是一种性能考量，如果 map 存储了数以亿计的 <code>key-value</code>，一次性搬迁将会造成比较大的延时，因此才采用逐步搬迁策略。</p>
<p>在搬迁函数 <code>evacuate</code> 中，其逻辑主要涉及一个是 <strong>bucket 序列号的变化</strong>，另外一个就是<strong>搬迁区间的确认</strong>。</p>
<ul>
<li><strong>bucket 序列号的变化</strong></li>
</ul>
<p>对于 bucket 序列号的变化，增量扩容（条件1）和等量扩容（条件2）都需要进行 bucket 的搬迁工作。对于等量扩容而言，由于 buckets 的数量不变，因此可以按照序号来搬迁。例如老的的 0 号 bucket，仍然搬至新的 0 号 bucket 中。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="等量扩容bucket序列号"></p>
<p>但是，对于增量扩容而言，就会有所不同。例如原来的 B&#x3D;5，那么增量扩容时，B 就会变成 6。那么决定 key 值落入哪个 bucket 的低位哈希值就会发生变化（<strong>从取 5 位变为取 6 位</strong>），取新的低位 hash 值得过程称为 <strong>rehash</strong>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9bucket%E5%BA%8F%E5%88%97%E5%8F%B7.webp" alt="增量扩容bucket序列号"></p>
<p>因此，在增量扩容中，某个 key 在搬迁前后 bucket 序号可能和原来相等，<strong>也可能是相比原来加上 2^B（原来的 B 值），取决于低 hash 值第倒数第 B+1 位是 0 还是 1</strong>。</p>
<p>如下图中，当原始的 B &#x3D; 3 时，旧 buckets 数组长度为 8，在编号为 2 的 bucket 中，其 2 号 cell 和 5 号 cell，它们的低 3 位哈希值相同（不相同的话，也就不会落在同一个桶中了），但是它们的低 4 位分别是 0010、1010。当发生了增量扩容，2 号就会被搬迁到新 buckets 数组的 2 号 bucket 中去，5 号被搬迁到新 buckets 数组的 10 号 bucket 中去，它们的桶号差距是 2 的 3 次方。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9rehash.webp" alt="增量扩容rehash"></p>
<ul>
<li><strong>搬迁区间的确认</strong></li>
</ul>
<p>在源码中，有 <code>bucket x</code> 和 <code>bucket y</code> 的概念，其实就是增量扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 <code>bucket x</code>，后一半桶被称为 <code>bucket y</code>。一个 bucket 中的 key 可能会分裂到两个桶中去，分别位于 <code>bucket x</code> 的桶，或 <code>bucket y</code> 中的桶。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个区间（而对于同一个桶而言，搬迁到 <code>bucket x</code> 和 <code>bucket y</code> 桶序号的差别是老的 buckets 大小，即 <code>2^old_B</code>）。</p>
<p><img src="https://qiniu.xiaoming.net.cn/bucketX%E5%92%8CbucketY.webp" alt="bucketX和bucketY"></p>
<p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 <code>key/value</code> 值 copy 到目的地相应的位置。设置 <code>key</code> 在原始 buckets 的 <code>tophash</code> 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的<code>bucket x</code> 或是 <code>bucket y</code>，新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p>
<p><strong>为什么确定 key 落在哪个区间很重要？</strong></p>
<p>因为对于增量扩容而言，原本一个 <code>bucket</code> 中的 <code>key</code> 会被分裂到两个 <code>bucket</code> 中去，它们分别处于 <code>bucket x</code> 和 <code>bucket y</code> 中，但是它们之间存在关系 <code>bucket x + 2^B = bucket y</code> （其中，B 是老 bucket 对应的 B 值）。</p>
<p>假设 <code>key</code> 所在的老 <code>bucket</code> 序号为 n，那么如果 <code>key</code> 落在新的 <code>bucket x</code>，则它应该置入 <code> bucket x 起始位置 + n*bucket</code> 的内存中去；如果 <code>key</code> 落在新的 <code>bucket y</code>，则它应该置入 <code>bucket y 起始位置 + n*bucket</code> 的内存中去。因此，确定 <code>key</code> 落在哪个区间，这样就很方便进行内存地址计算，快速找到 <code>key</code> 应该插入的内存地址。</p>
<p>下面看看 <code>evacuate() </code> 函数的具体实现：</p>
<pre><code class="go">func evacuate(t *maptype, h *hmap, oldbucket uintptr) &#123;
    // 传进来的 oldbucket 实际上是当前定位到的需要搬迁的 bucket
    // 这里首先定位原先 bucket 的位置
    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
    // 获取扩容之前 bucket 的个数
    newbit := h.noldbuckets()
    // 判断该 bucket 是否已经完成搬迁
    if !evacuated(b) &#123;
        
        // 官方TODO，后续也许会实现：如果没有迭代器使用旧的存储桶，则重用溢出存储桶而不是使用新的存储桶。 

        // xy 包含了高低区间的搬迁目的地内存信息，[bucket, index, key, value]
         // x.b 是对应的搬迁目的桶
         // x.k 是指向对应目的桶中存储当前 key 的内存地址
        // x.e 是指向对应目的桶中存储当前 value 的内存地址
        var xy [2]evacDst
        x := &amp;xy[0]
        // 获取基地址
        x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
        x.k = add(unsafe.Pointer(x.b), dataOffset)
        x.e = add(x.k, bucketCnt*uintptr(t.keysize))

        // 只有当增量扩容时才计算 bucket y 的相关信息（和后续计算 useY 相呼应）
        if !h.sameSizeGrow() &#123;
            y := &amp;xy[1]
            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
            y.k = add(unsafe.Pointer(y.b), dataOffset)
            y.e = add(y.k, bucketCnt*uintptr(t.keysize))
        &#125;

        // evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。
         // bucket 还会链接 overflow bucket，它们同样需要搬迁。
         // 因此同样会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。
 
         // 遍历当前桶 bucket 和其之后的溢出桶 overflow bucket
         // 注意：初始的 b 是待搬迁的老 bucket
        for ; b != nil; b = b.overflow(t) &#123;
            k := add(unsafe.Pointer(b), dataOffset)
            e := add(k, bucketCnt*uintptr(t.keysize))
            // 遍历桶中的 cell，这里 i，k，e 分别用于对应 tophash 下标，key 和 value
            for i := 0; i &lt; bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) &#123;
                // 获取tophash
                top := b.tophash[i]
                // 如果当前 cell 的 tophash 值是 emptyOne 或者 emptyRest，
                // 则代表此 cell 没有key。将其标记为evacuatedEmpty，表示它“已经被搬迁”。
                if isEmpty(top) &#123;
                    b.tophash[i] = evacuatedEmpty
                    continue
                &#125;
                // 正常不会出现这种情况
                 // 未被搬迁的 cell 只可能是 emptyOne、emptyRest 或是正常的 top hash（大于等于 minTopHash）
                if top &lt; minTopHash &#123;
                    throw(&quot;bad map state&quot;)
                &#125;
                k2 := k
                // 如果 key 是指针，则解引用
                if t.indirectkey() &#123;
                    k2 = *((*unsafe.Pointer)(k2))
                &#125;
                var useY uint8
                // 如果是增量扩容
                if !h.sameSizeGrow() &#123;
                    // 计算哈希值，判断当前key和vale是要被搬迁到bucket x还是bucket y
                    hash := t.hasher(k2, uintptr(h.hash0))
                    if h.flags&amp;iterator != 0 &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) &#123;
                        // 有一个特殊情况：有一种 key，每次对它计算 hash，得到的结果都不一样。
                        // 这个 key 就是 math.NaN() 的结果，它的含义是 not a number，类型是 float64。
                         // 当它作为 map 的 key时，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！
                        // 这个 key 是永远不会被 Get 操作获取的！当使用 m[math.NaN()] 语句的时候，是查不出来结果的。
                        // 这个 key 只有在遍历整个 map 的时候，才能被找到。
                        // 并且，可以向一个 map 插入多个数量的 math.NaN() 作为 key，它们并不会被互相覆盖。
                        // 当搬迁碰到 math.NaN() 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。
                        // 如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。
                        useY = top &amp; 1
                        top = tophash(hash)
                    &#125; else &#123;
                        // 对于正常的 key，则进入 else 的逻辑
                        if hash&amp;newbit != 0 &#123;
                            useY = 1
                        &#125;
                    &#125;
                &#125;

                if evacuatedX+1 != evacuatedY || evacuatedX^1 != evacuatedY &#123;
                    throw(&quot;bad evacuatedN&quot;)
                &#125;

                // 标示这个位置k，v 迁到 x 还是 y，
                // 因为 evacuatedX + 1 == evacuatedY，如果 useY 是 0，那就是 x，否则是 y
                b.tophash[i] = evacuatedX + useY
                // useY 要么为0，要么为 1。
                // 这里就是选取在 bucket x 的起始内存位置，或者选择在 bucket y 的起始内存位置
                // （只有增量同步才会有这个选择可能）。
                dst := &amp;xy[useY]                 

                // 如果目的地的桶已经装满了（8个cell），那么需要新建一个溢出桶，继续搬迁到溢出桶上去。
                if dst.i == bucketCnt &#123;
                    //  newoverflow() 前面分析过，它会当将已经事先创建好的 overflow bucket 设置到 bucket 上了
                    dst.b = h.newoverflow(t, dst.b)
                    dst.i = 0
                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)
                    dst.e = add(dst.k, bucketCnt*uintptr(t.keysize))
                &#125;
                // 通过与操作直接避免了边界检查，并设置相应下标位置的值为 tophash（真的妙！！！）
                dst.b.tophash[dst.i&amp;(bucketCnt-1)] = top
                // 如果待搬迁的key是指针，则复制指针过去
                if t.indirectkey() &#123;
                    *(*unsafe.Pointer)(dst.k) = k2
                &#125; else &#123;
                    // 如果待搬迁的key是值，则复制值过去 
                    typedmemmove(t.key, dst.k, k)
                &#125;
                // value 和 key 同理
                if t.indirectelem() &#123;
                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)
                &#125; else &#123;
                    typedmemmove(t.elem, dst.e, e)
                &#125;
                // 将当前搬迁目的桶的记录 key/value 的索引值（也可以理解为 cell 的索引值）加一
                dst.i++
                // 计算下一个 dst.k,dst.e 的内存地址
                // 由于桶的内存布局中在最后还有 overflow 的指针，所以这里不用担心更新有可能会超出 key 和 value 数组的指针地址。
                dst.k = add(dst.k, uintptr(t.keysize))
                dst.e = add(dst.e, uintptr(t.elemsize))
            &#125;
        &#125;
        // 如果没有协程在使用老的桶，就对老的桶进行清理，用于帮助 gc
        if h.flags&amp;oldIterator == 0 &amp;&amp; t.bucket.ptrdata != 0 &#123;
            b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
            // 只清除 bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态
            ptr := add(b, dataOffset)
            n := uintptr(t.bucketsize) - dataOffset
            memclrHasPointers(ptr, n)
        &#125;
    &#125;

    // 用于更新搬迁进度
    if oldbucket == h.nevacuate &#123;
        advanceEvacuationMark(h, t, newbit)
    &#125;
&#125;
</code></pre>
<p>更新搬迁进度的函数 <code>advanceEvacuationMark</code> 实现如下：</p>
<pre><code class="go">func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) &#123;
    // 搬迁桶的进度加一
    h.nevacuate++
    // 实验表明，1024 至少会比 newbit 高出一个数量级。
    // newbit 是传进来的参数，代表扩容之前老的 bucket 个数。
    // 所以，用当前进度加 1024 用于确保 O(1) 行为。
    stop := h.nevacuate + 1024
    if stop &gt; newbit &#123;
        stop = newbit
    &#125;
    // 计算已经搬迁完的桶数
    for h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;
        h.nevacuate++
    &#125;
    // 如果h.nevacuate == newbit，则代表所有的桶都已经搬迁完毕
    if h.nevacuate == newbit &#123; // newbit == # of oldbuckets
        // 搬迁完毕，所以指向老的 buckets 的指针置为nil
        h.oldbuckets = nil
        // 前面说过，如果 map 中 key 和 value 均不包含指针，则都可以 inline。
        // 那么保存它们的 buckets 数组其实是挂在 hmap.extra 中的。
        // 所以，这种情况下，其实我们是搬迁的 extra 的 buckets 数组。
        // 因此，在这种情况下，需要在搬迁完毕后，将 hmap.extra.oldoverflow 指针置为nil。
        if h.extra != nil &#123;
            h.extra.oldoverflow = nil
        &#125;
        // 最后，清除正在扩容的标志位，扩容完毕。
        h.flags &amp;^= sameSizeGrow
    &#125;
&#125;
</code></pre>
<p>这里在看一下对于判断当前 <code>bucket</code> 是否搬迁完成的函数 <code>evacuated</code> ：</p>
<pre><code class="go">func evacuated(b *bmap) bool &#123;
    h := b.tophash[0]
    return h &gt; emptyOne &amp;&amp; h &lt; minTopHash
&#125;
</code></pre>
<p>如果 <code>b.tophash[0]</code> 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p>
<pre><code>empty = 0
evacuatedEmpty = 1
evacuatedX = 2
evacuatedY = 3
minTopHash = 4
</code></pre>
<p>到这里就完成了 map 的扩容，总结一下整体的流程如下：</p>
<ol>
<li>首先判断是需要等量扩容还是增量扩容，增量扩容的条件是<code>元素个数 &gt; 桶（bucket）总数 * 6.5</code>。而等量扩容的条件是当<code>桶总数 &lt; 2 ^ 15</code> 时，如果<code>溢出桶总数 &gt;= 桶总数</code>，则认为溢出桶过多;当<code>桶总数 &gt;= 2 ^ 15</code> 时，直接与 <code>2 ^ 15</code> 比较，当<code>溢出桶总数 &gt;= 2 ^ 15</code> 时，即认为溢出桶太多了</li>
<li>记录当前 <code>buckets</code> 数据，申请新的 <code>buckets</code> 空间</li>
<li>将 <code>oldbuckets</code> 指针原有的 <code>buckets</code>，设置 <code>nextOverflow</code> 指针</li>
<li>通过 <code>growWork</code> 函数执行旧键值对的搬迁，搬迁采用渐进式的方式，每次至多搬迁 2 个bucket。</li>
<li>搬迁过程会进行 rehash，对于等量扩容，则只需要将旧的键值对取出来依次放入即可；对于增量扩容，从哈希值的倒数 B 位（原来的 B 值）多取 1 位，变成 B+1位（这里其实是因为扩容后容量为 2 倍，所以在最高位多取一位相当于乘以 2）。然后根据多取出来的一位是 0 还是 1 进行分配，0 则分配到前一般桶 <code>bucket x</code> 加上偏移的位置；1 则分配到后一般桶 <code>backet y</code> 对应加上偏移的位置。</li>
</ol>
<p>针对下面的 map，其 B 为3，所以原始 buckets 数组为8。当 map 元素数变多，加载因子超过 6.5，所以引起了增量扩容。</p>
<p>以 3 号 <code>bucket</code> 为例，可以看到，由于 B 值加 1，所以在新选取桶时，需要取低 4 位哈希值，这样就会造成 cell 会被搬迁到新 buckets 数组中不同的桶（3 号或 11 号桶）中去。注意，在一个桶中，搬迁 cell 的工作是有序的：它们是依序填进对应新桶的 <code>cell</code> 中去的。</p>
<p>当然，实际情况中 3 号桶很可能还有溢出桶，在这里为了简化绘图，假设 3 号桶没有溢出桶，如果有溢出桶，则相应地添加到新的 3 号桶和 11 号桶中即可，如果对应的 3 号和 11 号桶均装满，则给新的桶添加溢出桶来装载。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp" alt="扩容例子图示"></p>
<p>对于下图的 map，其 B 也为 3。假设整个 map 中的 <code>overflow</code> 过多，触发了等量扩容。注意，等量扩容时，新的 <code>buckets</code> 数组大小和旧 <code>buckets</code> 数组是一样的。</p>
<p>以 6 号桶为例，它有一个 bucket 和 3 个 overflow buckets，但是实际上桶里的数据非常稀疏，等量扩容的目的就是为了把松散的键值对重新排列一次，以使 <code>bucket</code> 的使用率更高，进而保证更快的存取。搬迁完毕后，新的 6 号桶中只有一个基础 <code>bucket</code>，暂时并不需要溢出桶。这样，和原 6 号桶相比，数据变得紧密，使后续的数据存取变快。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%A4%BA.webp" alt="等量扩容例子图示"></p>
<h3 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h3><p>哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<p>删除操作底层的执行函数是 <code>mapdelete</code>，它的流程如下：</p>
<ol>
<li><p>首先会检查 <code>h.flags</code> 标志，如果发现写标位是 1，直接 <code>panic</code>，因为这表明有其他协程同时在进行写操作。</p>
</li>
<li><p>接着计算 <code>key</code> 的哈希，找到落入的 <code>bucket</code>。检查此 <code>map</code> 如果正在扩容的过程中，直接触发一次搬迁操作。</p>
</li>
<li><p>删除操作同样是两层循环，核心还是找到 <code>key</code> 的具体位置。寻找过程都是类似的，在 <code>bucket</code> 中挨个 <code>cell</code> 寻找。</p>
</li>
<li><p>找到对应位置后，对 <code>key</code> 或者 <code>value</code> 进行“清零”操作。</p>
</li>
<li><p>修改 <code>map</code> 中 <code>cell</code> 的状态，如果 <code>bucket</code> 以一堆 <code>emptyOne</code> 状态结束, 还需要将其更改为 <code>emptyRest</code> 状态</p>
</li>
</ol>
<pre><code class="go">func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) &#123;
    // 如果开启了竞态检测 -race
    if raceenabled &amp;&amp; h != nil &#123;
        callerpc := getcallerpc()
        pc := funcPC(mapdelete)
        racewritepc(unsafe.Pointer(h), callerpc, pc)
        raceReadObjectPC(t.key, key, callerpc, pc)
    &#125;
    // 如果开启了memory sanitizer -msan
    if msanenabled &amp;&amp; h != nil &#123;
        msanread(key, t.key.size)
    &#125;
    // 如果map为空或者元素个数为0, 直接返回
    if h == nil || h.count == 0 &#123;
        if t.hashMightPanic() &#123;
            t.hasher(key, 0) // see issue 23734
        &#125;
        return
    &#125;
    // 当 h.flags 对应的值为 hashWriting (代表有其他goroutine正在往map中写key)时,
    // 那么位计算的结果不为0, 因此抛出错误
    if h.flags&amp;hashWriting != 0 &#123;
        throw(&quot;concurrent map writes&quot;)
    &#125;

    hash := t.hasher(key, uintptr(h.hash0))

    // 将 flags 的值与 hashWriting 做按位 &quot;异或&quot; 运算
    // 之所以调用 t.hasher 后设置 hashWriting, 是因为 t.hasher 可能会 panic, 
    // 在这种情况下, 实际上并没有执行写(删除)操作.
    h.flags ^= hashWriting

    // 计算出桶的位置
    bucket := hash &amp; bucketMask(h.B)
    if h.growing() &#123;
        // 直接触发一次搬迁操作
        growWork(t, h, bucket)
    &#125;
    // 获取 bucket 的内存地址
    b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
    bOrig := b
    top := tophash(hash)
search:
    // 以下是查找的核心逻辑
    // 同样双重循环遍历: 外层循环是从桶到溢出桶遍历; 内层是桶中的cell遍历
    // 跳出循环的条件有三种: 
    // 第一种是已经找到 key 值, 并且已经完成清理工作
    // 第二种是当前桶再无溢出桶;
    // 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest, 它代表此时的桶后面的 cell 还未利用, 所以无需再继续遍历
    for ; b != nil; b = b.overflow(t) &#123;
        for i := uintptr(0); i &lt; bucketCnt; i++ &#123;
            if b.tophash[i] != top &#123;
                // 第三种情况
                if b.tophash[i] == emptyRest &#123;
                    break search
                &#125;
                continue
            &#125;
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            k2 := k
            if t.indirectkey() &#123;
                k2 = *((*unsafe.Pointer)(k2))
            &#125;
            if !t.key.equal(key, k2) &#123;
                continue
            &#125;
            // 第一种情况, 说明已经找到了 key 值完全一样
            // 对 key 清零
            if t.indirectkey() &#123;
                *(*unsafe.Pointer)(k) = nil
            &#125; else if t.key.ptrdata != 0 &#123;
                memclrHasPointers(k, t.key.size)
            &#125;
            e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
            // 对 value 清零
            if t.indirectelem() &#123;
                *(*unsafe.Pointer)(e) = nil
            &#125; else if t.elem.ptrdata != 0 &#123;
                memclrHasPointers(e, t.elem.size)
            &#125; else &#123;
                memclrNoHeapPointers(e, t.elem.size)
            &#125;
            // 对应的 tophash 设置成 emptyOne
            b.tophash[i] = emptyOne
            
            // 如果 bucket 现在以一堆 emptyOne 状态结束, 将其更改为 emptyRest 状态.
            // 将此功能设为一个单独的函数会很好, 但是 for 循环当前不可内联
            // 可以立即结束循环的的两种状况:
            // 情况1: 当前 cell 是 bucket 的最后一个 cell, 且后续的 overflow bucket 的 cell tophash 不为 emptyRest
            // 情况2: 当前 cell 后续的 cell tophash 不为 emptyRest
            
            if i == bucketCnt-1 &#123;
                // 第一种情况
                if b.overflow(t) != nil &amp;&amp; b.overflow(t).tophash[0] != emptyRest &#123;
                    goto notLast
                &#125;
            &#125; else &#123;
                // 第二种情况
                if b.tophash[i+1] != emptyRest &#123;
                    goto notLast
                &#125;
            &#125;
            // 如果 bucket 现在以一堆 emptyOne 状态结束, 将其更改为 emptyRest 状态
            // 在这里存在两种情况:
            // 跳出本循环的两种情况:
            // 1. 遇到桶内的第一个 bucket。注意: 桶实质上就是一个单向的链表。
            // 2. 遇到 cell 的 tophash 非删除状态(emptyOne)
            for &#123;
                b.tophash[i] = emptyRest
                if i == 0 &#123;
                    // 回到桶开始的位置
                    if b == bOrig &#123;
                        break
                    &#125;
                    // 获取当前 bucket 的前面的 prev bucket(即 prev bucket 的 overflow 是当前 bucket)
                    // 每次都是从桶内的首个元素开始，相当于从后往前将 emptyOne 改成 emptyRest
                    c := b
                    for b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;
                    &#125;
                    i = bucketCnt - 1
                &#125; else &#123;
                    i--
                &#125;
                if b.tophash[i] != emptyOne &#123;
                    break
                &#125;
            &#125;
        notLast:
            // 对应 count 值减一
            h.count--
            break search
        &#125;
    &#125;

    if h.flags&amp;hashWriting == 0 &#123;
        throw(&quot;concurrent map writes&quot;)
    &#125;
    // 清除 hashWriting flag
    h.flags &amp;^= hashWriting
&#125;
</code></pre>
<p>同样，和写入函数一样，根据 key 类型的不同，删除操作会被优化成更具体的函数：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">删除</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapdelete_fast32(t *maptype, h *hmap, key uint32)</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapdelete_fast64(t *maptype, h *hmap, key uint64)</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapdelete_faststr(t *maptype, h *hmap, ky string)</td>
</tr>
</tbody></table>
<h3 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h3><p><strong>迭代 map 的结果是无序的</strong>，对于下面的例子：</p>
<pre><code class="go">package main
func main() &#123;
    m := make(map[int]int)
    for i := 0; i &lt; 10; i++ &#123;
        m[i] = i
    &#125;
    for k, v := range m &#123;
        fmt.Println(k, v)
    &#125;
&#125;	
</code></pre>
<p>运行以上代码，会发现每次输出顺序都是不同的。</p>
<p>map 遍历的过程，是按序遍历 <code>bucket</code>，同时按需遍历 <code>bucket</code> 中和其 <code>overflow bucket</code> 中的 <code>cell</code>。但是 map 在扩容后，会发生 <code>key</code> 的搬迁，这造成原来落在一个 <code>bucket</code> 中的 key，搬迁后，有可能会落到其他 <code>bucket</code> 中了，从这个角度看，遍历 map 的结果就不可能是按照原来的顺序了。</p>
<p>但其实，go 为了保证遍历 map 的结果是无序的，做了以下事情：map在遍历时，并不是从固定的 0 号 bucket 开始遍历的，每次遍历，都会从一个<strong>随机值序号的 bucket，再从其中随机的 cell 开始遍历。然后再按照桶序遍历下去，直到回到起始桶结束</strong>。</p>
<p>下面的例子是遍历一个处于未扩容状态的 map。如果 map 正处于扩容状态时，需要先判断当前遍历 <code>bucket</code> 是否已经完成搬迁，如果数据还在老的 <code>bucket</code>，那么就去老 <code>bucket</code> 中拿数据。</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E7%9A%84%E9%81%8D%E5%8E%86.webp" alt="go map的遍历"></p>
<p>当发生了增量扩容时，一个老的 <code>bucket</code> 数据可能会分裂到两个不同的 <code>bucket</code> 中去，那么此时，如果需要从老的 <code>bucket</code> 中遍历数据，例如 1 号，则**不能将老 1 号 <code>bucket</code> 中的数据全部取出，仅仅只能取出老 1 号 <code>bucket</code> 中那些在裂变之后，分配到新 1 号 <code>bucket</code> 中的那些 <code>key</code>**。</p>
<p>对下面的例子进行编译：</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    m := make(map[string]int)
    m[&quot;silverming&quot;] = 18
    for k, v := range m &#123;
        fmt.Println(k, v)
    &#125;
&#125;
</code></pre>
<p>执行命令：</p>
<pre><code class="shell">go tool compile -S main.go 
</code></pre>
<p>可以看到如下几行汇编的代码：</p>
<pre><code class="shell">//...
0x0104 00260 (main.go:8)  CALL    runtime.mapiterinit(SB)
//...
0x01c8 00456 (main.go:8)  CALL    runtime.mapiternext(SB)
//...
</code></pre>
<p>可以看到对于 map 的迭代，底层调用的是 <code>mapiterinit</code> 和 <code>mapiternext</code> 函数。</p>
<p><code>mapiterinit</code> 就是对 <code>hiter</code> 结构体里的字段进行初始化赋值操作，这个结构用于保证随机性。</p>
<p><code>hiter</code> 的结构如下：</p>
<pre><code class="go">type hiter struct &#123;
    // key 指针
    key         unsafe.Pointer
    // value 指针
    elem        unsafe.Pointer
    // map 类型，包含如 key size 大小等
    t           *maptype
    h           *hmap
    // 初始化时指向的 buckets
    buckets     unsafe.Pointer
    // 当前遍历到的 bmap
    bptr        *bmap
    overflow    *[]*bmap       // keeps overflow buckets of hmap.buckets alive
    oldoverflow *[]*bmap       // keeps overflow buckets of hmap.oldbuckets alive
    // 起始遍历的 bucket 编号
    startBucket uintptr
    // 在迭代过程中开始的桶内偏移，也就是从桶的哪个 cell 开始
    offset      uint8
    // 是否又从头遍历了
    wrapped     bool
    // B 的大小
    B           uint8
    // 当前 cell 序号
    i           uint8
    // 指向当前的 bucket
    bucket      uintptr
    // 因为扩容需要检查的 bucket
    checkBucket uintptr
&#125;
</code></pre>
<p><code>mapinterinit</code> 函数的实现如下：</p>
<pre><code class="go">// mapiterinit 初始化用于在 map 上进行遍历的 hiter 结构
// it 指向的 hiter 结构由编译器顺序传递在堆栈上分配, 或者由 reflect_mapiterinit 在堆上分配
// 由于结构包含指针, 因此两者都需要将 hiter 归零
func mapiterinit(t *maptype, h *hmap, it *hiter) &#123;
    // 如果开启了竞态检测 -race
    if raceenabled &amp;&amp; h != nil &#123;
        callerpc := getcallerpc()
        racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit))
    &#125;

    // hmap 不存在 或者 hmap 没有存储数据
    if h == nil || h.count == 0 &#123;
        return
    &#125;

    // hiter 的大小是 12 个系统指针大小。在 cmd/compile/internal/gc/reflect.go:hiter() 当中有这样的体现
    if unsafe.Sizeof(hiter&#123;&#125;)/sys.PtrSize != 12 &#123;
        throw(&quot;hash_iter size incorrect&quot;) // see cmd/compile/internal/gc/reflect.go
    &#125;
    it.t = t
    it.h = h

    // 抓取桶状态快照
    it.B = h.B
    it.buckets = h.buckets
    if t.bucket.ptrdata == 0 &#123;
        // 重新分配 overflow 
        // 并在 hiter 中存储指向当前 h.extra.overflow 和 h.extra.oldoverflow.
        // 这样在迭代的过程中, 不论 table 的增长还是有新的 overflow buckets 被添加到 table 当中
        // 都可以让 overflow bucket 处于活动状态
        h.createOverflow()
        it.overflow = h.extra.overflow
        it.oldoverflow = h.extra.oldoverflow
    &#125;

    // 随机迭代的关键代码
    // 生成随机数
    r := uintptr(fastrand())
    if h.B &gt; 31-bucketCntBits &#123;
        // 在 B&gt;28 时, 增加一个偏移量
        r += uintptr(fastrand()) &lt;&lt; 31
    &#125;
    // 确定从哪个 bucket 开始遍历
    // bucketMask(h.B)	返回 2^B-1，也就是桶的数量-1
    it.startBucket = r &amp; bucketMask(h.B)
    // 确定从哪个 bucket 的哪个 cell 开始遍历
    it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))

    // iterator state
    it.bucket = it.startBucket

    // 标记当前的迭代器
    // 多个迭代器可以同事运行
    if old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;
        atomic.Or8(&amp;h.flags, iterator|oldIterator)
    &#125;

    // 开始进行迭代
    mapiternext(it)
&#125;
</code></pre>
<p>上面的代码实现中，例如，B &#x3D; 2，那 <code> bucketMask(h.B)</code> 结果就是 3，低 8 位为 <code>00000011</code>，将 r 与之相与，就可以得到一个 <code>0~3</code> 的 bucket 序号；<code>bucketCnt - 1</code> 等于 7，低 8 位为 <code>00000111</code>，将 r 右移 2 位后，与 7 相与，就可以得到一个 <code>0~7</code> 号的 cell。</p>
<p>于是，在 <code>mapiternext</code> 函数中就会从 <code>it.startBucket</code> 的 <code>it.offset</code> 号的 <code>cell</code> 开始遍历，取出其中的 <code>key</code> 和 <code>value</code>，直到又回到起点 <code>bucket</code>，完成遍历过程。</p>
<p>源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，通过图形化的方式说说整个遍历过程。</p>
<p>假设有下图所示的一个 map，起始时 B &#x3D; 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，1 号裂变成 1 号和 3 号；0 号 bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-1.png" alt="go map遍历-1"></p>
<p>这时，对此 map 进行遍历。假设经过初始化后，startBucket &#x3D; 3，offset &#x3D; 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-2.png" alt="go map遍历-2"></p>
<p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2。</p>
<p>因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。判断方法就是：</p>
<pre><code class="go">func evacuated(b *bmap) bool &#123;
    h := b.tophash[0]
    return h &gt; empty &amp;&amp; h &lt; minTopHash
&#125;
</code></pre>
<p>如果 b.tophash[0] 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p>
<pre><code class="go">empty = 0
evacuatedEmpty = 1
evacuatedX = 2
evacuatedY = 3
minTopHash = 4
</code></pre>
<p>在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。</p>
<p>依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时的遍历结果仅有一个元素。</p>
<p>由于返回的 key 不为空，所以会继续调用 mapiternext 函数。</p>
<p>继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。</p>
<p>新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。</p>
<p>那是不是把老 0 号 bucket 中的所有 key 都取出来呢？并没有这么简单，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 <code>*bucket</code> 指针，也就是所谓的新 buckets）。所以，只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key。</p>
<p>因此，<code>lowbits == 00</code> 的将进入遍历结果集。</p>
<p>和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。</p>
<p>继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 <code>lowbit == 10</code> 的那些 key。</p>
<p>最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。</p>
<p>所以整个遍历后的结果就是：</p>
<p><img src="https://qiniu.xiaoming.net.cn/go%20map%E9%81%8D%E5%8E%86-3.png" alt="go map遍历-3"></p>
<p>接下来看看遍历过程，<code>mapiternext</code> 的实现：</p>
<pre><code class="go">func mapiternext(it *hiter) &#123;
    h := it.h
    // 如果开启了竞态检测 -race
    if raceenabled &#123;
        callerpc := getcallerpc()
        racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext))
    &#125;
    // 检测当前是不是有 groutine 在进行写入，有的话直接抛出错误
    if h.flags&amp;hashWriting != 0 &#123;
        throw(&quot;concurrent map iteration and map write&quot;)
    &#125;
       
    // 获取相应的元素
    t := it.t
    bucket := it.bucket
    b := it.bptr
    i := it.i
    checkBucket := it.checkBucket

next:
    // current bucket 为 nil, 第一次或者最后一次迭代
    if b == nil &#123;
        // 当前的 bucket 是开始的 bucket 并且已经遍历过了
        if bucket == it.startBucket &amp;&amp; it.wrapped &#123;
            // end of iteration
            it.key = nil
            it.elem = nil
            return
        &#125;
        // 如果迭代器是在增长过程中启动的，尚未完成增长。
        // 并且要查看的存储桶尚未装满（即尚未撤离旧存储桶），
        // 则需要遍历旧存储桶，仅返回将要迁移到该存储桶的旧存储桶的值。 
        // 也就是像上面的例子，仅仅只能取出老 1 号 bucket 中那些在裂变之后，分配到新 1 号 bucket 中的那些 key。
        if h.growing() &amp;&amp; it.B == h.B &#123;
            // 按位与操作，根据 bucket 新增位是 1 还是 0 判断分配到哪里，
            // 0 的是需要遍历的（见扩容原理）
            oldbucket := bucket &amp; it.h.oldbucketmask()
            b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
            // 判断当前 bucket 是否已经搬迁了
            if !evacuated(b) &#123;
                // 如果还没有完成搬迁，则当前 bucket 不需要遍历，后面会跳到 oldbucket 中遍历
                checkBucket = bucket
            &#125; else &#123;
                // 还没后完成搬迁，则当前 bucket 不需要遍历
                b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))
                checkBucket = noCheck
            &#125;
        &#125; else &#123;
            // 正常情况，没有发生扩容时的遍历
            b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))
            checkBucket = noCheck
        &#125;
        bucket++
        // 到了顺序上的最后一个 bucket，置 0 继续遍历
        if bucket == bucketShift(it.B) &#123;
            bucket = 0
            it.wrapped = true
        &#125;
        i = 0
    &#125;
    // 遍历当前 bucket 的 cell
    for ; i &lt; bucketCnt; i++ &#123;
        offi := (i + it.offset) &amp; (bucketCnt - 1)
        // 
        if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;
            // TODO: emptyRest is hard to use here, as we start iterating
            // in the middle of a bucket. It&#39;s feasible, just tricky.
            // 当前的 cell 状态是 emptyRest, emptyOne(空), evacuatedEmpty(迁移前是emptyRest, emptyOne)
            continue
        &#125;
        // 获取 k,e 分别对应 key 和 value 的内存地址
        k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))
        if t.indirectkey() &#123;
            k = *((*unsafe.Pointer)(k))
        &#125;
        e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize))
        // 去掉需要忽略的特殊情况，也就是增量扩容的情况
        if checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;
            // 特殊情况：需要遍历 oldbucket 的场景
            // 遍历 oldbucket，跳过将要转到另一个新 bucket 的任何键（在增长过程中，每个 oldbucket 会扩展到两个 bucket 中）。
            // reflexivekey() // true if k==k for all keys
            if t.reflexivekey() || t.key.equal(k, k) &#123;
                // 如果 oldbucket 中的 cell 不是搬移到迭代中的当前新存储桶的, 则将其跳过.
                hash := t.hasher(k, uintptr(h.hash0))
                if hash&amp;bucketMask(it.B) != checkBucket &#123;
                    continue
                &#125;
            &#125; else &#123;
                // 如果 k！= k(也就是 key 值是 NaNs 的特殊情况), 则 hash 不可重复. 这里需要对迁移期间发送 NaN 的方向进行可重复且随机的选择.
                // 这里将使用低位的 tophash 来决定 NaN 的走法.
                // 注意: 这种情况就是为什么我们需要两个迁移值, 即 evacuatedX 和 evacuatedY, 它们的低位不同.
                if checkBucket&gt;&gt;(it.B-1) != uintptr(b.tophash[offi]&amp;1) &#123;
                    continue
                &#125;
            &#125;
        &#125;
        // 遍历, 获取对应的 k, v   
        if (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||
            !(t.reflexivekey() || t.key.equal(k, k)) &#123;
            // 特殊情况: 
            // 在正常状况(没有发生map扩容[增量方式])下进行遍历也称为 golden data; 
            // 或者
            // key != key (只能发生 key=NANs 的状况下), 这些 key 是没法更新和删除的, 只能在遍历的时候返回。
            it.key = k
            if t.indirectelem() &#123;
                e = *((*unsafe.Pointer)(e))
            &#125;
            it.elem = e
        &#125; else &#123;
            // 自从启动迭代器以来，哈希表已经增长。这个 key 的 value 现在位于其他位置。
            // 检查当前哈希表中的数据。
            // 此代码处理 key 已被删除，更新，删除或重新插入的情况。
            // 注意：这里需要重新注册 key ，因为它可能已更新为 equal（）相同但不相同的 key（例如+0.0与-0.0）。
            rk, re := mapaccessK(t, h, k)
            if rk == nil &#123;
                // key 已经被删除
                continue
            &#125;
            it.key = rk
            it.elem = re
        &#125;
        // 后续处理
        it.bucket = bucket
        if it.bptr != b &#123; // avoid unnecessary write barrier; see issue 14921
            it.bptr = b
        &#125;
        it.i = i + 1
        it.checkBucket = checkBucket
        return
    &#125;
    b = b.overflow(t)
    i = 0
    goto next
&#125;
</code></pre>
<p>在上面的遍历过程中有一个特殊情况，如果碰到 key 是 <code>math.NaN()</code> 这种的，处理方式要看它被分裂后具体落入哪个 <code>bucket</code>。只不过只用看它 <code>tophash</code> 的最低位。如果 <code>tophash</code> 的最低位是 0 ，分配到 <code>X part</code>；如果是 1 ，则分配到 <code>Y part</code>。据此决定是否取出 <code>key</code>，放到遍历结果集里。</p>
<p>map 遍历的核心在于理解 2 倍扩容时，老 <code>bucket</code> 会分裂到 2 个新 <code>bucket</code> 中去。而遍历操作，会按照新 <code>bucket</code> 的序号顺序进行，碰到老 <code>bucket</code> 未搬迁的情况时，要在老 <code>bucket</code> 中找到将来要搬迁到新 <code>bucket</code> 来的 key。也就是上面说的当发生了增量扩容时，一个老的 <code>bucket</code> 数据可能会分裂到两个不同的 <code>bucket</code> 中去，那么此时，如果需要从老的 <code>bucket</code> 中遍历数据，例如 1 号，则不能将老 1 号 <code>bucket</code> 中的数据全部取出，仅仅只能取出老 1 号 <code>bucket</code> 中那些在裂变之后，分配到新 1 号 <code>bucket</code> 中的那些 <code>key</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 Map 的相关实现原理，可以看到，它并不是一个并发安全的数据结构。同时对 map 进行读写时，程序很容易出错。因此，要想在并发情况下使用 map，可以加上锁（<code>sync.Mutex</code> 或者 <code>sync.RwMutex</code>）。其实，Go 标准库中已经实现了并发安全的 map——<code>sync.Map</code>。</p>
<p>遍历 map 的结果是无序的，在使用中，应该注意到该点。</p>
<p>通过 map 的结构体可以知道，它其实是通过指针指向底层 buckets 数组。所以和 slice 一样，尽管 go 函数都是值传递，但是，当 map 作为参数被函数调用时，在函数内部对 map 的操作同样会影响到外部的map。</p>
<p>另外，有个特殊的 key 值 <code>math.NaN</code>，它每次生成的哈希值是不一样的，这会造成 <code>m[math.NaN]</code> 是拿不到值的，而且多次对它赋值，会让 map 中存在多个 <code>math.NaN</code> 的 key。</p>
<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<p>对于下面的例子：</p>
<pre><code class="go">package main

func myFunction(a, b int) (int, int) &#123;
    return a + b, a - b
&#125;

func main() &#123;
    myFunction(66, 77)
&#125;
</code></pre>
<p><code>main</code> 函数在调用 <code>myFunction</code> 之前会先通过汇编指令 <code>SUBQ $40, SP</code> 指令在栈上分配了 40 字节的内存空间，分配如下的栈结构：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A81.png" alt="函数调用1"></p>
<p>相应的大小和用途如下：</p>
<table>
<thead>
<tr>
<th>空间</th>
<th>大小</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SP+32 ~ BP</td>
<td>8 字节</td>
<td><code>main</code> 函数的栈基址指针</td>
</tr>
<tr>
<td>SP+16 ~ SP+32</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个返回值</td>
</tr>
<tr>
<td>SP ~ SP+16</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个参数</td>
</tr>
</tbody></table>
<p>当入参时，入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 <code>SP ~ SP+8</code>，第二个参数存储在 <code>SP+8 ~ SP+16</code> 的空间中。</p>
<p>当准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并执行 <code>myFunction</code> 的汇编指令。</p>
<p><code>muFunction</code> 函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如下图所示：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82.png" alt="函数调用2"></p>
<p><strong>图 4-3 myFunction 函数返回前的栈</strong></p>
<p>在 <code>myFunction</code> 返回后，<code>main</code> 函数会恢复栈基址指针并销毁已经失去作用的 40 字节栈内存。</p>
<h2 id="跟-C-语言对比"><a href="#跟-C-语言对比" class="headerlink" title="跟 C 语言对比"></a>跟 C 语言对比</h2><p>C 语言和 Go 语言在设计函数的调用惯例时选择了不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。这两种设计的优点和缺点如下：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li><strong>CPU 访问栈的开销比访问寄存器高几十倍</strong>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><strong>Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。</p>
<h3 id="整型和数组"><a href="#整型和数组" class="headerlink" title="整型和数组"></a>整型和数组</h3><p>如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p>
<pre><code class="go">func myFunction(i int, arr [2]int) &#123;
    fmt.Printf(&quot;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&quot;, i, &amp;i, arr, &amp;arr)
&#125;

func main() &#123;
    i := 30
    arr := [2]int&#123;66, 77&#125;
    fmt.Printf(&quot;before calling - i=(%d, %p) arr=(%v, %p)\n&quot;, i, &amp;i, arr, &amp;arr)
    myFunction(i, arr)
    fmt.Printf(&quot;after  calling - i=(%d, %p) arr=(%v, %p)\n&quot;, i, &amp;i, arr, &amp;arr)
&#125;

$ go run main.go
before calling - i=(30, 0xc0000b2008) arr=([66 77], 0xc0000b2010)
in my_funciton - i=(30, 0xc0000b2028) arr=([66 77], 0xc0000b2040)
after  calling - i=(30, 0xc0000b2008) arr=([66 77], 0xc0000b2010)
</code></pre>
<p>当通过命令运行这段代码时会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p>
<p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。</p>
<p>如果在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？这里更新 <code>myFunction</code> 函数并重新执行这段代码：</p>
<pre><code class="go">func myFunction(i int, arr [2]int) &#123;
    i = 29
    arr[1] = 88
    fmt.Printf(&quot;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&quot;, i, &amp;i, arr, &amp;arr)
&#125;

$ go run main.go
before calling - i=(30, 0xc00012a008) arr=([66 77], 0xc00012a010)
in my_funciton - i=(29, 0xc00012a028) arr=([66 88], 0xc00012a040)
after  calling - i=(30, 0xc00012a008) arr=([66 77], 0xc00012a010)
</code></pre>
<p>可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以能得出如下结论：<strong>Go 语言的整型和数组类型都是值传递的，也就是在调用函数时会对内容进行拷贝。需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成比较大的影响。</strong></p>
<h3 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h3><p>下面这段代码中定义了一个结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p>
<pre><code class="go">type MyStruct struct &#123;
    i int
&#125;

func myFunction(a MyStruct, b *MyStruct) &#123;
    a.i = 31
    b.i = 41
    fmt.Printf(&quot;in my_function - a=(%d, %p) b=(%v, %p)\n&quot;, a, &amp;a, b, &amp;b)
&#125;

func main() &#123;
    a := MyStruct&#123;i: 30&#125;
    b := &amp;MyStruct&#123;i: 40&#125;
    fmt.Printf(&quot;before calling - a=(%d, %p) b=(%v, %p)\n&quot;, a, &amp;a, b, &amp;b)
    myFunction(a, b)
    fmt.Printf(&quot;after calling  - a=(%d, %p) b=(%v, %p)\n&quot;, a, &amp;a, b, &amp;b)
&#125;

$ go run main.go
before calling - a=(&#123;30&#125;, 0xc0000b2008) b=(&amp;&#123;40&#125;, 0xc0000ac018)
in my_function - a=(&#123;31&#125;, 0xc0000b2028) b=(&amp;&#123;41&#125;, 0xc0000ac028)
after calling  - a=(&#123;30&#125;, 0xc0000b2008) b=(&amp;&#123;41&#125;, 0xc0000ac018)
</code></pre>
<p>从上述运行的结果可以得出如下结论：</p>
<ul>
<li>传递结构体时：会拷贝结构体中的全部内容；</li>
<li>传递结构体指针时：会拷贝结构体指针；</li>
</ul>
<p>修改结构体指针是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。</p>
<p>简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p>
<pre><code class="go">type MyStruct struct &#123;
    i int
    j int
&#125;

func myFunction(ms *MyStruct) &#123;
    ptr := unsafe.Pointer(ms)
    for i := 0; i &lt; 2; i++ &#123;
        c := (*int)(unsafe.Pointer((uintptr(ptr) + uintptr(8*i))))
        *c += i + 1
        fmt.Printf(&quot;[%p] %d\n&quot;, c, *c)
    &#125;
&#125;

func main() &#123;
    a := &amp;MyStruct&#123;i: 40, j: 50&#125;
    myFunction(a)
    fmt.Printf(&quot;[%p] %v\n&quot;, a, a)
&#125;

$ go run main.go
[0xc000134010] 41
[0xc000134018] 52
[0xc000134010] &amp;&#123;41 52&#125;
</code></pre>
<p>在这段代码中，通过指针修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p>
<p>如果将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p>
<pre><code class="go">type MyStruct struct &#123;
    i int
    j int
&#125;

func myFunction(ms *MyStruct) *MyStruct &#123;
    return ms
&#125;

$ go tool compile -S -N -l main.go
&quot;&quot;.myFunction STEXT nosplit size=20 args=0x10 locals=0x0
    0x0000 00000 (main.go:8)	MOVQ	$0, &quot;&quot;.~r1+16(SP) // 初始化返回值
    0x0009 00009 (main.go:9)	MOVQ	&quot;&quot;.ms+8(SP), AX   // 复制引用
    0x000e 00014 (main.go:9)	MOVQ	AX, &quot;&quot;.~r1+16(SP) // 返回引用
    0x0013 00019 (main.go:9)	RET
</code></pre>
<p>在这段汇编语言中，当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令复制引用，然后将复制后的指针作为返回值传递回调用方。根据上面函数调用的原理，可以知道此时栈内的结构如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A83.png" alt="函数调用3"></p>
<p>所以将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
<p>需要注意，在传递数组或者内存占用非常大的结构体时，应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Go 语言中接口的实现都是隐式的，只需要实现接口中的方法就相当于实现了接口。<strong>Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查</strong>。例如有以下代码：</p>
<pre><code class="go">type error interface &#123;
    Error() string
&#125;

type RPCError struct &#123;
    Code    int64
    Message string
&#125;

// *RPCError 实现了 error 接口
func (e *RPCError) Error() string &#123;
    return fmt.Sprintf(&quot;%s, code=%d&quot;, e.Message, e.Code)
&#125;

func main() &#123;
    var rpcErr error = NewRPCError(400, &quot;unknown err&quot;) // 赋值进行类型检查1
    err := AsErr(rpcErr) // 传参进行类型检查
    println(err)
&#125;

func NewRPCError(code int64, msg string) error &#123;
    return &amp;RPCError&#123; // 参数返回类型检查
        Code:    code,
        Message: msg,
    &#125;
&#125;

func AsErr(err error) error &#123;
    return err
&#125;
</code></pre>
<p>Go 语言在编译期间会对代码进行类型检查，上面的代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才检查类型，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface&#123;&#125;</code>：</p>
<p>Go 语言使用 <code>runtime.iface</code> 表示第一种接口，使用 <code>runtime.eface</code> 表示第二种不包含任何方法的接口 <code>interface&#123;&#125;</code>，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface&#123;&#125;</code> 类型不是任意类型。如果将类型转换成了 <code>interface&#123;&#125;</code> 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 <code>interface&#123;&#125;</code>。</p>
<pre><code class="go">package main

func main() &#123;
    type Test struct&#123;&#125;
    v := Test&#123;&#125;
    Print(v)
&#125;

func Print(v interface&#123;&#125;) &#123;
    println(v)
&#125;
</code></pre>
<p>上面 <code>Print</code> 函数不接受任意类型的参数，只接受 <code>interface&#123;&#125;</code> 类型的值，在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface&#123;&#125;</code> 类型。</p>
<h2 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h2><p>下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<pre><code class="go">type Cat struct &#123;&#125;
type Duck interface &#123; ... &#125;

func (c  Cat) Quack &#123;&#125;  // 使用结构体实现接口
func (c *Cat) Quack &#123;&#125;  // 使用结构体指针实现接口

var d Duck = Cat&#123;&#125;      // 使用结构体初始化变量
var d Duck = &amp;Cat&#123;&#125;     // 使用结构体指针初始化变量
</code></pre>
<p>实现接口的类型和初始化返回的类型两个维度共组成了四种情况，然而这四种情况不是都能通过编译器的检查：</p>
<table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th>结构体指针实现接口</th>
</tr>
</thead>
<tbody><tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td>不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td>通过</td>
</tr>
</tbody></table>
<p>四种中只有使用指针实现接口，使用结构体初始化变量无法通过编译，其他的三种情况都可以正常执行。</p>
<p>也就是说，<strong>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法</strong></p>
<p>对于方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<pre><code class="go">type Cat struct&#123;&#125;

func (c Cat) Quack() &#123;
    fmt.Println(&quot;meow&quot;)
&#125;

func main() &#123;
    var c Duck = &amp;Cat&#123;&#125;
    c.Quack()
&#125;
</code></pre>
<p>作为指针的 <code>&amp;Cat&#123;&#125;</code> 变量能够<strong>隐式地获取</strong>到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。表面上看，<code>*Cat</code> 类型并没有实现 <code>Quack</code> 方法，但是因为 <code>Cat</code> 类型实现了 <code>Quack</code> 方法，所以让 <code>*Cat</code> 类型自动拥有了 <code>Quack</code> 方法。</p>
<p>但是如果将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<pre><code class="go">type Duck interface &#123;
    Quack()
&#125;

type Cat struct&#123;&#125;

func (c *Cat) Quack() &#123;
    fmt.Println(&quot;meow&quot;)
&#125;

func main() &#123;
    var c Duck = Cat&#123;&#125;
    c.Quack()
&#125;

$ go build interface.go
./interface.go:20:6: cannot use Cat literal (type Cat) as type Duck in assignment:
    Cat does not implement Duck (Quack method has pointer receiver)
</code></pre>
<p>编译器会提醒：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。</p>
<p>原因在于，Go 语言在传递参数时都是传值的：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%80%BC%E6%83%85%E5%86%B5.png" alt="指针和接口传值情况"></p>
<p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat&#123;&#125;</code> 还是 <code>&amp;Cat&#123;&#125;</code>，<strong>使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝</strong>：</p>
<ul>
<li>如上图左侧，<strong>对于 <code>&amp;Cat&#123;&#125;</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat&#123;&#125;</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体</strong>；</li>
<li>如上图右侧，<strong>对于 <code>Cat&#123;&#125;</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat&#123;&#125;</code>，因为方法的参数是 <code>Cat</code>，编译器不会无中生有创建一个新的指针</strong>；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>从设计上来说，接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如<strong>果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者</strong>。</p>
<p>因此，当使用指针实现接口时，只有指针类型的变量才会实现该接口；当使用结构体实现接口时，指针类型和结构体类型都会实现该接口。</p>
<h3 id="值接收者和指针接收者应用场景"><a href="#值接收者和指针接收者应用场景" class="headerlink" title="值接收者和指针接收者应用场景"></a>值接收者和指针接收者应用场景</h3><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li><p>方法能够修改接收者指向的值。</p>
</li>
<li><p>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</p>
</li>
</ul>
<p>但是是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<strong>本质</strong>。</p>
<p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p>
<blockquote>
<p>Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作<strong>标头（header）值</strong>。从技术细节上说，字符串也是一种引用类型。</p>
<p>每个引用类型创建的标头值是<strong>包含一个指向底层数据结构的指针</strong>。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。</p>
</blockquote>
<p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。</p>
<h2 id="接口的数据结构"><a href="#接口的数据结构" class="headerlink" title="接口的数据结构"></a>接口的数据结构</h2><p>Go 语言<strong>根据接口类型是否包含一组方法</strong>将接口类型分成了两类：</p>
<ul>
<li>使用 <code>runtime.iface</code> 结构体表示包含方法的接口</li>
<li>使用 <code>runtime.eface</code> 结构体表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型；</li>
</ul>
<h3 id="eface-结构"><a href="#eface-结构" class="headerlink" title="eface 结构"></a>eface 结构</h3><p><code>runtime.eface</code> 结构体在 Go 语言中的定义是这样的：</p>
<pre><code class="go">type eface struct &#123;	// 16 字节
    _type *_type
    data  unsafe.Pointer
&#125;
</code></pre>
<p>由于 <code>interface&#123;&#125;</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针：维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型；<code>data</code> 描述了具体的值。</p>
<p>从上述结构也能推断出：Go 语言的任意类型都可以转换成 <code>interface&#123;&#125;</code>。</p>
<h3 id="iface-结构"><a href="#iface-结构" class="headerlink" title="iface 结构"></a>iface 结构</h3><p>另一个用于表示接口的结构体是 <code>runtime.iface</code>：</p>
<pre><code class="go">type iface struct &#123; // 16 字节
    tab  *itab
    data unsafe.Pointer
&#125;
</code></pre>
<p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示<strong>接口的类型以及赋给这个接口的实体类型</strong>。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p>
<h4 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h4><p><code>runtime.itab</code> 结构体是接口类型的核心组成部分，每一个 <code>runtime.itab</code> 都占 32 字节，可以将其看成<strong>接口类型</strong>和<strong>具体类型</strong>的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p>
<pre><code class="go">type itab struct &#123; // 32 字节
    inter *interfacetype
    _type *_type
    hash  uint32
    _     [4]byte
    fun   [1]uintptr
&#125;
</code></pre>
<ul>
<li><p><code>inter</code> 字段则描述了接口的类型</p>
</li>
<li><p><code>_type</code> 字段描述了实体的具体类型</p>
</li>
<li><p><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>runtime._type</code> 是否一致；</p>
</li>
<li><p><code>fun</code> 是一个动态大小的数组，用于放置和接口方法对应的具体数据类型的方法地址。它是一个用于动态派发的虚函数表，存储了一组函数指针。一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p>
<p>另外，数组大小虽然是 1，但是这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。所以虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun </code>数组中保存的元素数量是不确定的。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p>
</li>
</ul>
<h4 id="interfacetype"><a href="#interfacetype" class="headerlink" title="interfacetype"></a>interfacetype</h4><p><code>interfacetype</code> 描述的是接口的类型，它的实现如下：</p>
<pre><code class="go">type interfacetype struct &#123;
    typ     _type
    pkgpath name
    mhdr    []imethod
&#125;
</code></pre>
<p>它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。这里需要注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p>
<h4 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h4><p><code>runtime._type</code> 是 Go 语言类型的运行时表示。它描述了实体的类型，包括内存对齐方式，大小等。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<blockquote>
<p>注意这里的 hash 值是根据类型、方法生成的，与 data 内容无关</p>
</blockquote>
<pre><code class="go">type _type struct &#123;
    // 存储了类型占用的内存空间，为内存空间的分配提供信息
    size       uintptr
    ptrdata    uintptr
    // 类型的 hash 值，能够快速确定类型是否相等
    hash       uint32
    // 类型的 flag，和反射相关
    tflag      tflag
    // 内存对齐相关
    align      uint8
    fieldAlign uint8
    // 类型的编号，有 bool, slice, struct 等等等等
    kind       uint8
    // 用于判断当前类型的多个对象是否相等，
    // 该字段是为了减少 Go 语言二进制包大小从 `typeAlg` 结构体中迁移过来的
    equal      func(unsafe.Pointer, unsafe.Pointer) bool
    // gc 相关
    gcdata     *byte
    str        nameOff
    ptrToThis  typeOff
&#125;
</code></pre>
<p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p>
<pre><code class="go">type arraytype struct &#123;    
    typ   _type    
    elem  *_type    
    slice *_type    
    len   uintptr
&#125;
type chantype struct &#123;    
    typ  _type    
    elem *_type    
    dir  uintptr
&#125;
type slicetype struct &#123;    
    typ  _type    
    elem *_type
&#125;
type structtype struct &#123;    
    typ     _type    
    pkgPath name    
    fields  []structfield
&#125;
</code></pre>
<p>这些数据类型的结构体定义，是反射实现的基础。</p>
<p>整体来说，iface 的结构如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/iface%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="iface整体结构"></p>
<h2 id="接口的动态类型和动态值"><a href="#接口的动态类型和动态值" class="headerlink" title="接口的动态类型和动态值"></a>接口的动态类型和动态值</h2><p>从上面的数据结构可以看到，<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<strong>动态类型</strong>和<strong>动态值</strong>。而<strong>接口值包括动态类型和动态值</strong>。</p>
<p>接口值的零值是指动态类型和动态值都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p>
<p>例如下面的例子：</p>
<pre><code class="go">type Coder interface &#123;
    code()
&#125;

type Gopher struct &#123;
    name string
&#125;

func (g Gopher) code() &#123;
    fmt.Printf(&quot;%s is coding\n&quot;, g.name)
&#125;

func main() &#123;
    var c Coder
    fmt.Println(c == nil)
    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)

    var g *Gopher
    fmt.Println(g == nil)

    c = g
    fmt.Println(c == nil)
    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="shell">true
c: &lt;nil&gt;, &lt;nil&gt;
true
false
c: *main.Gopher, &lt;nil&gt;
</code></pre>
<p>一开始，<code>c</code> 的动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p>
<p>再看一个例子：</p>
<pre><code class="go">package main

type TestStruct struct&#123;&#125;

func NilOrNot(v interface&#123;&#125;) bool &#123;
    return v == nil
&#125;

func main() &#123;
    var s *TestStruct
    fmt.Println(s == nil)      // #=&gt; true
    fmt.Println(NilOrNot(s))   // #=&gt; false
&#125;

$ go run main.go
true
false
</code></pre>
<p>简单总结一下上述代码执行的结果：</p>
<ul>
<li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li>
<li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li>
</ul>
<p>出现上述现象的原因是： 调用 <code>NilOrNot </code> 函数时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>TestStruct</code> 类型会转换成 <code>interface&#123;&#125;</code> 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。 </p>
<h2 id="编译器自动检测类型是否实现接口"><a href="#编译器自动检测类型是否实现接口" class="headerlink" title="编译器自动检测类型是否实现接口"></a>编译器自动检测类型是否实现接口</h2><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p>
<pre><code class="go">var _ io.Writer = (*myWriter)(nil)
</code></pre>
<p>这种做法是为了让编译器由此检查 <code>myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p>
<p>下面有个例子：</p>
<pre><code class="go">package main

import &quot;io&quot;

type myWriter struct &#123;
    
&#125;

/*func (w myWriter) Write(p []byte) (n int, err error) &#123;    
    return
&#125;*/

func main() &#123;    
    // 检查 *myWriter 类型是否实现了 io.Writer 接口    
    var _ io.Writer = (*myWriter)(nil)
    
    // 检查 myWriter 类型是否实现了 io.Writer 接口    
    var _ io.Writer = myWriter&#123;&#125;
&#125;
</code></pre>
<p>注释掉为 <code>myWriter</code> 定义的 <code>Write</code> 函数后，运行程序：</p>
<pre><code>src/main.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:    
    *myWriter does not implement io.Writer (missing Write method)
src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment:    
    myWriter does not implement io.Writer (missing Write method)
</code></pre>
<p>报错信息：<code>*myWriter/myWriter</code> 未实现 <code>io.Writer</code> 接口，也就是未实现 <code>Write</code> 方法。</p>
<p>解除注释后，运行程序不报错。</p>
<p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p>
<p>总结一下，<em>可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</em></p>
<pre><code class="go">var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter&#123;&#125;
</code></pre>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p>
<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>需要反射的 2 个常见场景：</p>
<ol>
<li>有时需要编写一个函数，但是并不知道传给函数的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li>
<li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li>
</ol>
<p>但是使用反射也存在一定的风险：</p>
<ol>
<li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li>
<li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li>
<li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，<strong>对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性</strong>。</li>
</ol>
<h2 id="反射的三大法则"><a href="#反射的三大法则" class="headerlink" title="反射的三大法则"></a>反射的三大法则</h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码，但是过量的使用反射会使程序逻辑变得难以理解并且运行缓慢。在 Go 官方关于反射的博客中提到，反射有三大定律：</p>
<ol>
<li><p>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</p>
</li>
<li><p>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</p>
</li>
<li><p>要修改反射对象，其值必须可设置；</p>
</li>
</ol>
<h3 id="第一法则"><a href="#第一法则" class="headerlink" title="第一法则"></a>第一法则</h3><p>反射是一种检测存储在 <code>interface</code> 中的类型和值机制。这可以通过 <code>TypeOf</code> 函数和 <code>ValueOf</code> 函数得到。</p>
<p>反射的第一法则是能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。这里之所以说是 <code>interface</code> ，是因为当执行如 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是<strong>由于 <code>reflect.TypeOf</code>、<code>reflect.ValueOf</code> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</strong>所以实际上都是从 <code>interface&#123;&#125;</code> 中反射对象。</p>
<p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型，这也就是为什么第一条法则是从接口到反射对象。</p>
<p>上面提到的 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数就能完成这里的转换，如果认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。</p>
<h3 id="第二法则"><a href="#第二法则" class="headerlink" title="第二法则"></a>第二法则</h3><p>第二条实际上和第一条是相反的机制，它将 <code>ValueOf</code> 的返回值通过 <code>Interface()</code> 函数反向转变成 <code>interface</code> 变量。</p>
<p>反射的第二法则是可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code> 中的 <code>reflect.Value.Interface</code> 就能完成这项工作。</p>
<p>不过调用 <code>reflect.Value.Interface</code> 方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<pre><code class="go">v := reflect.ValueOf(1)
v.Interface().(int)
</code></pre>
<p>第一第二法则就是说接口型变量和反射类型对象可以相互转化，反射类型对象实际上就是指的前面说的<code>reflect.Type</code> 和 <code>reflect.Value</code>。</p>
<h3 id="第三法则"><a href="#第三法则" class="headerlink" title="第三法则"></a>第三法则</h3><p>如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，所以第二种情况在语言层面是不被允许的。</p>
<p>举一个经典例子：</p>
<pre><code class="go">var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
</code></pre>
<p>执行上面的代码会产生 panic，原因是反射变量 <code>v</code> 不能代表 <code>x</code> 本身，因为调用 <code>reflect.ValueOf(x)</code> 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 <code>v</code> 代表的只是 <code>x</code> 的一个拷贝，因此对 <code>v</code> 进行操作是被禁止的。</p>
<p>可设置是反射变量 <code>Value</code> 的一个性质，但不是所有的 <code>Value</code> 都是可被设置的。</p>
<p>就像在一般的函数里那样，当想改变传入的变量时，使用指针就可以解决了。但是在反射中：</p>
<pre><code class="go">var x float64 = 3.4
p := reflect.ValueOf(&amp;x)
fmt.Println(&quot;type of p:&quot;, p.Type())
fmt.Println(&quot;settability of p:&quot;, p.CanSet())
</code></pre>
<p>输出是这样的：</p>
<pre><code>type of p: *float64
settability of p: false
</code></pre>
<p>也就是说即使使用指针，<code>p</code> 还不是代表 <code>x</code>，这只是 <code>x</code> 的指针，<code>p.Elem()</code> 才真正代表 <code>x</code>（相当于解引用），这样就可以真正操作 <code>x</code> 了：</p>
<pre><code class="go">v := p.Elem()
v.SetFloat(7.1)
fmt.Println(v.Interface()) // 7.1
fmt.Println(x) // 7.1
</code></pre>
<p>关于第三条，记住一句话：如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p>
<h2 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h2><p>当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，<strong>反射就是通过接口的类型信息实现的，反射建立在类型的基础上</strong>。</p>
<p>Go 语言在 <code>reflect</code> 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。</p>
<h3 id="types-和-interface"><a href="#types-和-interface" class="headerlink" title="types 和 interface"></a>types 和 interface</h3><p>Go 语言中，每个变量都有一个静态类型，也就是声明时候的类型。这是在编译阶段就确定了的，比如 <code>int, float64, []int</code> 等等。注意，这个类型是声明时候的类型，不是底层数据类型。</p>
<p>Go 官方博客里就举了一个例子：</p>
<pre><code class="go">type MyInt int

var i int
var j MyInt
</code></pre>
<p>尽管 i，j 的底层类型都是 int，但他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 <code>MyInt</code>。</p>
<p>反射主要与 <code>interface&#123;&#125;</code> 类型相关。上面的接口一节已经列出了 <code>interface</code> 的底层结构，即 <code>iface</code> 和 <code>eface</code> 。</p>
<p><code>iface</code> 描述的是非空接口，它包含方法；</p>
<pre><code class="go">type iface struct &#123;
    tab  *itab
    data unsafe.Pointer
&#125;

type itab struct &#123;
    inter  *interfacetype
    _type  *_type
    link   *itab
    hash   uint32
    bad    bool
    inhash bool
    unused [2]byte
    fun    [1]uintptr
&#125;
</code></pre>
<p>其中 <code>itab</code> 由具体类型 <code>_type</code> 以及 <code>interfacetype</code> 组成。<code>_type</code> 表示具体类型，而 <code>interfacetype</code> 则表示具体类型实现的接口类型。</p>
<p>与之相对的是 <code>eface</code>，描述的是空接口，不包含任何方法，Go 语言里有的类型都实现了空接口。</p>
<pre><code class="go">type eface struct &#123;
    _type *_type
    data  unsafe.Pointer
&#125;
</code></pre>
<p>它只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p>
<p>需要明确的一点：<strong>接口变量可以存储任何实现了接口定义的所有方法的变量</strong>。</p>
<p>Go 语言中最常见的就是 <code>Reader</code> 和 <code>Writer</code> 接口：</p>
<pre><code class="go">type Reader interface &#123;
    Read(p []byte) (n int, err error)
&#125;

type Writer interface &#123;
    Write(p []byte) (n int, err error)
&#125;
</code></pre>
<p>接下来，就是接口之间的各种转换和赋值了：</p>
<pre><code class="go">var r io.Reader
tty, err := os.OpenFile(&quot;/Users/silverming/test&quot;, os.O_RDWR, 0)
if err != nil &#123;
    return nil, err
&#125;
r = tty
</code></pre>
<p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，**这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code>**。</p>
<p>之后，<code>r = tty</code> 这一语句，<strong>将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</strong></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BE%8B.png" alt="接口变量存储实例"></p>
<p>此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p>
<pre><code class="go">var w io.Writer
w = r.(io.Writer)
</code></pre>
<p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p>
<p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，<strong>但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> 。</strong><code>w</code> 的内存形式如下图：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E8%B5%8B%E5%80%BCio.writer.png" alt="使用断言赋值io.writer"></p>
<p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p>
<p>最后，再看一个赋值：</p>
<pre><code>var empty interface&#123;&#125;
empty = w
</code></pre>
<p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E8%B5%8B%E5%80%BC%E7%BB%99%E7%A9%BA%E6%8E%A5%E5%8F%A3.png" alt="赋值给空接口"></p>
<p>从上面的三张图可以看到，<code>interface</code> 包含三部分信息：<code>_type</code> 是类型信息，<code>*data</code> 指向实际类型的实际值，<code>itab</code> 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法）。</p>
<h3 id="emptyInterface"><a href="#emptyInterface" class="headerlink" title="emptyInterface"></a>emptyInterface</h3><p>Go 语言的 <code>interface&#123;&#125;</code> 类型在语言内部是通过 <code>reflect.emptyInterface</code> 结体表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据。</p>
<p>这里的 <code>emptyInterface</code> 和上面提到的 <code>eface</code> 其实是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 <code>reflect</code> 包，后者在 <code>runtime</code> 包。 <code>eface.typ</code> 就是动态类型。</p>
<pre><code class="go">type emptyInterface struct &#123;
    typ  *rtype
    word unsafe.Pointer
&#125;
</code></pre>
<h3 id="TypeOf-方法的实现原理"><a href="#TypeOf-方法的实现原理" class="headerlink" title="TypeOf 方法的实现原理"></a>TypeOf 方法的实现原理</h3><p><code>reflect</code> 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p>
<p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，能获取数据的运行时表示，因此程序员可以获取甚至改变类型的值。</p>
<p><code>reflect</code> 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p>
<pre><code class="go">func TypeOf(i interface&#123;&#125;) Type 
func ValueOf(i interface&#123;&#125;) Value
</code></pre>
<p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface&#123;&#125;</code>，看下源码：</p>
<pre><code class="go">func TypeOf(i interface&#123;&#125;) Type &#123;
    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))
    return toType(eface.typ)
&#125;
</code></pre>
<p>调用此函数时，实参会先被转化为 <code>interface&#123;&#125;</code> 类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface&#123;&#125;</code> 变量里了。然后将传入的变量隐式转换成 <code>reflect.emptyInterface</code> 类型，并获取其中存储的类型信息 <code>reflect.rtype</code>。</p>
<p>至于 <code>toType</code> 函数，只是做了一个类型转换：</p>
<pre><code class="go">func toType(t *rtype) Type &#123;
    if t == nil &#123;
        return nil
    &#125;
    return t
&#125;
</code></pre>
<h4 id="rtype"><a href="#rtype" class="headerlink" title="rtype"></a>rtype</h4><p>首先看看获取的 <code>rtypr</code> ，它和 <code>_type</code> 是一回事，而且源代码里也注释了：两边要保持同步：</p>
<pre><code class="go">// rtype must be kept in sync with ../runtime/type.go:/^type._type.
type rtype struct &#123;
    size       uintptr
    ptrdata    uintptr // number of bytes in the type that can contain pointers
    hash       uint32  // hash of type; avoids computation in hash tables
    tflag      tflag   // extra type information flags
    align      uint8   // alignment of variable with this type
    fieldAlign uint8   // alignment of struct field with this type
    kind       uint8   // enumeration for C
    // function for comparing objects of this type
    // (ptr to object A, ptr to object B) -&gt; ==?
    equal     func(unsafe.Pointer, unsafe.Pointer) bool
    gcdata    *byte   // garbage collection data
    str       nameOff // string form
    ptrToThis typeOff // type for pointer to this type, may be zero
&#125;
</code></pre>
<p><code>reflect</code> 包下所有的类型都会包含 <code>rtype</code> 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。</p>
<p>比如下面的 <code>arrayType</code> 和 <code>chanType</code> 都包含 <code>rytpe</code>，而前者还包含 slice，len 等和数组相关的信息；后者则包含 <code>dir</code> 表示通道方向的信息：</p>
<pre><code class="go">// arrayType represents a fixed array type.
type arrayType struct &#123;
    rtype `reflect:&quot;array&quot;`
    elem  *rtype // array element type
    slice *rtype // slice type
    len   uintptr
&#125;

// chanType represents a channel type.
type chanType struct &#123;
    rtype `reflect:&quot;chan&quot;`
    elem  *rtype  // channel element type
    dir   uintptr // channel direction (ChanDir)
&#125;
</code></pre>
<h4 id="Type-接口的方法"><a href="#Type-接口的方法" class="headerlink" title="Type 接口的方法"></a>Type 接口的方法</h4><p> 注意，<code>TypeOf</code> 函数的返回值 <code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而上面的 <code>*rtype</code> 实现了 <code>Type</code> 接口。Type 接口有如下的方法：</p>
<pre><code class="go">type Type interface &#123;
    // 所有的类型都可以调用下面这些函数

    // 此类型的变量对齐后所占用的字节数
    Align() int

    // 如果是 struct 的字段，对齐后占用的字节数
    FieldAlign() int

    // 方法返回类型的方法集中的第 i 个方法。 
    // 如果不在[0， NumMethod （））范围内，它会发生 panic。
    // 
    // 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，
    // 其第一个参数为接收方。
    // 
    // 对于接口类型，返回的 Method 的 Type 字段给出方法签名，没有接收方，而 Func 字段为 nil。
    // 
    // 仅可导出方法，并且它们按字典顺序排序
    Method(int) Method

    // MethodByName 返回在类型的方法集中具有该名称的方法和一个布尔值，指示是否找到该方法。
    // 
    // 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，
    // 其第一个参数为接收方。
    //    
    // 对于接口类型，返回的 Method 的 Type 字段给出方法签名，没有接收方，而 Func 字段为 nil
    MethodByName(string) (Method, bool)

    // 获取类型方法集里导出的方法个数
    NumMethod() int

    // 类型名称
    Name() string

    // 返回类型所在的路径，如：encoding/base64
    PkgPath() string

    // 返回类型的大小，和 unsafe.Sizeof 功能类似
    Size() uintptr

    // 返回类型的字符串表示形式
    String() string

    // 返回类型的类型值
    Kind() Kind

    // 类型是否实现了接口 u
    Implements(u Type) bool

    // 是否可以赋值给 u
    AssignableTo(u Type) bool

    // 是否可以类型转换成 u
    ConvertibleTo(u Type) bool

    // 类型是否可以比较
    Comparable() bool
    
   
    // 下面的方法仅适用于某些特定类型，具体取决于种类。
    // 每种类型允许使用的方法有：
    //	Int*, Uint*, Float*, Complex*: Bits
    //	Array: Elem, Len
    //	Chan: ChanDir, Elem
    //	Func: In, NumIn, Out, NumOut, IsVariadic.
    //	Map: Key, Elem
    //	Ptr: Elem
    //	Slice: Elem
    //	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField

    // 类型所占据的位数
    Bits() int

    // 返回通道的方向，只能是 chan 类型调用，其他类型会 panic
    ChanDir() ChanDir

    // 返回类型是否是可变参数，只能是 func 类型调用
    // 比如 t 是类型 func(x int, y ... float64)
    // 那么 t.IsVariadic() == true
    IsVariadic() bool

    // 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用
    Elem() Type

    // 返回结构体类型的第 i 个字段，只能是结构体类型调用
    // 如果 i 超过了总字段数，就会 panic
    Field(i int) StructField

    // 返回嵌套的结构体的字段，等效于为每个索引 i 依次调用 Field
    FieldByIndex(index []int) StructField

    // 通过字段名称获取字段
    FieldByName(name string) (StructField, bool)

    // FieldByNameFunc returns the struct field with a name
    // 返回名称符合 func 函数的字段
    FieldByNameFunc(match func(string) bool) (StructField, bool)

    // 获取函数类型的第 i 个参数的类型
    In(i int) Type

    // 返回 map 的 key 类型，只能由类型 map 调用
    Key() Type

    // 返回 Array 的长度，只能由类型 Array 调用
    Len() int

    // 返回类型字段的数量，只能由类型 Struct 调用
    NumField() int

    // 返回函数类型的输入参数个数
    NumIn() int

    // 返回函数类型的返回值个数
    NumOut() int

    // 返回函数类型的第 i 个值的类型
    Out(i int) Type

    // 返回类型结构体的相同部分
    common() *rtype
    // 返回类型结构体的不同部分
    uncommon() *uncommonType
&#125;
</code></pre>
<p><code>Type</code> 定义了非常多的方法，通过它们可以获取类型的一切信息。注意到，<code>Type</code> 接口实现了 <code>String()</code> 函数，满足 <code>fmt.Stringer</code> 接口，因此使用 <code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。另外，<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是打印参数的动态类型。</p>
<p>例如：</p>
<pre><code class="go">fmt.Printf(&quot;%T&quot;, 3) // int
</code></pre>
<h3 id="ValueOf-实现原理"><a href="#ValueOf-实现原理" class="headerlink" title="ValueOf 实现原理"></a>ValueOf 实现原理</h3><p><code>ValueOf</code> 的实现源码如下：</p>
<pre><code class="go">func ValueOf(i interface&#123;&#125;) Value &#123;
    if i == nil &#123;
        return Value&#123;&#125;
    &#125;

    // 保证当前值逃逸到堆上
    escapes(i)

    return unpackEface(i)	
&#125;

// 分解 eface
func unpackEface(i interface&#123;&#125;) Value &#123;
    e := (*emptyInterface)(unsafe.Pointer(&amp;i))

    t := e.typ
    if t == nil &#123;
        return Value&#123;&#125;
    &#125;
    
    f := flag(t.Kind())
    if ifaceIndir(t) &#123;
        f |= flagIndir
    &#125;
    return Value&#123;t, e.word, f&#125;
&#125;
</code></pre>
<p>返回值 <code>reflect.Value</code> 表示 <code>interface&#123;&#125;</code> 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 <code>_type</code> (具体到这里是指 <code>structType</code>) 类型持有的关于结构体的字段信息、偏移信息，以及 <code>*data</code> 所指向的内容 —— 结构体的实际值。</p>
<p>从源码看，先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p>
<p><code>Value</code> 结构体定义了很多方法，通过这些方法可以直接操作 <code>Value</code> 字段 <code>ptr</code> 所指向的实际数据：</p>
<pre><code class="go">// 设置切片的 len 字段，如果类型不是切片，就会panic
 func (v Value) SetLen(n int)
 
 // 设置切片的 cap 字段
 func (v Value) SetCap(n int)
 
 // 设置字典的 kv
 func (v Value) SetMapIndex(key, val Value)

 // 返回切片、字符串、数组的索引 i 处的值
 func (v Value) Index(i int) Value
 
 // 根据名称获取结构体的内部字段值
 func (v Value) FieldByName(name string) Value
 
 // ……
</code></pre>
<p><code>Value</code> 字段还有很多其他的方法。例如：</p>
<pre><code class="go">// 用来获取 int 类型的值
func (v Value) Int() int64

// 用来获取结构体字段（成员）数量
func (v Value) NumField() int

// 尝试向通道发送数据（不会阻塞）
func (v Value) TrySend(x reflect.Value) bool

// 通过参数列表 in 调用 v 值所代表的函数（或方法
func (v Value) Call(in []Value) (r []Value) 

// 调用变参长度可变的函数
func (v Value) CallSlice(in []Value) []Value
</code></pre>
<p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。<code>Type()</code> 方法也可以返回变量的类型信息，与 <code>reflect.TypeOf()</code> 函数等价。<code>Interface()</code> 方法可以将 <code>Value</code> 还原成原来的 <code>interface</code>。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Interface%E3%80%81type%E3%80%81value%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="三者关系"></p>
<p>总结一下：<code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p>
<h3 id="reflect-Set的实现"><a href="#reflect-Set的实现" class="headerlink" title="reflect.Set的实现"></a>reflect.Set的实现</h3><p>当想要更新 <code>reflect.Value</code> 时，一般需要这样做：</p>
<pre><code class="go">func main() &#123;
     i := 2.33
     v := reflect.ValueOf(&amp;i)
     v.Elem().SetFloat(6.66)
    // value:  6.66
     log.Println(&quot;value: &quot;, i)
&#125;
</code></pre>
<p>这里会需要调用 <code>reflect.Value.Set</code> 更新反射对象，该方法会调用 <code>reflect.flag.mustBeAssignable</code> 和 <code>reflect.flag.mustBeExported</code> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<pre><code class="go">func (v Value) Set(x Value) &#123;
    // 检查当前反射对象是否是可以被设置
    v.mustBeAssignable()
    // 检查 x 字段是否是对外公开
    x.mustBeExported() // do not let unexported x leak
    var target unsafe.Pointer
    if v.kind() == Interface &#123;
        target = v.ptr
    &#125;
    x = x.assignTo(&quot;reflect.Set&quot;, v.typ, target)
    if x.flag&amp;flagIndir != 0 &#123;
        // func typedmemmove(t *rtype, dst unsafe.Pointer, src unsafe.Pointer)
        // typedmemmove 将类型 t 的值从 src 复制到 dst。
        typedmemmove(v.typ, v.ptr, x.ptr)
    &#125; else &#123;
        *(*unsafe.Pointer)(v.ptr) = x.ptr
    &#125;
&#125;
</code></pre>
<p><code>Set</code> 函数的步骤如下：</p>
<ol>
<li><p>检查反射对象及其字段是否可以被设置。</p>
</li>
<li><p>检查反射对象及其字段是否导出（对外公开）。</p>
</li>
<li><p>调用 <code>assignTo</code> 方法创建一个新的反射对象并对原本的反射对象进行覆盖。</p>
<p><code>assignTo</code> 会根据当前和被设置的反射对象类型创建一个新的 <code>reflect.Value</code>结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li>
</ul>
<pre><code class="go">func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value &#123;
    if v.flag&amp;flagMethod != 0 &#123;
        v = makeMethodValue(context, v)
    &#125;

    switch &#123;
    case directlyAssignable(dst, v.typ):
        // Overwrite type so that they match.
        // Same memory layout, so no harm done.
        fl := v.flag&amp;(flagAddr|flagIndir) | v.flag.ro()
        fl |= flag(dst.Kind())
        // 返回一个新的结构题
        return Value&#123;dst, v.ptr, fl&#125;

    case implements(dst, v.typ):
        if target == nil &#123;
            target = unsafe_New(dst)
        &#125;
        if v.Kind() == Interface &amp;&amp; v.IsNil() &#123;
            // A nil ReadWriter passed to nil Reader is OK,
            // but using ifaceE2I below will panic.
            // Avoid the panic by returning a nil dst (e.g., Reader) explicitly.
            return Value&#123;dst, nil, flag(Interface)&#125;
        &#125;
        x := valueInterface(v, false)
        if dst.NumMethod() == 0 &#123;
            *(*interface&#123;&#125;)(target) = x
        &#125; else &#123;
            ifaceE2I(dst, x, target)
        &#125;
        return Value&#123;dst, target, flagIndir | flag(Interface)&#125;
    &#125;

    // Failed.
    panic(context + &quot;: value of type &quot; + v.typ.String() + &quot; is not assignable to type &quot; + dst.String())
&#125;
</code></pre>
</li>
<li><p>根据 <code>assignTo</code> 方法所返回的指针值，对当前反射对象的指针进行值的修改。</p>
</li>
</ol>
<p>简单来讲就是，检查是否可以设置，接着创建一个新的对象，最后对其修改。是一个非常标准的赋值流程。</p>
<h2 id="未导出成员"><a href="#未导出成员" class="headerlink" title="未导出成员"></a>未导出成员</h2><p>利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。</p>
<p>注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。</p>
<blockquote>
<p>一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。<br><code>CanAddr</code> 不能说明一个变量是否可以被修改。<br><code>CanSet</code> 则可以检查对应的 <code>reflect.Value</code> 是否可取地址并可被修改。</p>
</blockquote>
<pre><code class="go">package main

import (
    &quot;reflect&quot;
    &quot;fmt&quot;
)

type Child struct &#123;
    Name     string
    handsome bool
&#125;

func main() &#123;
    qcrao := Child&#123;Name: &quot;qcrao&quot;, handsome: true&#125;

    v := reflect.ValueOf(&amp;qcrao)

    f := v.Elem().FieldByName(&quot;Name&quot;)
    fmt.Println(f.String())

    f.SetString(&quot;stefno&quot;)
    fmt.Println(f.String())

    f = v.Elem().FieldByName(&quot;handsome&quot;)
    
    // 这一句会导致 panic，因为 handsome 字段未导出
    //f.SetBool(true)
    fmt.Println(f.Bool())
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code>qcrao
stefno
true
</code></pre>
<p>上面的例子中，<code>handsome</code> 字段未导出，可以读取，但不能调用相关 <code>set</code> 方法，否则会 <code>panic</code>。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。</p>
<h2 id="反射的实际应用"><a href="#反射的实际应用" class="headerlink" title="反射的实际应用"></a>反射的实际应用</h2><p>反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p>
<p>这里举 2 个例子：json 序列化和 DeepEqual 函数。</p>
<h3 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h3><p><code>json</code> 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。</p>
<p>Go 语言中，主要提供 2 个函数用于序列化和反序列化：</p>
<pre><code>func Marshal(v interface&#123;&#125;) ([]byte, error)
func Unmarshal(data []byte, v interface&#123;&#125;) error
</code></pre>
<p>两个函数的参数都包含 <code>interface</code>，具体实现的时候，都会用到反射相关的特性。</p>
<p>对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 <code>get</code> 函数或者 <code>set</code> 函数进行实际的操作。</p>
<h3 id="DeepEqual-的作用及原理"><a href="#DeepEqual-的作用及原理" class="headerlink" title="DeepEqual 的作用及原理"></a>DeepEqual 的作用及原理</h3><p>在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。</p>
<p>例如：如何判断两个 <code>slice</code> 所有的元素完全相同；如何判断两个 <code>map</code> 的 <code>key</code> 和 <code>value</code> 完全相同等等。</p>
<p>上述问题，可以通过 <code>DeepEqual</code> 函数实现。</p>
<pre><code class="go">func DeepEqual(x, y interface&#123;&#125;) bool
</code></pre>
<p><code>DeepEqual</code> 函数的参数是两个 <code>interface</code>，实际上也就是可以输入任意类型，输出 <code>true</code> 或者 <code>flase</code> 表示输入的两个变量是否是“深度”相等。</p>
<p>先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</p>
<pre><code class="go">type MyInt int
type YourInt int

func main() &#123;
    m := MyInt(1)
    y := YourInt(1)

    fmt.Println(reflect.DeepEqual(m, y)) // false
&#125;
</code></pre>
<p>上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 <code>MyInt</code>，后者是 <code>YourInt</code>，因此两者不是“深度”相等。</p>
<p>在源码里，有对 <code>DeepEqual</code> 函数的非常清楚地注释，列举了不同类型，<code>DeepEqual</code> 的比较情形，这里做一个总结：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>深度相等情形</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>Struct</td>
<td>相应字段，包含导出和不导出，“深度”相等</td>
</tr>
<tr>
<td>Func</td>
<td>只有两者都是 nil 时</td>
</tr>
<tr>
<td>Interface</td>
<td>两者存储的具体值“深度”相等</td>
</tr>
<tr>
<td>Map</td>
<td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td>
</tr>
<tr>
<td>Pointer</td>
<td>1、使用 &#x3D;&#x3D; 比较的结果相等；2、指向的实体“深度”相等</td>
</tr>
<tr>
<td>Slice</td>
<td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] &#x3D;&#x3D; &amp;y[0] 或者 相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>numbers, bools, strings, and channels</td>
<td>使用 &#x3D;&#x3D; 比较的结果为真</td>
</tr>
</tbody></table>
<p>一般情况下，<code>DeepEqual</code> 的实现只需要递归地调用 <code>==</code> 就可以比较两个变量是否是真的“深度”相等。</p>
<p>但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等<em>；</em>float 类型，由于精度的原因，也是不能使用 <code>==</code> 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。</p>
<p>对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。</p>
<p>同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。</p>
<p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p>
<p>来看源码：</p>
<pre><code class="go">func DeepEqual(x, y interface&#123;&#125;) bool &#123;
    if x == nil || y == nil &#123;
        return x == y
    &#125;
    v1 := ValueOf(x)
    v2 := ValueOf(y)
    if v1.Type() != v2.Type() &#123;
        return false
    &#125;
    return deepValueEqual(v1, v2, make(map[visit]bool), 0)
&#125;
</code></pre>
<p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。</p>
<p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p>
<p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p>
<p>代码比较长，思路却比较简单清晰：核心是一个 <code>switch</code> 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。</p>
<p>实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 <code>map</code> 类型的比较：</p>
<pre><code class="go">// deepValueEqual 函数
// ……

case Map:
    if v1.IsNil() != v2.IsNil() &#123;
        return false
    &#125;
    if v1.Len() != v2.Len() &#123;
        return false
    &#125;
    if v1.Pointer() == v2.Pointer() &#123;
        return true
    &#125;
    for _, k := range v1.MapKeys() &#123;
        val1 := v1.MapIndex(k)
        val2 := v2.MapIndex(k)
        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) &#123;
            return false
        &#125;
    &#125;
    return true
    
// ……
</code></pre>
<p>和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p>
<pre><code class="go">type visit struct &#123;
    a1  unsafe.Pointer
    a2  unsafe.Pointer
    typ Type
&#125;

map[visit]bool
</code></pre>
<p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 <code>true</code>。</p>
<h1 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h1><p>Channel 是支撑 Go 语言高性能并发编程模型的重要结构。Go 语言中最常见的、也是经常被人提及的设计模式就是：<strong>不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存</strong>。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。</p>
<p>虽然在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺序进程（Communicating sequential processes，CSP）。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Goroutine%20%E4%BD%BF%E7%94%A8%20Channel%20%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png" alt="Goroutine 使用 Channel 传递数据"></p>
<p>上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。</p>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>Channel 在运行时使用 <code>runtime.hchan</code>结构体表示，当创建一个 channel 的时候，实际上创建的是如下的一个结构体：</p>
<pre><code class="go">type hchan struct &#123;
    qcount   uint
    dataqsiz uint
    buf      unsafe.Pointer
    elemsize uint16
    closed   uint32
    elemtype *_type
    sendx    uint
    recvx    uint
    recvq    waitq
    sendq    waitq

    lock mutex
&#125;
</code></pre>
<p>该结构体中的五个字段 <code>qcount</code>、<code>dataqsiz</code>、<code>buf</code>、<code>sendx</code>、<code>recv</code> 构建底层的循环队列：</p>
<ul>
<li><code>qcount</code> — Channel 中的元素个数；</li>
<li><code>dataqsiz</code> — Channel 中的循环队列的长度；</li>
<li><code>buf</code> — Channel 的缓冲区数据指针；</li>
<li><code>sendx</code> — Channel 的发送操作处理到的位置；</li>
<li><code>recvx</code> — Channel 的接收操作处理到的位置；</li>
</ul>
<p>除此之外，<code>elemsize</code> 和 <code>elemtype</code> 分别表示当前 Channel 能够收发的元素类型和大小；<code>sendq</code> 和 <code>recvq</code> 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 <code>runtime.waitq</code> 表示，链表中所有的元素都是 <code>runtime.sudog</code> 结构：</p>
<pre><code class="go">type waitq struct &#123;
    first *sudog
    last  *sudog
&#125;
</code></pre>
<p><code>runtime.sudog</code> 表示一个在等待列表中的 Goroutine，该结构中存储了两个分别指向前后 <code>runtime.sudog</code> 的指针以构成链表。</p>
<h2 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h2><p>Go 语言中所有 Channel 的创建都会使用 <code>make</code> 关键字。编译器会将 <code>make(chan int, 10)</code> 表达式转换成 <code>OMAKE</code> 类型的节点，并在类型检查阶段将 <code>OMAKE</code> 类型的节点转换成 <code>OMAKECHAN</code> 类型。这一阶段会对传入 <code>make</code> 关键字的缓冲区大小进行检查，如果不向 <code>make</code> 传递表示缓冲区大小的参数，那么就会设置一个默认值 0，也就是当前的 Channel 不存在缓冲区。</p>
<pre><code class="go">func makechan(t *chantype, size int) *hchan &#123;
    elem := t.elem
    mem, _ := math.MulUintptr(elem.size, uintptr(size))

    var c *hchan
    switch &#123;
    case mem == 0:
        c = (*hchan)(mallocgc(hchanSize, nil, true))
        c.buf = c.raceaddr()
    case elem.kind&amp;kindNoPointers != 0:
        c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        c.buf = add(unsafe.Pointer(c), hchanSize)
    default:
        c = new(hchan)
        c.buf = mallocgc(mem, elem, true)
    &#125;
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)
    return c
&#125;
</code></pre>
<p>上述代码根据 Channel 中收发元素的类型和缓冲区的大小初始化 <code>runtime.hchan</code> 和缓冲区：</p>
<ul>
<li>如果当前 Channel 中不存在缓冲区，那么就只会为 <code>runtime.hchan</code>分配一段内存空间；</li>
<li>如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li>
<li>在默认情况下会单独为 <code>runtime.hchan</code> 和缓冲区分配内存；</li>
</ul>
<p>在函数的最后会统一更新  <code>elemsize</code>、<code>elemtype</code> 和 <code>dataqsiz</code> 几个字段。</p>
<h2 id="向通道传递数据"><a href="#向通道传递数据" class="headerlink" title="向通道传递数据"></a>向通道传递数据</h2><p>当想要向 Channel 发送数据时，就需要使用 <code>ch &lt;- i</code> 语句，编译器会将它解析成 <code>OSEND</code> 节点并最终调用 <code>runtime.chansend</code> 并传入 Channel 和需要发送的数据。</p>
<pre><code class="go">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;
    lock(&amp;c.lock)

    if c.closed != 0 &#123;
        unlock(&amp;c.lock)
        panic(plainError(&quot;send on closed channel&quot;))
    &#125;
</code></pre>
<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。<strong>所以本质上往 channel 中写数据也是有加锁操作的</strong></p>
<p>如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序。</p>
<p>该函数的执行过程分成以下的三个部分：</p>
<ul>
<li>当存在等待的接收者时，通过 <code>runtime.send</code> <strong>直接将数据发送给阻塞的接收者</strong>；</li>
<li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li>
<li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li>
</ul>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 <code>runtime.chansend</code> 会从接收队列 <code>recvq</code> 中取出最先陷入等待的 Goroutine 并直接向它发送数据：</p>
<pre><code class="go">if sg := c.recvq.dequeue(); sg != nil &#123;
        send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)
        return true
    &#125;
</code></pre>
<p>发送数据时会调用 <code>runtime.send</code>，该函数的执行可以分成两个部分：</p>
<ol>
<li>调用 <code>runtime.sendDirect</code> 将发送的数据直接拷贝到 <code>x = &lt;-c</code> 表达式中变量 <code>x</code> 所在的内存地址上；</li>
<li>调用 <code>runtime.goready</code> 将等待接收数据的 Goroutine 标记成可运行状态 <code>Grunnable</code> 并把该 Goroutine 放到发送方所在的处理器的 <code>runnext</code> 上等待执行，该处理器在下一次调度时会立刻唤醒数据的接收方；</li>
</ol>
<pre><code class="go">func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) &#123;
    if sg.elem != nil &#123;
        sendDirect(c.elemtype, sg, ep)
        sg.elem = nil
    &#125;
    gp := sg.g
    unlockf()
    gp.param = unsafe.Pointer(sg)
    goready(gp, skip+1)
&#125;
</code></pre>
<p>需要注意的是，<strong>发送数据的过程只是将接收方的 Goroutine 放到了处理器的 <code>runnext</code> 中，程序没有立刻执行该 Goroutine</strong>。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>如果创建的 Channel 包含缓冲区并且 Channel 中的数据没有装满，首先会使用 <code>runtime.chanbuf</code> 计算出下一个可以存储数据的位置，然后通过 <code>runtime.typedmemmove</code> 将发送的数据拷贝到缓冲区中并增加 <code>sendx</code> 索引和 <code>qcount</code> 计数器。如果当前 Channel 的缓冲区未满，向 Channel 发送的数据会存储在 Channel 的 <code>sendx</code> 索引所在的位置并将 <code>sendx</code> 索引加一。因为这里的 <code>buf</code> 是一个循环数组，所以当 <code>sendx</code> 等于 <code>dataqsiz</code> 时会重新回到数组开始的位置。</p>
<pre><code class="go">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;
    ...
    if c.qcount &lt; c.dataqsiz &#123;
        qp := chanbuf(c, c.sendx)
        typedmemmove(c.elemtype, qp, ep)
        c.sendx++
        if c.sendx == c.dataqsiz &#123;
            c.sendx = 0
        &#125;
        c.qcount++
        unlock(&amp;c.lock)
        return true
    &#125;
    ...
&#125;
</code></pre>
<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><p>当 Channel 没有接收者能够处理数据时，<strong>向 Channel 发送数据会被下游阻塞</strong>，当然使用 <code>select</code> 关键字可以向 Channel 非阻塞地发送消息。向 Channel 阻塞地发送数据会执行下面的代码，可以简单梳理一下这段代码的逻辑：</p>
<pre><code class="go">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;
    ...
    if !block &#123;
        unlock(&amp;c.lock)
        return false
    &#125;

    gp := getg()
    mysg := acquireSudog()
    mysg.elem = ep
    mysg.g = gp
    mysg.c = c
    gp.waiting = mysg
    c.sendq.enqueue(mysg)
    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)

    gp.waiting = nil
    gp.param = nil
    mysg.c = nil
    releaseSudog(mysg)
    return true
&#125;
</code></pre>
<ol>
<li>调用 <code>runtime.getg</code> 获取发送数据使用的 Goroutine；</li>
<li>执行 <code>runtime.acquireSudog</code> 获取 <code>runtime.sudog</code> 结构并设置这一次阻塞发送的相关信息，例如发送的 Channel、是否在 select 中和待发送数据的内存地址等；</li>
<li>将刚刚创建并初始化的 <code>runtime.sudog</code> 加入发送等待队列，并设置到当前 Goroutine 的 <code>waiting</code> 上，表示 Goroutine 正在等待该 <code>sudog</code> 准备就绪；</li>
<li>调用 <code>runtime.goparkunlock</code> 将当前的 Goroutine 陷入沉睡等待唤醒；</li>
<li>被调度器唤醒后会执行一些收尾工作，将一些属性置零并且释放 <code>runtime.sudog</code> 结构体；</li>
</ol>
<p>函数在最后会返回 <code>true</code> 表示这次我们已经成功向 Channel 发送了数据。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p>
<ol>
<li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li>
<li>如果不满足上面的两种情况，会创建一个 <code>runtime.sudog</code> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li>
</ol>
<p><strong>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</strong></p>
<ol>
<li><strong>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</strong></li>
<li><strong>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <code>runtime.goparkunlock</code> 触发 Goroutine 的调度让出处理器的使用权；</strong></li>
</ol>
<h2 id="从通道接收数据"><a href="#从通道接收数据" class="headerlink" title="从通道接收数据"></a>从通道接收数据</h2><p>Go 语言中可以使用两种不同的方式去接收 Channel 中的数据：</p>
<pre><code class="go">i &lt;- ch
i, ok &lt;- ch
</code></pre>
<p>这两种不同的方法经过编译器的处理都会变成 <code>ORECV</code> 类型的节点，后者会在类型检查阶段被转换成 <code>OAS2RECV</code> 类型。</p>
<p>虽然不同的接收方式会被转换成 <code>runtime.chanrecv1</code> 和 <code>runtime.chanrecv2</code> 两种不同函数的调用，但是这两个函数最终还是会调用 <code>runtime.chanrecv</code>。</p>
<p>当<strong>从一个空 Channel 接收数据时会直接调用 <code>runtime.gopark</code> 让出处理器的使用权</strong>。</p>
<p><strong>如果当前 Channel 已经被关闭并且缓冲区中不存在任何数据，那么会清除 <code>ep</code> 指针中的数据并立刻返回</strong>。</p>
<pre><code class="go">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123;
    if c == nil &#123;
        if !block &#123;
            return
        &#125;
        gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
        throw(&quot;unreachable&quot;)
    &#125;

    // 这里也加了锁
    lock(&amp;c.lock)

    if c.closed != 0 &amp;&amp; c.qcount == 0 &#123;
        unlock(&amp;c.lock)
        if ep != nil &#123;
            typedmemclr(c.elemtype, ep)
        &#125;
        return true, false
    &#125;
</code></pre>
<p>从代码可以看出，<strong>对于 channel 的读操作，同样是加了锁来保障并发安全</strong>。</p>
<p>除了上述两种特殊情况，使用 <code>runtime.chanrecv</code> 从 Channel 接收数据时还包含以下三种不同情况：</p>
<ul>
<li>当存在等待的发送者时，通过 <code>runtime.recv</code> 从阻塞的发送者或者缓冲区中获取数据；</li>
<li>当缓冲区存在数据时，从 Channel 的缓冲区中接收数据；</li>
<li>当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据；</li>
</ul>
<h3 id="直接接收"><a href="#直接接收" class="headerlink" title="直接接收"></a>直接接收</h3><p>当 Channel 的 <code>sendq</code> 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几，只是发送数据时调用的是 <code>runtime.send</code> 函数，而接收数据时使用 <code>runtime.recv</code>：</p>
<pre><code class="go">if sg := c.sendq.dequeue(); sg != nil &#123;
        recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)
        return true, true
    &#125;
</code></pre>
<p>该函数会根据缓冲区的大小分别处理不同的情况：</p>
<ul>
<li>如果 Channel 不存在缓冲区；<ol>
<li>调用 <code>runtime.recvDirect</code> 将 Channel 发送队列中 Goroutine 存储的 <code>elem</code> 数据拷贝到目标内存地址中；</li>
</ol>
</li>
<li>如果 Channel 存在缓冲区；<ol>
<li>将队列中的数据拷贝到接收方的内存地址；</li>
<li>将发送队列头的数据拷贝到缓冲区中，释放一个阻塞的发送方；</li>
</ol>
</li>
</ul>
<p>无论发生哪种情况，运行时都会调用 <code>runtime.goready</code> 将当前处理器的 <code>runnext</code> 设置成发送数据的 Goroutine，<strong>在调度器下一次调度时将阻塞的发送方唤醒</strong>。</p>
<h3 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>当 Channel 的缓冲区中已经包含数据时，从 Channel 中接收数据会直接从缓冲区中 <code>recvx</code> 的索引位置中取出数据进行处理。如果接收数据的内存地址不为空，那么会使用 <code>runtime.typedmemmove</code>将缓冲区中的数据拷贝到内存中、清除队列中的数据并完成收尾工作。收尾工作包括递增 <code>recvx</code>，一旦发现索引超过了 Channel 的容量时，会将它归零重置循环队列的索引；除此之外，该函数还会减少 <code>qcount</code> 计数器并释放持有 Channel 的锁。</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p><strong>当 Channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞的</strong>，然而不是所有的接收操作都是阻塞的，与 <code>select</code> 语句结合使用时就可能会使用到非阻塞的接收操作。</p>
<p>在正常的接收场景中，会使用 <code>runtime.sudog</code> 将当前 Goroutine 包装成一个处于等待状态的 Goroutine 并将其加入到接收队列中。</p>
<p>完成入队之后，还会调用 <code>runtime.goparkunlock</code> 立刻触发 Goroutine 的调度，让出处理器的使用权并等待调度器的调度。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>梳理一下从 Channel 中接收数据时可能会发生的五种情况：</p>
<ol>
<li>如果 Channel 为空，那么会直接调用 <code>runtime.gopark</code>挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，<code>runtime.chanrecv</code>会直接返回；</li>
<li>如果 Channel 的 <code>sendq</code> 队列中存在挂起的 Goroutine，会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据，那么直接读取 <code>recvx</code> 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 <code>runtime.sudog</code> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p><strong>总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</strong></p>
<ol>
<li><strong>当 Channel 为空时；</strong></li>
<li><strong>当缓冲区中不存在数据并且也不存在数据的发送者时；</strong></li>
</ol>
<h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>编译器会将用于关闭管道的 <code>close</code> 关键字转换成 <code>OCLOSE</code> 节点以及 <code>runtime.closechan</code> 函数。</p>
<p>当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接崩溃并抛出异常：</p>
<pre><code class="go">func closechan(c *hchan) &#123;
    if c == nil &#123;
        panic(plainError(&quot;close of nil channel&quot;))
    &#125;

    lock(&amp;c.lock)
    if c.closed != 0 &#123;
        unlock(&amp;c.lock)
        panic(plainError(&quot;close of closed channel&quot;))
    &#125;
</code></pre>
<p>处理完了这些异常的情况之后就可以开始执行关闭 Channel 的逻辑了，主要工作就是将 <code>recvq</code> 和 <code>sendq</code> 两个队列中的数据加入到 Goroutine 列表 <code>gList</code> 中，与此同时该函数会清除所有 <code>runtime.sudog</code> 上未被处理的元素，最后会为所有被阻塞的 Goroutine 调用 <code>runtime.goready</code> 触发调度。</p>
<p><strong>参考文章</strong>：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.iminho.me/wiki/blog-26.html">Go 语言数组和切片的原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pvzO8wu13gLKK00zp77zWA">由浅到深，入门Go语言Map实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hmOBmHFiybS0JqoCpQHmSw">Go是如何设计Map的</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jq65sSHTX-ucSG8TlI5Zxg">深度解密Go语言之map</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyq6239075/article/details/106047992">深入理解GO语言：map结构原理和源码分析</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/271145056">三万字带你认识 Go 底层 map 的实现</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">Go 语言设计与实现 3.3 节</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA">深度解密Go语言之关于 interface 的 10 个问题</a></p>
<p><a target="_blank" rel="noopener" href="https://qcrao.com/2019/05/07/dive-into-go-reflection/#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">深度解密Go语言之反射</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/onl3sBCSNs8l42uihi_p4A">解密 Go 语言之反射 reflect</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>打工不易，想买杯奶茶</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://qiniu.xiaoming.net.cn/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="Silverming 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/16/Go%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="prev" title="Go 内存管理与垃圾回收">
                  <i class="fa fa-chevron-left"></i> Go 内存管理与垃圾回收
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/16/go%E4%B8%ADContext%E5%8C%85/" rel="next" title="Go 中 Context 包">
                  Go 中 Context 包 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备18114217号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silverming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:04</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
