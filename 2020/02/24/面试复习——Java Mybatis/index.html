<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Java MyBatis</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M2RT7SDT3L', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2icon.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1. MyBatis 有什么特点？
MyBatis 中的 SQL 语句和主要业务代码分离，我们一般会把 MyBatis 中的 SQL 语句统一放在 XML 配置文件中，便于统一维护。

解除 SQL 与程序代码的耦合，通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。SQL 和代码的分离，提高了可维护性。

MyBatis 比较简单和轻量：本身就很小且简单。没有任何第三方依赖，只要通过配置 jar 包，或者如果使用 Maven 项目的话只需要配置 Maven 以来就可以。易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。

屏蔽样板代码：MyBatis 会屏蔽原始的 JDBC 样板代码，让你把更多的精力专注于 SQL 的书写和属性-字段映射上。
.."></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Java MyBatis</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-MyBatis-有什么特点？"><span class="toc-text">1. MyBatis 有什么特点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MyBatis-整体架构"><span class="toc-text">2. MyBatis 整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口层"><span class="toc-text">接口层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据处理层"><span class="toc-text">数据处理层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置解析"><span class="toc-text">配置解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-解析与-scripting-模块"><span class="toc-text">SQL 解析与 scripting 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-执行"><span class="toc-text">SQL 执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础支持层"><span class="toc-text">基础支持层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反射模块"><span class="toc-text">反射模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换模块"><span class="toc-text">类型转换模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志模块"><span class="toc-text">日志模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源加载模块"><span class="toc-text">资源加载模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析器模块"><span class="toc-text">解析器模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据源模块"><span class="toc-text">数据源模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务管理模块"><span class="toc-text">事务管理模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存模块"><span class="toc-text">缓存模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binding-模块"><span class="toc-text">Binding 模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Mybatis核心组件-Mybatis中SQL语句执行过程"><span class="toc-text">3. Mybatis核心组件(Mybatis中SQL语句执行过程)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SqlSessionFactory"><span class="toc-text">SqlSessionFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SqlSessionFactory-的执行流程"><span class="toc-text">SqlSessionFactory 的执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SqlSession"><span class="toc-text">SqlSession</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MapperProxy"><span class="toc-text">MapperProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor"><span class="toc-text">Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-的继承结构"><span class="toc-text">Executor 的继承结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor的创建和选择"><span class="toc-text">Executor的创建和选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-的具体执行过程"><span class="toc-text">Executor 的具体执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatementHandler"><span class="toc-text">StatementHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StatementHandler-的继承结构"><span class="toc-text">StatementHandler 的继承结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StatementHandler-的创建和源码分析"><span class="toc-text">StatementHandler 的创建和源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParameterHandler"><span class="toc-text">ParameterHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParameterHandler-介绍"><span class="toc-text">ParameterHandler 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParameterHandler-的解析过程"><span class="toc-text">ParameterHandler 的解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResultSetHandler"><span class="toc-text">ResultSetHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ResultSetHandler-简介"><span class="toc-text">ResultSetHandler 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResultSetHandler-解析过程"><span class="toc-text">ResultSetHandler 解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-执行过程总结"><span class="toc-text">SQL 执行过程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-configuration标签下有哪些标签？"><span class="toc-text">4. configuration标签下有哪些标签？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#properties"><span class="toc-text">properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#settings"><span class="toc-text">settings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeAliases"><span class="toc-text">typeAliases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeHandlers"><span class="toc-text">typeHandlers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objectFactory"><span class="toc-text">objectFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugins"><span class="toc-text">plugins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#environments"><span class="toc-text">environments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#databaseIdProvider"><span class="toc-text">databaseIdProvider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mappers"><span class="toc-text">mappers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-什么是Mybatis？"><span class="toc-text">5. 什么是Mybatis？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-MyBatis的优缺点"><span class="toc-text">6. MyBatis的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#优点"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缺点"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-MyBatis-框架适用场合"><span class="toc-text">7. MyBatis 框架适用场合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-和-的区别是什么？"><span class="toc-text">8. #{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-当实体类中的属性名和表中的字段名不一样-，怎么办？"><span class="toc-text">9. 当实体类中的属性名和表中的字段名不一样 ，怎么办？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-模糊查询-like-语句该怎么写"><span class="toc-text">10. 模糊查询 like 语句该怎么写?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><span class="toc-text">11. 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Mybatis-是如何进行分页的？分页插件的原理是什么？"><span class="toc-text">12. Mybatis 是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><span class="toc-text">13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-如何执行批量插入"><span class="toc-text">14. 如何执行批量插入?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-如何获取自动生成的-主-键值"><span class="toc-text">15. 如何获取自动生成的(主)键值?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在mapper中配置insert节点的属性"><span class="toc-text">在mapper中配置insert节点的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在全局配置文件中配置settings节点"><span class="toc-text">在全局配置文件中配置settings节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#针对Oracle等无主键的数据库）在-insert-节点中加入-selectKey-属性"><span class="toc-text">针对Oracle等无主键的数据库）在 insert 节点中加入 selectKey 属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-在-mapper-中如何传递多个参数"><span class="toc-text">16. 在 mapper 中如何传递多个参数?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用索引：按照参数排序，arg从0开始，param从1开始"><span class="toc-text">使用索引：按照参数排序，arg从0开始，param从1开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-param-注解"><span class="toc-text">使用 @param 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个参数封装成-map"><span class="toc-text">多个参数封装成 map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql"><span class="toc-text">17. Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-Xml-映射文件中，除了常见的-select、insert、updae、delete-标签之外，还有哪些标签？"><span class="toc-text">18. Xml 映射文件中，除了常见的 select、insert、updae、delete 标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><span class="toc-text">19. Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里"><span class="toc-text">20. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-一对一、一对多的关联查询"><span class="toc-text">21. 一对一、一对多的关联查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-MyBatis-实现一对一有几种方式-具体怎么操作的？"><span class="toc-text">22. MyBatis 实现一对一有几种方式?具体怎么操作的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><span class="toc-text">23. Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-Mybatis-的一级、二级缓存"><span class="toc-text">24. Mybatis 的一级、二级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-什么是-MyBatis-的接口绑定？有哪些实现方式"><span class="toc-text">25. 什么是 MyBatis 的接口绑定？有哪些实现方式?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-使用-MyBatis-的-mapper-接口调用时有哪些要求？"><span class="toc-text">26. 使用 MyBatis 的 mapper 接口调用时有哪些要求？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-Mapper-编写有哪几种方式？"><span class="toc-text">27. Mapper 编写有哪几种方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一种：使用传统Dao层开发"><span class="toc-text">第一种：使用传统Dao层开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二种：Mapper动态代理开发（不用自己写Dao实现类）"><span class="toc-text">第二种：Mapper动态代理开发（不用自己写Dao实现类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三种：使用-mapper-扫描器"><span class="toc-text">第三种：使用 mapper 扫描器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><span class="toc-text">28. 简述 Mybatis 的插件运行原理，以及如何编写一个插件。</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E9%9D%A2%E8%AF%95"><i class="tag post-item-tag">面试</i></a><a href="/tags/java"><i class="tag post-item-tag">java</i></a><a href="/tags/mybatis"><i class="tag post-item-tag">mybatis</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Java MyBatis</h1><time class="has-text-grey" datetime="2020-02-24T07:26:46.000Z">2020-02-24</time><article class="mt-2 post-content"><h1 id="1-MyBatis-有什么特点？"><a href="#1-MyBatis-有什么特点？" class="headerlink" title="1. MyBatis 有什么特点？"></a>1. MyBatis 有什么特点？</h1><ul>
<li><p>MyBatis 中的 SQL 语句和主要业务代码分离，我们一般会把 MyBatis 中的 SQL 语句统一放在 XML 配置文件中，便于统一维护。</p>
</li>
<li><p>解除 SQL 与程序代码的耦合，通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。SQL 和代码的分离，提高了可维护性。</p>
</li>
<li><p>MyBatis 比较简单和轻量：本身就很小且简单。没有任何第三方依赖，只要通过配置 jar 包，或者如果使用 Maven 项目的话只需要配置 Maven 以来就可以。易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</p>
</li>
<li><p>屏蔽样板代码：MyBatis 会屏蔽原始的 JDBC 样板代码，让你把更多的精力专注于 SQL 的书写和属性-字段映射上。</p>
</li>
<li><p>编写原生 SQL，支持多表关联：MyBatis 最主要的特点就是可以手动编写 SQL 语句，能够支持多表关联查询。</p>
</li>
<li><p>提供映射标签，支持对象与数据库的 ORM 字段关系映射</p>
<blockquote>
<p>对象关系映射(Object Relational Mapping，简称ORM) ，是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。</p>
</blockquote>
</li>
<li><p>提供 XML 标签，支持编写动态 SQL。可以使用 MyBatis XML 标签，起到 SQL 模版的效果，减少繁杂的 SQL 语句，便于维护。</p>
</li>
</ul>
<a id="more"></a>

<h1 id="2-MyBatis-整体架构"><a href="#2-MyBatis-整体架构" class="headerlink" title="2. MyBatis 整体架构"></a>2. MyBatis 整体架构</h1><p>MyBatis <strong>最上面是接口层</strong>，接口层就是开发人员在 Mapper 或者是 Dao 接口中的接口定义，是查询、新增、更新还是删除操作；<strong>中间层是数据处理层</strong>，主要是配置 Mapper -&gt; XML 层级之间的参数映射，SQL 解析，SQL 执行，结果映射的过程。<strong>上述两种流程都由基础支持层来提供功能支撑</strong>，基础支持层包括连接管理，事务管理，配置加载，缓存处理等。</p>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E6%9E%B6%E6%9E%84.png" alt="MyBatis架构"></p>
<h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>在不与Spring 集成的情况下，使用 MyBatis 执行数据库的操作主要如下：</p>
<pre><code class="java">InputStream is = Resources.getResourceAsStream(&quot;myBatis-config.xml&quot;);
SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
SqlSessionFactory factory = builder.build(is);
sqlSession = factory.openSession();</code></pre>
<p>其中的 <code>SqlSessionFactory</code>,<code>SqlSession</code> 是 MyBatis 接口的核心类，尤其是 <code>SqlSession</code>，这个接口是MyBatis 中最重要的接口，这个接口能够执行命令，获取映射，管理事务。</p>
<h2 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h2><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>在 Mybatis 初始化过程中，会加载 <code>mybatis-config.xml</code> 配置文件、映射配置文件以及 Mapper 接口中的注解信息，解析后的配置信息会形成相应的对象并保存到 <code>Configration</code> 对象中。之后，根据该对象创建 <code>SqlSessionFactory</code> 对象。待 Mybatis 初始化完成后，可以通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code> 对象并开始数据库操作。</p>
<h3 id="SQL-解析与-scripting-模块"><a href="#SQL-解析与-scripting-模块" class="headerlink" title="SQL 解析与 scripting 模块"></a>SQL 解析与 scripting 模块</h3><p>Mybatis 实现的动态 SQL 语句，几乎可以编写出所有满足需要的 SQL。</p>
<p>Mybatis 中 scripting 模块会根据用户传入的参数，解析映射文件中定义的动态 SQL 节点，形成数据库能执行的 SQL 语句。</p>
<h3 id="SQL-执行"><a href="#SQL-执行" class="headerlink" title="SQL 执行"></a>SQL 执行</h3><p>SQL 语句的执行涉及多个组件，包括 MyBatis 的四大核心，它们是: <code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>。SQL 的执行过程可以用下面这幅图来表示：</p>
<p><img src="http://qiniu.xiaoming.net.cn/mybatis%E4%B8%ADsql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MyBatis中sql执行过程"></p>
<p>MyBatis 层级结构各个组件的介绍(这里只是简单介绍，具体介绍在后面)：</p>
<ul>
<li><code>SqlSession</code>：它是 MyBatis 核心 API，主要用来执行命令，获取映射，管理事务。接收开发人员提供 Statement Id 和参数。并返回操作结果。</li>
<li><code>Executor</code> ：执行器，是 MyBatis 调度的核心，负责 SQL 语句的生成以及查询缓存的维护。</li>
<li><code>StatementHandler</code> :  封装了 JDBC Statement 操作，负责对 JDBC Statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。</li>
<li><code>ParameterHandler</code> :  负责对用户传递的参数转换成 JDBC Statement 所需要的参数。</li>
<li><code>ResultSetHandler</code> : 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。</li>
<li><code>TypeHandler</code> :  用于 Java 类型和 JDBC 类型之间的转换。</li>
<li><code>MappedStatement</code> : 动态 SQL 的封装</li>
<li><code>SqlSource</code> :  表示从 XML 文件或注释读取的映射语句的内容，它创建将从用户接收的输入参数传递给数据库的 SQL。</li>
<li><code>Configuration</code> :  MyBatis 所有的配置信息都维持在 Configuration 对象之中。</li>
</ul>
<h2 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h2><h3 id="反射模块"><a href="#反射模块" class="headerlink" title="反射模块"></a>反射模块</h3><p>Mybatis 中的反射模块，对 Java 反射进行了很好的封装，提供了简易的 API，方便上层调用，并且对反射操作进行了一系列的优化，比如，缓存了类的元数据（MetaClass）和对象的元数据（MetaObject），提高了反射操作的性能。</p>
<h3 id="类型转换模块"><a href="#类型转换模块" class="headerlink" title="类型转换模块"></a>类型转换模块</h3><p>Mybatis 的别名机制，能够简化配置文件，该机制是类型转换模块的主要功能之一。类型转换模块的另一个功能是实现 JDBC 类型与 Java 类型的转换。在 SQL 语句绑定参数时，会将数据由 Java 类型转换成 JDBC 类型；在映射结果集时，会将数据由 JDBC 类型转换成 Java 类型。</p>
<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>在 Java 中，有很多优秀的日志框架，如 Log4j、Log4j2、slf4j 等。Mybatis 除了提供了详细的日志输出信息，还能够集成多种日志框架，其日志模块的主要功能就是集成第三方日志框架。</p>
<h3 id="资源加载模块"><a href="#资源加载模块" class="headerlink" title="资源加载模块"></a>资源加载模块</h3><p>该模块主要封装了类加载器，确定了类加载器的使用顺序，并提供了加载类文件和其它资源文件的功能。</p>
<h3 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h3><p>该模块有两个主要功能：一个是封装了 XPath，为 Mybatis 初始化时解析 <code>mybatis-config.xml</code> 配置文件以及映射配置文件提供支持；另一个为处理动态 SQL 语句中的占位符提供支持。</p>
<h3 id="数据源模块"><a href="#数据源模块" class="headerlink" title="数据源模块"></a>数据源模块</h3><p>Mybatis 自身提供了相应的数据源实现，也提供了与第三方数据源集成的接口。数据源是开发中的常用组件之一，很多开源的数据源都提供了丰富的功能，如连接池、检测连接状态等，选择性能优秀的数据源组件，对于提供 ORM 框架以及整个应用的性能都是非常重要的。</p>
<h3 id="事务管理模块"><a href="#事务管理模块" class="headerlink" title="事务管理模块"></a>事务管理模块</h3><p>一般地，Mybatis 与 Spring 框架集成，由 Spring 框架管理事务。但 Mybatis 自身对数据库事务进行了抽象，提供了相应的事务接口和简单实现。</p>
<h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>Mybatis 中有一级缓存和二级缓存，这两级缓存都依赖于缓存模块中的实现。但是需要注意，这两级缓存与Mybatis 以及整个应用是运行在同一个 JVM 中的，共享同一块内存，如果这两级缓存中的数据量较大，则可能影响系统中其它功能，所以需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p>
<h3 id="Binding-模块"><a href="#Binding-模块" class="headerlink" title="Binding 模块"></a>Binding 模块</h3><p>在调用 SqlSession 相应方法执行数据库操作时，需要制定映射文件中定义的 SQL 节点，如果 SQL 中出现了拼写错误，那就只能在运行时才能发现。为了能尽早发现这种错误，Mybatis 通过 Binding 模块将用户自定义的 Mapper 接口与映射文件关联起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应的 SQL 语句完成数据库操作，从而避免上述问题。注意，在开发中，我们只是创建了 Mapper 接口，而并没有编写实现类，这是因为 Mybatis 自动为 Mapper 接口创建了动态代理对象。</p>
<h1 id="3-Mybatis核心组件-Mybatis中SQL语句执行过程"><a href="#3-Mybatis核心组件-Mybatis中SQL语句执行过程" class="headerlink" title="3. Mybatis核心组件(Mybatis中SQL语句执行过程)"></a>3. Mybatis核心组件(Mybatis中SQL语句执行过程)</h1><p>这些组件实现了从 SQL 语句到映射到 JDBC 再到数据库字段之间的转换，执行 SQL 语句并输出结果集。</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>对于任何框架而言，在使用该框架之前都要经历过一系列的初始化流程，MyBatis 也不例外。MyBatis 的初始化流程如下:</p>
<pre><code class="java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
sqlSessionFactory.openSession();</code></pre>
<p>上述流程中比较重要的一个对象就是 <code>SqlSessionFactory</code>，<code>SqlSessionFactory</code> 是 MyBatis 框架中的一个接口，它主要负责的是</p>
<ul>
<li>MyBatis 框架初始化操作</li>
<li>为开发人员提供SqlSession 对象</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E4%B8%ADsqlsessionFactory.jpg" alt="MyBatis中sqlSessionFactory类"></p>
<p><code>SqlSessionFactory</code> 有两个实现类，一个是 <code>SqlSessionManager</code> 类，一个是 <code>DefaultSqlSessionFactory</code> 类</p>
<ul>
<li><code>DefaultSqlSessionFactory</code> : SqlSessionFactory 的默认实现类，是真正生产会话的工厂类，这个类的实例的生命周期是全局的，它只会在首次调用时生成一个实例（单例模式），就一直存在直到服务器关闭。</li>
<li><code>SqlSessionManager</code> ：已被废弃，原因大概是: SqlSessionManager 中需要维护一个自己的线程池，而使用 MyBatis 更多的是要与 Spring 进行集成，并不会单独使用，所以维护自己的 ThreadLocal 并没有什么意义，所以 SqlSessionManager 已经不再使用。</li>
</ul>
<h3 id="SqlSessionFactory-的执行流程"><a href="#SqlSessionFactory-的执行流程" class="headerlink" title="SqlSessionFactory 的执行流程"></a>SqlSessionFactory 的执行流程</h3><p>首先第一步是 SqlSessionFactory 的创建</p>
<pre><code class="java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre>
<p>从这行代码入手，首先创建了一个 <code>SqlSessionFactoryBuilder</code> 工厂，这是一个建造者模式的设计思想，由 <code>builder</code> 建造者来创建 <code>SqlSessionFactory</code> 工厂</p>
<p>然后调用 <code>SqlSessionFactoryBuilder</code> 中的 <code>build</code> 方法传递一个 <code>InputStream</code> 输入流，Inputstream 输入流中就是你传过来的配置文件 <code>mybatis-config.xml</code>，<code>SqlSessionFactoryBuilder</code> 根据传入的 <code>InputStream</code> 输入流和 <code>environment</code>、<code>properties</code> 属性创建一个 <code>XMLConfigBuilder</code> 对象。<code>SqlSessionFactoryBuilder</code> 对象调用 <code>XMLConfigBuilder</code> 的 <code>parse()</code> 方法，流程如下。</p>
<p><img src="http://qiniu.xiaoming.net.cn/SqlSessionFactory%20%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="SqlSessionFactory 的执行流程"></p>
<p>XMLConfigBuilder 会解析 <code>/configuration</code> 标签，<code>configuration</code> 是 MyBatis 中最重要的一个标签。</p>
<p><img src="http://qiniu.xiaoming.net.cn/parseConfiguration%E6%96%B9%E6%B3%95.jpg" alt="parseConfiguration方法"></p>
<p>每一个属性都对应着一个解析方法，都是使用 XPath 把标签进行解析，解析完成后返回一个 <code>DefaultSqlSessionFactory</code> 对象，它是 <code>SqlSessionFactory</code> 的默认实现类。这就是 <code>SqlSessionFactoryBuilder</code> 的初始化流程，通过流程我们可以看到，初始化流程就是对一个个 <code>/configuration</code> 标签下子标签的解析过程。</p>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>在 MyBatis 初始化流程结束，也就是 SqlSessionFactoryBuilder -&gt; SqlSessionFactory 的获取流程后，我们就可以通过 SqlSessionFactory 对象得到 SqlSession 然后执行 SQL 语句了。</p>
<p><img src="http://qiniu.xiaoming.net.cn/sqlSessionFactory%E8%8E%B7%E5%8F%96sqlsession%E6%B5%81%E7%A8%8B.jpg" alt="sqlSessionFactory获取sqlSession流程"></p>
<p>在 <code>SqlSessionFactory.openSession</code> 过程中我们可以看到，会调用到 <code>DefaultSqlSessionFactory</code> 中的 <code>openSessionFromDataSource</code> 方法，这个方法主要创建了两个与分析执行流程重要的对象，一个是 <code>Executor</code> 执行器对象，一个是 <code>SqlSession</code> 对象。</p>
<p><code>SqlSession</code> 对象是 MyBatis 中最重要的一个对象，这个接口能够执行命令，获取映射，管理事务。<code>SqlSession</code> 中定义了一系列模版方法，让你能够执行简单的 CRUD 操作，也可以通过 getMapper 获取 Mapper 层，执行自定义 SQL 语句，因为 SqlSession 在执行 SQL 语句之前是需要先开启一个会话，涉及到事务操作，所以还会有 commit、 rollback、close 等方法。这也是模版设计模式的一种应用。</p>
<h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p><code>MapperProxy</code> 是 Mapper 映射 SQL 语句的关键对象，我们写的 Dao 层或者 Mapper 层都是通过 MapperProxy 来和对应的 SQL 语句进行绑定的。绑定过程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/MapperProxy%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy绑定过程"></p>
<p>这就是 MyBatis 的核心绑定流程，可以看到 <code>SqlSession</code> 首先调用 <code>getMapper</code> 方法， SqlSession 是大哥级别的人物，只定义标准。</p>
<p>SqlSession 把事情交给 <code>Configuration</code> 去做，然后 <code>Configuration</code> 有调用 <code>MapperRegistry</code>。<code>MapperRegistry</code> 相当于项目经理，项目经理只从大面上把握项目进度，不需要知道手下的小弟是如何工作的，把任务完成了就好。最终真正干活的还是 <code>MapperProxyFactory</code>。通过这段代码 <code>Proxy.newProxyInstance</code> ，可以看出使用了动态代理。</p>
<p>也就是说，MyBatis 中 Mapper 和 SQL 语句的绑定正是通过动态代理来完成的。</p>
<p>通过动态代理，就可以方便的在 Dao 层或者 Mapper 层定义接口，实现自定义的增删改查操作了。</p>
<p>接下来再看看 sql 语句执行过程</p>
<p><img src="http://qiniu.xiaoming.net.cn/MapperProxy%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy中sql语句执行过程"></p>
<p><code>MapperProxyFactory</code> 会生成代理对象，这个对象就是 <code>MapperProxy</code>，最终会调用到 <code>mapperMethod.execute</code> 方法，execute 方法比较长，其实逻辑比较简单，就是判断是插入、更新、删除还是查询语句，其中如果是查询的话，还会判断返回值的类型:</p>
<p><img src="http://qiniu.xiaoming.net.cn/mapperMethod.execute%E6%96%B9%E6%B3%95.jpg" alt="mapperMethod.execute方法"></p>
<p>以 selectList 为例，来看一下下面的执行过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/mapperMethod%E4%B8%ADselectList%E6%BA%90%E7%A0%81.jpg" alt="DefaultSqlSession中selectList源码"></p>
<p>这是 <code>DefaultSqlSession</code> 中 <code>selectList</code> 的代码，可以看到出现了 <code>executor</code>。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 的创建如下：由 Configuration 对象创建了一个 Executor 对象</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg" alt="Executor创建"></p>
<h3 id="Executor-的继承结构"><a href="#Executor-的继承结构" class="headerlink" title="Executor 的继承结构"></a>Executor 的继承结构</h3><p>每一个 SqlSession 都会拥有一个 Executor 对象，这个对象负责增删改查的具体操作，可以简单的将它理解为 JDBC 中 Statement 的封装版。也可以理解为 SQL 的执行引擎，要干活总得有一个发起人吧，可以把 Executor 理解为发起人的角色。</p>
<p>Executor 的继承体系如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg" alt="Executor继承结构"></p>
<p>如上图所示，位于继承体系最顶层的是 Executor 执行器，它有两个实现类，分别是 <code>BaseExecutor</code> 和 <code>CachingExecutor</code>。</p>
<p><code>BaseExecutor</code> 是一个抽象类，这种通过抽象的实现接口的方式是适配器设计模式之接口适配的体现，是Executor 的默认实现，实现了大部分 Executor 接口定义的功能，降低了接口实现的难度。<code>BaseExecutor</code> 的子类有三个，分别是 <code>SimpleExecutor</code>、<code>ReuseExecutor</code> 和 <code>BatchExecutor</code>。</p>
<ul>
<li><code>SimpleExecutor</code> : 简单执行器，是 MyBatis 中默认使用的执行器，每执行一次 update 或 select，就开启一个Statement 对象，用完就直接关闭 Statement 对象(可以是 Statement 或者是 PreparedStatment 对象)</li>
<li><code>ReuseExecutor</code> : 可重用执行器，这里的重用指的是重复使用 Statement，它会在内部使用一个 Map 把创建的 Statement 都缓存起来，每次执行 SQL 命令的时候，都会去判断是否存在基于该 SQL 的 Statement 对象，如果存在 Statement 对象并且对应的 connection 还没有关闭的情况下就继续使用之前的 Statement 对象，并将其缓存起来。因为每一个 SqlSession 都有一个新的 Executor 对象，所以我们缓存在 ReuseExecutor 上的 Statement 作用域是同一个 SqlSession。</li>
<li><code>BatchExecutor</code> : 批处理执行器，用于将多个 SQL 一次性输出到数据库</li>
<li><code>CachingExecutor</code> : 缓存执行器，先从缓存中查询结果，如果存在就返回之前的结果；如果不存在，再委托给 Executor delegate 去数据库中取，delegate 可以是上面任何一个执行器。</li>
</ul>
<h3 id="Executor的创建和选择"><a href="#Executor的创建和选择" class="headerlink" title="Executor的创建和选择"></a>Executor的创建和选择</h3><p>Executor 是由 Configuration 创建的，Configuration 会根据执行器的类型创建，如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%89%E6%8B%A9.jpg" alt="Executor的创建和选择"></p>
<p>这一步就是执行器的创建过程，根据传入的 <code>ExecutorType</code> 类型来判断是哪种执行器，如果不指定 <code>ExecutorType</code> ，默认创建的是简单执行器。它的赋值可以通过两个地方进行赋值：</p>
<p>可以通过<settings>标签来设置当前工程中所有的 SqlSession 对象使用默认的 Executor:</p>
<pre><code class="xml">&lt;settings&gt;
 &lt;!--取值范围 SIMPLE, REUSE, BATCH --&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
&lt;/settings&gt;</code></pre>
<p>另外一种直接通过Java对方法赋值的方式:</p>
<pre><code class="java">session = factory.openSession(ExecutorType.BATCH);</code></pre>
<h3 id="Executor-的具体执行过程"><a href="#Executor-的具体执行过程" class="headerlink" title="Executor 的具体执行过程"></a>Executor 的具体执行过程</h3><p>Executor 中的大部分方法的调用链其实是差不多的，执行流程图如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%20%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="Executor的具体执行过程"></p>
<p>紧跟着上面的 selectList 继续分析，它会调用到 <code>executor.query</code> 方法。</p>
<p>当有一个查询请求访问的时候，首先会经过 Executor 的实现类 <code>CachingExecutor</code> ，先从缓存中查询 SQL 是否是第一次执行，如果是第一次执行的话，那么就直接执行 SQL 语句，并创建缓存，如果第二次访问相同的 SQL 语句的话，那么就会直接从缓存中提取。</p>
<p>下面这段代码是从 <code>selectList -&gt; 从缓存中 query</code> 的具体过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2.jpg" alt="Executor具体执行过程2-从缓存获取"></p>
<p>下面代码会判断缓存中是否有这条 SQL 语句的执行结果，如果没有的话，就再重新创建 Executor 执行器执行 SQL 语句，注意， <code>list = doQuery</code> 是真正执行 SQL 语句的过程，这个过程中会创建我们上面提到的三种执行器，这里我们使用的是简单执行器。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5.jpg" alt="Executor具体执行过程2-直接执行sql语句"></p>
<p>到这里，执行器所做的工作就完事了，Executor 会把后续的工作交给 StatementHandler 继续执行。</p>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><p><code>StatementHandler</code> 是四大组件中最重要的一个对象，负责操作 Statement 对象与数据库进行交互，在工作时还会使用 <code>ParameterHandler</code> 和 <code>ResultSetHandler</code> 对参数进行映射，对结果进行实体类的绑定，这两个组件我们后面说。</p>
<p>在搭建原生 JDBC 的时候，会有这样一行代码:</p>
<pre><code class="java">Statement stmt = conn.createStatement(); //也可以使用PreparedStatement来做</code></pre>
<p>这行代码创建的 <code>Statement</code> 对象或者是 <code>PreparedStatement</code> 对象就是由 <code>StatementHandler</code> 进行管理的。</p>
<h3 id="StatementHandler-的继承结构"><a href="#StatementHandler-的继承结构" class="headerlink" title="StatementHandler 的继承结构"></a>StatementHandler 的继承结构</h3><p><img src="http://qiniu.xiaoming.net.cn/StatementHandler%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg" alt="StatementHandler 的继承结构"></p>
<p>有没有感觉和  Executor 的继承体系很相似呢？最顶级接口是四大组件对象，分别有两个实现类 <code>BaseStatementHandler</code>  和  <code>RoutingStatementHandler</code>，<code>BaseStatementHandler</code> 有三个实现类, 他们分别是 <code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code> 和 <code>CallableStatementHandler</code>。</p>
<p><code>RoutingStatementHandler</code> : RoutingStatementHandler 并没有对 Statement 对象进行使用，只是根据 <code>StatementType</code> 来创建一个代理，代理的就是对应 Handler 的三种实现类。在MyBatis 工作时,使用的 <code>StatementHandler</code> 接口对象实际上就是 <code>RoutingStatementHandler</code> 对象。</p>
<p><code>BaseStatementHandler</code> : 是 <code>StatementHandler</code> 接口的另一个实现类，它本身是一个抽象类，用于简化 <code>StatementHandler</code> 接口实现的难度，属于适配器设计模式体现，它主要有三个实现类</p>
<ul>
<li><code>SimpleStatementHandler</code>: 管理 Statement 对象并向数据库中推送不需要预编译的SQL语句。</li>
<li><code>PreparedStatementHandler</code>: 管理 Statement 对象并向数据中推送需要预编译的SQL语句。</li>
<li><code>CallableStatementHandler</code>：管理 Statement 对象并调用数据库中的存储过程。</li>
</ul>
<blockquote>
<p>这里注意一下，<code>SimpleStatementHandler</code> 和 <code>PreparedStatementHandler</code> 的区别是 SQL 语句是否包含变量，是否通过外部进行参数传入。<code>SimpleStatementHandler</code> 用于执行没有任何参数传入的 SQL,<code>PreparedStatementHandler</code> 需要对外部传入的变量和参数进行提前参数绑定和赋值。</p>
</blockquote>
<h3 id="StatementHandler-的创建和源码分析"><a href="#StatementHandler-的创建和源码分析" class="headerlink" title="StatementHandler 的创建和源码分析"></a>StatementHandler 的创建和源码分析</h3><p>继续来分析上面 query 的调用链路，StatementHandler 的创建过程如下:</p>
<p><img src="http://qiniu.xiaoming.net.cn/StatementHandler%20%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.jpg" alt="StatementHandler 的创建和源码分析"></p>
<p>MyBatis 会根据 SQL 语句的类型进行对应 StatementHandler 的创建。以预处理 StatementHandler 为例，创建过程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/PreparedStatementHandler%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="PrepareStatementHandler创建过程"></p>
<p>执行器不仅掌管着 StatementHandler 的创建，还掌管着创建 Statement 对象，设置参数等，在创建完 PreparedStatement 之后，就需要对参数进行处理了。</p>
<p>综上，sql语句的执行流程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BB%8Eexecutor%E5%88%B0handler%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="从executor到handler执行流程"></p>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><h3 id="ParameterHandler-介绍"><a href="#ParameterHandler-介绍" class="headerlink" title="ParameterHandler 介绍"></a>ParameterHandler 介绍</h3><p><code>ParameterHandler</code> 相比于其他的组件就简单很多了，<code>ParameterHandler</code> 译为参数处理器，负责为 <code>PreparedStatement</code> 的 sql 语句参数动态赋值，这个接口很简单只有两个方法:</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%E6%8E%A5%E5%8F%A3.jpg" alt="ParameterHandler接口"></p>
<p><code>ParameterHandler</code> 只有一个实现类 <code>DefaultParameterHandler</code> ， 它实现了这两个方法。</p>
<ul>
<li><code>getParameterObject</code>：用于读取参数</li>
<li><code>setParameters</code>: 用于对 <code>PreparedStatement</code> 的参数赋值</li>
</ul>
<h3 id="ParameterHandler-的解析过程"><a href="#ParameterHandler-的解析过程" class="headerlink" title="ParameterHandler 的解析过程"></a>ParameterHandler 的解析过程</h3><p>上面我们讨论过了 ParameterHandler 的创建过程，下面继续上面 <code>parameterSize</code> 流程：</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%20%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.jpg" alt="ParameterHandler 的解析过程"></p>
<p>这就是具体参数的解析过程了，注释如下：</p>
<pre><code class="java">public void setParameters(PreparedStatement ps) {
  ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());
  // parameterMappings 就是对 #{} 或者 ${} 里面参数的封装
  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
  if (parameterMappings != null) {
    // 如果是参数化的SQL，便需要循环取出并设置参数的值
    for (int i = 0; i &lt; parameterMappings.size(); i++) {
      ParameterMapping parameterMapping = parameterMappings.get(i);
      // 如果参数类型不是 OUT ，这个类型与 CallableStatementHandler 有关
      // 因为存储过程不存在输出参数，所以参数不是输出参数的时候，就需要设置。
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        // 得到 #{}  中的属性名
        String propertyName = parameterMapping.getProperty();
        // 如果 propertyName 是 Map 中的key
        if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params
          // 通过key 来得到 additionalParameter 中的value值
          value = boundSql.getAdditionalParameter(propertyName);
        }
        // 如果不是 additionalParameters 中的key，而且传入参数是 null， 则value 就是null
        else if (parameterObject == null) {
          value = null;
        }
        // 如果 typeHandlerRegistry 中已经注册了这个参数的 Class 对象，即它是 Primitive 或者是String 的话
        else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          // 否则就是 Map
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        // 在通过 SqlSource 的parse 方法得到parameterMappings 的具体实现中，我们会得到parameterMappings 的 typeHandler
        TypeHandler typeHandler = parameterMapping.getTypeHandler();
        // 获取 typeHandler 的jdbc type
        JdbcType jdbcType = parameterMapping.getJdbcType();
        if (value == null &amp;&amp; jdbcType == null) {
          jdbcType = configuration.getJdbcTypeForNull();
        }
        try {
          typeHandler.setParameter(ps, i + 1, value, jdbcType);
        } catch (TypeException e) {
          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);
        } catch (SQLException e) {
          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);
        }
      }
    }
  }
}</code></pre>
<p>下面用一个流程图表示一下 ParameterHandler 的解析过程，以简单执行器为例：</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%20%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="ParameterHandler 的解析过程流程图"></p>
<p>在完成 <code>ParameterHandler</code> 对 SQL 参数的预处理后，回到 <code>SimpleExecutor</code> 中的 <code>doQuery</code> 方法：</p>
<p><img src="http://qiniu.xiaoming.net.cn/SimpleExecutor%E4%B8%AD%E7%9A%84%20doQuery%E6%96%B9%E6%B3%95.jpg" alt="SimpleExecutor中的 doQuery方法"></p>
<p>上面又引出来了一个重要的组件那就是 <code>ResultSetHandler</code>。</p>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><h3 id="ResultSetHandler-简介"><a href="#ResultSetHandler-简介" class="headerlink" title="ResultSetHandler 简介"></a>ResultSetHandler 简介</h3><p><code>ResultSetHandler</code> 也是一个非常简单的接口:</p>
<p><img src="http://qiniu.xiaoming.net.cn/ResultHandler%E6%8E%A5%E5%8F%A3.jpg" alt="ResultHandler接口"></p>
<p><code>ResultSetHandler</code> 是一个接口，它只有一个默认的实现类，像是 <code>ParameterHandler</code> 一样，它的默认实现类是 <code>DefaultResultSetHandler</code></p>
<h3 id="ResultSetHandler-解析过程"><a href="#ResultSetHandler-解析过程" class="headerlink" title="ResultSetHandler 解析过程"></a>ResultSetHandler 解析过程</h3><p>MyBatis 只有一个默认的实现类就是 <code>DefaultResultSetHandler</code>，<code>DefaultResultSetHandler</code> 主要负责处理两件事:</p>
<ul>
<li>处理 Statement 执行后产生的结果集，生成结果列表</li>
<li>处理存储过程执行后的输出参数</li>
</ul>
<p>按照 Mapper 文件中配置的 <code>ResultType</code> 或 <code>ResultMap</code> 来封装成对应的对象，最后将封装的对象返回即可。</p>
<pre><code class="java">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
  ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

  final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

  int resultSetCount = 0;
  // 获取第一个结果集
  ResultSetWrapper rsw = getFirstResultSet(stmt);
  // 获取结果映射
  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
  // 结果映射的大小
  int resultMapCount = resultMaps.size();
  // 校验结果映射的数量
  validateResultMapsCount(rsw, resultMapCount);
  // 如果ResultSet 包装器不是null， 并且 resultmap 的数量  &gt;  resultSet 的数量的话
  // 因为 resultSetCount 第一次肯定是0，所以直接判断 ResultSetWrapper 是否为 0 即可
  while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
    // 从 resultMap 中取出 resultSet 数量
    ResultMap resultMap = resultMaps.get(resultSetCount);
    // 处理结果集, 关闭结果集
    handleResultSet(rsw, resultMap, multipleResults, null);
    rsw = getNextResultSet(stmt);
    cleanUpAfterHandlingResultSet();
    resultSetCount++;
  }

  // 从 mappedStatement 取出结果集
  String[] resultSets = mappedStatement.getResultSets();
  if (resultSets != null) {
    while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
      if (parentMapping != null) {
        String nestedResultMapId = parentMapping.getNestedResultMapId();
        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
        handleResultSet(rsw, resultMap, null, parentMapping);
      }
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }
  }

  return collapseSingleResultList(multipleResults);
}</code></pre>
<p>其中涉及的主要对象有：</p>
<ul>
<li><code>ResultSetWrapper</code> : 结果集的包装器，主要针对结果集进行的一层包装，它的主要属性有</li>
<li><code>ResultSet</code> : Java JDBC ResultSet 接口表示数据库查询的结果。有关查询的文本显示了如何将查询结果作为java.sql.ResultSet 返回。然后迭代此ResultSet以检查结果。</li>
<li><code>TypeHandlerRegistry</code>: 类型注册器，TypeHandlerRegistry 在初始化的时候会把所有的 Java类型和类型转换器进行注册。</li>
<li><code>ColumnNames</code>: 字段的名称，也就是查询操作需要返回的字段名称</li>
<li><code>ClassNames</code>: 字段的类型名称，也就是 ColumnNames 每个字段名称的类型</li>
<li><code>JdbcTypes</code>:  JDBC 的类型，也就是 java.sql.Types 类型</li>
<li><code>ResultMap</code>: 负责处理更复杂的映射关系</li>
</ul>
<p>在 <code>DefaultResultSetHandler</code> 中处理完结果映射，并把上述结构返回给调用的客户端，从而执行完成一条完整的SQL语句。</p>
<h2 id="SQL-执行过程总结"><a href="#SQL-执行过程总结" class="headerlink" title="SQL 执行过程总结"></a>SQL 执行过程总结</h2><pre><code class="java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
DeptDao deptDao = sqlSession.getMapper(DeptDao.class);</code></pre>
<p>首先是 <code>SqlSessionFactory</code>  的创建：</p>
<p>由上面可以看到通过 一个 <code>SqlSessionFactoryBuilder</code> 工厂，这是一个建造者模式的设计思想，由 <code>builder</code> 建造者来创建 <code>SqlSessionFactory</code> 工厂</p>
<p>然后调用 <code>SqlSessionFactoryBuilder</code> 中的 <code>build</code> 方法传递一个 <code>InputStream</code> 输入流，<code>Inputstream</code> 输入流中就是你传过来的配置文件 <code>mybatis-config.xml</code>，<code>SqlSessionFactoryBuilder</code> 根据传入的 <code>InputStream</code> 输入流和 <code>environment</code>、<code>properties</code> 属性创建一个 <code>XMLConfigBuilder</code> 对象，然后调用 <code>XMLConfigBuilder</code> 的 <code>parse()</code>  方法，该方法首先创建一个  <code>XMLConfigBuilder</code>  对象，通过这个对象的 <code>parser()</code> 方法对 xml 文件从 <code>configuration</code> 节点进行解析，对一个属性都对应一个解析方法，都是使用 XPath 把标签进行解析，解析完成后将这个配置好的 <code>configuration</code> 放到工厂的 <code>configuration</code> 变量里，最终 <code>build</code> 方法返回一个 <code>DefaultSqlSessionFactory</code> 对象，它是 <code>SqlSessionFactory</code> 的默认实现类。</p>
<p>接着是 <code>SqlSession</code> 的创建：</p>
<p>通过 <code>SqlSessionFactory</code> 工厂的 <code>openSession</code> 方法可以获取到一个 <code>SqlSession</code> ，该方法通过调用 <code>DefaultSqlSessionFactory</code> 的 <code>openSessionFromDataSource</code> 方法，会配置好 <code>configuration</code>、<code>executor</code> 执行器、事务属性等，然后传入 <code>DefaultSqlSession</code> 的构造方法创建出 <code>DefaultSqlSession</code> 。</p>
<p><code>Executor</code> 的创建：</p>
<p><code>Executor</code> 的创建是在创建 <code>SqlSession</code> 过程中，<code>openSessionFromDataSource</code> 会利用配置好的 <code>Configuration</code> 对象创建 <code>Executor</code> 对象，<code>Configuration</code> 会根据传入的执行器的类型创建相应的执行器。</p>
<p>再接下来是 Dao 层接口和 SQL 语句的绑定：</p>
<p><code>SqlSession</code> 的 <code>getMapper</code> 方法会调用 <code>Configuration</code> 的 <code>getMapper</code> 方法，其又会调用 <code>MapperRegistry</code> 中的 <code>getMapper</code> 方法，在这个方法中，会将 <code>Class</code> 作为参数构建 <code>MapperProxyFactory</code>，接着通过动态代理调用 <code>MapperProxyFactory</code> 的 <code>newInstance</code> 方法把当前 <code>sqlSession</code>传入，从而实现 <code>Dao</code> 和 <code>Sql</code> 的绑定。</p>
<p><code>MapperProxyFactory</code> 会生成代理对象，这个对象就是 <code>MapperProxy</code>,其中 <code>invoke</code> 方法中，就实现了相应的绑定方法，其实现调用到 <code>mapperMethod.execute</code> 方法，这个方法判断是插入、更新、删除还是查询语句，然后调用 <code>sqlSession</code> 相应的方法，其中如果是查询的话，还会判断返回值的类型。以 <code>selectList</code> 为例，其方法最后调用的是 <code>executor</code> 执行器的 <code>query</code> 方法。</p>
<p><code>Executor</code> 具体执行过程：</p>
<p>首先调用的是 <code>CachingExecutor</code> 的 <code>query</code> 方法，先从缓存中查询 SQL 是否是第一次执行，如果是第一次执行的话（<code>cache == null</code>)，那么就直接执行 SQL 语句，并创建缓存，如果第二次访问相同的 SQL 语句的话，那么就会直接从缓存中提取。</p>
<p>在找不到缓存的情况下，会重新创建 <code>Executor</code> 执行器来执行 SQL 语句，首先调用 <code>BaseExecutor</code> 的 <code>queryFromDatabase</code> 方法，该方法又会调用 <code>SimpleExecutor</code> 的 <code>doQuery</code> 方法，在这个方法里，会获取 <code>Configuration</code> 并通过 <code>Configuration</code> 获取 <code>StatementHandler</code> 处理器，由它来继续往下执行。<code>Configuration</code> 会根据 SQL 语句的类型进行对应 <code>StatementHandler</code> 的创建。</p>
<p>之后会调用 <code>Executor</code> 中的 <code>preparedStatement</code>方法，该方法会调用传入的 <code>StatementHandler</code> 的 <code>prepare</code> 方法获取一个 <code>PreparedStatement</code> 对象，同时调用 <code>handler</code> 的 <code>parameterize</code> 方法，该方法会调用 <code>ParameterHandler</code> 的 <code>setParameters</code> 方法将 <code>PreparedStatement</code>传入，用于为 <code>PreparedStatement</code> 的 sql 语句参数动态赋值。</p>
<p>在完成 <code>ParameterHandler</code> 对 SQL 参数的预处理后，回到 <code>SimpleExecutor</code> 中继续往下执行，会执行 <code>PreparedStatementHandler</code> 的 <code>doQuery</code> 方法，该方法中 <code>PreparedStatement</code> 执行 <code>execute</code> 方法进行查询，然后通过 <code>ResultSetHandler</code> 的 <code>handleResultSets</code> 对会返结果集进行处理并返回，这就完成了一次完整的 SQL 执行过程。</p>
<h1 id="4-configuration标签下有哪些标签？"><a href="#4-configuration标签下有哪些标签？" class="headerlink" title="4. configuration标签下有哪些标签？"></a>4. configuration标签下有哪些标签？</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>外部属性，这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
&lt;/properties&gt;</code></pre>
<p>一般用来给 environment 标签中的 dataSource 赋值</p>
<pre><code class="xml">&lt;environment id=&quot;development&quot;&gt;
  &lt;transactionManager type=&quot;JDBC&quot; /&gt;
  &lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;
  &lt;/dataSource&gt;
&lt;/environment&gt;</code></pre>
<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>MyBatis 中极其重要的配置，它们会改变 MyBatis 的运行时行为。</p>
<p>settings 中配置有很多。这里介绍几个平常使用过程中比较重要的配置：</p>
<p><img src="http://qiniu.xiaoming.net.cn/myBatis%20setting%E8%8A%82%E7%82%B9%E5%86%85%E5%AE%B9.jpg" alt="MyBatis中Setting节点内容"></p>
<pre><code class="xml">&lt;settings&gt;
  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;</code></pre>
<h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><p>类型别名，类型别名是为 Java 类型设置的一个名字。它只和 XML 配置有关。</p>
<pre><code class="xml">&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
<p>当这样配置时，Blog 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><p>类型处理器，无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p>
<p>在 <code>org.apache.ibatis.type</code> 包下有很多已经实现好的 TypeHandler，可以参考如下:</p>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E5%AE%9E%E7%8E%B0%E5%A5%BD%E7%9A%84%20TypeHandler.jpg" alt="MyBatis 实现好的 TypeHandler"></p>
<p>可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。</p>
<p>具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很方便的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。</p>
<h2 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h2><p>对象工厂，MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。</p>
<pre><code class="java">public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {
    return Collection.class.isAssignableFrom(type);
  }
}</code></pre>
<p>然后需要在 XML 中配置此对象工厂</p>
<pre><code class="xml">&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
  &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;</code></pre>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件开发，插件开发是 MyBatis 设计人员给开发人员留给自行开发的接口，MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。MyBatis 允许使用插件来拦截的方法调用包括：<code>Executor</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code> 接口，这几个接口也是 MyBatis 中非常重要的接口。</p>
<h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><p>MyBatis 环境配置，MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。</p>
<p>这里注意一点，虽然 environments 可以指定多个环境，但是 SqlSessionFactory 只能有一个，为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。</p>
<pre><code class="java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</code></pre>
<p>环境配置如下:</p>
<pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
  &lt;environment id=&quot;development&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;
      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
    &lt;/transactionManager&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
    &lt;/dataSource&gt;
  &lt;/environment&gt;
&lt;/environments&gt;</code></pre>
<h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>数据库厂商标示，MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。</p>
<pre><code class="xml">&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;
  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;
  &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;
  &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;
&lt;/databaseIdProvider&gt;</code></pre>
<h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>映射器，这是告诉 MyBatis 去哪里找到这些 SQL 语句，mappers 映射配置有四种方式</p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;

&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<h1 id="5-什么是Mybatis？"><a href="#5-什么是Mybatis？" class="headerlink" title="5. 什么是Mybatis？"></a>5. 什么是Mybatis？</h1><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</p>
<p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返回 result 的过程）</p>
<h1 id="6-MyBatis的优缺点"><a href="#6-MyBatis的优缺点" class="headerlink" title="6. MyBatis的优缺点"></a>6. MyBatis的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</li>
<li>能够与 Spring 很好的集成；</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写</li>
<li>SQL 语句的功底有一定要求。</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ol>
<h1 id="7-MyBatis-框架适用场合"><a href="#7-MyBatis-框架适用场合" class="headerlink" title="7. MyBatis 框架适用场合"></a>7. MyBatis 框架适用场合</h1><p>MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。</p>
<p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</p>
<h1 id="8-和-的区别是什么？"><a href="#8-和-的区别是什么？" class="headerlink" title="8. #{}和${}的区别是什么？"></a>8. #{}和${}的区别是什么？</h1><p><code>#</code> 表示的是占位符，<code>#{}</code> 是预编译处理，<code>${}</code> 是字符串替换。Mybatis 在处理 <code>#{}</code> 时，会将 sql 中的 <code>#{}</code> 替换为 <code>?</code> 号，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值；</p>
<p>Mybatis 在处理 <code>${}</code> 时，就是把 <code>{}</code> 替换成变量的值。</p>
<p>使用 <code>#{}</code> 可以有效的防止 SQL 注入，提高系统安全性。</p>
<ul>
<li><code>${}</code> 是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如 <code>${driver}</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#{}</code>是 sql 的参数占位符，Mybatis 会将 sql 中的 <code>#{}</code> 替换为 <code>?</code> 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code>，<code>#{item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h1 id="9-当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#9-当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="9. 当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>9. 当实体类中的属性名和表中的字段名不一样 ，怎么办？</h1><p>当对类中的某个属性定义的属性名与所对应的数据表的字段名不一致时，需要手动配置指定对应字段名，否则会读取不到数据，有两种方法进行指定：</p>
<ol>
<li><p>通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; parameterType=&quot;int&quot; resultType=&quot;Blog&quot;&gt;
 select id,title,author_id as authorId,featured,style from Blogs where id = #{id}
&lt;/select&gt;</code></pre>
</li>
<li><p>配置 <code>resultMap</code>，在 mapper 配置文件中，添加 <code>resultMap</code> 节点，同时在 statement 中指定 <code>resultMap</code>，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.xm.mapper.BlogMapper&quot;&gt;
 &lt;resultMap id=&quot;blogResultMap&quot; type=&quot;Blog&quot;&gt;
     &lt;id column=&quot;id&quot; property=&quot;id&quot; javaType=&quot;INTEGER&quot;/&gt;
     &lt;result column=&quot;author_id&quot; property=&quot;authorId&quot; javaType=&quot;INTEGER&quot;/&gt;
 &lt;/resultMap&gt;

 &lt;select id=&quot;selectBlog2&quot; parameterType=&quot;int&quot; resultMap=&quot;blogResultMap&quot;&gt;
     select * from blogs where id = #{id}
 &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
</li>
</ol>
<h1 id="10-模糊查询-like-语句该怎么写"><a href="#10-模糊查询-like-语句该怎么写" class="headerlink" title="10. 模糊查询 like 语句该怎么写?"></a>10. 模糊查询 like 语句该怎么写?</h1><ol>
<li><p>在 Java 代码中添加 sql 通配符。</p>
<pre><code class="java">String wildcardname = &quot;%smi%&quot;;
List&lt;name&gt; names = mapper.selectlike(wildcardname);</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectlike&quot;&gt;
select * from foo where bar like #{value}
&lt;/select&gt;</code></pre>
</li>
<li><p>在 sql 语句中拼接通配符，会引起 sql 注入</p>
<pre><code class="java">String wildcardname = &quot;smi&quot;;
List&lt;name&gt; names = mapper.selectlike(wildcardname);</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectlike&quot;&gt;
select * from foo where bar like &quot;%&quot;#{value}&quot;%&quot;
&lt;/select&gt;</code></pre>
</li>
</ol>
<h1 id="11-通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#11-通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="11. 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>11. 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><ol>
<li>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。</li>
<li>Mapper 接口是没有实现类的，当调用接口方法时，<code>接口全限名+方法名拼接字符串</code>作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个 MapperStatement 对象。</li>
<li>举例： <code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>namespace</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>id</code> 为 <code>findStudentById</code> 的 MapperStatement。</li>
<li>Mapper 接口里的方法，是不能重载的，因为是使用 <code>全限名+方法名</code> 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</li>
</ol>
<h1 id="12-Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#12-Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="12. Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>12. Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h1 id="13-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#13-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
<p>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。有了列名与属性名的映射关系后,Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="14-如何执行批量插入"><a href="#14-如何执行批量插入" class="headerlink" title="14. 如何执行批量插入?"></a>14. 如何执行批量插入?</h1><p>首先,创建一个简单的 insert 语句:</p>
<pre><code class="xml">&lt;insert id=&quot;insertname&quot;&gt;
insert into names (name) values (#{value})
&lt;/insert&gt;</code></pre>
<p>然后在 java 代码中像下面这样执行批处理插入:</p>
<pre><code class="java">List &lt; string &gt; names = new arraylist();
names.add(“fred”);
names.add(“barney”);
names.add(“betty”);
names.add(“wilma”);
// 注意这里 executortype.batch
sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);
try {
    namemapper mapper = sqlsession.getmapper(namemapper.class);
    for (string name: names) {
        mapper.insertname(name);
    }
    sqlsession.commit();
}catch (Exception e) {
    e.printStackTrace();
    sqlSession.rollback();
    throw e;
}finally {
    sqlsession.close();
}</code></pre>
<h1 id="15-如何获取自动生成的-主-键值"><a href="#15-如何获取自动生成的-主-键值" class="headerlink" title="15. 如何获取自动生成的(主)键值?"></a>15. 如何获取自动生成的(主)键值?</h1><p>有三种方式进行设置：</p>
<h2 id="在mapper中配置insert节点的属性"><a href="#在mapper中配置insert节点的属性" class="headerlink" title="在mapper中配置insert节点的属性"></a>在mapper中配置insert节点的属性</h2><pre><code>seGeneratedKeys = true keyProperty=”id”</code></pre><p><code>useGeneratedKeys</code> 仅对 <code>insert</code> 和 <code>update</code> 有用，这会令 MyBatis 使用 JDBC 的 <code>getGeneratedKeys</code> 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</p>
<p><code>keyProperty</code> 仅对 <code>insert</code> 和 <code>update</code> 有用，唯一标记一个属性，指定主键名是什么，MyBatis 会通过 <code>getGeneratedKeys</code> 的返回值或者通过 <code>insert</code> 语句的 <code>selectKey</code> 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</p>
<p><code>insert</code> 方法总是返回一个 <code>int</code> 值 ，这个值代表的是插入的行数。</p>
<p>如果采用自增长策略，自动生成的键值在 <code>insert</code> 方法执行完后可以被设置到传入的参数对象中。</p>
<pre><code class="xml">&lt;insert id=&quot;insertname&quot; usegeneratedkeys=&quot;true&quot; keyproperty=&quot;id&quot;&gt;
insert into names (name) values (#{name})
&lt;/insert&gt;</code></pre>
<pre><code class="java">Name name = new name();
name.setname(&quot;fred&quot;);
int rows = mapper.insertname(name);
// 完成后,id 已经被设置到对象中
System.out.println(&quot;rows inserted = &quot; + rows);
System.out.println(&quot;generated key value = &quot; + name.getid());</code></pre>
<h2 id="在全局配置文件中配置settings节点"><a href="#在全局配置文件中配置settings节点" class="headerlink" title="在全局配置文件中配置settings节点"></a>在全局配置文件中配置settings节点</h2><p>在全局配置文件中配置 <code>settings</code> 节点，并且在 <code>mapper</code> 的 <code>insert</code> 节点指定主键名，即配置<code>keyProperty=&quot;id&quot;</code></p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;</code></pre>
<h2 id="针对Oracle等无主键的数据库）在-insert-节点中加入-selectKey-属性"><a href="#针对Oracle等无主键的数据库）在-insert-节点中加入-selectKey-属性" class="headerlink" title="针对Oracle等无主键的数据库）在 insert 节点中加入 selectKey 属性"></a>针对Oracle等无主键的数据库）在 insert 节点中加入 selectKey 属性</h2><p>其有以下变量属性：</p>
<ul>
<li><code>keyProperty</code>：selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>
<li><code>keyColumn</code>：匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>
<li><code>resultType</code>：结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</li>
<li><code>order</code>：这可以被设置为 <code>BEFORE</code> 或 <code>AFTER</code>。如果设置为 <code>BEFORE</code>，那么它会首先生成主键，设置 <code>keyProperty</code> 然后执行插入语句。如果设置为 <code>AFTER</code>，那么先执行插入语句，然后是 <code>selectKey</code> 中的语句(这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用)。</li>
<li><code>statementType</code>：<code>STATEMENT</code>，<code>PREPARED</code> 或 <code>CALLABLE</code> 的一个。这会让 MyBatis 分别使用 <code>Statement</code>，<code>PreparedStatement</code> 或 <code>CallableStatement</code>，默认值：<code>PREPARED</code>。</li>
</ul>
<pre><code class="xml">&lt;insert id=&quot;insertBlog2&quot; parameterType=&quot;Blog&quot; keyProperty=&quot;id&quot;&gt;
    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select LAST_INSERT_ID()
    &lt;/selectKey&gt;
    insert into blogs (title, author_id, featured, style) value (#{title},#{authorId},#{featured},#{style})
&lt;/insert&gt;</code></pre>
<h1 id="16-在-mapper-中如何传递多个参数"><a href="#16-在-mapper-中如何传递多个参数" class="headerlink" title="16. 在 mapper 中如何传递多个参数?"></a>16. 在 mapper 中如何传递多个参数?</h1><h2 id="使用索引：按照参数排序，arg从0开始，param从1开始"><a href="#使用索引：按照参数排序，arg从0开始，param从1开始" class="headerlink" title="使用索引：按照参数排序，arg从0开始，param从1开始"></a>使用索引：按照参数排序，arg从0开始，param从1开始</h2><p>DAO 层的函数</p>
<pre><code class="java">public UserselectUser(String name,String area);</code></pre>
<p>对应的 xml,<code>#{0}</code> 代表接收的是 dao 层中的第一个参数，<code>#{1}</code> 代表 dao 层中第二<br>参数，更多参数一致往后加即可。</p>
<pre><code class="xml">&lt;select id=&quot;selectUser&quot;resultMap=&quot;BaseResultMap&quot;&gt;
    select * fromuser_user_t whereuser_name = #{0} and user_area=#{1}
&lt;/select&gt;</code></pre>
<h2 id="使用-param-注解"><a href="#使用-param-注解" class="headerlink" title="使用 @param 注解"></a>使用 @param 注解</h2><pre><code class="java">List&lt;Blog&gt; selectBlogByPage2(
        @Param(value = &quot;offset&quot;) int offset,
        @Param(value = &quot;pagesize&quot;) int pagesize);</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectBlogByPage2&quot; resultMap=&quot;blogResultMap&quot;&gt;
    select * from blogs limit #{offset},#{pagesize}
&lt;/select&gt;</code></pre>
<h2 id="多个参数封装成-map"><a href="#多个参数封装成-map" class="headerlink" title="多个参数封装成 map"></a>多个参数封装成 map</h2><p>mapper 的配置保持不变，其中的<strong>占位符参数名要和测试中 map 的 <code>key</code> 一一对应</strong></p>
<pre><code class="java">public void testSelectBlogByPage3(){
    SqlSession sqlSession = MyBatisUtil.sqlSession();
    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);
    //自己构建一个map
    Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();
    //注意key要和参数名对应
    map.put(&quot;offset&quot;,0);
    map.put(&quot;pagesize&quot;,2);
    List&lt;Blog&gt; blogs = mapper.selectBlogByPage3(map);
    sqlSession.close();
    for (Blog blog : blogs) {
        System.out.println(blog);
    }
}</code></pre>
<h1 id="17-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql"><a href="#17-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql" class="headerlink" title="17. Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql?"></a>17. Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql?</h1><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p>
<p>Mybatis 提供了 9 种动态 sql 标签：</p>
<ul>
<li><code>if</code>：提供了可选的查询方案，如果 if 中的条件成立，则执行 if 中的语句，否则只执行 if 外的 sql 语句</li>
<li><code>choose</code>(<code>when</code>,<code>otherwise</code>)：用于多个条件判断，当满足其中某个 when 条件时，sql 语句加上其中的内容，否则只执行外部的内容，一旦某个when条件成立，就不会再判断下面的when语句了。三者搭配使用，相当于java中 <code>switch</code>,<code>case</code>,<code>default</code>用法</li>
<li><code>where</code>：如果希望 where 条件语句也在需要的时候才加入，可以使用 where 来进行判断。where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 <code>WHERE</code> 子句。而且，<strong>若语句的开头为 <code>AND</code> 或 <code>OR</code>，where 元素也会将它们去除</strong>（搭配 <code>if</code> 使用）</li>
<li><code>set</code>：可以使用 set 元素实现按需更新，指定具体需要更新的字段,set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号。</li>
<li><code>trim</code>：trim 可以用于指定加入的前缀和指定自动去除的前面或后面的内容，它有下面四个属性</li>
</ul>
<ol>
<li><code>prefix</code> ：加入的前置名</li>
<li><code>suffix</code>：加入的后缀名</li>
<li><code>prefixOverrides</code>：自动去除前面的内容</li>
<li><code>suffiexOverrides</code>：自动去除后面的内容</li>
</ol>
<ul>
<li><code>foreach</code>：foreach 是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。</li>
</ul>
<h1 id="18-Xml-映射文件中，除了常见的-select、insert、updae、delete-标签之外，还有哪些标签？"><a href="#18-Xml-映射文件中，除了常见的-select、insert、updae、delete-标签之外，还有哪些标签？" class="headerlink" title="18. Xml 映射文件中，除了常见的 select、insert、updae、delete 标签之外，还有哪些标签？"></a>18. Xml 映射文件中，除了常见的 select、insert、updae、delete 标签之外，还有哪些标签？</h1><p><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段,<code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<h1 id="19-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#19-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="19. Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>19. Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；</p>
<p>原因就是 <code>namespace+id</code> 是作为 <code>Map&lt;String, MapperStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，<code>namespace+id</code> 自然也就不同</p>
<h1 id="20-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里"><a href="#20-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里" class="headerlink" title="20. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里?"></a>20. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里?</h1><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具</p>
<h1 id="21-一对一、一对多的关联查询"><a href="#21-一对一、一对多的关联查询" class="headerlink" title="21. 一对一、一对多的关联查询"></a>21. 一对一、一对多的关联查询</h1><p>一对一 xml 配置方案：</p>
<p>在需要进行关联查询的 mapper 中配置 <code>association</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应该实体类关联另一个实体类的变量名</li>
<li><code>column</code>：对应表的字段名</li>
<li><code>javaType</code>：对应关联的实体类</li>
<li><code>select</code>：指定子查询（注意要加入名称空间）</li>
</ul>
<p>一对多 xml配置方案：</p>
<p>在 mapper 文件中使用 <code>collection</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应表中的 commentsList</li>
<li><code>column</code>：当前表与外表关联的键（一般是id）</li>
<li><code>javaType</code>：对应 property 的类型</li>
<li><code>ofType</code>：对应外表的实体类</li>
</ul>
<pre><code class="xml">&lt;mapper namespace=&quot;com.lcb.mapping.userMapper&quot;&gt;
    &lt;!--association 一对一关联查询 --&gt;
    &lt;select id=&quot;getClass&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap&quot;&gt;
        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id}
    &lt;/select&gt;
    &lt;resultMap type=&quot;com.lcb.user.Classes&quot; id=&quot;ClassesResultMap&quot;&gt;
        &lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;
        &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;
        &lt;association property=&quot;teacher&quot; javaType=&quot;com.lcb.user.Teacher&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;!--collection 一对多关联查询 --&gt;
    &lt;select id=&quot;getClass2&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap2&quot;&gt;
        select * from class c,teacher t,student s where c.teacher_id=t.t_id 
        and c.c_id=s.class_id and c.c_id=#{id}
    &lt;/select&gt;
    &lt;resultMap type=&quot;com.lcb.user.Classes&quot; id=&quot;ClassesResultMap2&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;
        &lt;association property=&quot;teacher&quot; javaType=&quot;com.lcb.user.Teacher&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;
        &lt;/association&gt;
        &lt;collection property=&quot;student&quot; ofType=&quot;com.lcb.user.Student&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;s_id&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;s_name&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;</code></pre>
<h1 id="22-MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#22-MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="22. MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>22. MyBatis 实现一对一有几种方式?具体怎么操作的？</h1><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在 <code>resultMap</code> 里面配置 <code>association</code> 节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键 id，再去另外一个表里面查询数据,也是通过 <code>association</code> 配置，但另外一个表的查询通过 <code>select</code> 属性配置。</p>
<p>同理，对于一对多也有两种，对应将 <code>association</code> 节点改成 <code>collection</code> 即可。</p>
<h1 id="23-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#23-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="23. Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>23. Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><p>Mybatis 仅支持 <code>association</code> 关联对象和 <code>collection</code> 关联集合对象的延迟加载,<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p>
<p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 <code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>延迟加载分为积极延迟加载和非积极延迟加载，当开启延迟加载后，默认是积极延迟加载。</p>
<ul>
<li>积极延迟加载：只要获取任意属性内容，无论属性是否是关联表的内容，都会执行关联的表查询</li>
<li>非积极延迟加载：使用非延迟加载，只有当访问关联表数据时，才会执行关联表的查询。<pre><code class="xml">&lt;settings &gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;</code></pre>
</li>
</ul>
<h1 id="24-Mybatis-的一级、二级缓存"><a href="#24-Mybatis-的一级、二级缓存" class="headerlink" title="24. Mybatis 的一级、二级缓存"></a>24. Mybatis 的一级、二级缓存</h1><p>一级缓存: 基于 <code>PerpetualCache</code>(永久缓存) 的 <code>HashMap</code> 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。另外，如果在两次查询中间有增删改的操作，那么 MyBatis 就会重新刷新清空缓存区，那么下一次查询会重新执行 sql 语句默认打开一级缓存。</p>
<p>二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 <code>Serializable</code> 序列化接口(可用来保存对象的状态),在它的映射文件中配置 <code>&lt;cache/&gt;</code></p>
<pre><code class="java">public class Blogs implements Serializable {
    ...
}</code></pre>
<pre><code class="xml">&lt;cache  /&gt;</code></pre>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h1 id="25-什么是-MyBatis-的接口绑定？有哪些实现方式"><a href="#25-什么是-MyBatis-的接口绑定？有哪些实现方式" class="headerlink" title="25. 什么是 MyBatis 的接口绑定？有哪些实现方式?"></a>25. 什么是 MyBatis 的接口绑定？有哪些实现方式?</h1><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code> 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 <code>namespace</code> 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</p>
<h1 id="26-使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#26-使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="26. 使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>26. 使用 MyBatis 的 mapper 接口调用时有哪些要求？</h1><ol>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；</li>
<li>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 <code>parameterType</code> 的类型相同；</li>
<li>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 <code>resultType</code> 的类型相同；</li>
<li>Mapper.xml 文件中的 <code>namespace</code> 即是 <code>mapper</code> 接口的类路径。</li>
</ol>
<h1 id="27-Mapper-编写有哪几种方式？"><a href="#27-Mapper-编写有哪几种方式？" class="headerlink" title="27. Mapper 编写有哪几种方式？"></a>27. Mapper 编写有哪几种方式？</h1><h2 id="第一种：使用传统Dao层开发"><a href="#第一种：使用传统Dao层开发" class="headerlink" title="第一种：使用传统Dao层开发"></a>第一种：使用传统Dao层开发</h2><p>接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写 mapper 接口，mapper 接口实现类、mapper.xml 文件。</p>
<ol>
<li>在 sqlMapConfig.xml 中配置 mapper.xml 的位置<pre><code class="xml">&lt;mappers&gt;
 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;
 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;
&lt;/mappers&gt;</code></pre>
</li>
<li>定义 mapper 接口</li>
<li>实现类继承 <code>SqlSessionDaoSupport</code>,mapper 方法中可以通过 <code>this.getSqlSession()</code>进行数据增删改查。<pre><code class="java">public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao {
 @Override
 public User selectUserById(int id) {
     User user = this.getSqlSession().selectOne(&quot;com.xm.dao.UserDao.selectUserById&quot;, id);//指定到后面需要写的mapper映射文件的命名空间下
     return user;
 }
}</code></pre>
</li>
<li>spring 配置<pre><code class="xml">&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
 &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
 &lt;!-- 注入mybatis配置文件 --&gt;
 &lt;property name=&quot;configLocation&quot; value=&quot;classpath:spring-mybatis.xml&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</li>
</ol>
<h2 id="第二种：Mapper动态代理开发（不用自己写Dao实现类）"><a href="#第二种：Mapper动态代理开发（不用自己写Dao实现类）" class="headerlink" title="第二种：Mapper动态代理开发（不用自己写Dao实现类）"></a>第二种：Mapper动态代理开发（不用自己写Dao实现类）</h2><ol>
<li>使用 <code>org.mybatis.spring.mapper.MapperFactoryBean</code> ：在 <code>sqlMapConfig.xml</code> 中配置 <code>mapper.xml</code> 的位置，如果 <code>mapper.xml</code> 和 <code>mapper</code> 接口的名称相同且在同一个目录，这里可以不用配置：<pre><code class="xml">&lt;mappers&gt;
 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;
 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;
&lt;/mappers&gt;</code></pre>
</li>
<li>定义 mapper 接口：</li>
</ol>
<ul>
<li>mapper.xml 中的 namespace 为 mapper 接口的地址</li>
<li>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</li>
<li>Spring 中定义<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryBean&quot;/&gt;
  &lt;!-- 此处关联到dao层接口 --&gt;
  &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xm.dao.UserDao&quot;/&gt;
&lt;/bean&gt;</code></pre>
</li>
</ul>
<h2 id="第三种：使用-mapper-扫描器"><a href="#第三种：使用-mapper-扫描器" class="headerlink" title="第三种：使用 mapper 扫描器"></a>第三种：使用 mapper 扫描器</h2><ol>
<li>mapper.xml 文件编写：</li>
</ol>
<ul>
<li>mapper.xml 中的 <code>namespace</code> 为 <code>mapper</code> 接口的地址；</li>
<li>mapper 接口中的方法名和 <code>mapper.xml</code> 中的定义的 <code>statement</code> 的 <code>id</code> 保持一致；</li>
<li>如果将 mapper.xml 和 mapper接口的名称保持一致则不用在 <code>sqlMapConfig.xml</code> 中进行配置。</li>
</ul>
<ol start="2">
<li>定义 mapper 接口：注意 <code>mapper.xml</code> 的文件名和 <code>mapper</code> 的接口名称保持一致，且放在同一个目录</li>
<li>配置 mapper 扫描器：<pre><code class="xml">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
 &lt;!-- 基本包 --&gt;
 &lt;property name=&quot;basePackage&quot; value=&quot;com.xm.dao&quot;/&gt;
&lt;/bean&gt;</code></pre>
</li>
<li>使用扫描器后从 spring 容器中获取 mapper 的实现对象。</li>
</ol>
<h1 id="28-简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#28-简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="28. 简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>28. 简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h1><p>Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>编写插件：实现 Mybatis 的 <code>Interceptor</code> 接口并复写 <code>ntercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<p><strong>参考目录</strong></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/AyItaTuLGYHvY9w9EJ-rOg" target="_blank" rel="noopener">面试官问你MyBatis SQL是如何执行的？把这篇文章甩给他</a><br><a href="https://www.cnblogs.com/godoforange/p/11623535.html" target="_blank" rel="noopener">Mybatis面试题吐血总结</a></p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/03/23/Nginx%E9%9B%86%E7%BE%A4/" title="Nginx 集群"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Nginx 集群</span></a><a class="button is-default" href="/2020/02/24/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94Docker/" title="Docker常见问题"><span class="has-text-weight-semibold">下一页: Docker常见问题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备18114217号</a></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>