<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Dubbo源码解析</title><meta name="description" content="Wechat:934933088"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '54ebb03ad7ad5b762ac8ff7958df6d3f';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="https://qiniu.xiaoming.net.cn/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%A0%87.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">silverming's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Dubbo源码解析</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-标签解析过程"><span class="toc-text">Dubbo 标签解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionParser"><span class="toc-text">BeanDefinitionParser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DubboBeanDefinitionParser"><span class="toc-text">DubboBeanDefinitionParser</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#parser-方法"><span class="toc-text">parser 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beanClass-gt-DubboNamespaceHandler-init"><span class="toc-text">beanClass -&gt; DubboNamespaceHandler.init()</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Dubbo"><i class="tag post-item-tag">Dubbo</i></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F"><i class="tag post-item-tag">分布式</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Dubbo源码解析</h1><time class="has-text-grey" datetime="2020-05-11T02:58:26.000Z">2020-05-11</time><article class="mt-2 post-content"><h1 id="Dubbo-标签解析过程"><a href="#Dubbo-标签解析过程" class="headerlink" title="Dubbo 标签解析过程"></a>Dubbo 标签解析过程</h1><p>以 Spring Boot 配置的解析过程分析：</p>
<h2 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h2><p>这是 Spring 定义的一个用于解析标签的总接口，用于处理自定义的解析接口，该方法中只有一个 <code>parser</code> 方法。Dubbo 实现了该接口，通过查看实现类可以找到 <code>DubboBeanDefinitionParser</code>，这个就是 Duboo 的标签解析起。</p>
<a id="more"></a>

<h2 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h2><pre><code class="java">public class DubboBeanDefinitionParser implements BeanDefinitionParser {

    private static final Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);
    private static final Pattern GROUP_AND_VERION = Pattern.compile(&quot;^[\\-.0-9_a-zA-Z]+(\\:[\\-.0-9_a-zA-Z]+)?$&quot;);
    private final Class&lt;?&gt; beanClass;
    private final boolean required;

    public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) {
        this.beanClass = beanClass;
        this.required = required;
    }
  //...
}</code></pre>
<p>其解析过程就在这个类的 <code>parser</code> 方法中：</p>
<pre><code class="java">       @Override
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        return parse(element, parserContext, beanClass, required);
    }
        private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) {
        RootBeanDefinition beanDefinition = new RootBeanDefinition();
        beanDefinition.setBeanClass(beanClass);
        beanDefinition.setLazyInit(false);
        String id = element.getAttribute(&quot;id&quot;);
      //...</code></pre>
<h3 id="parser-方法"><a href="#parser-方法" class="headerlink" title="parser 方法"></a>parser 方法</h3><p><code>parser</code> 方法在运行时会被执行多次，挨个解析标签，解析的关键代码如下：</p>
<p>在这个过程中，<code>parser</code>方法会挨个判断传入的 <code>beanClass</code> 的类型，根据传入的类型设置相应的 <code>beanDefinition</code>。</p>
<pre><code class="java">        if (ProtocolConfig.class.equals(beanClass)) {
            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {
                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);
                PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;);
                if (property != null) {
                    Object value = property.getValue();
                    if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) {
                        definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id));
                    }
                }
            }
        } else if (ServiceBean.class.equals(beanClass)) {
            String className = element.getAttribute(&quot;class&quot;);
            if (className != null &amp;&amp; className.length() &gt; 0) {
                RootBeanDefinition classDefinition = new RootBeanDefinition();
                classDefinition.setBeanClass(ReflectUtils.forName(className));
                classDefinition.setLazyInit(false);
                parseProperties(element.getChildNodes(), classDefinition);
                beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;));
            }
        } else if (ProviderConfig.class.equals(beanClass)) {
            parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition);
        } else if (ConsumerConfig.class.equals(beanClass)) {
            parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition);
        }</code></pre>
<h3 id="beanClass-gt-DubboNamespaceHandler-init"><a href="#beanClass-gt-DubboNamespaceHandler-init" class="headerlink" title="beanClass -&gt; DubboNamespaceHandler.init()"></a>beanClass -&gt; DubboNamespaceHandler.init()</h3><p>从上面的分析可以知道，解析过程会根据传入的 <code>beanClass</code> 的类型不同而执行不同的操作，而 <code>beanClass</code> 的传入主要是在该类的构造方法中，通过对构造方法打断点调试，可以看到，在构造器的前一步执行了 <code>DubboNamespaceHandler</code> 类的 <code>init</code> 方法：</p>
<pre><code class="java">    @Override
    public void init() {
        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));
        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));
        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));
        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));
        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));
        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));
        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));
        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));
        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));
        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());
    }</code></pre>
<p>在这个名称空间处理器类中，<code>init</code>方法创建了多个对应不同标签的类定义解析器，从而完成了上面的标签解析过程。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/07/18/go%E5%85%A5%E9%97%A8/" title="go 入门"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: go 入门</span></a><a class="button is-default" href="/2020/04/08/Dubbo%E5%85%A5%E9%97%A8/" title="Dubbo入门"><span class="has-text-weight-semibold">下一页: Dubbo入门</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiao-ming9/xiao-ming9.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> silverming 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>footnotes</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>